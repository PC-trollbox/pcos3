{"backend":{"files":{"apps":{"df.js":"6febc758a27f16bcafa4cab0d70c9db5dfb53a2a0142ff7ddccc5406e097cb0561687873897de0226a5c14833109973eb3fd3f00f7cef642ce4611027c6fbb5a","format.js":"291f00e9af1610fa9297fa0ac3b757b7b99f3289dea9c35b7e4297331a25fe0c98daf7651ecf4ede200a8632b0d1473a0a726abd7cec725c6ec6c5ff6ed0cda7","initdisk.js":"50c470d56a433cdfafc4d89e6198b0879402df2e72b5660366dde90bd254a2b622d154f00966f11d68ec1e2ab1084fbc17b0cbd5c012638bdab1516c48dfbf53","llda_tool.js":"4a39fe59890e2726b130bc1c7fb321401b8011c9d2deb8b7febf2aacc95de6a4b8241e9f98b9adcf16c16afb648848f19653537a9dde15a459512581a7ed74bb","mount.js":"1247eff9eaa3e383a5f8402794934d372cd4866beb9c3e2a153d02dea3ac5925e25fea292be47890436bcb12108238669feb7a3262419c58f6980edc89187682","mountinfo.js":"bda243c3a3de2a07b4c01c2145d8e1cfaed38b577c9b5872931d2360e21ce8cd716cdcebfa60bbe9cf1aaf49550cecf4f110361f8ac5baa3a097756a29bb868b","pivot_root.js":"19a6a030c7ad32cc5ea1da1d74321710e5b300a03a6f7037353464612bf3b8ff7e6a149d2b3ae4f07549d419f81bb84af5fcd29e4570b431dceac29cc8a1ae78","umount.js":"7a87a8c812d21de5699c14d6b7b24badf6566032f83ae7968f869a7fdee5579a9023acabcb592fca9178b9a73d0a6e8c65466836f309308d75a6ec98a8fd8768"}},"permissions":{"apps/df.js":{"world":"rx"},"apps/format.js":{"world":"rx"},"apps/initdisk.js":{"world":"rx"},"apps/llda_tool.js":{"world":"rx"},"apps/mount.js":{"world":"rx"},"apps/mountinfo.js":{"world":"rx"},"apps/pivot_root.js":{"world":"rx"},"apps/umount.js":{"world":"rx"},"apps/":{"world":"rx"},"":{"world":"rx"}}},"files":{"6febc758a27f16bcafa4cab0d70c9db5dfb53a2a0142ff7ddccc5406e097cb0561687873897de0226a5c14833109973eb3fd3f00f7cef642ce4611027c6fbb5a":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: GET_LOCALE, FS_LIST_PARTITIONS\n// signature: 270e3ff5f552cddebd10b1e2e6bc5b2d406acb7e5acafaa5b11de8d63820070541a257c38d37821da87870840207955cbf860246852f88ad6deafef8da488f02\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.windowVisibility(false);\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"df: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\tlet human = exec_args.includes(\"-h\") || exec_args.includes(\"--human-readable\");\n\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"DF_HEADER\") + \"\\r\\n\");\n\tlet estimateStorage = await availableAPIs.estimateStorage();\n\tfor (let medium in estimateStorage) {\n\t\tlet displayedSize = estimateStorage[medium].total;\n\t\tif (human) displayedSize = await availableAPIs.ufInfoUnits([estimateStorage[medium].total, true]);\n\t\tlet displayedUsed = estimateStorage[medium].used;\n\t\tif (human) displayedUsed = await availableAPIs.ufInfoUnits([estimateStorage[medium].used, true]);\n\t\tlet displayedFree = estimateStorage[medium].free;\n\t\tif (human) displayedFree = await availableAPIs.ufInfoUnits([estimateStorage[medium].free, true]);\n\t\tawait availableAPIs.toMyCLI(medium + \"\\t\" + displayedSize + \"\\t\" + displayedUsed + \"\\t\" + displayedFree + \"\\t\" + Math.floor(estimateStorage[medium].used / estimateStorage[medium].total * 100) + \"%\\r\\n\");\n\t}\n\tawait availableAPIs.terminate();\n})();\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); null;","291f00e9af1610fa9297fa0ac3b757b7b99f3289dea9c35b7e4297331a25fe0c98daf7651ecf4ede200a8632b0d1473a0a726abd7cec725c6ec6c5ff6ed0cda7":"// =====BEGIN MANIFEST=====\n// allow: GET_LOCALE, LLDISK_LIST_PARTITIONS, LLDISK_WRITE, LLDISK_REMOVE, LLDISK_READ, CSP_OPERATIONS\n// signer: automaticSigner\n// signature: 51ed74a9856cd40758c801d6d7cd2c99684fef58a8ce126f0dcffcd6f0a3450d8286e18915c618daeae7c7e80c8b9ba2a9f950a541b064d7c66b78e01cee3c0e\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.windowVisibility(false);\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"format: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\tif (!exec_args.length) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"FORMAT_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"FORMAT_DESCRIPTION\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"FORMAT_FSTYPE\") + \"\\r\\n\")\n\t\tawait availableAPIs.toMyCLI(\"format: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\tif (exec_args.length < 2 || exec_args.length > 3) {\n\t\tawait availableAPIs.toMyCLI(\"format: \" + await availableAPIs.lookupLocale(\"ARGUMENT_COUNT_MISMATCH\") + \"\\r\\n\");\n\t\treturn await availableAPIs.terminate();\n\t}\n\t\n\tlet knownNames;\n\ttry {\n\t\tknownNames = await availableAPIs.lldaList();\n\t\tif (knownNames.includes(exec_args[1]) && exec_args[2] != \"overwrite\") {\n\t\t\tawait availableAPIs.toMyCLI(\"format: \" + await availableAPIs.lookupLocale(\"FORMAT_OVERWRITE_WARN\") + \"\\r\\n\");\n\t\t\treturn await availableAPIs.terminate();\n\t\t}\n\n\t\tlet u8aToHex = (u8a) => Array.from(u8a).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\tif (exec_args[0] == \"pcfs\") {\n\t\t\tlet prevId = (await availableAPIs.lldaRead({ partition: exec_args[1] }))?.id || u8aToHex(await availableAPIs.cspOperation({\n\t\t\t\tcspProvider: \"basic\",\n\t\t\t\toperation: \"random\",\n\t\t\t\tcspArgument: new Uint8Array(64)\n\t\t\t}));\n\t\t\tawait availableAPIs.lldaWrite({\n\t\t\t\tpartition: exec_args[1],\n\t\t\t\tdata: {\n\t\t\t\t\tfiles: {},\n\t\t\t\t\tpermissions: {},\n\t\t\t\t\tid: prevId\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (exec_args[0].startsWith(\"pcfs_crypt\")) {\n\t\t\tlet monokey = exec_args[0].endsWith(\"_monokey\");\n\t\t\tlet prevId = (await availableAPIs.lldaRead({ partition: exec_args[1] }))?.id || u8aToHex(await availableAPIs.cspOperation({\n\t\t\t\tcspProvider: \"basic\",\n\t\t\t\toperation: \"random\",\n\t\t\t\tcspArgument: new Uint8Array(64)\n\t\t\t}));\n\t\t\tlet salt = u8aToHex(await availableAPIs.cspOperation({\n\t\t\t\tcspProvider: \"basic\",\n\t\t\t\toperation: \"random\",\n\t\t\t\tcspArgument: new Uint8Array(32)\n\t\t\t}));\n\t\t\tawait availableAPIs.lldaWrite({\n\t\t\t\tpartition: exec_args[1],\n\t\t\t\tdata: {\n\t\t\t\t\tfiles: {},\n\t\t\t\t\tpermissions: {},\n\t\t\t\t\tid: prevId,\n\t\t\t\t\tcryptodata: {\n\t\t\t\t\t\tpasswordLockingInitial: monokey,\n\t\t\t\t\t\tsalt: salt\n\t\t\t\t\t},\n\t\t\t\t\tencryptedFileTable: exec_args[0].endsWith(\"_filetable_monokey\")\n\t\t\t\t}\n\t\t\t})\n\t\t} else if (exec_args[0].startsWith(\"pcbm:\")) {\n\t\t\tlet diskDataPartition = exec_args[0].split(\":\").slice(1).join(\":\");\n\t\t\tawait availableAPIs.lldaWrite({\n\t\t\t\tpartition: exec_args[1],\n\t\t\t\tdata: `try {\n\t\t\t\t\tconst AsyncFunction = (async () => {}).constructor;\n\t\t\t\t\tlet pre_boot_part = coreExports.disk.partition(${JSON.stringify(diskDataPartition)}).getData();\n\t\t\t\t\tlet pre_boot_modules = pre_boot_part?.files;\n\t\t\t\t\tif (!pre_boot_modules) {\n\t\t\t\t\t\tcoreExports.tty_bios_api.println(\"No files were found in the storage partition\");\n\t\t\t\t\t\tthrow new Error(\"No files were found in the storage partition\");\n\t\t\t\t\t}\n\t\t\t\t\tpre_boot_modules = pre_boot_modules[coreExports.bootSection || \"boot\"];\n\t\t\t\t\tif (!pre_boot_modules) {\n\t\t\t\t\t\tcoreExports.tty_bios_api.println(\"No boot modules were found\");\n\t\t\t\t\t\tthrow new Error(\"No boot modules were found\");\n\t\t\t\t\t}\n\t\t\t\t\tlet pre_boot_module_list = Object.keys(pre_boot_modules);\n\t\t\t\t\tpre_boot_module_list = pre_boot_module_list.sort((a, b) => a.localeCompare(b));\n\t\t\t\t\tlet pre_boot_module_script = \"\";\n\t\t\t\t\tfor (let module of pre_boot_module_list) {\n\t\t\t\t\t\tif (coreExports.bootMode == \"logboot\") pre_boot_module_script += \"coreExports.tty_bios_api.println(\" + JSON.stringify(module) + \");\\\\n\";\n\t\t\t\t\t\tpre_boot_module_script += await coreExports.idb.readPart(pre_boot_part.id + \"-\" + pre_boot_modules[module]);\n\t\t\t\t\t}\n\t\t\t\t\tawait new AsyncFunction(pre_boot_module_script)();\n\t\t\t\t} catch (e) {\n\t\t\t\t\tcoreExports.tty_bios_api.println(\"Boot failed\");\n\t\t\t\t\tcoreExports.tty_bios_api.println(\"Press Enter to continue and log this error locally\");\n\t\t\t\t\tawait coreExports.tty_bios_api.inputLine();\n\t\t\t\t\tthrow e;\n\t\t\t\t}`\n\t\t\t});\n\t\t} else if (exec_args[0] == \"null\") {\n\t\t\tawait availableAPIs.lldaRemove({\n\t\t\t\tpartition: exec_args[1]\n\t\t\t});\n\t\t} else {\n\t\t\tawait availableAPIs.toMyCLI(\"format: \" + await availableAPIs.lookupLocale(\"FORMAT_UNKNOWN_FSTYPE\") + \"\\r\\n\");\n\t\t}\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"format: \" + e.name + \": \" + await availableAPIs.lookupLocale(e.message) + \" (\" + e.message + \")\\r\\n\");\n\t\treturn await availableAPIs.terminate();\n\t}\n\t\n\tawait availableAPIs.terminate();\n})();\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); null;","50c470d56a433cdfafc4d89e6198b0879402df2e72b5660366dde90bd254a2b622d154f00966f11d68ec1e2ab1084fbc17b0cbd5c012638bdab1516c48dfbf53":"// =====BEGIN MANIFEST=====\n// allow: GET_LOCALE, LLDISK_LIST_PARTITIONS, LLDISK_INIT_PARTITIONS\n// signer: automaticSigner\n// signature: 353a98f62dd474c05c23d7fe3afaf044166bad6a7868c893ab653a473a70c54ebf2d8bfbbbca517d2e9d328884bd3a7de313ac7dc11a30fb56e6d1f68796200e\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.windowVisibility(false);\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"initdisk: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\tif (!exec_args.length) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"INITDISK_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"INITDISK_DESCRIPTION\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"initdisk: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\tif (exec_args.length > 2) {\n\t\tawait availableAPIs.toMyCLI(\"initdisk: \" + await availableAPIs.lookupLocale(\"ARGUMENT_COUNT_MISMATCH\") + \"\\r\\n\");\n\t\treturn await availableAPIs.terminate();\n\t}\n\t\n\ttry {\n\t\tawait availableAPIs.lldaList();\n\t\tif (exec_args[1] != \"overwrite\") {\n\t\t\tawait availableAPIs.toMyCLI(\"initdisk: \" + await availableAPIs.lookupLocale(\"INITDISK_OVERWRITE_WARN\") + \"\\r\\n\");\n\t\t\treturn await availableAPIs.terminate();\n\t\t}\n\t} catch {}\n\t\n\ttry {\n\t\tawait availableAPIs.lldaInitPartitions();\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"initdisk: \" + await availableAPIs.lookupLocale(e.message) + \"\\r\\n\");\n\t}\n\tawait availableAPIs.terminate();\n})();\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); null;","4a39fe59890e2726b130bc1c7fb321401b8011c9d2deb8b7febf2aacc95de6a4b8241e9f98b9adcf16c16afb648848f19653537a9dde15a459512581a7ed74bb":"// =====BEGIN MANIFEST=====\n// allow: GET_LOCALE, LLDISK_WRITE, LLDISK_READ, FS_READ, FS_WRITE, FS_BYPASS_PERMISSIONS, LLDISK_LIST_PARTITIONS, LLDISK_REMOVE\n// signer: automaticSigner\n// signature: 6e7ff39dde3e86a5643b710b215cd050165e2ce79cee6b9033a1efd349515684d52aced7f4caaa56ac48059a98503843ab42794066aefe6b82fc52fa246d3c03\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.windowVisibility(false);\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"llda_tool: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\tif (!exec_args.length) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_ACTION_EXPORT\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_ACTION_IMPORT\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_ACTION_IMPORTSTRING\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_ACTION_COPY\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_ACTION_REMOVE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_ACTION_LIST\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_DISCLAIMER\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"llda_tool: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\n\ttry {\n\t\tif (exec_args[0] == \"export\") {\n\t\t\tawait availableAPIs.fs_write({\n\t\t\t\tpath: exec_args[2],\n\t\t\t\tdata: JSON.stringify(await availableAPIs.lldaRead({ partition: exec_args[1] }))\n\t\t\t});\n\t\t} else if (exec_args[0] == \"import\") {\n\t\t\tawait availableAPIs.lldaWrite({ partition: exec_args[2], data: JSON.parse(await availableAPIs.fs_read({ path: exec_args[1] })) });\n\t\t} else if (exec_args[0] == \"importstring\") {\n\t\t\tawait availableAPIs.lldaWrite({ partition: exec_args[2], data: await availableAPIs.fs_read({ path: exec_args[1] }) });\n\t\t} else if (exec_args[0] == \"copy\") {\n\t\t\tawait availableAPIs.lldaWrite({ partition: exec_args[2], data: await availableAPIs.lldaRead({ partition: exec_args[1] }) });\n\t\t} else if (exec_args[0] == \"remove\") {\n\t\t\tawait availableAPIs.lldaRemove({ partition: exec_args[1] });\n\t\t} else if (exec_args[0] == \"list\") {\n\t\t\tawait availableAPIs.toMyCLI(JSON.stringify(await availableAPIs.lldaList()) + \"\\r\\n\");\n\t\t} else {\n\t\t\tawait availableAPIs.toMyCLI(\"llda_tool: \" + await availableAPIs.lookupLocale(\"LLDA_UNKNOWN_ACTION\") + \"\\r\\n\");\n\t\t}\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"llda_tool: \" + await availableAPIs.lookupLocale(e.message) + \"\\r\\n\");\n\t}\n\t\n\tawait availableAPIs.terminate();\n})();\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); null;","1247eff9eaa3e383a5f8402794934d372cd4866beb9c3e2a153d02dea3ac5925e25fea292be47890436bcb12108238669feb7a3262419c58f6980edc89187682":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: GET_LOCALE, FS_MOUNT, GET_FILESYSTEMS\n// signature: b66db823eadcb66c4f185a70b79c00f95d5f7e0df4607965409947ecc93f96f078d0e2c5a42b1a65cb84bb4be77a833412e7554bb3a92b3299001b94e1be2c0b\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"mount: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\n\tlet pargs = {};\n\tlet ppos = [];\n\tfor (let arg of exec_args) {\n\t\tif (arg.startsWith(\"--\")) {\n\t\t\tlet key = arg.split(\"=\")[0].slice(2);\n\t\t\tlet value = arg.split(\"=\").slice(1).join(\"=\");\n\t\t\tif (arg.split(\"=\")[1] == null) value = true;\n\t\t\tif (pargs.hasOwnProperty(key)) {\n\t\t\t\tlet ogValues = pargs[key];\n\t\t\t\tif (ogValues instanceof Array) pargs[key] = [ ...ogValues, value ];\n\t\t\t\telse pargs[key] = [ ogValues, value ];\n\t\t\t} else pargs[key] = value;\n\t\t} else ppos.push(arg);\n\t}\n\n\tif (ppos.length < 2) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"MOUNT_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"MOUNT_DESCRIPTION\") + \"\\r\\n\");\n\t\ttry {\n\t\t\tawait availableAPIs.toMyCLI((await availableAPIs.lookupLocale(\"MOUNT_KNOWN_FS\")).replace(\"%s\", (await availableAPIs.supportedFilesystems()).join(\", \")) + \"\\r\\n\");\n\t\t} catch {\n\t\t\tawait availableAPIs.toMyCLI((await availableAPIs.lookupLocale(\"MOUNT_KNOWN_FS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"UNKNOWN_PLACEHOLDER\")) + \"\\r\\n\");\n\t\t}\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PPART\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PINPA\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PPASS\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PKEY\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PTYPE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PURL\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PINPI\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_POUPI\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"mount: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\n\ttry {\n\t\tawait availableAPIs.fs_mount({\n\t\t\tmountpoint: ppos[1],\n\t\t\tfilesystem: ppos[0],\n\t\t\tfilesystemOptions: pargs\n\t\t});\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"mount: \" + await availableAPIs.lookupLocale(e.message) + \"\\r\\n\");\n\t}\n\tawait availableAPIs.terminate();\n})();\n\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); ","bda243c3a3de2a07b4c01c2145d8e1cfaed38b577c9b5872931d2360e21ce8cd716cdcebfa60bbe9cf1aaf49550cecf4f110361f8ac5baa3a097756a29bb868b":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: GET_LOCALE, FS_LIST_PARTITIONS, GET_FILESYSTEMS\n// signature: 94ae29ad3355acb5baf4dcc5747c12d3a13c38718cc8d642c1e14bcec66edb2c23c67223a2617888a9be9413a5b3df0c22310a19ba4de2a10fc1d8b9aba8830c\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"mountinfo: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\n\tlet pargs = {};\n\tlet ppos = [];\n\tfor (let arg of exec_args) {\n\t\tif (arg.startsWith(\"--\")) {\n\t\t\tlet key = arg.split(\"=\")[0].slice(2);\n\t\t\tlet value = arg.split(\"=\").slice(1).join(\"=\");\n\t\t\tif (arg.split(\"=\")[1] == null) value = true;\n\t\t\tif (pargs.hasOwnProperty(key)) {\n\t\t\t\tlet ogValues = pargs[key];\n\t\t\t\tif (ogValues instanceof Array) pargs[key] = [ ...ogValues, value ];\n\t\t\t\telse pargs[key] = [ ogValues, value ];\n\t\t\t} else pargs[key] = value;\n\t\t} else ppos.push(arg);\n\t}\n\n\tif (ppos.length < 1) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"MOUNTINFO_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"MOUNTINFO_DESCRIPTION\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"mountinfo: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\n\ttry {\n\t\tawait availableAPIs.toMyCLI(JSON.stringify(await availableAPIs.fs_mountInfo(ppos[0]), null, \"\\t\").replaceAll(\"\\n\", \"\\r\\n\") + \"\\r\\n\");\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"mountinfo: \" + await availableAPIs.lookupLocale(e.message) + \"\\r\\n\");\n\t}\n\tawait availableAPIs.terminate();\n})();\n\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); ","19a6a030c7ad32cc5ea1da1d74321710e5b300a03a6f7037353464612bf3b8ff7e6a149d2b3ae4f07549d419f81bb84af5fcd29e4570b431dceac29cc8a1ae78":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: GET_LOCALE, SET_DEFAULT_SYSTEM\n// signature: dc13ef321b4c31c930b291d610a5cbc3f6fe4f3529735908ed4b3b9613a2823d16ff3164707ce5b1ce57ffe3afc5118363628f45c0daac61aaa8fa43a102e803\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.windowVisibility(false);\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"pivot_root: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\tif (!exec_args.length) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"PIVOT_ROOT_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"PIVOT_ROOT_DESCRIPTION\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"pivot_root: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\tawait availableAPIs.setSystemMount(exec_args[0]);\n\tawait availableAPIs.terminate();\n})();\n\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); null;","7a87a8c812d21de5699c14d6b7b24badf6566032f83ae7968f869a7fdee5579a9023acabcb592fca9178b9a73d0a6e8c65466836f309308d75a6ec98a8fd8768":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: GET_LOCALE, FS_UNMOUNT, GET_FILESYSTEMS\n// signature: db8cf0242ae539d5fb9249020281174539f65e5b50cf01e3647966a5e5be60241b1208f35c2436b78c2c459c33c2d6127785e29f0b68e87993d91a8cd656e00f\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"umount: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\n\tlet pargs = {};\n\tlet ppos = [];\n\tfor (let arg of exec_args) {\n\t\tif (arg.startsWith(\"--\")) {\n\t\t\tlet key = arg.split(\"=\")[0].slice(2);\n\t\t\tlet value = arg.split(\"=\").slice(1).join(\"=\");\n\t\t\tif (arg.split(\"=\")[1] == null) value = true;\n\t\t\tif (pargs.hasOwnProperty(key)) {\n\t\t\t\tlet ogValues = pargs[key];\n\t\t\t\tif (ogValues instanceof Array) pargs[key] = [ ...ogValues, value ];\n\t\t\t\telse pargs[key] = [ ogValues, value ];\n\t\t\t} else pargs[key] = value;\n\t\t} else ppos.push(arg);\n\t}\n\n\tif (ppos.length < 1) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"UMOUNT_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"UMOUNT_DESCRIPTION\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"UMOUNT_OPT_SYNCONLY\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"UMOUNT_OPT_FORCE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"umount: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\n\ttry {\n\t\tawait availableAPIs[\"fs_\" + (pargs[\"sync-only\"] == true ? \"sync\" : \"unmount\")]({\n\t\t\tmount: ppos[0],\n\t\t\tforce: pargs.force\n\t\t});\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"umount: \" + await availableAPIs.lookupLocale(e.message) + \"\\r\\n\");\n\t}\n\tawait availableAPIs.terminate();\n})();\n\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); "},"buildInfo":{"for":"1332","version":"1332","when":1751657439225,"signer":"moduleSigner","critical":false,"bootOrder":"50","signature":"f71ea6266c41c440041ac3df07d004bc560f295c99357f5155a5b92071a4524e189f8883121b4b8d4f3b14292db9722facf671af2443397f2853881840262303"}}