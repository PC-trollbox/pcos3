{"backend":{"files":{"apps":{"df.js":"d033565ee1e23fba9fc198d4590d874c34fce6964a5bba0874af16c6e8a13d579ed078b6f7ef1659d3bbdfbb348d1921c4cc96292c611c658aacae384954bee7","format.js":"8fd8d7aa0cca5afec407cf7e1b936b3c672cfe26af094ae01f1a814eadc468f60cc9a5889cad747c01cb1159a433699402badd2a28c2845ceeff2807be060910","initdisk.js":"e3be7a782a892b75cc5d41a02448457cfb148b78bcc0d7b2bf8e8df17b54e8153b052864902e8dc60eb92c384614c9c1f8b8ffa7fbc7ae03da745440a2b90acd","llda_tool.js":"146671a9645fe361aa0e64c236ac21d11606c5e4f95b4f60777697dcc210ef1c671dfd6706bd5f0d9b9db4b7005da6e5919e8adeca695aec839c1ba248632d83","mount.js":"224c4d233e29b1f7dd32c164c11958abace269addb52acd059a568ad51f42acf0f4dcb31a5fd10028837f2bfbffca03eec38206b26c18166d21015bc35d54792","mountinfo.js":"148d7228dd22af718a0cd1e4ec5490d5b78ec5f260516c3da10a05045201b941d4bbae6a452777f3816deb42836a7161c1669e86deb1197c26ab5c747c1797ec","pivot_root.js":"d72e5e4a27b8b2fa0a55e5f1542af2c3f6af2dd8dd0dd34bc367e96795eea9a58be72240b2c4ef871333723949a4176fb09407ec8f0e08f57ccb4dc2dcadbd23","umount.js":"f7a9643e87b27444bd9b41dad837dcb2ad4f028ff6a1ab5925f12caef8041a47af07fb81a6f319b71dc9e2b23c2d8e933570e28dd5c548519e936054060e31ed"}},"permissions":{"apps/df.js":{"world":"rx"},"apps/format.js":{"world":"rx"},"apps/initdisk.js":{"world":"rx"},"apps/llda_tool.js":{"world":"rx"},"apps/mount.js":{"world":"rx"},"apps/mountinfo.js":{"world":"rx"},"apps/pivot_root.js":{"world":"rx"},"apps/umount.js":{"world":"rx"},"apps/":{"world":"rx"},"":{"world":"rx"}}},"files":{"d033565ee1e23fba9fc198d4590d874c34fce6964a5bba0874af16c6e8a13d579ed078b6f7ef1659d3bbdfbb348d1921c4cc96292c611c658aacae384954bee7":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: GET_LOCALE, FS_LIST_PARTITIONS\n// signature: 270e3ff5f552cddebd10b1e2e6bc5b2d406acb7e5acafaa5b11de8d63820070541a257c38d37821da87870840207955cbf860246852f88ad6deafef8da488f02\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.windowVisibility(false);\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"df: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\tlet human = exec_args.includes(\"-h\") || exec_args.includes(\"--human-readable\");\n\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"DF_HEADER\") + \"\\r\\n\");\n\tlet estimateStorage = await availableAPIs.estimateStorage();\n\tfor (let medium in estimateStorage) {\n\t\tlet displayedSize = estimateStorage[medium].total;\n\t\tif (human) displayedSize = await availableAPIs.ufInfoUnits([estimateStorage[medium].total, true]);\n\t\tlet displayedUsed = estimateStorage[medium].used;\n\t\tif (human) displayedUsed = await availableAPIs.ufInfoUnits([estimateStorage[medium].used, true]);\n\t\tlet displayedFree = estimateStorage[medium].free;\n\t\tif (human) displayedFree = await availableAPIs.ufInfoUnits([estimateStorage[medium].free, true]);\n\t\tawait availableAPIs.toMyCLI(medium + \"\\t\" + displayedSize + \"\\t\" + displayedUsed + \"\\t\" + displayedFree + \"\\t\" + Math.floor(estimateStorage[medium].used / estimateStorage[medium].total * 100) + \"%\\r\\n\");\n\t}\n\tawait availableAPIs.terminate();\n})();\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); null;","8fd8d7aa0cca5afec407cf7e1b936b3c672cfe26af094ae01f1a814eadc468f60cc9a5889cad747c01cb1159a433699402badd2a28c2845ceeff2807be060910":"// =====BEGIN MANIFEST=====\n// allow: GET_LOCALE, LLDISK_LIST_PARTITIONS, LLDISK_WRITE, LLDISK_REMOVE, LLDISK_READ, CSP_OPERATIONS\n// signer: automaticSigner\n// signature: 51ed74a9856cd40758c801d6d7cd2c99684fef58a8ce126f0dcffcd6f0a3450d8286e18915c618daeae7c7e80c8b9ba2a9f950a541b064d7c66b78e01cee3c0e\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.windowVisibility(false);\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"format: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\tif (!exec_args.length) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"FORMAT_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"FORMAT_DESCRIPTION\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"FORMAT_FSTYPE\") + \"\\r\\n\")\n\t\tawait availableAPIs.toMyCLI(\"format: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\tif (exec_args.length < 2 || exec_args.length > 3) {\n\t\tawait availableAPIs.toMyCLI(\"format: \" + await availableAPIs.lookupLocale(\"ARGUMENT_COUNT_MISMATCH\") + \"\\r\\n\");\n\t\treturn await availableAPIs.terminate();\n\t}\n\t\n\tlet knownNames;\n\ttry {\n\t\tknownNames = await availableAPIs.lldaList();\n\t\tif (knownNames.includes(exec_args[1]) && exec_args[2] != \"overwrite\") {\n\t\t\tawait availableAPIs.toMyCLI(\"format: \" + await availableAPIs.lookupLocale(\"FORMAT_OVERWRITE_WARN\") + \"\\r\\n\");\n\t\t\treturn await availableAPIs.terminate();\n\t\t}\n\n\t\tlet u8aToHex = (u8a) => Array.from(u8a).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\tif (exec_args[0] == \"pcfs\") {\n\t\t\tlet prevId = (await availableAPIs.lldaRead({ partition: exec_args[1] }))?.id || u8aToHex(await availableAPIs.cspOperation({\n\t\t\t\tcspProvider: \"basic\",\n\t\t\t\toperation: \"random\",\n\t\t\t\tcspArgument: new Uint8Array(64)\n\t\t\t}));\n\t\t\tawait availableAPIs.lldaWrite({\n\t\t\t\tpartition: exec_args[1],\n\t\t\t\tdata: {\n\t\t\t\t\tfiles: {},\n\t\t\t\t\tpermissions: {},\n\t\t\t\t\tid: prevId\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (exec_args[0].startsWith(\"pcfs_crypt\")) {\n\t\t\tlet monokey = exec_args[0].endsWith(\"_monokey\");\n\t\t\tlet prevId = (await availableAPIs.lldaRead({ partition: exec_args[1] }))?.id || u8aToHex(await availableAPIs.cspOperation({\n\t\t\t\tcspProvider: \"basic\",\n\t\t\t\toperation: \"random\",\n\t\t\t\tcspArgument: new Uint8Array(64)\n\t\t\t}));\n\t\t\tlet salt = u8aToHex(await availableAPIs.cspOperation({\n\t\t\t\tcspProvider: \"basic\",\n\t\t\t\toperation: \"random\",\n\t\t\t\tcspArgument: new Uint8Array(32)\n\t\t\t}));\n\t\t\tawait availableAPIs.lldaWrite({\n\t\t\t\tpartition: exec_args[1],\n\t\t\t\tdata: {\n\t\t\t\t\tfiles: {},\n\t\t\t\t\tpermissions: {},\n\t\t\t\t\tid: prevId,\n\t\t\t\t\tcryptodata: {\n\t\t\t\t\t\tpasswordLockingInitial: monokey,\n\t\t\t\t\t\tsalt: salt\n\t\t\t\t\t},\n\t\t\t\t\tencryptedFileTable: exec_args[0].endsWith(\"_filetable_monokey\")\n\t\t\t\t}\n\t\t\t})\n\t\t} else if (exec_args[0].startsWith(\"pcbm:\")) {\n\t\t\tlet diskDataPartition = exec_args[0].split(\":\").slice(1).join(\":\");\n\t\t\tawait availableAPIs.lldaWrite({\n\t\t\t\tpartition: exec_args[1],\n\t\t\t\tdata: `try {\n\t\t\t\t\tconst AsyncFunction = (async () => {}).constructor;\n\t\t\t\t\tlet pre_boot_part = coreExports.disk.partition(${JSON.stringify(diskDataPartition)}).getData();\n\t\t\t\t\tlet pre_boot_modules = pre_boot_part?.files;\n\t\t\t\t\tif (!pre_boot_modules) {\n\t\t\t\t\t\tcoreExports.tty_bios_api.println(\"No files were found in the storage partition\");\n\t\t\t\t\t\tthrow new Error(\"No files were found in the storage partition\");\n\t\t\t\t\t}\n\t\t\t\t\tpre_boot_modules = pre_boot_modules[coreExports.bootSection || \"boot\"];\n\t\t\t\t\tif (!pre_boot_modules) {\n\t\t\t\t\t\tcoreExports.tty_bios_api.println(\"No boot modules were found\");\n\t\t\t\t\t\tthrow new Error(\"No boot modules were found\");\n\t\t\t\t\t}\n\t\t\t\t\tlet pre_boot_module_list = Object.keys(pre_boot_modules);\n\t\t\t\t\tpre_boot_module_list = pre_boot_module_list.sort((a, b) => a.localeCompare(b));\n\t\t\t\t\tlet pre_boot_module_script = \"\";\n\t\t\t\t\tfor (let module of pre_boot_module_list) {\n\t\t\t\t\t\tif (coreExports.bootMode == \"logboot\") pre_boot_module_script += \"coreExports.tty_bios_api.println(\" + JSON.stringify(module) + \");\\\\n\";\n\t\t\t\t\t\tpre_boot_module_script += await coreExports.idb.readPart(pre_boot_part.id + \"-\" + pre_boot_modules[module]);\n\t\t\t\t\t}\n\t\t\t\t\tawait new AsyncFunction(pre_boot_module_script)();\n\t\t\t\t} catch (e) {\n\t\t\t\t\tcoreExports.tty_bios_api.println(\"Boot failed\");\n\t\t\t\t\tcoreExports.tty_bios_api.println(\"Press Enter to continue and log this error locally\");\n\t\t\t\t\tawait coreExports.tty_bios_api.inputLine();\n\t\t\t\t\tthrow e;\n\t\t\t\t}`\n\t\t\t});\n\t\t} else if (exec_args[0] == \"null\") {\n\t\t\tawait availableAPIs.lldaRemove({\n\t\t\t\tpartition: exec_args[1]\n\t\t\t});\n\t\t} else {\n\t\t\tawait availableAPIs.toMyCLI(\"format: \" + await availableAPIs.lookupLocale(\"FORMAT_UNKNOWN_FSTYPE\") + \"\\r\\n\");\n\t\t}\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"format: \" + e.name + \": \" + await availableAPIs.lookupLocale(e.message) + \" (\" + e.message + \")\\r\\n\");\n\t\treturn await availableAPIs.terminate();\n\t}\n\t\n\tawait availableAPIs.terminate();\n})();\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); null;","e3be7a782a892b75cc5d41a02448457cfb148b78bcc0d7b2bf8e8df17b54e8153b052864902e8dc60eb92c384614c9c1f8b8ffa7fbc7ae03da745440a2b90acd":"// =====BEGIN MANIFEST=====\n// allow: GET_LOCALE, LLDISK_LIST_PARTITIONS, LLDISK_INIT_PARTITIONS\n// signer: automaticSigner\n// signature: 353a98f62dd474c05c23d7fe3afaf044166bad6a7868c893ab653a473a70c54ebf2d8bfbbbca517d2e9d328884bd3a7de313ac7dc11a30fb56e6d1f68796200e\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.windowVisibility(false);\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"initdisk: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\tif (!exec_args.length) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"INITDISK_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"INITDISK_DESCRIPTION\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"initdisk: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\tif (exec_args.length > 2) {\n\t\tawait availableAPIs.toMyCLI(\"initdisk: \" + await availableAPIs.lookupLocale(\"ARGUMENT_COUNT_MISMATCH\") + \"\\r\\n\");\n\t\treturn await availableAPIs.terminate();\n\t}\n\t\n\ttry {\n\t\tawait availableAPIs.lldaList();\n\t\tif (exec_args[1] != \"overwrite\") {\n\t\t\tawait availableAPIs.toMyCLI(\"initdisk: \" + await availableAPIs.lookupLocale(\"INITDISK_OVERWRITE_WARN\") + \"\\r\\n\");\n\t\t\treturn await availableAPIs.terminate();\n\t\t}\n\t} catch {}\n\t\n\ttry {\n\t\tawait availableAPIs.lldaInitPartitions();\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"initdisk: \" + await availableAPIs.lookupLocale(e.message) + \"\\r\\n\");\n\t}\n\tawait availableAPIs.terminate();\n})();\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); null;","146671a9645fe361aa0e64c236ac21d11606c5e4f95b4f60777697dcc210ef1c671dfd6706bd5f0d9b9db4b7005da6e5919e8adeca695aec839c1ba248632d83":"// =====BEGIN MANIFEST=====\n// allow: GET_LOCALE, LLDISK_WRITE, LLDISK_READ, FS_READ, FS_WRITE, FS_BYPASS_PERMISSIONS, LLDISK_LIST_PARTITIONS, LLDISK_REMOVE\n// signer: automaticSigner\n// signature: 6e7ff39dde3e86a5643b710b215cd050165e2ce79cee6b9033a1efd349515684d52aced7f4caaa56ac48059a98503843ab42794066aefe6b82fc52fa246d3c03\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.windowVisibility(false);\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"llda_tool: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\tif (!exec_args.length) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_ACTION_EXPORT\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_ACTION_IMPORT\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_ACTION_IMPORTSTRING\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_ACTION_COPY\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_ACTION_REMOVE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_ACTION_LIST\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_DISCLAIMER\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"llda_tool: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\n\ttry {\n\t\tif (exec_args[0] == \"export\") {\n\t\t\tawait availableAPIs.fs_write({\n\t\t\t\tpath: exec_args[2],\n\t\t\t\tdata: JSON.stringify(await availableAPIs.lldaRead({ partition: exec_args[1] }))\n\t\t\t});\n\t\t} else if (exec_args[0] == \"import\") {\n\t\t\tawait availableAPIs.lldaWrite({ partition: exec_args[2], data: JSON.parse(await availableAPIs.fs_read({ path: exec_args[1] })) });\n\t\t} else if (exec_args[0] == \"importstring\") {\n\t\t\tawait availableAPIs.lldaWrite({ partition: exec_args[2], data: await availableAPIs.fs_read({ path: exec_args[1] }) });\n\t\t} else if (exec_args[0] == \"copy\") {\n\t\t\tawait availableAPIs.lldaWrite({ partition: exec_args[2], data: await availableAPIs.lldaRead({ partition: exec_args[1] }) });\n\t\t} else if (exec_args[0] == \"remove\") {\n\t\t\tawait availableAPIs.lldaRemove({ partition: exec_args[1] });\n\t\t} else if (exec_args[0] == \"list\") {\n\t\t\tawait availableAPIs.toMyCLI(JSON.stringify(await availableAPIs.lldaList()) + \"\\r\\n\");\n\t\t} else {\n\t\t\tawait availableAPIs.toMyCLI(\"llda_tool: \" + await availableAPIs.lookupLocale(\"LLDA_UNKNOWN_ACTION\") + \"\\r\\n\");\n\t\t}\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"llda_tool: \" + await availableAPIs.lookupLocale(e.message) + \"\\r\\n\");\n\t}\n\t\n\tawait availableAPIs.terminate();\n})();\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); null;","224c4d233e29b1f7dd32c164c11958abace269addb52acd059a568ad51f42acf0f4dcb31a5fd10028837f2bfbffca03eec38206b26c18166d21015bc35d54792":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: GET_LOCALE, FS_MOUNT, GET_FILESYSTEMS\n// signature: b66db823eadcb66c4f185a70b79c00f95d5f7e0df4607965409947ecc93f96f078d0e2c5a42b1a65cb84bb4be77a833412e7554bb3a92b3299001b94e1be2c0b\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"mount: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\n\tlet pargs = {};\n\tlet ppos = [];\n\tfor (let arg of exec_args) {\n\t\tif (arg.startsWith(\"--\")) {\n\t\t\tlet key = arg.split(\"=\")[0].slice(2);\n\t\t\tlet value = arg.split(\"=\").slice(1).join(\"=\");\n\t\t\tif (arg.split(\"=\")[1] == null) value = true;\n\t\t\tif (pargs.hasOwnProperty(key)) {\n\t\t\t\tlet ogValues = pargs[key];\n\t\t\t\tif (ogValues instanceof Array) pargs[key] = [ ...ogValues, value ];\n\t\t\t\telse pargs[key] = [ ogValues, value ];\n\t\t\t} else pargs[key] = value;\n\t\t} else ppos.push(arg);\n\t}\n\n\tif (ppos.length < 2) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"MOUNT_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"MOUNT_DESCRIPTION\") + \"\\r\\n\");\n\t\ttry {\n\t\t\tawait availableAPIs.toMyCLI((await availableAPIs.lookupLocale(\"MOUNT_KNOWN_FS\")).replace(\"%s\", (await availableAPIs.supportedFilesystems()).join(\", \")) + \"\\r\\n\");\n\t\t} catch {\n\t\t\tawait availableAPIs.toMyCLI((await availableAPIs.lookupLocale(\"MOUNT_KNOWN_FS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"UNKNOWN_PLACEHOLDER\")) + \"\\r\\n\");\n\t\t}\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PPART\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PINPA\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PPASS\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PKEY\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PTYPE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PURL\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PINPI\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_POUPI\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"mount: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\n\ttry {\n\t\tawait availableAPIs.fs_mount({\n\t\t\tmountpoint: ppos[1],\n\t\t\tfilesystem: ppos[0],\n\t\t\tfilesystemOptions: pargs\n\t\t});\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"mount: \" + await availableAPIs.lookupLocale(e.message) + \"\\r\\n\");\n\t}\n\tawait availableAPIs.terminate();\n})();\n\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); ","148d7228dd22af718a0cd1e4ec5490d5b78ec5f260516c3da10a05045201b941d4bbae6a452777f3816deb42836a7161c1669e86deb1197c26ab5c747c1797ec":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: GET_LOCALE, FS_LIST_PARTITIONS, GET_FILESYSTEMS\n// signature: 94ae29ad3355acb5baf4dcc5747c12d3a13c38718cc8d642c1e14bcec66edb2c23c67223a2617888a9be9413a5b3df0c22310a19ba4de2a10fc1d8b9aba8830c\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"mountinfo: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\n\tlet pargs = {};\n\tlet ppos = [];\n\tfor (let arg of exec_args) {\n\t\tif (arg.startsWith(\"--\")) {\n\t\t\tlet key = arg.split(\"=\")[0].slice(2);\n\t\t\tlet value = arg.split(\"=\").slice(1).join(\"=\");\n\t\t\tif (arg.split(\"=\")[1] == null) value = true;\n\t\t\tif (pargs.hasOwnProperty(key)) {\n\t\t\t\tlet ogValues = pargs[key];\n\t\t\t\tif (ogValues instanceof Array) pargs[key] = [ ...ogValues, value ];\n\t\t\t\telse pargs[key] = [ ogValues, value ];\n\t\t\t} else pargs[key] = value;\n\t\t} else ppos.push(arg);\n\t}\n\n\tif (ppos.length < 1) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"MOUNTINFO_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"MOUNTINFO_DESCRIPTION\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"mountinfo: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\n\ttry {\n\t\tawait availableAPIs.toMyCLI(JSON.stringify(await availableAPIs.fs_mountInfo(ppos[0]), null, \"\\t\").replaceAll(\"\\n\", \"\\r\\n\") + \"\\r\\n\");\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"mountinfo: \" + await availableAPIs.lookupLocale(e.message) + \"\\r\\n\");\n\t}\n\tawait availableAPIs.terminate();\n})();\n\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); ","d72e5e4a27b8b2fa0a55e5f1542af2c3f6af2dd8dd0dd34bc367e96795eea9a58be72240b2c4ef871333723949a4176fb09407ec8f0e08f57ccb4dc2dcadbd23":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: GET_LOCALE, SET_DEFAULT_SYSTEM\n// signature: dc13ef321b4c31c930b291d610a5cbc3f6fe4f3529735908ed4b3b9613a2823d16ff3164707ce5b1ce57ffe3afc5118363628f45c0daac61aaa8fa43a102e803\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.windowVisibility(false);\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"pivot_root: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\tif (!exec_args.length) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"PIVOT_ROOT_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"PIVOT_ROOT_DESCRIPTION\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"pivot_root: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\tawait availableAPIs.setSystemMount(exec_args[0]);\n\tawait availableAPIs.terminate();\n})();\n\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); null;","f7a9643e87b27444bd9b41dad837dcb2ad4f028ff6a1ab5925f12caef8041a47af07fb81a6f319b71dc9e2b23c2d8e933570e28dd5c548519e936054060e31ed":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: GET_LOCALE, FS_UNMOUNT, GET_FILESYSTEMS\n// signature: db8cf0242ae539d5fb9249020281174539f65e5b50cf01e3647966a5e5be60241b1208f35c2436b78c2c459c33c2d6127785e29f0b68e87993d91a8cd656e00f\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"umount: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\n\tlet pargs = {};\n\tlet ppos = [];\n\tfor (let arg of exec_args) {\n\t\tif (arg.startsWith(\"--\")) {\n\t\t\tlet key = arg.split(\"=\")[0].slice(2);\n\t\t\tlet value = arg.split(\"=\").slice(1).join(\"=\");\n\t\t\tif (arg.split(\"=\")[1] == null) value = true;\n\t\t\tif (pargs.hasOwnProperty(key)) {\n\t\t\t\tlet ogValues = pargs[key];\n\t\t\t\tif (ogValues instanceof Array) pargs[key] = [ ...ogValues, value ];\n\t\t\t\telse pargs[key] = [ ogValues, value ];\n\t\t\t} else pargs[key] = value;\n\t\t} else ppos.push(arg);\n\t}\n\n\tif (ppos.length < 1) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"UMOUNT_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"UMOUNT_DESCRIPTION\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"UMOUNT_OPT_SYNCONLY\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"UMOUNT_OPT_FORCE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"umount: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\n\ttry {\n\t\tawait availableAPIs[\"fs_\" + (pargs[\"sync-only\"] == true ? \"sync\" : \"unmount\")]({\n\t\t\tmount: ppos[0],\n\t\t\tforce: pargs.force\n\t\t});\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"umount: \" + await availableAPIs.lookupLocale(e.message) + \"\\r\\n\");\n\t}\n\tawait availableAPIs.terminate();\n})();\n\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); "},"buildInfo":{"for":"1566","version":1566,"when":1764181671978,"signer":"moduleSigner","critical":false,"bootOrder":"50","commonName":"terminal-disks","friendlyNameRef":"TERMDISK_MODULE_NAME","signature":"a523642e2003025c6de73f5b3a3274e8d7bd379d60095c993a3be09a97d60d7f8878ac516f464d1304606ee3ce21f632df2e927a4d02b5715cacc52dea93970e"}}