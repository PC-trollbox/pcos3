{"backend":{"files":{"apps":{"df.js":"072c3e00baf5ef652fd715184ce51c74d9e45f820c5a07d0a513f509f3dfcb3597ca1011ce7389990ba1b3ddd91d81ee0f96c318308ca6cab67fb6bc0c53f37a","format.js":"9d6f64d0b0ad2c17f0d8d89de0deb5a777aa396d0b068266e519d7dde84ceb33decda0c6eab0d2f9ef2c20c60e28b89893f8048448f1a8df5014a5a3569ed76f","initdisk.js":"4ba767e56abe90272bcd1bb17309730a7766016759ea8bed27807bf376685db27a924dc94b3c82d371d00f624860f37583d618c987fbf8a6086808ecb2c74399","llda_tool.js":"f33b2eabaf679a0a9b40f97658d1d623e4a86929a15859efe52d7ffca9e493b1f4bed6935b5412966eb90c03907f7c1dcfd1f47e8b9f81bf7d22c6e223565308","mount.js":"adcc13888d32e3d19f43226b9d8882565b2d8e4b1022a3ef4fb622cfc216ca52cb3bc460f6dd2b802a6d7f026512b9f19f5a0109b08147adcef88cf19bc58a3b","mountinfo.js":"1f5649440da37b22a6eb67199f170ca05114f39f33337530683a510f1df2556956f722f95cb2bd0c8f315c366c21f803df3b0c2df4e7a0cc79a910055860fef6","pivot_root.js":"d639b0edacf3ea08d5dd78a9646e79ce663dcf5fd11fdbdea9c62d49c857a99dfb7cc2ccc285eed2190eeaa6fee3cb0a09d52c1ff0e089adc50213c6acfe29ee","umount.js":"4a438d47fd71377639c71be621cee81f893ec021d05bd56c7afa9415da2429d4ff95f588ce4853b06531d84a848e017f3e585bf6c5528b9a7e1d601761201a8f"}},"permissions":{"apps/df.js":{"world":"rx"},"apps/format.js":{"world":"rx"},"apps/initdisk.js":{"world":"rx"},"apps/llda_tool.js":{"world":"rx"},"apps/mount.js":{"world":"rx"},"apps/mountinfo.js":{"world":"rx"},"apps/pivot_root.js":{"world":"rx"},"apps/umount.js":{"world":"rx"},"apps/":{"world":"rx"},"":{"world":"rx"}}},"files":{"072c3e00baf5ef652fd715184ce51c74d9e45f820c5a07d0a513f509f3dfcb3597ca1011ce7389990ba1b3ddd91d81ee0f96c318308ca6cab67fb6bc0c53f37a":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: GET_LOCALE, FS_LIST_PARTITIONS\n// signature: 270e3ff5f552cddebd10b1e2e6bc5b2d406acb7e5acafaa5b11de8d63820070541a257c38d37821da87870840207955cbf860246852f88ad6deafef8da488f02\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.windowVisibility(false);\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"df: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\tlet human = exec_args.includes(\"-h\") || exec_args.includes(\"--human-readable\");\n\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"DF_HEADER\") + \"\\r\\n\");\n\tlet estimateStorage = await availableAPIs.estimateStorage();\n\tfor (let medium in estimateStorage) {\n\t\tlet displayedSize = estimateStorage[medium].total;\n\t\tif (human) displayedSize = await availableAPIs.ufInfoUnits([estimateStorage[medium].total, true]);\n\t\tlet displayedUsed = estimateStorage[medium].used;\n\t\tif (human) displayedUsed = await availableAPIs.ufInfoUnits([estimateStorage[medium].used, true]);\n\t\tlet displayedFree = estimateStorage[medium].free;\n\t\tif (human) displayedFree = await availableAPIs.ufInfoUnits([estimateStorage[medium].free, true]);\n\t\tawait availableAPIs.toMyCLI(medium + \"\\t\" + displayedSize + \"\\t\" + displayedUsed + \"\\t\" + displayedFree + \"\\t\" + Math.floor(estimateStorage[medium].used / estimateStorage[medium].total * 100) + \"%\\r\\n\");\n\t}\n\tawait availableAPIs.terminate();\n})();\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); null;","9d6f64d0b0ad2c17f0d8d89de0deb5a777aa396d0b068266e519d7dde84ceb33decda0c6eab0d2f9ef2c20c60e28b89893f8048448f1a8df5014a5a3569ed76f":"// =====BEGIN MANIFEST=====\n// allow: GET_LOCALE, LLDISK_LIST_PARTITIONS, LLDISK_WRITE, LLDISK_REMOVE, LLDISK_READ, CSP_OPERATIONS\n// signer: automaticSigner\n// signature: 51ed74a9856cd40758c801d6d7cd2c99684fef58a8ce126f0dcffcd6f0a3450d8286e18915c618daeae7c7e80c8b9ba2a9f950a541b064d7c66b78e01cee3c0e\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.windowVisibility(false);\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"format: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\tif (!exec_args.length) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"FORMAT_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"FORMAT_DESCRIPTION\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"FORMAT_FSTYPE\") + \"\\r\\n\")\n\t\tawait availableAPIs.toMyCLI(\"format: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\tif (exec_args.length < 2 || exec_args.length > 3) {\n\t\tawait availableAPIs.toMyCLI(\"format: \" + await availableAPIs.lookupLocale(\"ARGUMENT_COUNT_MISMATCH\") + \"\\r\\n\");\n\t\treturn await availableAPIs.terminate();\n\t}\n\t\n\tlet knownNames;\n\ttry {\n\t\tknownNames = await availableAPIs.lldaList();\n\t\tif (knownNames.includes(exec_args[1]) && exec_args[2] != \"overwrite\") {\n\t\t\tawait availableAPIs.toMyCLI(\"format: \" + await availableAPIs.lookupLocale(\"FORMAT_OVERWRITE_WARN\") + \"\\r\\n\");\n\t\t\treturn await availableAPIs.terminate();\n\t\t}\n\n\t\tlet u8aToHex = (u8a) => Array.from(u8a).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\tif (exec_args[0] == \"pcfs\") {\n\t\t\tlet prevId = (await availableAPIs.lldaRead({ partition: exec_args[1] }))?.id || u8aToHex(await availableAPIs.cspOperation({\n\t\t\t\tcspProvider: \"basic\",\n\t\t\t\toperation: \"random\",\n\t\t\t\tcspArgument: new Uint8Array(64)\n\t\t\t}));\n\t\t\tawait availableAPIs.lldaWrite({\n\t\t\t\tpartition: exec_args[1],\n\t\t\t\tdata: {\n\t\t\t\t\tfiles: {},\n\t\t\t\t\tpermissions: {},\n\t\t\t\t\tid: prevId\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (exec_args[0].startsWith(\"pcfs_crypt\")) {\n\t\t\tlet monokey = exec_args[0].endsWith(\"_monokey\");\n\t\t\tlet prevId = (await availableAPIs.lldaRead({ partition: exec_args[1] }))?.id || u8aToHex(await availableAPIs.cspOperation({\n\t\t\t\tcspProvider: \"basic\",\n\t\t\t\toperation: \"random\",\n\t\t\t\tcspArgument: new Uint8Array(64)\n\t\t\t}));\n\t\t\tlet salt = u8aToHex(await availableAPIs.cspOperation({\n\t\t\t\tcspProvider: \"basic\",\n\t\t\t\toperation: \"random\",\n\t\t\t\tcspArgument: new Uint8Array(32)\n\t\t\t}));\n\t\t\tawait availableAPIs.lldaWrite({\n\t\t\t\tpartition: exec_args[1],\n\t\t\t\tdata: {\n\t\t\t\t\tfiles: {},\n\t\t\t\t\tpermissions: {},\n\t\t\t\t\tid: prevId,\n\t\t\t\t\tcryptodata: {\n\t\t\t\t\t\tpasswordLockingInitial: monokey,\n\t\t\t\t\t\tsalt: salt\n\t\t\t\t\t},\n\t\t\t\t\tencryptedFileTable: exec_args[0].endsWith(\"_filetable_monokey\")\n\t\t\t\t}\n\t\t\t})\n\t\t} else if (exec_args[0].startsWith(\"pcbm:\")) {\n\t\t\tlet diskDataPartition = exec_args[0].split(\":\").slice(1).join(\":\");\n\t\t\tawait availableAPIs.lldaWrite({\n\t\t\t\tpartition: exec_args[1],\n\t\t\t\tdata: `try {\n\t\t\t\t\tconst AsyncFunction = (async () => {}).constructor;\n\t\t\t\t\tlet pre_boot_part = coreExports.disk.partition(${JSON.stringify(diskDataPartition)}).getData();\n\t\t\t\t\tlet pre_boot_modules = pre_boot_part?.files;\n\t\t\t\t\tif (!pre_boot_modules) {\n\t\t\t\t\t\tcoreExports.tty_bios_api.println(\"No files were found in the storage partition\");\n\t\t\t\t\t\tthrow new Error(\"No files were found in the storage partition\");\n\t\t\t\t\t}\n\t\t\t\t\tpre_boot_modules = pre_boot_modules[coreExports.bootSection || \"boot\"];\n\t\t\t\t\tif (!pre_boot_modules) {\n\t\t\t\t\t\tcoreExports.tty_bios_api.println(\"No boot modules were found\");\n\t\t\t\t\t\tthrow new Error(\"No boot modules were found\");\n\t\t\t\t\t}\n\t\t\t\t\tlet pre_boot_module_list = Object.keys(pre_boot_modules);\n\t\t\t\t\tpre_boot_module_list = pre_boot_module_list.sort((a, b) => a.localeCompare(b));\n\t\t\t\t\tlet pre_boot_module_script = \"\";\n\t\t\t\t\tfor (let module of pre_boot_module_list) {\n\t\t\t\t\t\tif (coreExports.bootMode == \"logboot\") pre_boot_module_script += \"coreExports.tty_bios_api.println(\" + JSON.stringify(module) + \");\\\\n\";\n\t\t\t\t\t\tpre_boot_module_script += await coreExports.idb.readPart(pre_boot_part.id + \"-\" + pre_boot_modules[module]);\n\t\t\t\t\t}\n\t\t\t\t\tawait new AsyncFunction(pre_boot_module_script)();\n\t\t\t\t} catch (e) {\n\t\t\t\t\tcoreExports.tty_bios_api.println(\"Boot failed\");\n\t\t\t\t\tcoreExports.tty_bios_api.println(\"Press Enter to continue and log this error locally\");\n\t\t\t\t\tawait coreExports.tty_bios_api.inputLine();\n\t\t\t\t\tthrow e;\n\t\t\t\t}`\n\t\t\t});\n\t\t} else if (exec_args[0] == \"null\") {\n\t\t\tawait availableAPIs.lldaRemove({\n\t\t\t\tpartition: exec_args[1]\n\t\t\t});\n\t\t} else {\n\t\t\tawait availableAPIs.toMyCLI(\"format: \" + await availableAPIs.lookupLocale(\"FORMAT_UNKNOWN_FSTYPE\") + \"\\r\\n\");\n\t\t}\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"format: \" + e.name + \": \" + await availableAPIs.lookupLocale(e.message) + \" (\" + e.message + \")\\r\\n\");\n\t\treturn await availableAPIs.terminate();\n\t}\n\t\n\tawait availableAPIs.terminate();\n})();\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); null;","4ba767e56abe90272bcd1bb17309730a7766016759ea8bed27807bf376685db27a924dc94b3c82d371d00f624860f37583d618c987fbf8a6086808ecb2c74399":"// =====BEGIN MANIFEST=====\n// allow: GET_LOCALE, LLDISK_LIST_PARTITIONS, LLDISK_INIT_PARTITIONS\n// signer: automaticSigner\n// signature: 353a98f62dd474c05c23d7fe3afaf044166bad6a7868c893ab653a473a70c54ebf2d8bfbbbca517d2e9d328884bd3a7de313ac7dc11a30fb56e6d1f68796200e\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.windowVisibility(false);\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"initdisk: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\tif (!exec_args.length) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"INITDISK_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"INITDISK_DESCRIPTION\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"initdisk: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\tif (exec_args.length > 2) {\n\t\tawait availableAPIs.toMyCLI(\"initdisk: \" + await availableAPIs.lookupLocale(\"ARGUMENT_COUNT_MISMATCH\") + \"\\r\\n\");\n\t\treturn await availableAPIs.terminate();\n\t}\n\t\n\ttry {\n\t\tawait availableAPIs.lldaList();\n\t\tif (exec_args[1] != \"overwrite\") {\n\t\t\tawait availableAPIs.toMyCLI(\"initdisk: \" + await availableAPIs.lookupLocale(\"INITDISK_OVERWRITE_WARN\") + \"\\r\\n\");\n\t\t\treturn await availableAPIs.terminate();\n\t\t}\n\t} catch {}\n\t\n\ttry {\n\t\tawait availableAPIs.lldaInitPartitions();\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"initdisk: \" + await availableAPIs.lookupLocale(e.message) + \"\\r\\n\");\n\t}\n\tawait availableAPIs.terminate();\n})();\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); null;","f33b2eabaf679a0a9b40f97658d1d623e4a86929a15859efe52d7ffca9e493b1f4bed6935b5412966eb90c03907f7c1dcfd1f47e8b9f81bf7d22c6e223565308":"// =====BEGIN MANIFEST=====\n// allow: GET_LOCALE, LLDISK_WRITE, LLDISK_READ, FS_READ, FS_WRITE, FS_BYPASS_PERMISSIONS, LLDISK_LIST_PARTITIONS, LLDISK_REMOVE\n// signer: automaticSigner\n// signature: 6e7ff39dde3e86a5643b710b215cd050165e2ce79cee6b9033a1efd349515684d52aced7f4caaa56ac48059a98503843ab42794066aefe6b82fc52fa246d3c03\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.windowVisibility(false);\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"llda_tool: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\tif (!exec_args.length) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_ACTION_EXPORT\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_ACTION_IMPORT\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_ACTION_IMPORTSTRING\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_ACTION_COPY\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_ACTION_REMOVE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_ACTION_LIST\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_DISCLAIMER\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"llda_tool: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\n\ttry {\n\t\tif (exec_args[0] == \"export\") {\n\t\t\tawait availableAPIs.fs_write({\n\t\t\t\tpath: exec_args[2],\n\t\t\t\tdata: JSON.stringify(await availableAPIs.lldaRead({ partition: exec_args[1] }))\n\t\t\t});\n\t\t} else if (exec_args[0] == \"import\") {\n\t\t\tawait availableAPIs.lldaWrite({ partition: exec_args[2], data: JSON.parse(await availableAPIs.fs_read({ path: exec_args[1] })) });\n\t\t} else if (exec_args[0] == \"importstring\") {\n\t\t\tawait availableAPIs.lldaWrite({ partition: exec_args[2], data: await availableAPIs.fs_read({ path: exec_args[1] }) });\n\t\t} else if (exec_args[0] == \"copy\") {\n\t\t\tawait availableAPIs.lldaWrite({ partition: exec_args[2], data: await availableAPIs.lldaRead({ partition: exec_args[1] }) });\n\t\t} else if (exec_args[0] == \"remove\") {\n\t\t\tawait availableAPIs.lldaRemove({ partition: exec_args[1] });\n\t\t} else if (exec_args[0] == \"list\") {\n\t\t\tawait availableAPIs.toMyCLI(JSON.stringify(await availableAPIs.lldaList()) + \"\\r\\n\");\n\t\t} else {\n\t\t\tawait availableAPIs.toMyCLI(\"llda_tool: \" + await availableAPIs.lookupLocale(\"LLDA_UNKNOWN_ACTION\") + \"\\r\\n\");\n\t\t}\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"llda_tool: \" + await availableAPIs.lookupLocale(e.message) + \"\\r\\n\");\n\t}\n\t\n\tawait availableAPIs.terminate();\n})();\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); null;","adcc13888d32e3d19f43226b9d8882565b2d8e4b1022a3ef4fb622cfc216ca52cb3bc460f6dd2b802a6d7f026512b9f19f5a0109b08147adcef88cf19bc58a3b":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: GET_LOCALE, FS_MOUNT, GET_FILESYSTEMS\n// signature: b66db823eadcb66c4f185a70b79c00f95d5f7e0df4607965409947ecc93f96f078d0e2c5a42b1a65cb84bb4be77a833412e7554bb3a92b3299001b94e1be2c0b\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"mount: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\n\tlet pargs = {};\n\tlet ppos = [];\n\tfor (let arg of exec_args) {\n\t\tif (arg.startsWith(\"--\")) {\n\t\t\tlet key = arg.split(\"=\")[0].slice(2);\n\t\t\tlet value = arg.split(\"=\").slice(1).join(\"=\");\n\t\t\tif (arg.split(\"=\")[1] == null) value = true;\n\t\t\tif (pargs.hasOwnProperty(key)) {\n\t\t\t\tlet ogValues = pargs[key];\n\t\t\t\tif (ogValues instanceof Array) pargs[key] = [ ...ogValues, value ];\n\t\t\t\telse pargs[key] = [ ogValues, value ];\n\t\t\t} else pargs[key] = value;\n\t\t} else ppos.push(arg);\n\t}\n\n\tif (ppos.length < 2) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"MOUNT_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"MOUNT_DESCRIPTION\") + \"\\r\\n\");\n\t\ttry {\n\t\t\tawait availableAPIs.toMyCLI((await availableAPIs.lookupLocale(\"MOUNT_KNOWN_FS\")).replace(\"%s\", (await availableAPIs.supportedFilesystems()).join(\", \")) + \"\\r\\n\");\n\t\t} catch {\n\t\t\tawait availableAPIs.toMyCLI((await availableAPIs.lookupLocale(\"MOUNT_KNOWN_FS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"UNKNOWN_PLACEHOLDER\")) + \"\\r\\n\");\n\t\t}\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PPART\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PINPA\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PPASS\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PKEY\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PTYPE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PURL\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PINPI\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_POUPI\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"mount: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\n\ttry {\n\t\tawait availableAPIs.fs_mount({\n\t\t\tmountpoint: ppos[1],\n\t\t\tfilesystem: ppos[0],\n\t\t\tfilesystemOptions: pargs\n\t\t});\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"mount: \" + await availableAPIs.lookupLocale(e.message) + \"\\r\\n\");\n\t}\n\tawait availableAPIs.terminate();\n})();\n\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); ","1f5649440da37b22a6eb67199f170ca05114f39f33337530683a510f1df2556956f722f95cb2bd0c8f315c366c21f803df3b0c2df4e7a0cc79a910055860fef6":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: GET_LOCALE, FS_LIST_PARTITIONS, GET_FILESYSTEMS\n// signature: 94ae29ad3355acb5baf4dcc5747c12d3a13c38718cc8d642c1e14bcec66edb2c23c67223a2617888a9be9413a5b3df0c22310a19ba4de2a10fc1d8b9aba8830c\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"mountinfo: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\n\tlet pargs = {};\n\tlet ppos = [];\n\tfor (let arg of exec_args) {\n\t\tif (arg.startsWith(\"--\")) {\n\t\t\tlet key = arg.split(\"=\")[0].slice(2);\n\t\t\tlet value = arg.split(\"=\").slice(1).join(\"=\");\n\t\t\tif (arg.split(\"=\")[1] == null) value = true;\n\t\t\tif (pargs.hasOwnProperty(key)) {\n\t\t\t\tlet ogValues = pargs[key];\n\t\t\t\tif (ogValues instanceof Array) pargs[key] = [ ...ogValues, value ];\n\t\t\t\telse pargs[key] = [ ogValues, value ];\n\t\t\t} else pargs[key] = value;\n\t\t} else ppos.push(arg);\n\t}\n\n\tif (ppos.length < 1) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"MOUNTINFO_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"MOUNTINFO_DESCRIPTION\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"mountinfo: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\n\ttry {\n\t\tawait availableAPIs.toMyCLI(JSON.stringify(await availableAPIs.fs_mountInfo(ppos[0]), null, \"\\t\").replaceAll(\"\\n\", \"\\r\\n\") + \"\\r\\n\");\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"mountinfo: \" + await availableAPIs.lookupLocale(e.message) + \"\\r\\n\");\n\t}\n\tawait availableAPIs.terminate();\n})();\n\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); ","d639b0edacf3ea08d5dd78a9646e79ce663dcf5fd11fdbdea9c62d49c857a99dfb7cc2ccc285eed2190eeaa6fee3cb0a09d52c1ff0e089adc50213c6acfe29ee":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: GET_LOCALE, SET_DEFAULT_SYSTEM\n// signature: dc13ef321b4c31c930b291d610a5cbc3f6fe4f3529735908ed4b3b9613a2823d16ff3164707ce5b1ce57ffe3afc5118363628f45c0daac61aaa8fa43a102e803\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.windowVisibility(false);\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"pivot_root: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\tif (!exec_args.length) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"PIVOT_ROOT_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"PIVOT_ROOT_DESCRIPTION\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"pivot_root: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\tawait availableAPIs.setSystemMount(exec_args[0]);\n\tawait availableAPIs.terminate();\n})();\n\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); null;","4a438d47fd71377639c71be621cee81f893ec021d05bd56c7afa9415da2429d4ff95f588ce4853b06531d84a848e017f3e585bf6c5528b9a7e1d601761201a8f":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: GET_LOCALE, FS_UNMOUNT, GET_FILESYSTEMS\n// signature: db8cf0242ae539d5fb9249020281174539f65e5b50cf01e3647966a5e5be60241b1208f35c2436b78c2c459c33c2d6127785e29f0b68e87993d91a8cd656e00f\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"umount: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\n\tlet pargs = {};\n\tlet ppos = [];\n\tfor (let arg of exec_args) {\n\t\tif (arg.startsWith(\"--\")) {\n\t\t\tlet key = arg.split(\"=\")[0].slice(2);\n\t\t\tlet value = arg.split(\"=\").slice(1).join(\"=\");\n\t\t\tif (arg.split(\"=\")[1] == null) value = true;\n\t\t\tif (pargs.hasOwnProperty(key)) {\n\t\t\t\tlet ogValues = pargs[key];\n\t\t\t\tif (ogValues instanceof Array) pargs[key] = [ ...ogValues, value ];\n\t\t\t\telse pargs[key] = [ ogValues, value ];\n\t\t\t} else pargs[key] = value;\n\t\t} else ppos.push(arg);\n\t}\n\n\tif (ppos.length < 1) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"UMOUNT_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"UMOUNT_DESCRIPTION\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"UMOUNT_OPT_SYNCONLY\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"UMOUNT_OPT_FORCE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"umount: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\n\ttry {\n\t\tawait availableAPIs[\"fs_\" + (pargs[\"sync-only\"] == true ? \"sync\" : \"unmount\")]({\n\t\t\tmount: ppos[0],\n\t\t\tforce: pargs.force\n\t\t});\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"umount: \" + await availableAPIs.lookupLocale(e.message) + \"\\r\\n\");\n\t}\n\tawait availableAPIs.terminate();\n})();\n\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); "},"buildInfo":{"for":"1552","version":1552,"when":1763637014848,"signer":"moduleSigner","critical":false,"bootOrder":"50","commonName":"terminal-disks","friendlyNameRef":"TERMDISK_MODULE_NAME","signature":"4b4708cd8e6ac9fdf0af854b84d37c2c72c52fe9d0e88e8f77ef0c7fa2f617495f4840c54d34b8be8869b0b2a1aae00875f1f5d0306c4acedb7513e570209202"}}