{"backend":{"files":{"apps":{"df.js":"d44dc89772024b86114523eb5973cd5e852c14b07e63c8b8394ae2ad69063286c8b63029d2b756a97d92ca89fc7da072695d39f93472ad63396cbe3f41965a27","format.js":"5cb62a03e02a8b7a04a14808da2c045f8847516599ec41c5399e8ca0941337e1ec770236e3c9a9188a5c1816c8ae2e3538d7fedb1ea8b79cd1820e5f2cc807b1","initdisk.js":"d391a9d03c765b08e0bc582fffafa6819c25f4b44904391c697c55daf517bd7e3998b9287e1c3b94fe586a0703cbd866c14cd07ce00ac3495ff849250d32c34d","llda_tool.js":"be905cc9d9359c63db143b6ac70443e674d986e6895941b59dde4bfa24b47a12cc3c829416b00ad7a680151ec2b184aefda497aab2571869a12aa3557cf53ca0","mount.js":"da023c0a48c93f2d6213c365842fd7be6a18461bdbc2132db77dc86866cb2fc73f2128f96be81baf5ca648acf1aed4896a8b8c51fff4a5bea74155c28643dbc5","mountinfo.js":"a9b7b8a6cc0b9b727f169af61c19a7f39df9c0cd44a966ee1daaecef12b163e48ed7b8b2cf0987d922d16e07a6637c81871fa103d9405e806ccd1a43f3046a21","pivot_root.js":"24ca2db4b95961c255f4b573564e5a0f03e6734972363cca6108da69dfd5fc818ae47e6b0736f5abbbfcfa4f5767d8cf5ef70eca0162b7b9178e4555f54be0e4","umount.js":"b90cdc34d4253c48e1ebc86b9044ee334027b6744afc0a575294e8b7124873ce3270b294b2a572cbaae65100e6379c875e7b9d4e9ca045dc17d1d72d53cb9347"}},"permissions":{"apps/df.js":{"world":"rx"},"apps/format.js":{"world":"rx"},"apps/initdisk.js":{"world":"rx"},"apps/llda_tool.js":{"world":"rx"},"apps/mount.js":{"world":"rx"},"apps/mountinfo.js":{"world":"rx"},"apps/pivot_root.js":{"world":"rx"},"apps/umount.js":{"world":"rx"},"apps/":{"world":"rx"},"":{"world":"rx"}}},"files":{"d44dc89772024b86114523eb5973cd5e852c14b07e63c8b8394ae2ad69063286c8b63029d2b756a97d92ca89fc7da072695d39f93472ad63396cbe3f41965a27":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: GET_LOCALE, FS_LIST_PARTITIONS\n// signature: 270e3ff5f552cddebd10b1e2e6bc5b2d406acb7e5acafaa5b11de8d63820070541a257c38d37821da87870840207955cbf860246852f88ad6deafef8da488f02\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.windowVisibility(false);\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"df: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\tlet human = exec_args.includes(\"-h\") || exec_args.includes(\"--human-readable\");\n\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"DF_HEADER\") + \"\\r\\n\");\n\tlet estimateStorage = await availableAPIs.estimateStorage();\n\tfor (let medium in estimateStorage) {\n\t\tlet displayedSize = estimateStorage[medium].total;\n\t\tif (human) displayedSize = await availableAPIs.ufInfoUnits([estimateStorage[medium].total, true]);\n\t\tlet displayedUsed = estimateStorage[medium].used;\n\t\tif (human) displayedUsed = await availableAPIs.ufInfoUnits([estimateStorage[medium].used, true]);\n\t\tlet displayedFree = estimateStorage[medium].free;\n\t\tif (human) displayedFree = await availableAPIs.ufInfoUnits([estimateStorage[medium].free, true]);\n\t\tawait availableAPIs.toMyCLI(medium + \"\\t\" + displayedSize + \"\\t\" + displayedUsed + \"\\t\" + displayedFree + \"\\t\" + Math.floor(estimateStorage[medium].used / estimateStorage[medium].total * 100) + \"%\\r\\n\");\n\t}\n\tawait availableAPIs.terminate();\n})();\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); null;","5cb62a03e02a8b7a04a14808da2c045f8847516599ec41c5399e8ca0941337e1ec770236e3c9a9188a5c1816c8ae2e3538d7fedb1ea8b79cd1820e5f2cc807b1":"// =====BEGIN MANIFEST=====\n// allow: GET_LOCALE, LLDISK_LIST_PARTITIONS, LLDISK_WRITE, LLDISK_REMOVE, LLDISK_READ, CSP_OPERATIONS\n// signer: automaticSigner\n// signature: 51ed74a9856cd40758c801d6d7cd2c99684fef58a8ce126f0dcffcd6f0a3450d8286e18915c618daeae7c7e80c8b9ba2a9f950a541b064d7c66b78e01cee3c0e\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.windowVisibility(false);\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"format: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\tif (!exec_args.length) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"FORMAT_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"FORMAT_DESCRIPTION\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"FORMAT_FSTYPE\") + \"\\r\\n\")\n\t\tawait availableAPIs.toMyCLI(\"format: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\tif (exec_args.length < 2 || exec_args.length > 3) {\n\t\tawait availableAPIs.toMyCLI(\"format: \" + await availableAPIs.lookupLocale(\"ARGUMENT_COUNT_MISMATCH\") + \"\\r\\n\");\n\t\treturn await availableAPIs.terminate();\n\t}\n\t\n\tlet knownNames;\n\ttry {\n\t\tknownNames = await availableAPIs.lldaList();\n\t\tif (knownNames.includes(exec_args[1]) && exec_args[2] != \"overwrite\") {\n\t\t\tawait availableAPIs.toMyCLI(\"format: \" + await availableAPIs.lookupLocale(\"FORMAT_OVERWRITE_WARN\") + \"\\r\\n\");\n\t\t\treturn await availableAPIs.terminate();\n\t\t}\n\n\t\tlet u8aToHex = (u8a) => Array.from(u8a).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\tif (exec_args[0] == \"pcfs\") {\n\t\t\tlet prevId = (await availableAPIs.lldaRead({ partition: exec_args[1] }))?.id || u8aToHex(await availableAPIs.cspOperation({\n\t\t\t\tcspProvider: \"basic\",\n\t\t\t\toperation: \"random\",\n\t\t\t\tcspArgument: new Uint8Array(64)\n\t\t\t}));\n\t\t\tawait availableAPIs.lldaWrite({\n\t\t\t\tpartition: exec_args[1],\n\t\t\t\tdata: {\n\t\t\t\t\tfiles: {},\n\t\t\t\t\tpermissions: {},\n\t\t\t\t\tid: prevId\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (exec_args[0].startsWith(\"pcfs_crypt\")) {\n\t\t\tlet monokey = exec_args[0].endsWith(\"_monokey\");\n\t\t\tlet prevId = (await availableAPIs.lldaRead({ partition: exec_args[1] }))?.id || u8aToHex(await availableAPIs.cspOperation({\n\t\t\t\tcspProvider: \"basic\",\n\t\t\t\toperation: \"random\",\n\t\t\t\tcspArgument: new Uint8Array(64)\n\t\t\t}));\n\t\t\tlet salt = u8aToHex(await availableAPIs.cspOperation({\n\t\t\t\tcspProvider: \"basic\",\n\t\t\t\toperation: \"random\",\n\t\t\t\tcspArgument: new Uint8Array(32)\n\t\t\t}));\n\t\t\tawait availableAPIs.lldaWrite({\n\t\t\t\tpartition: exec_args[1],\n\t\t\t\tdata: {\n\t\t\t\t\tfiles: {},\n\t\t\t\t\tpermissions: {},\n\t\t\t\t\tid: prevId,\n\t\t\t\t\tcryptodata: {\n\t\t\t\t\t\tpasswordLockingInitial: monokey,\n\t\t\t\t\t\tsalt: salt\n\t\t\t\t\t},\n\t\t\t\t\tencryptedFileTable: exec_args[0].endsWith(\"_filetable_monokey\")\n\t\t\t\t}\n\t\t\t})\n\t\t} else if (exec_args[0].startsWith(\"pcbm:\")) {\n\t\t\tlet diskDataPartition = exec_args[0].split(\":\").slice(1).join(\":\");\n\t\t\tawait availableAPIs.lldaWrite({\n\t\t\t\tpartition: exec_args[1],\n\t\t\t\tdata: `try {\n\t\t\t\t\tconst AsyncFunction = (async () => {}).constructor;\n\t\t\t\t\tlet pre_boot_part = coreExports.disk.partition(${JSON.stringify(diskDataPartition)}).getData();\n\t\t\t\t\tlet pre_boot_modules = pre_boot_part?.files;\n\t\t\t\t\tif (!pre_boot_modules) {\n\t\t\t\t\t\tcoreExports.tty_bios_api.println(\"No files were found in the storage partition\");\n\t\t\t\t\t\tthrow new Error(\"No files were found in the storage partition\");\n\t\t\t\t\t}\n\t\t\t\t\tpre_boot_modules = pre_boot_modules[coreExports.bootSection || \"boot\"];\n\t\t\t\t\tif (!pre_boot_modules) {\n\t\t\t\t\t\tcoreExports.tty_bios_api.println(\"No boot modules were found\");\n\t\t\t\t\t\tthrow new Error(\"No boot modules were found\");\n\t\t\t\t\t}\n\t\t\t\t\tlet pre_boot_module_list = Object.keys(pre_boot_modules);\n\t\t\t\t\tpre_boot_module_list = pre_boot_module_list.sort((a, b) => a.localeCompare(b));\n\t\t\t\t\tlet pre_boot_module_script = \"\";\n\t\t\t\t\tfor (let module of pre_boot_module_list) {\n\t\t\t\t\t\tif (coreExports.bootMode == \"logboot\") pre_boot_module_script += \"coreExports.tty_bios_api.println(\" + JSON.stringify(module) + \");\\\\n\";\n\t\t\t\t\t\tpre_boot_module_script += await coreExports.idb.readPart(pre_boot_part.id + \"-\" + pre_boot_modules[module]);\n\t\t\t\t\t}\n\t\t\t\t\tawait new AsyncFunction(pre_boot_module_script)();\n\t\t\t\t} catch (e) {\n\t\t\t\t\tcoreExports.tty_bios_api.println(\"Boot failed\");\n\t\t\t\t\tcoreExports.tty_bios_api.println(\"Press Enter to continue and log this error locally\");\n\t\t\t\t\tawait coreExports.tty_bios_api.inputLine();\n\t\t\t\t\tthrow e;\n\t\t\t\t}`\n\t\t\t});\n\t\t} else if (exec_args[0] == \"null\") {\n\t\t\tawait availableAPIs.lldaRemove({\n\t\t\t\tpartition: exec_args[1]\n\t\t\t});\n\t\t} else {\n\t\t\tawait availableAPIs.toMyCLI(\"format: \" + await availableAPIs.lookupLocale(\"FORMAT_UNKNOWN_FSTYPE\") + \"\\r\\n\");\n\t\t}\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"format: \" + e.name + \": \" + await availableAPIs.lookupLocale(e.message) + \" (\" + e.message + \")\\r\\n\");\n\t\treturn await availableAPIs.terminate();\n\t}\n\t\n\tawait availableAPIs.terminate();\n})();\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); null;","d391a9d03c765b08e0bc582fffafa6819c25f4b44904391c697c55daf517bd7e3998b9287e1c3b94fe586a0703cbd866c14cd07ce00ac3495ff849250d32c34d":"// =====BEGIN MANIFEST=====\n// allow: GET_LOCALE, LLDISK_LIST_PARTITIONS, LLDISK_INIT_PARTITIONS\n// signer: automaticSigner\n// signature: 353a98f62dd474c05c23d7fe3afaf044166bad6a7868c893ab653a473a70c54ebf2d8bfbbbca517d2e9d328884bd3a7de313ac7dc11a30fb56e6d1f68796200e\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.windowVisibility(false);\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"initdisk: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\tif (!exec_args.length) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"INITDISK_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"INITDISK_DESCRIPTION\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"initdisk: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\tif (exec_args.length > 2) {\n\t\tawait availableAPIs.toMyCLI(\"initdisk: \" + await availableAPIs.lookupLocale(\"ARGUMENT_COUNT_MISMATCH\") + \"\\r\\n\");\n\t\treturn await availableAPIs.terminate();\n\t}\n\t\n\ttry {\n\t\tawait availableAPIs.lldaList();\n\t\tif (exec_args[1] != \"overwrite\") {\n\t\t\tawait availableAPIs.toMyCLI(\"initdisk: \" + await availableAPIs.lookupLocale(\"INITDISK_OVERWRITE_WARN\") + \"\\r\\n\");\n\t\t\treturn await availableAPIs.terminate();\n\t\t}\n\t} catch {}\n\t\n\ttry {\n\t\tawait availableAPIs.lldaInitPartitions();\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"initdisk: \" + await availableAPIs.lookupLocale(e.message) + \"\\r\\n\");\n\t}\n\tawait availableAPIs.terminate();\n})();\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); null;","be905cc9d9359c63db143b6ac70443e674d986e6895941b59dde4bfa24b47a12cc3c829416b00ad7a680151ec2b184aefda497aab2571869a12aa3557cf53ca0":"// =====BEGIN MANIFEST=====\n// allow: GET_LOCALE, LLDISK_WRITE, LLDISK_READ, FS_READ, FS_WRITE, FS_BYPASS_PERMISSIONS, LLDISK_LIST_PARTITIONS, LLDISK_REMOVE\n// signer: automaticSigner\n// signature: 6e7ff39dde3e86a5643b710b215cd050165e2ce79cee6b9033a1efd349515684d52aced7f4caaa56ac48059a98503843ab42794066aefe6b82fc52fa246d3c03\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.windowVisibility(false);\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"llda_tool: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\tif (!exec_args.length) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_ACTION_EXPORT\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_ACTION_IMPORT\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_ACTION_IMPORTSTRING\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_ACTION_COPY\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_ACTION_REMOVE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_ACTION_LIST\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_DISCLAIMER\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"llda_tool: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\n\ttry {\n\t\tif (exec_args[0] == \"export\") {\n\t\t\tawait availableAPIs.fs_write({\n\t\t\t\tpath: exec_args[2],\n\t\t\t\tdata: JSON.stringify(await availableAPIs.lldaRead({ partition: exec_args[1] }))\n\t\t\t});\n\t\t} else if (exec_args[0] == \"import\") {\n\t\t\tawait availableAPIs.lldaWrite({ partition: exec_args[2], data: JSON.parse(await availableAPIs.fs_read({ path: exec_args[1] })) });\n\t\t} else if (exec_args[0] == \"importstring\") {\n\t\t\tawait availableAPIs.lldaWrite({ partition: exec_args[2], data: await availableAPIs.fs_read({ path: exec_args[1] }) });\n\t\t} else if (exec_args[0] == \"copy\") {\n\t\t\tawait availableAPIs.lldaWrite({ partition: exec_args[2], data: await availableAPIs.lldaRead({ partition: exec_args[1] }) });\n\t\t} else if (exec_args[0] == \"remove\") {\n\t\t\tawait availableAPIs.lldaRemove({ partition: exec_args[1] });\n\t\t} else if (exec_args[0] == \"list\") {\n\t\t\tawait availableAPIs.toMyCLI(JSON.stringify(await availableAPIs.lldaList()) + \"\\r\\n\");\n\t\t} else {\n\t\t\tawait availableAPIs.toMyCLI(\"llda_tool: \" + await availableAPIs.lookupLocale(\"LLDA_UNKNOWN_ACTION\") + \"\\r\\n\");\n\t\t}\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"llda_tool: \" + await availableAPIs.lookupLocale(e.message) + \"\\r\\n\");\n\t}\n\t\n\tawait availableAPIs.terminate();\n})();\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); null;","da023c0a48c93f2d6213c365842fd7be6a18461bdbc2132db77dc86866cb2fc73f2128f96be81baf5ca648acf1aed4896a8b8c51fff4a5bea74155c28643dbc5":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: GET_LOCALE, FS_MOUNT, GET_FILESYSTEMS\n// signature: b66db823eadcb66c4f185a70b79c00f95d5f7e0df4607965409947ecc93f96f078d0e2c5a42b1a65cb84bb4be77a833412e7554bb3a92b3299001b94e1be2c0b\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"mount: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\n\tlet pargs = {};\n\tlet ppos = [];\n\tfor (let arg of exec_args) {\n\t\tif (arg.startsWith(\"--\")) {\n\t\t\tlet key = arg.split(\"=\")[0].slice(2);\n\t\t\tlet value = arg.split(\"=\").slice(1).join(\"=\");\n\t\t\tif (arg.split(\"=\")[1] == null) value = true;\n\t\t\tif (pargs.hasOwnProperty(key)) {\n\t\t\t\tlet ogValues = pargs[key];\n\t\t\t\tif (ogValues instanceof Array) pargs[key] = [ ...ogValues, value ];\n\t\t\t\telse pargs[key] = [ ogValues, value ];\n\t\t\t} else pargs[key] = value;\n\t\t} else ppos.push(arg);\n\t}\n\n\tif (ppos.length < 2) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"MOUNT_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"MOUNT_DESCRIPTION\") + \"\\r\\n\");\n\t\ttry {\n\t\t\tawait availableAPIs.toMyCLI((await availableAPIs.lookupLocale(\"MOUNT_KNOWN_FS\")).replace(\"%s\", (await availableAPIs.supportedFilesystems()).join(\", \")) + \"\\r\\n\");\n\t\t} catch {\n\t\t\tawait availableAPIs.toMyCLI((await availableAPIs.lookupLocale(\"MOUNT_KNOWN_FS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"UNKNOWN_PLACEHOLDER\")) + \"\\r\\n\");\n\t\t}\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PPART\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PINPA\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PPASS\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PKEY\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PTYPE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PURL\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PINPI\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_POUPI\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"mount: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\n\ttry {\n\t\tawait availableAPIs.fs_mount({\n\t\t\tmountpoint: ppos[1],\n\t\t\tfilesystem: ppos[0],\n\t\t\tfilesystemOptions: pargs\n\t\t});\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"mount: \" + await availableAPIs.lookupLocale(e.message) + \"\\r\\n\");\n\t}\n\tawait availableAPIs.terminate();\n})();\n\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); ","a9b7b8a6cc0b9b727f169af61c19a7f39df9c0cd44a966ee1daaecef12b163e48ed7b8b2cf0987d922d16e07a6637c81871fa103d9405e806ccd1a43f3046a21":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: GET_LOCALE, FS_LIST_PARTITIONS, GET_FILESYSTEMS\n// signature: 94ae29ad3355acb5baf4dcc5747c12d3a13c38718cc8d642c1e14bcec66edb2c23c67223a2617888a9be9413a5b3df0c22310a19ba4de2a10fc1d8b9aba8830c\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"mountinfo: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\n\tlet pargs = {};\n\tlet ppos = [];\n\tfor (let arg of exec_args) {\n\t\tif (arg.startsWith(\"--\")) {\n\t\t\tlet key = arg.split(\"=\")[0].slice(2);\n\t\t\tlet value = arg.split(\"=\").slice(1).join(\"=\");\n\t\t\tif (arg.split(\"=\")[1] == null) value = true;\n\t\t\tif (pargs.hasOwnProperty(key)) {\n\t\t\t\tlet ogValues = pargs[key];\n\t\t\t\tif (ogValues instanceof Array) pargs[key] = [ ...ogValues, value ];\n\t\t\t\telse pargs[key] = [ ogValues, value ];\n\t\t\t} else pargs[key] = value;\n\t\t} else ppos.push(arg);\n\t}\n\n\tif (ppos.length < 1) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"MOUNTINFO_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"MOUNTINFO_DESCRIPTION\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"mountinfo: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\n\ttry {\n\t\tawait availableAPIs.toMyCLI(JSON.stringify(await availableAPIs.fs_mountInfo(ppos[0]), null, \"\\t\").replaceAll(\"\\n\", \"\\r\\n\") + \"\\r\\n\");\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"mountinfo: \" + await availableAPIs.lookupLocale(e.message) + \"\\r\\n\");\n\t}\n\tawait availableAPIs.terminate();\n})();\n\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); ","24ca2db4b95961c255f4b573564e5a0f03e6734972363cca6108da69dfd5fc818ae47e6b0736f5abbbfcfa4f5767d8cf5ef70eca0162b7b9178e4555f54be0e4":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: GET_LOCALE, SET_DEFAULT_SYSTEM\n// signature: dc13ef321b4c31c930b291d610a5cbc3f6fe4f3529735908ed4b3b9613a2823d16ff3164707ce5b1ce57ffe3afc5118363628f45c0daac61aaa8fa43a102e803\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.windowVisibility(false);\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"pivot_root: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\tif (!exec_args.length) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"PIVOT_ROOT_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"PIVOT_ROOT_DESCRIPTION\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"pivot_root: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\tawait availableAPIs.setSystemMount(exec_args[0]);\n\tawait availableAPIs.terminate();\n})();\n\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); null;","b90cdc34d4253c48e1ebc86b9044ee334027b6744afc0a575294e8b7124873ce3270b294b2a572cbaae65100e6379c875e7b9d4e9ca045dc17d1d72d53cb9347":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: GET_LOCALE, FS_UNMOUNT, GET_FILESYSTEMS\n// signature: db8cf0242ae539d5fb9249020281174539f65e5b50cf01e3647966a5e5be60241b1208f35c2436b78c2c459c33c2d6127785e29f0b68e87993d91a8cd656e00f\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"umount: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\n\tlet pargs = {};\n\tlet ppos = [];\n\tfor (let arg of exec_args) {\n\t\tif (arg.startsWith(\"--\")) {\n\t\t\tlet key = arg.split(\"=\")[0].slice(2);\n\t\t\tlet value = arg.split(\"=\").slice(1).join(\"=\");\n\t\t\tif (arg.split(\"=\")[1] == null) value = true;\n\t\t\tif (pargs.hasOwnProperty(key)) {\n\t\t\t\tlet ogValues = pargs[key];\n\t\t\t\tif (ogValues instanceof Array) pargs[key] = [ ...ogValues, value ];\n\t\t\t\telse pargs[key] = [ ogValues, value ];\n\t\t\t} else pargs[key] = value;\n\t\t} else ppos.push(arg);\n\t}\n\n\tif (ppos.length < 1) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"UMOUNT_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"UMOUNT_DESCRIPTION\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"UMOUNT_OPT_SYNCONLY\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"UMOUNT_OPT_FORCE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"umount: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\n\ttry {\n\t\tawait availableAPIs[\"fs_\" + (pargs[\"sync-only\"] == true ? \"sync\" : \"unmount\")]({\n\t\t\tmount: ppos[0],\n\t\t\tforce: pargs.force\n\t\t});\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"umount: \" + await availableAPIs.lookupLocale(e.message) + \"\\r\\n\");\n\t}\n\tawait availableAPIs.terminate();\n})();\n\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); "},"buildInfo":{"for":"1433","version":1433,"when":1757088949484,"signer":"moduleSigner","critical":false,"bootOrder":"50","commonName":"terminal-disks","signature":"c316216357624a110d15d0737c41a77e2e72d2097aa9bdd4a802ccde874e65ea0442a6105ca8660f7ffd7d91c310c79a44dfcb65ce94cde8e02a922a8a9ef508"}}