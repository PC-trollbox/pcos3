// This is a generated file after netinst transform. Please modify the corresponding files, not this file directly.
// (c) Copyright 2025 PCsoft. MIT license: https://spdx.org/licenses/MIT.html
let installerModuleBundle = {"00-keys.fs":{"backend":{"files":{"etc":{"keys":{"automaticSigner":"cf4729117791a25aaa5554dce54615928236683332f06f2d1137409cf538e905e4c87630a4f32885908d7cd5a4f4f4d5f62526216b6194c2970a3d01468afdc7","khrl":{"list.khrl":"78a00b62423f2248ef8f0c988816f40a06e30b14090c545ae09e80f09c5779e4b0374e66e99f199a5407aeb6de10cb6cdc76f0bed09507c88edde3cd652d0360"},"moduleSigner":"f2b5b343f422f0133f2eecc1386831f09a58da08b953f589e7fc89f98385694060c09ccbaef306ed2d70f0488c0816074b15b3e487b4024df091dc7811306c51","pcosIntermediate":"3ef5b2a992213b20e1b1b49e4974318768e2c103a5981c71c0bb2d2aa693d27384429742743212015b6b1c09550d4f79c5900efa3e1cc838d35bac2b5b72d3bb"}}},"permissions":{"etc/keys/automaticSigner":{"world":"rx"},"etc/keys/khrl/list.khrl":{"world":"rx"},"etc/keys/khrl/":{"world":"rx"},"etc/keys/moduleSigner":{"world":"rx"},"etc/keys/pcosIntermediate":{"world":"rx"},"etc/keys/":{"world":"rx"},"etc/":{"world":"rx"},"":{"world":"rx"}}},"files":{"cf4729117791a25aaa5554dce54615928236683332f06f2d1137409cf538e905e4c87630a4f32885908d7cd5a4f4f4d5f62526216b6194c2970a3d01468afdc7":"{\"signature\":\"c6c4be0b02149b43fed017499ef0837ecac9d08a3e2d6a12cf08a461c49074c6196b7d322363751614f9e482a9abb311662a2975c72d0496fcbacf594d56f30f\",\"keyInfo\":{\"key\":{\"crv\":\"Ed25519\",\"x\":\"_HNsnL890zN3JRAnsCsuY7ylCMDc5_TRv3ka8R1v0Xc\",\"kty\":\"OKP\"},\"usages\":[\"appTrust\"],\"signedBy\":\"pcosIntermediate\",\"friendlyNameDB\":{\"en\":\"PCsoft program trust authority\",\"ru\":\"Центр доверия программам PCsoft\"}}}","78a00b62423f2248ef8f0c988816f40a06e30b14090c545ae09e80f09c5779e4b0374e66e99f199a5407aeb6de10cb6cdc76f0bed09507c88edde3cd652d0360":"{\"list\":[],\"signature\":\"db1cf22f8dd93d745fb81b49f84349ac6ff7cec7b3d2b223ece67c5c125a69084435eddacbb0c8aa3c1b3ce7d5215d55264b08b5a1f6fe5d36581da855508a09\"}","f2b5b343f422f0133f2eecc1386831f09a58da08b953f589e7fc89f98385694060c09ccbaef306ed2d70f0488c0816074b15b3e487b4024df091dc7811306c51":"{\"signature\":\"6b6b36003efcff84262ed9b4b00c487d66825b49de15789184d7764a2a3903f727c947311b3f56af4768012aa9c272f19efe28af2d73565bab6cb21bfe254205\",\"keyInfo\":{\"key\":{\"crv\":\"Ed25519\",\"x\":\"B37OlkJK3rhgF90Vb8k1ZHH9mPFJvBiiw1d65kOMGtw\",\"kty\":\"OKP\"},\"usages\":[\"moduleTrust\"],\"signedBy\":\"pcosIntermediate\",\"friendlyNameDB\":{\"en\":\"PCsoft module trust authority\",\"ru\":\"Центр доверия модулям PCsoft\"}}}","3ef5b2a992213b20e1b1b49e4974318768e2c103a5981c71c0bb2d2aa693d27384429742743212015b6b1c09550d4f79c5900efa3e1cc838d35bac2b5b72d3bb":"{\"signature\":\"153d673631a544919bf800a72417a3468bde67575f2e290b9ace1f50fc24a7697f2d50a15a6f17d00b9460820c220532a71f89036c369059adba44908e7fdc0f\",\"keyInfo\":{\"key\":{\"crv\":\"Ed25519\",\"x\":\"qKoTLfZH16PqwOKEnll19B7lDp3tEjeyCXBzGIhGwNY\",\"kty\":\"OKP\"},\"usages\":[\"keyTrust\"],\"friendlyNameDB\":{\"en\":\"PCsoft intermediate trust authority\",\"ru\":\"Промежуточный центр доверия PCsoft\"}}}"},"buildInfo":{"for":"1580","version":1580,"when":1766238578398,"critical":true,"bootOrder":"00","commonName":"keys","friendlyNameRef":"KEYS_MODULE_NAME","signature":"e1f16a8daf945fca555b3c5fd7782d2c14c20a057bb3ed2b42dc5e5b4034053ed3ca193d77320137f777acfd6d4024ba6524d053cb57a49f396517398dc4d302"}},"50-bootable.fs":{"backend":{"files":{"boot":{"00-pcos.js":"4edb012d47f687e0388342a36167e0ffdcc2fe3f859616f96dd82690cbaf9505b63e4079ec65f6063ca4d95f6deb0d7d3bb4f4ad6466a5cf315805e71cb1d00c","00-pcosksk.js":"e461e7646ad5e2bacd26849dd43e14e455298e38ebcd47d4738a5d67a65c82648d5f3bfc6d636d385484ea41cd0259d1feef111adf98f785c96e4f5d6f347ece","01-fs.js":"897da6d9fbcee187e4e92169530d26a5c19735dce068be3ac6115bd43b5a5d3d07b1973ec3c9d1fa97045a1df2eaf75e8e15a2591046b798cb5512bd2b9e3496","01-fsck.js":"5e4273a4b5124a28aa722d5a9ac554369573e0b10a872d6c6685bdca342a83121b51631d91885eeb310a61cf0daf834ad50d18aa8b5a0a96fcd7129a1e16c19b","01-fsmodules.js":"d86b696d9abb61c82f81ec2e6ecfbc88fa72c2cf3dbeb2b5e680cdf32ebca6c1dccd6f1bbd268333a15d077bc490b3994cb2fac1a11232399cf77bbb5aca08b3","02-ui.js":"f6761d3ce5899ce9a66d354627cb50a399a4b8cb5457ca9023c84c20ded708120de10f829234c32a2ba85797ba69d4b3aa816d15d7849a476bfe4d29949af011","04-ipc.js":"a95238a321eb52b2b138d2ab2e6c834e832398d84f262a7ca4c00902edfac5edc9e559f7cb297b8177e189fe49e76aa5907ca5b4b9f47ecae9c1e35fdccc355c","04-websockets.js":"acd051885a9d2fd67087dd1e6ae5387aa4f4a2e93948bc721d75960c30ee7eb3be9301db71a2be82561ad858f0f48bcef1a3aad425f5c2f7cd70799cc1f8f371","05-lull.js":"d68ccb58bb95628dd5f222979a1a49f2c4c1ddde14880551ac2787803c151fddd461f89ded1ee0534f6fb26b659bd40d34ff843625e8f3a2f7fe6be8b5bf9a5e","05-network.js":"10d8259d75df6d9d7ab9dd45a0730d732c99bace58f0e99830519f27c372c87ca8d3ede6c77fe162d0982e486b8761ca048701affae925ad94f4a7cdc38acfec","05-reeapis.js":"19e6582838471318c6c625e64004a3a9ce845dd71d63d97a0de42e67906dfba2f1dda31d9a4bc153d18e77cea7866d0a7c855edd78d434c8d3eaedb67316acca","06-csp.js":"2027051c071bf8b2c212789a7e0e38262bc353340b87d477ff7391a2ad0320f182dceeae68c0cc5d5621d2739ad8ed369d7bb62ba8bfb2c01ad75d022a01c517","06-locales.js":"713bf8a46ba4d7e575011798d624d29832ea66ad2c06ea2f6dce99348226d82629aca81cee1036c731f9c3f640f9bd1112d568183bb2760b57e47ae977edc4a1","07-tasks.js":"7d115335d9e4d96d74b8a56d393179b0d0a0c8ff760d5dfb0177e79a61ec757c677f3f8230fd2d184a61943fef53c2378e0dcc40af484b33824fd63982011328","09-logout.js":"2bf1c89a2309e4998aeac94fa9b6412b044a6e321a607dd86be0991372879dfd2b6c51e9df6d1101167bea4f22968d5fd12add3f518b8f0df9095de6ec94b5a8","09-restart.js":"057f807b158093bd2a57c5251a3368b096800e80bcab9f57becf67c482d1cb48d8ad569342141d282a523be0b9a101e81e1631b9ad86f0a32794ee99313b0f90","11-userfriendliness.js":"8e1cefc8590ea2effcbbb6ac1323831d9fcf850eea99d5804f2ef6d1fe525fae8a9f389047658da2bd939adeb92d0b0e5f6e99377535f6daef71d1a0f2030a6e","12-tokens.js":"031000dd0bf460735a7e9548ef0a85498a0d76469f5074b8a19c3ce6c91a1a8c0b39e7eebaeb424399110df360516963a43b9a4572e3f4ee768f173d4eb55d2b","12-users.js":"50cf5614f6b4552fd200c14075fdccb48e5a754887fa5485251213f8225d707f0ea46c7e2f184c406896c3e11a4775a76c80c8bce0d3bd4366f9e773925a7f5b","13-authui.js":"6421cb64b14363f98f07e9de6b6b3a1aa0bbe0f1a783f72288b6893fb45b93aacfad188b34a01e2ec85d4ade78810b6ad176bb5f39cb46bb5c16f0468497de6b","13-consentui.js":"e2f516d6ed2a8c0757f401cb47b80bbc0cc23a1e92cabbe5243801205f51ac99b4e69130c96c46b95761bb5c5d2ce1c75802c7a2674bb9de0133631a4ffca17d","14-logon-requirement.js":"467c549fde5d1ebe135a3b1492f87b08623fea900121a34b3412ecd1bdce2f217fbdd2fc6e72d1fa1b78319b50c58f85c60f502f0e5fff38354fbb4a5a50cc88","18-logon-requirement-enforce.js":"9b1c4b3ed1290ed2df63237ec11e469307e894aa2a614a74aef0c6cfcd98780c4799a25818e1e27c4789b8c11e416b1cbd8d53a9e68e18241c2425b77c7d9411","99-finished.js":"0ad3288505ad576eb0e2db2de7c8f25d3161a738573357566c18a4af17b04b5c1f6de395822023b14950dc3f4d3b50be9ea087fdfa9779ef528d64f970b1135a"}},"permissions":{"boot/00-pcos.js":{"world":"rx"},"boot/00-pcosksk.js":{"world":"rx"},"boot/01-fs.js":{"world":"rx"},"boot/01-fsck.js":{"world":"rx"},"boot/01-fsmodules.js":{"world":"rx"},"boot/02-ui.js":{"world":"rx"},"boot/04-ipc.js":{"world":"rx"},"boot/04-websockets.js":{"world":"rx"},"boot/05-lull.js":{"world":"rx"},"boot/05-network.js":{"world":"rx"},"boot/05-reeapis.js":{"world":"rx"},"boot/06-csp.js":{"world":"rx"},"boot/06-locales.js":{"world":"rx"},"boot/07-tasks.js":{"world":"rx"},"boot/09-logout.js":{"world":"rx"},"boot/09-restart.js":{"world":"rx"},"boot/11-userfriendliness.js":{"world":"rx"},"boot/12-tokens.js":{"world":"rx"},"boot/12-users.js":{"world":"rx"},"boot/13-authui.js":{"world":"rx"},"boot/13-consentui.js":{"world":"rx"},"boot/14-logon-requirement.js":{"world":"rx"},"boot/18-logon-requirement-enforce.js":{"world":"rx"},"boot/99-finished.js":{"world":"rx"},"boot/":{"world":"rx"},"":{"world":"rx"}}},"files":{"4edb012d47f687e0388342a36167e0ffdcc2fe3f859616f96dd82690cbaf9505b63e4079ec65f6063ca4d95f6deb0d7d3bb4f4ad6466a5cf315805e71cb1d00c":"// @pcos-app-mode native\nconst pcos_version = \"1580\";\nconst build_time = 1766238578334;\n \nlet modules = {\n\tcore: coreExports,\n\tpcos_version,\n\tbuild_time\n};\nglobalThis.modules = modules;\n\nasync function panic(code, component) {\n\tmodules.shuttingDown = true;\n\tif (modules.session) modules.session.muteAllSessions();\n\tlet baseLocales = {\n\t\t\"PANIC_LINE1\": \"A critical problem has been detected while using the operating system. Its stability is at risk now.\",\n\t\t\"PANIC_LINE2\": \"Problem code: %s\",\n\t\t\"PANIC_UNSPECIFIED_ERROR\": \"UNSPECIFIED_ERROR\",\n\t\t\"PROBLEMATIC_COMPONENT\": \"Problematic component: %s\",\n\t\t\"PROBLEMATIC_PARAMS\": \"Problematic parameters: %s\",\n\t\t\"PROBLEMATIC_JS\": \"Problematic JavaScript: %s: %s\",\n\t\t\"PANIC_LINE3\": \"If you have seen this error message the first time, attempt rebooting.\",\n\t\t\"PANIC_LINE4\": \"If you see this error message once more, there is something wrong with the system.\",\n\t\t\"PANIC_LINE5\": \"You can try repairing the system by using the installer to repair install or clean install PCOS 3.\",\n\t\t\"PANIC_LINE6\": \"Proper shutdown procedure follows now:\",\n\t\t\"PANIC_TASK_KILLED\": \"task:%s: killed\",\n\t\t\"PANIC_MOUNT_UNMOUNTED\": \"mount:%s: unmounted\",\n\t\t\"PANIC_MOUNT_FAILED\": \"mount:%s: %s: %s\"\n\t}\n\tlet currentLocales = modules.locales;\n\tif (currentLocales) currentLocales = currentLocales[navigator.language.slice(0, 2).toLowerCase()];\n\tif (!currentLocales) currentLocales = baseLocales;\n\tif (!Object.keys(baseLocales).every(key => currentLocales.hasOwnProperty(key))) currentLocales = baseLocales;\n\n\tmodules.core.tty_bios_api.println(currentLocales.PANIC_LINE1);\n\tmodules.core.tty_bios_api.println(currentLocales.PANIC_LINE2.replace(\"%s\", (code || currentLocales.PANIC_UNSPECIFIED_ERROR)));\n\tif (component) {\n\t\tif (component.name) modules.core.tty_bios_api.println(currentLocales.PROBLEMATIC_COMPONENT.replace(\"%s\", component.name));\n\t\tif (component.params) modules.core.tty_bios_api.println(currentLocales.PROBLEMATIC_PARAMS.replace(\"%s\", JSON.stringify(component.params, null, \"\\t\")));\n\t\tif (component.underlyingJS) {\n\t\t\tmodules.core.tty_bios_api.println(currentLocales.PROBLEMATIC_JS.replace(\"%s\", component.underlyingJS.name).replace(\"%s\", component.underlyingJS.message));\n\t\t\tif (component.underlyingJS.stack) modules.core.tty_bios_api.println(component.underlyingJS.stack);\n\t\t}\n\t}\n\tmodules.core.tty_bios_api.println(currentLocales.PANIC_LINE3);\n\tmodules.core.tty_bios_api.println(currentLocales.PANIC_LINE4);\n\tmodules.core.tty_bios_api.println(currentLocales.PANIC_LINE5);\n\tmodules.core.tty_bios_api.println(currentLocales.PANIC_LINE6);\n\ttry {\n\t\tmodules.websocket._handles[modules.network.ws].ws.onclose = null;\n\t\tmodules.websocket._handles[modules.network.ws].ws.close();\n\t\tdelete modules.websocket._handles[modules.network.ws];\n\t} catch {}\n\tif (modules.tasks) for (let task in modules.tasks.tracker) {\n\t\tmodules.core.tty_bios_api.println(currentLocales.PANIC_TASK_KILLED.replace(\"%s\", modules.tasks.tracker[task].file));\n\t\tmodules.tasks.tracker[task].ree.closeDown();\n\t}\n\tif (modules.fs) for (let mount in modules.fs.mounts) {\n\t\ttry {\n\t\t\tawait modules.fs.unmount(mount);\n\t\t\tmodules.core.tty_bios_api.println(currentLocales.PANIC_MOUNT_UNMOUNTED.replace(\"%s\", mount));\n\t\t} catch (e) {\n\t\t\tmodules.core.tty_bios_api.println(currentLocales.PANIC_MOUNT_FAILED.replace(\"%s\", mount).replace(\"%s\", e.name).replace(\"%s\", e.message));\n\t\t}\n\t}\n\tif (modules.session) modules.session.destroy();\n\tthrow (component ? component.underlyingJS : null) || code || \"UNSPECIFIED_ERROR\";\n}\n\nfunction startupMemo() {\n\tmodules.core.tty_bios_api.println(\"PCsoft PCOS 3, build \" + pcos_version);\n\tmodules.core.tty_bios_api.println(\"Logical processors: \" + navigator.hardwareConcurrency);\n\tmodules.core.tty_bios_api.println(\"Memory available: \" + ((navigator.deviceMemory * 1024) || \"<unavailable>\") + \" MB\");\n}\nstartupMemo();","e461e7646ad5e2bacd26849dd43e14e455298e38ebcd47d4738a5d67a65c82648d5f3bfc6d636d385484ea41cd0259d1feef111adf98f785c96e4f5d6f347ece":"async function ksk() {\n\t// @pcos-app-mode native\n\t// Key signing key\n\tlet ksk = {\"crv\":\"Ed25519\",\"x\":\"mjUAHanuB4DVdOViC_DRkE2QHqv9rAo2INDQHU3YgfY\",\"kty\":\"OKP\"};\n\tif (ksk.stub == \"present\") {\n\t\tlet e = new Error(\"The key signing key was not built into this build.\");\n\t\tpanic(\"KEY_SIGNING_KEY_NOT_BUILT\", {\n\t\t\tname: \"ksk\",\n\t\t\tparams: [ \"stub\" ],\n\t\t\tunderlyingJS: e\n\t\t});\n\t\tthrow e;\n\t}\n\tif (ksk.stub != \"present\") modules.ksk = ksk;\n\tif (modules.ksk) {\n\t\ttry {\n\t\t\tmodules.ksk_imported = await crypto.subtle.importKey(\"jwk\", modules.ksk, { name: \"Ed25519\" }, false, [\"verify\"]);\n\t\t} catch (e) {\n\t\t\tpanic(\"KEY_SIGNING_KEY_IMPORT_FAILED\", {\n\t\t\t\tname: \"ksk\",\n\t\t\t\tunderlyingJS: e\n\t\t\t});\n\t\t\tthrow e;\n\t\t}\n\t}\n}\nawait ksk();","897da6d9fbcee187e4e92169530d26a5c19735dce068be3ac6115bd43b5a5d3d07b1973ec3c9d1fa97045a1df2eaf75e8e15a2591046b798cb5512bd2b9e3496":"function loadFs() {\n\t// @pcos-app-mode native\n\tlet fs = {\n\t\tread: async function(file, sessionToken) {\n\t\t\tlet mount = file.split(\"/\")[0];\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\treturn await this.mounts[mount].read(file.split(\"/\").slice(1).join(\"/\"), sessionToken);\n\t\t},\n\t\twrite: async function(file, data, sessionToken) {\n\t\t\tlet filePath = file.split(\"/\").slice(1);\n\t\t\tif (filePath.includes(\"\")) throw new Error(\"PATH_INCLUDES_EMPTY\");\n\t\t\tlet mount = file.split(\"/\")[0];\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\tif (modules.core.bootMode == \"readonly\") throw new Error(\"READ_ONLY_BMGR\");\n\t\t\tif (this.mounts[mount].read_only) throw new Error(\"READ_ONLY_DEV\");\n\t\t\treturn await this.mounts[mount].write(file.split(\"/\").slice(1).join(\"/\"), data, sessionToken);\n\t\t},\n\t\trm: async function(file, sessionToken) {\n\t\t\tlet mount = file.split(\"/\")[0];\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\tif (modules.core.bootMode == \"readonly\") throw new Error(\"READ_ONLY_BMGR\");\n\t\t\tif (this.mounts[mount].read_only) throw new Error(\"READ_ONLY_DEV\");\n\t\t\treturn await this.mounts[mount].rm(file.split(\"/\").slice(1).join(\"/\"), sessionToken);\n\t\t},\n\t\tmkdir: async function(folder, sessionToken) {\n\t\t\tlet filePath = folder.split(\"/\").slice(1);\n\t\t\tif (filePath.includes(\"\")) throw new Error(\"PATH_INCLUDES_EMPTY\");\n\t\t\tlet mount = folder.split(\"/\")[0];\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\tif (modules.core.bootMode == \"readonly\") throw new Error(\"READ_ONLY_BMGR\");\n\t\t\tif (this.mounts[mount].read_only) throw new Error(\"READ_ONLY_DEV\");\n\t\t\tif (!this.mounts[mount].directory_supported) throw new Error(\"NO_DIRECTORY_SUPPORT\");\n\t\t\treturn await this.mounts[mount].mkdir(folder.split(\"/\").slice(1).join(\"/\"), sessionToken);\n\t\t},\n\t\tpermissions: async function(folder, sessionToken) {\n\t\t\tlet mount = folder.split(\"/\")[0];\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\tif (!this.mounts[mount].permissions_supported) {\n\t\t\t\ttry {\n\t\t\t\t\tlet userInfo = await modules.tokens.info(sessionToken);\n\t\t\t\t\treturn { owner: userInfo.user, group: userInfo.groups[0] || userInfo.user, world: \"rwx\" };\n\t\t\t\t} catch {}\n\t\t\t\treturn { owner: randomNames, group: randomNames, world: \"rwx\" };\n\t\t\t}\n\t\t\treturn await this.mounts[mount].permissions(folder.split(\"/\").slice(1).join(\"/\"), sessionToken);\n\t\t},\n\t\tlsmounts: function() {\n\t\t\treturn Object.keys(this.mounts);\n\t\t},\n\t\tunmount: async function(mount, sessionToken, force) {\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\tif (!this.mounts[mount].read_only && modules.core.bootMode != \"readonly\" && !force) await this.sync(mount, sessionToken);\n\t\t\tif (!force) await this.mounts[mount].unmount(sessionToken);\n\t\t\tdelete this.mounts[mount];\n\t\t},\n\t\tchown: async function(file, owner, sessionToken) {\n\t\t\tlet filePath = file.split(\"/\").slice(1);\n\t\t\tif (filePath.includes(\"\")) throw new Error(\"PATH_INCLUDES_EMPTY\");\n\t\t\tlet mount = file.split(\"/\")[0];\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\tif (modules.core.bootMode == \"readonly\") throw new Error(\"READ_ONLY_BMGR\");\n\t\t\tif (this.mounts[mount].read_only) throw new Error(\"READ_ONLY_DEV\");\n\t\t\tif (!this.mounts[mount].permissions_supported) return;\n\t\t\treturn await this.mounts[mount].chown(file.split(\"/\").slice(1).join(\"/\"), owner, sessionToken);\n\t\t},\n\t\tchgrp: async function(file, group, sessionToken) {\n\t\t\tlet filePath = file.split(\"/\").slice(1);\n\t\t\tif (filePath.includes(\"\")) throw new Error(\"PATH_INCLUDES_EMPTY\");\n\t\t\tlet mount = file.split(\"/\")[0];\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\tif (modules.core.bootMode == \"readonly\") throw new Error(\"READ_ONLY_BMGR\");\n\t\t\tif (this.mounts[mount].read_only) throw new Error(\"READ_ONLY_DEV\");\n\t\t\tif (!this.mounts[mount].permissions_supported) return;\n\t\t\treturn await this.mounts[mount].chgrp(file.split(\"/\").slice(1).join(\"/\"), group, sessionToken);\n\t\t},\n\t\tchmod: async function(file, permissions, sessionToken) {\n\t\t\tlet filePath = file.split(\"/\").slice(1);\n\t\t\tif (filePath.includes(\"\")) throw new Error(\"PATH_INCLUDES_EMPTY\");\n\t\t\tlet mount = file.split(\"/\")[0];\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\tif (modules.core.bootMode == \"readonly\") throw new Error(\"READ_ONLY_BMGR\");\n\t\t\tif (this.mounts[mount].read_only) throw new Error(\"READ_ONLY_DEV\");\n\t\t\tif (!this.mounts[mount].permissions_supported) return;\n\t\t\treturn await this.mounts[mount].chmod(file.split(\"/\").slice(1).join(\"/\"), permissions, sessionToken);\n\t\t},\n\t\tls: async function(folder, sessionToken) {\n\t\t\tlet mount = folder.split(\"/\")[0];\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\treturn await this.mounts[mount].ls(folder.split(\"/\").slice(1).join(\"/\"), sessionToken);\n\t\t},\n\t\tisDirectory: async function(path, sessionToken) {\n\t\t\tlet mount = path.split(\"/\")[0];\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\tif (!path.split(\"/\").slice(1).join(\"/\")) return true;\n\t\t\tif (!this.mounts[mount].directory_supported) return false;\n\t\t\treturn await this.mounts[mount].isDirectory(path.split(\"/\").slice(1).join(\"/\"), sessionToken);\n\t\t},\n\t\tmountInfo: async function(mount) {\n\t\t\treturn {\n\t\t\t\tread_only: this.mounts[mount].read_only || false,\n\t\t\t\tpermissions_supported: this.mounts[mount].permissions_supported || false,\n\t\t\t\tdirectory_supported: this.mounts[mount].directory_supported || false,\n\t\t\t\tfilesystem: this.mounts[mount].filesystem || \"unknown\"\n\t\t\t}\n\t\t},\n\t\tsync: async function(mount, sessionToken) {\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\tif (!this.mounts[mount].read_only && modules.core.bootMode != \"readonly\") return await this.mounts[mount].sync(sessionToken);\n\t\t},\n\t\tmounts: {}\n\t}\n\t\n\tasync function PCFSiDBMount(options) {\n\t\tlet partition;\n\t\ttry {\n\t\t\tpartition = modules.core.disk.partition(options.partition);\n\t\t\tpartition = partition.getData();\n\t\t} catch (e) {\n\t\t\tthrow new Error(\"PARTITION_FAILED: \" + e.toString() + \"\\n---begin stack---\\n\" + e.stack + \"\\n---end stack---\");\n\t\t}\n\t\tif (!Object.keys(partition).includes(\"files\") || !Object.keys(partition).includes(\"permissions\") || !Object.keys(partition).includes(\"id\")) throw new Error(\"PARTITION_NOT_PCFS\");\n\t\tlet partitionId = partition.id;\n\t\tpartition = null;\n\t\treturn {\n\t\t\tread: async function(key) {\n\t\t\t\tlet pathParts = key.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_FILE\");\n\t\t\t\t}\n\t\t\t\tif (typeof files === \"object\") throw new Error(\"IS_A_DIR\");\n\t\t\t\treturn String(await modules.core.idb.readPart(partitionId + \"-\" + files));\n\t\t\t},\n\t\t\twrite: async function(key, value) {\n\t\t\t\tkey = String(key);\n\t\t\t\tvalue = String(value);\n\t\t\t\tlet existenceChecks = key.split(\"/\").slice(0, -1);\n\t\t\t\tif (existenceChecks[0] == \"\") existenceChecks = existenceChecks.slice(1);\n\t\t\t\tif (existenceChecks[existenceChecks.length - 1] == \"\") existenceChecks = existenceChecks.slice(0, -1);\n\t\t\t\tlet basename = key.split(\"/\").slice(-1)[0];\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of existenceChecks) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files[basename] === \"object\") throw new Error(\"IS_A_DIR\");\n\t\t\t\tlet id = files[basename] || crypto.getRandomValues(new Uint8Array(64)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tawait modules.core.idb.writePart(partitionId + \"-\" + id, value);\n\t\t\t\tif (!files[basename]) this.backend = this._recursive_op(this.backend, \"files/\" + key, { type: \"write\", value: id });\n\t\t\t},\n\t\t\trm: async function(key) {\n\t\t\t\tkey = String(key);\n\t\t\t\tlet pathParts = key.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_FILE_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files === \"object\" && Object.keys(files).length > 0) throw new Error(\"NON_EMPTY_DIR\");\n\t\t\t\tif (typeof files === \"string\") await modules.core.idb.removePart(partitionId + \"-\" + files);\n\t\t\t\tthis.backend = this._recursive_op(this.backend, \"files/\" + key, { type: \"delete\" });\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tdelete backend.permissions[key];\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tls: async function(directory) {\n\t\t\t\tdirectory = String(directory);\n\t\t\t\tlet pathParts = directory.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files !== \"object\") throw new Error(\"IS_A_FILE\");\n\t\t\t\treturn Object.keys(files);\n\t\t\t},\n\t\t\tmkdir: async function(directory) {\n\t\t\t\tdirectory = String(directory);\n\t\t\t\tlet existenceChecks = directory.split(\"/\").slice(0, -1);\n\t\t\t\tif (existenceChecks[0] == \"\") existenceChecks = existenceChecks.slice(1);\n\t\t\t\tif (existenceChecks[existenceChecks.length - 1] == \"\") existenceChecks = existenceChecks.slice(0, -1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of existenceChecks) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (files[directory.split(\"/\").slice(-1)[0]]) throw new Error(\"DIR_EXISTS\");\n\t\t\t\tthis.backend = this._recursive_op(this.backend, \"files/\" + directory, { type: \"write\", value: {} });\n\t\t\t},\n\t\t\tpermissions: async function(file) {\n\t\t\t\tfile = String(file);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet permissions = this.backend.permissions[properFile] || {};\n\t\t\t\treturn {\n\t\t\t\t\towner: permissions.owner || randomNames,\n\t\t\t\t\tgroup: permissions.group || randomNames,\n\t\t\t\t\tworld: permissions.world || \"\",\n\t\t\t\t\trandom: !(permissions.owner || permissions.group || permissions.world) ? true : undefined\n\t\t\t\t};\n\t\t\t},\n\t\t\tchown: async function(file, owner) {\n\t\t\t\tfile = String(file);\n\t\t\t\towner = String(owner);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tif (Object.prototype.hasOwnProperty(properFile)) throw new Error(\"TECHNICAL_LIMITATIONS\");\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.owner = owner;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tchgrp: async function(file, group) {\n\t\t\t\tfile = String(file);\n\t\t\t\tgroup = String(group);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tif (Object.prototype.hasOwnProperty(properFile)) throw new Error(\"TECHNICAL_LIMITATIONS\");\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.group = group;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tchmod: async function(file, permissions) {\n\t\t\t\tfile = String(file);\n\t\t\t\tpermissions = String(permissions);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tif (Object.prototype.hasOwnProperty(properFile)) throw new Error(\"TECHNICAL_LIMITATIONS\");\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.world = permissions;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tsync: async function() {\n\t\t\t\tawait modules.core.disk.sync();\n\t\t\t},\n\t\t\tisDirectory: function(key) {\n\t\t\t\tkey = String(key);\n\t\t\t\tlet pathParts = key.split(\"/\").slice(0, -1);\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet basename = key.split(\"/\").slice(-1)[0];\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (!files.hasOwnProperty(basename)) throw new Error(\"NO_SUCH_FILE_DIR\");\n\t\t\t\tif (typeof files[basename] === \"object\") return true;\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tunmount: () => true,\n\t\t\t_recursive_op: function(obj, path, action, stage = 0) {\n\t\t\t\tif (path.split(\"/\").length == (stage + 1)) {\n\t\t\t\t\tif (action.type == \"delete\") delete obj[path.split(\"/\").slice(-1)[0]];\n\t\t\t\t\tif (action.type == \"write\") obj[path.split(\"/\").slice(-1)[0]] = action.value;\n\t\t\t\t} else obj[path.split(\"/\")[stage]] = this._recursive_op(obj[path.split(\"/\")[stage]], path, action, stage + 1);\n\t\t\t\treturn obj;\n\t\t\t},\n\t\t\tdirectory_supported: true,\n\t\t\tread_only: !!options.read_only,\n\t\t\tfilesystem: \"PCFS\",\n\t\t\tpermissions_supported: true,\n\t\t\tpartition: null,\n\t\t\tget backend() {\n\t\t\t\tif (!this.partition) this.partition = modules.core.disk.partition(options.partition);\n\t\t\t\treturn this.partition.getData();\n\t\t\t},\n\t\t\tset backend(data) {\n\t\t\t\tif (!this.partition) this.partition = modules.core.disk.partition(options.partition);\n\t\t\t\tthis.partition.setData(data);\n\t\t\t}\n\t\t};\n\t};\n\n\tasync function PCFSiDBAESCryptMount(options) {\n\t\tlet partition;\n\t\ttry {\n\t\t\tpartition = modules.core.disk.partition(options.partition);\n\t\t\tpartition = partition.getData();\n\t\t} catch (e) {\n\t\t\tthrow new Error(\"PARTITION_FAILED: \" + e.toString() + \"\\n---begin stack---\\n\" + e.stack + \"\\n---end stack---\");\n\t\t}\n\t\tif (!Object.keys(partition).includes(\"files\") || !Object.keys(partition).includes(\"permissions\") || !Object.keys(partition).includes(\"cryptodata\") || !Object.keys(partition).includes(\"id\")) throw new Error(\"PARTITION_NOT_PCFS_ENCRYPTED\");\n\t\tif (options.interactivePassword) {\n\t\t\tlet passwordInput = \"\";\n\t\t\tlet tbi = modules.core.tty_bios_api;\n\t\t\tfunction outputPasswordAsking() {\n\t\t\t\ttbi.clear();\n\t\t\t\ttbi.println(\"|--------------------------------------------|\")\n\t\t\t\ttbi.println(\"| Mounting encrypted partition               |\");\n\t\t\t\ttbi.println(\"|--------------------------------------------|\");\n\t\t\t\ttbi.println(\"| Enter your password. Typed \" + passwordInput.length + \" characters. \" + \" \".repeat(Math.max((3 - (passwordInput.length).toString().length), 0)) + \"|\");\n\t\t\t\ttbi.println(\"| Press Enter to mount.                      |\");\n\t\t\t\ttbi.println(\"|--------------------------------------------|\");\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\toutputPasswordAsking();\n\t\t\t\tlet key = await tbi.inputKey();\n\t\t\t\tif (key.key == \"Enter\") break;\n\t\t\t\tif (key.key.length == 1) passwordInput += key.key;\n\t\t\t\tif (key.key == \"Backspace\") passwordInput = passwordInput.slice(0, -1);\n\t\t\t}\n\t\t\toptions.password = passwordInput;\n\t\t}\n\t\tif (options.password) options.key = await modules.core.pbkdf2(options.password, partition.cryptodata.salt);\n\t\tif (!options.key) throw new Error(\"GETTING_KEY_FAILED\");\n\t\tlet importedKey = await crypto.subtle.importKey(\"raw\", Uint8Array.from(options.key.match(/.{1,2}/g).map(a => parseInt(a, 16))), { name: \"AES-GCM\" }, false, [ \"encrypt\", \"decrypt\" ]);\n\t\toptions.key = options.key.length + \"L\";\n\t\toptions.password = options.password.length + \"L\";\n\t\tif (partition.cryptodata.passwordLockingInitial) {\n\t\t\tlet baseData = crypto.getRandomValues(new Uint8Array(32));\n\t\t\tlet iv = crypto.getRandomValues(new Uint8Array(16));\n\t\t\tlet ct = new Uint8Array(await crypto.subtle.encrypt({ name: \"AES-GCM\", iv }, importedKey, baseData));\n\t\t\tlet passwordLocking = new Uint8Array(iv.length + ct.length);\n\t\t\tpasswordLocking.set(iv);\n\t\t\tpasswordLocking.set(ct, iv.length);\n\t\t\tpartition.cryptodata.passwordLocking = passwordLocking.reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\tif (partition.encryptedFileTable) {\n\t\t\t\tlet fileIV = crypto.getRandomValues(new Uint8Array(16));\n\t\t\t\tlet fileCT = new Uint8Array(await crypto.subtle.encrypt({ name: \"AES-GCM\", iv: fileIV }, importedKey, new TextEncoder().encode(JSON.stringify({\n\t\t\t\t\tfiles: partition.files,\n\t\t\t\t\tpermissions: partition.permissions\n\t\t\t\t}))));\n\t\t\t\tpartition.files = {};\n\t\t\t\tpartition.permissions = {};\n\t\t\t\tlet ept = new Uint8Array(fileIV.length + fileCT.length);\n\t\t\t\tept.set(fileIV);\n\t\t\t\tept.set(fileCT, fileIV.length);\n\t\t\t\tpartition.encryptedFileTable = ept.reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t}\n\t\t\tdelete partition.cryptodata.passwordLockingInitial;\n\t\t\tmodules.core.disk.partition(options.partition).setData(partition);\n\t\t}\n\t\tif (partition.cryptodata.passwordLocking) {\n\t\t\tlet iv = new Uint8Array(partition.cryptodata.passwordLocking.slice(0, 32).match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\tlet ct = new Uint8Array(partition.cryptodata.passwordLocking.slice(32).match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\tawait crypto.subtle.decrypt({ name: \"AES-GCM\", iv }, importedKey, ct);\n\t\t}\n\t\tlet partitionId = partition.id;\n\t\tpartition = null;\n\t\treturn {\n\t\t\tread: async function(key) {\n\t\t\t\tkey = String(key);          \n\t\t\t\tlet pathParts = key.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tlet files = (await this.getBackend()).files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_FILE\");\n\t\t\t\t}\n\t\t\t\tif (typeof files === \"object\") throw new Error(\"IS_A_DIR\");\n\t\t\t\tlet part = await modules.core.idb.readPart(partitionId + \"-\" + files);\n\t\t\t\tlet iv = new Uint8Array(part.slice(0, 32).match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\t\tlet ct = new Uint8Array(part.slice(32).match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\t\treturn new TextDecoder().decode(new Uint8Array(await crypto.subtle.decrypt({ name: \"AES-GCM\", iv }, this.key, ct)));\n\t\t\t},\n\t\t\twrite: async function(key, value) {\n\t\t\t\tkey = String(key);\n\t\t\t\tvalue = String(value);\n\t\t\t\tlet existenceChecks = key.split(\"/\").slice(0, -1);\n\t\t\t\tif (existenceChecks[0] == \"\") existenceChecks = existenceChecks.slice(1);\n\t\t\t\tif (existenceChecks[existenceChecks.length - 1] == \"\") existenceChecks = existenceChecks.slice(0, -1);\n\t\t\t\tlet basename = key.split(\"/\").slice(-1)[0];\n\t\t\t\tlet files = (await this.getBackend()).files;\n\t\t\t\tfor (let part of existenceChecks) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files[basename] === \"object\") throw new Error(\"IS_A_DIR\");\n\t\t\t\tlet id = files[basename] || crypto.getRandomValues(new Uint8Array(64)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet newIV = crypto.getRandomValues(new Uint8Array(16));\n\t\t\t\tlet newCT = new Uint8Array(await crypto.subtle.encrypt({ name: \"AES-GCM\", iv: newIV }, this.key, new TextEncoder().encode(value)));\n\t\t\t\tlet newPart = new Uint8Array(newIV.length + newCT.length);\n\t\t\t\tnewPart.set(newIV);\n\t\t\t\tnewPart.set(newCT, newIV.length);\n\t\t\t\tnewPart = newPart.reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tawait modules.core.idb.writePart(partitionId + \"-\" + id, newPart);\n\t\t\t\tif (!files[basename]) await this.setBackend(this._recursive_op(await this.getBackend(), \"files/\" + key, { type: \"write\", value: id }));\n\t\t\t},\n\t\t\trm: async function(key) {\n\t\t\t\tkey = String(key);\n\t\t\t\tlet pathParts = key.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet files = (await this.getBackend()).files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_FILE_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files === \"object\" && Object.keys(files).length > 0) throw new Error(\"NON_EMPTY_DIR\");\n\t\t\t\tif (typeof files === \"string\") await modules.core.idb.removePart(partitionId + \"-\" + files);\n\t\t\t\tawait this.setBackend(this._recursive_op(await this.getBackend(), \"files/\" + key, { type: \"delete\" }));\n\t\t\t\tlet backend = await this.getBackend();\n\t\t\t\tdelete backend.permissions[key];\n\t\t\t\tawait this.setBackend(backend);\n\t\t\t},\n\t\t\tls: async function(directory) {\n\t\t\t\tdirectory = String(directory);\n\t\t\t\tlet pathParts = directory.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet files = (await this.getBackend()).files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files !== \"object\") throw new Error(\"IS_A_FILE\");\n\t\t\t\treturn Object.keys(files);\n\t\t\t},\n\t\t\tmkdir: async function(directory) {\n\t\t\t\tdirectory = String(directory);\n\t\t\t\tlet existenceChecks = directory.split(\"/\").slice(0, -1);\n\t\t\t\tif (existenceChecks[0] == \"\") existenceChecks = existenceChecks.slice(1);\n\t\t\t\tif (existenceChecks[existenceChecks.length - 1] == \"\") existenceChecks = existenceChecks.slice(0, -1);\n\t\t\t\tlet files = (await this.getBackend()).files;\n\t\t\t\tfor (let part of existenceChecks) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (files[directory.split(\"/\").slice(-1)[0]]) throw new Error(\"DIR_EXISTS\");\n\t\t\t\tawait this.setBackend(this._recursive_op(await this.getBackend(), \"files/\" + directory, { type: \"write\", value: {} }));\n\t\t\t},\n\t\t\tpermissions: async function(file) {\n\t\t\t\tfile = String(file);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet permissions = (await this.getBackend()).permissions[properFile] || {};\n\t\t\t\treturn {\n\t\t\t\t\towner: permissions.owner || randomNames,\n\t\t\t\t\tgroup: permissions.group || randomNames,\n\t\t\t\t\tworld: permissions.world || \"\",\n\t\t\t\t\trandom: !(permissions.owner || permissions.group || permissions.world) ? true : undefined\n\t\t\t\t};\n\t\t\t},\n\t\t\tchown: async function(file, owner) {\n\t\t\t\tfile = String(file);\n\t\t\t\towner = String(owner);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tif (Object.prototype.hasOwnProperty(properFile)) throw new Error(\"TECHNICAL_LIMITATIONS\");\n\t\t\t\tlet backend = await this.getBackend();\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.owner = owner;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tawait this.setBackend(backend);\n\t\t\t},\n\t\t\tchgrp: async function(file, group) {\n\t\t\t\tfile = String(file);\n\t\t\t\tgroup = String(group);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tif (Object.prototype.hasOwnProperty(properFile)) throw new Error(\"TECHNICAL_LIMITATIONS\");\n\t\t\t\tlet backend = await this.getBackend();\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.group = group;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tawait this.setBackend(backend);\n\t\t\t},\n\t\t\tchmod: async function(file, permissions) {\n\t\t\t\tfile = String(file);\n\t\t\t\tpermissions = String(permissions);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tif (Object.prototype.hasOwnProperty(properFile)) throw new Error(\"TECHNICAL_LIMITATIONS\");\n\t\t\t\tlet backend = await this.getBackend();\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.world = permissions;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tawait this.setBackend(backend);\n\t\t\t},\n\t\t\tisDirectory: async function(key) {\n\t\t\t\tkey = String(key);\n\t\t\t\tlet pathParts = key.split(\"/\").slice(0, -1);\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet basename = key.split(\"/\").slice(-1)[0];\n\t\t\t\tlet files = (await this.getBackend()).files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (!files.hasOwnProperty(basename)) throw new Error(\"NO_SUCH_FILE_DIR\");\n\t\t\t\tif (typeof files[basename] === \"object\") return true;\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tsync: async function() {\n\t\t\t\tawait modules.core.disk.sync();\n\t\t\t},\n\t\t\tunmount: () => true,\n\t\t\t_recursive_op: function(obj, path, action, stage = 0) {\n\t\t\t\tif (path.split(\"/\").length == (stage + 1)) {\n\t\t\t\t\tif (action.type == \"delete\") delete obj[path.split(\"/\").slice(-1)[0]];\n\t\t\t\t\tif (action.type == \"write\") obj[path.split(\"/\").slice(-1)[0]] = action.value;\n\t\t\t\t} else obj[path.split(\"/\")[stage]] = this._recursive_op(obj[path.split(\"/\")[stage]], path, action, stage + 1);\n\t\t\t\treturn obj;\n\t\t\t},\n\t\t\tdirectory_supported: true,\n\t\t\tfilesystem: \"PCFS-AES\",\n\t\t\tread_only: !!options.read_only,\n\t\t\tpermissions_supported: true,\n\t\t\tpartition: null,\n\t\t\tgetBackend: async function() {\n\t\t\t\tif (!this.partition) this.partition = modules.core.disk.partition(options.partition);\n\t\t\t\tlet returnedData = this.partition.getData();\n\t\t\t\tif (returnedData.encryptedFileTable) {\n\t\t\t\t\tlet iv = new Uint8Array(returnedData.encryptedFileTable.slice(0, 32).match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\t\t\tlet ct = new Uint8Array(returnedData.encryptedFileTable.slice(32).match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\t\t\treturn JSON.parse(new TextDecoder().decode(new Uint8Array(await crypto.subtle.decrypt({ name: \"AES-GCM\", iv }, this.key, ct))));   \n\t\t\t\t}\n\t\t\t\treturn returnedData;\n\t\t\t},\n\t\t\tsetBackend: async function(data) {\n\t\t\t\tif (!this.partition) this.partition = modules.core.disk.partition(options.partition);\n\t\t\t\tlet returnedData = this.partition.getData();\n\t\t\t\tif (returnedData.encryptedFileTable) {\n\t\t\t\t\tlet newIV = crypto.getRandomValues(new Uint8Array(16));\n\t\t\t\t\tlet newCT = new Uint8Array(await crypto.subtle.encrypt({ name: \"AES-GCM\", iv: newIV }, this.key, new TextEncoder().encode(JSON.stringify(data))));\n\t\t\t\t\tlet newPart = new Uint8Array(newIV.length + newCT.length);\n\t\t\t\t\tnewPart.set(newIV);\n\t\t\t\t\tnewPart.set(newCT, newIV.length);\n\t\t\t\t\tnewPart = newPart.reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\t\treturn this.partition.setData({ ...returnedData, encryptedFileTable: newPart });\n\t\t\t\t}\n\t\t\t\tthis.partition.setData(data);\n\t\t\t},\n\t\t\tkey: importedKey\n\t\t};\n\t};\n\t\n\tfunction ramMount(options) {\n\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\treturn {\n\t\t\tread: async function(key) {\n\t\t\t\tkey = String(key);\n\t\t\t\tlet pathParts = key.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_FILE\");\n\t\t\t\t}\n\t\t\t\tif (typeof files === \"object\") throw new Error(\"IS_A_DIR\");\n\t\t\t\treturn String(this.ramFiles.get(files));\n\t\t\t},\n\t\t\twrite: async function(key, value) {\n\t\t\t\tkey = String(key);\n\t\t\t\tvalue = String(value);\n\t\t\t\tlet existenceChecks = key.split(\"/\").slice(0, -1);\n\t\t\t\tif (existenceChecks[0] == \"\") existenceChecks = existenceChecks.slice(1);\n\t\t\t\tif (existenceChecks[existenceChecks.length - 1] == \"\") existenceChecks = existenceChecks.slice(0, -1);\n\t\t\t\tlet basename = key.split(\"/\").slice(-1)[0];\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of existenceChecks) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files[basename] === \"object\") throw new Error(\"IS_A_DIR\");\n\t\t\t\tlet id = files[basename] || crypto.getRandomValues(new Uint8Array(64)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tthis.ramFiles.set(id, value);\n\t\t\t\tif (!files[basename]) this.backend = this._recursive_op(this.backend, \"files/\" + key, { type: \"write\", value: id });\n\t\t\t},\n\t\t\trm: async function(key) {\n\t\t\t\tkey = String(key);\n\t\t\t\tlet pathParts = key.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_FILE_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files === \"object\" && Object.keys(files).length > 0) throw new Error(\"NON_EMPTY_DIR\");\n\t\t\t\tif (typeof files === \"string\") this.ramFiles.delete(files);\n\t\t\t\tthis.backend = this._recursive_op(this.backend, \"files/\" + key, { type: \"delete\" });\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tdelete backend.permissions[key];\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tls: async function(directory) {\n\t\t\t\tdirectory = String(directory);\n\t\t\t\tlet pathParts = directory.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files !== \"object\") throw new Error(\"IS_A_FILE\");\n\t\t\t\treturn Object.keys(files);\n\t\t\t},\n\t\t\tmkdir: async function(directory) {\n\t\t\t\tdirectory = String(directory);\n\t\t\t\tlet existenceChecks = directory.split(\"/\").slice(0, -1);\n\t\t\t\tif (existenceChecks[0] == \"\") existenceChecks = existenceChecks.slice(1);\n\t\t\t\tif (existenceChecks[existenceChecks.length - 1] == \"\") existenceChecks = existenceChecks.slice(0, -1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of existenceChecks) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (files[directory.split(\"/\").slice(-1)[0]]) throw new Error(\"DIR_EXISTS\");\n\t\t\t\tthis.backend = this._recursive_op(this.backend, \"files/\" + directory, { type: \"write\", value: {} });\n\t\t\t},\n\t\t\tpermissions: async function(file) {\n\t\t\t\tfile = String(file);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet permissions = this.backend.permissions[properFile] || {};\n\t\t\t\treturn {\n\t\t\t\t\towner: permissions.owner || randomNames,\n\t\t\t\t\tgroup: permissions.group || randomNames,\n\t\t\t\t\tworld: permissions.world || \"\",\n\t\t\t\t\trandom: !(permissions.owner || permissions.group || permissions.world) ? true : undefined\n\t\t\t\t};\n\t\t\t},\n\t\t\tchown: async function(file, owner) {\n\t\t\t\tfile = String(file);\n\t\t\t\towner = String(owner);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tif (Object.prototype.hasOwnProperty(properFile)) throw new Error(\"TECHNICAL_LIMITATIONS\");\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.owner = owner;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tchgrp: async function(file, group) {\n\t\t\t\tfile = String(file);\n\t\t\t\tgroup = String(group);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tif (Object.prototype.hasOwnProperty(properFile)) throw new Error(\"TECHNICAL_LIMITATIONS\");\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.group = group;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tchmod: async function(file, permissions) {\n\t\t\t\tfile = String(file);\n\t\t\t\tpermissions = String(permissions);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tif (Object.prototype.hasOwnProperty(properFile)) throw new Error(\"TECHNICAL_LIMITATIONS\");\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.world = permissions;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tisDirectory: function(key) {\n\t\t\t\tkey = String(key);\n\t\t\t\tlet pathParts = key.split(\"/\").slice(0, -1);\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet basename = key.split(\"/\").slice(-1)[0];\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (!files.hasOwnProperty(basename)) throw new Error(\"NO_SUCH_FILE_DIR\");\n\t\t\t\tif (typeof files[basename] === \"object\") return true;\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\t_recursive_op: function(obj, path, action, stage = 0) {\n\t\t\t\tif (path.split(\"/\").length == (stage + 1)) {\n\t\t\t\t\tif (action.type == \"delete\") delete obj[path.split(\"/\").slice(-1)[0]];\n\t\t\t\t\tif (action.type == \"write\") obj[path.split(\"/\").slice(-1)[0]] = action.value;\n\t\t\t\t} else obj[path.split(\"/\")[stage]] = this._recursive_op(obj[path.split(\"/\")[stage]], path, action, stage + 1);\n\t\t\t\treturn obj;\n\t\t\t},\n\t\t\tsync: () => true,\n\t\t\tunmount: () => true,\n\t\t\tdirectory_supported: true,\n\t\t\tread_only: !!options.read_only,\n\t\t\tfilesystem: \"extramfs\",\n\t\t\tpermissions_supported: true,\n\t\t\tbackend: options.type == \"run\" ? { files: { run: {} }, permissions: {\n\t\t\t\t\"\": {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"rx\"\n\t\t\t\t},\n\t\t\t\trun: {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"rwx\"\n\t\t\t\t}\n\t\t\t}} : { files: {}, permissions: {\n\t\t\t\t\"\": {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"rx\"\n\t\t\t\t}\n\t\t\t} },\n\t\t\tramFiles: new Map()\n\t\t};\n\t}\n\t\n\tfunction preferenceMount(options) {\n\t\treturn {\n\t\t\tread: a => JSON.stringify(modules.core.prefs.read(a), null, \"\\t\"),\n\t\t\twrite: (a, b) => modules.core.prefs.write(a, JSON.parse(b)),\n\t\t\trm: a => modules.core.prefs.rm(a),\n\t\t\tls: a => modules.core.prefs.ls(a),\n\t\t\tpermissions: function() {\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\treturn {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t},\n\t\t\tchown: _ => !1,\n\t\t\tchgrp: _ => !1,\n\t\t\tchmod: _ => !1,\n\t\t\tsync: () => true,\n\t\t\tunmount: () => true,\n\t\t\tdirectory_supported: false,\n\t\t\tread_only: !!options.read_only,\n\t\t\tfilesystem: \"preffs\",\n\t\t\tpermissions_supported: true\n\t\t};\n\t}\n\n\tasync function SFSPMount(options) {\n\t\tlet session, serverData;\n\t\ttry {\n\t\t\tsession = await fetch(options.url + \"/session\");\n\t\t\tsession = await session.json();\n\t\t\tserverData = await fetch(options.url + \"/properties\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\theaders: {\n\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t},\n\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t...options,\n\t\t\t\t\tsessionToken: session\n\t\t\t\t})\n\t\t\t});\n\t\t\tserverData = await serverData.json();\n\t\t} catch (e) {\n\t\t\tthrow new Error(\"Could not connect to server\");\n\t\t}\n\t\treturn {\n\t\t\tread: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"read\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\twrite: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"write\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\trm: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"rm\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\tls: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"ls\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\tmkdir: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"mkdir\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\tpermissions: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"permissions\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\tchown: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"chown\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\tchgrp: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"chgrp\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\tchmod: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"chmod\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\tsync: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"sync\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\tisDirectory: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"isDirectory\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\tunmount: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"unmount\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\t...serverData\n\t\t};\n\t};\n\n\tasync function IPCMount(options) { // ChatGPT code below\n\t\tif (!options.inputPipeId || !options.outputPipeId) throw new Error(\"PIPE_IDS_REQUIRED\");\n\t\n\t\tconst inputPipeId = options.inputPipeId;\n\t\tconst outputPipeId = options.outputPipeId;\n\t\tlet lock = false;\n\t\n\t\tasync function acquireLock() {\n\t\t\treturn new Promise((resolve) => {\n\t\t\t\tconst tryLock = () => {\n\t\t\t\t\tif (!lock) {\n\t\t\t\t\t\tlock = true;\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsetTimeout(tryLock, 10); // retry after 10ms\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tsetTimeout(tryLock, 10);\n\t\t\t});\n\t\t}\n\t\n\t\tasync function releaseLock() {\n\t\t\tlock = false;\n\t\t}\n\t\n\t\t// Function to send request and receive response\n\t\tasync function ipcRequest(action, payload = {}) {\n\t\t\tawait acquireLock();\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tmodules.ipc.listenFor(outputPipeId).then((response) => {\n\t\t\t\t\treleaseLock();\n\t\t\t\t\tif (response.error) return reject(new Error(response.error));\n\t\t\t\t\treturn resolve(response.data);\n\t\t\t\t});\n\t\t\t\tmodules.ipc.send(inputPipeId, { action, ...payload });\n\t\t\t});\n\t\t}\n\t\n\t\t// Initial request to get filesystem properties\n\t\tconst filesystemData = await ipcRequest(\"properties\", { data: options });\n\t\n\t\treturn {\n\t\t\tread: async function(key) {\n\t\t\t\treturn ipcRequest(\"read\", { key: String(key) });\n\t\t\t},\n\t\t\twrite: async function(key, value) {\n\t\t\t\treturn ipcRequest(\"write\", { key: String(key), value: String(value) });\n\t\t\t},\n\t\t\trm: async function(key) {\n\t\t\t\treturn ipcRequest(\"rm\", { key: String(key) });\n\t\t\t},\n\t\t\tls: async function(directory) {\n\t\t\t\treturn ipcRequest(\"ls\", { directory: String(directory) });\n\t\t\t},\n\t\t\tmkdir: async function(directory) {\n\t\t\t\treturn ipcRequest(\"mkdir\", { directory: String(directory) });\n\t\t\t},\n\t\t\tpermissions: async function(file) {\n\t\t\t\treturn ipcRequest(\"permissions\", { file: String(file) });\n\t\t\t},\n\t\t\tchown: async function(file, owner) {\n\t\t\t\treturn ipcRequest(\"chown\", { file: String(file), owner: String(owner) });\n\t\t\t},\n\t\t\tchgrp: async function(file, group) {\n\t\t\t\treturn ipcRequest(\"chgrp\", { file: String(file), group: String(group) });\n\t\t\t},\n\t\t\tchmod: async function(file, permissions) {\n\t\t\t\treturn ipcRequest(\"chmod\", { file: String(file), permissions: String(permissions) });\n\t\t\t},\n\t\t\tisDirectory: async function(key) {\n\t\t\t\treturn ipcRequest(\"isDirectory\", { key: String(key) });\n\t\t\t},\n\t\t\tsync: async function() {\n\t\t\t\treturn ipcRequest(\"sync\");\n\t\t\t},\n\t\t\tunmount: async function() {\n\t\t\t\treturn ipcRequest(\"unmount\");\n\t\t\t},\n\t\t\t...filesystemData\n\t\t};\n\t} // ChatGPT code ends here\n\n\tasync function fileMount(options) {\n\t\tlet file = JSON.parse(await modules.fs.read(options.srcFile));\n\t\tlet backend = file.backend;\n\t\tdelete file.backend;\n\t\tlet files = file.files;\n\t\tdelete file.files;\n\t\treturn {\n\t\t\tread: async function(key) {\n\t\t\t\tkey = String(key);\n\t\t\t\tlet pathParts = key.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_FILE\");\n\t\t\t\t}\t\n\t\t\t\tif (typeof files === \"object\") throw new Error(\"IS_A_DIR\");\n\t\t\t\treturn String(this.files[files]);\n\t\t\t},\n\t\t\twrite: async function(key, value) {\n\t\t\t\tkey = String(key);\n\t\t\t\tvalue = String(value);\n\t\t\t\tlet existenceChecks = key.split(\"/\").slice(0, -1);\n\t\t\t\tif (existenceChecks[0] == \"\") existenceChecks = existenceChecks.slice(1);\n\t\t\t\tif (existenceChecks[existenceChecks.length - 1] == \"\") existenceChecks = existenceChecks.slice(0, -1);\n\t\t\t\tlet basename = key.split(\"/\").slice(-1)[0];\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of existenceChecks) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files[basename] === \"object\") throw new Error(\"IS_A_DIR\");\n\t\t\t\tlet id = files[basename] || crypto.getRandomValues(new Uint8Array(64)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tthis.files[id] = value;\n\t\t\t\tif (!files[basename]) this.backend = this._recursive_op(this.backend, \"files/\" + key, { type: \"write\", value: id });\n\t\t\t},\n\t\t\trm: async function(key) {\n\t\t\t\tkey = String(key);\n\t\t\t\tlet pathParts = key.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_FILE_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files === \"object\" && Object.keys(files).length > 0) throw new Error(\"NON_EMPTY_DIR\");\n\t\t\t\tif (typeof files === \"string\") delete this.files[files];\n\t\t\t\tthis.backend = this._recursive_op(this.backend, \"files/\" + key, { type: \"delete\" });\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tdelete backend.permissions[key];\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tls: async function(directory) {\n\t\t\t\tdirectory = String(directory);\n\t\t\t\tlet pathParts = directory.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files !== \"object\") throw new Error(\"IS_A_FILE\");\n\t\t\t\treturn Object.keys(files);\n\t\t\t},\n\t\t\tmkdir: async function(directory) {\n\t\t\t\tdirectory = String(directory);\n\t\t\t\tlet existenceChecks = directory.split(\"/\").slice(0, -1);\n\t\t\t\tif (existenceChecks[0] == \"\") existenceChecks = existenceChecks.slice(1);\n\t\t\t\tif (existenceChecks[existenceChecks.length - 1] == \"\") existenceChecks = existenceChecks.slice(0, -1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of existenceChecks) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (files[directory.split(\"/\").slice(-1)[0]]) throw new Error(\"DIR_EXISTS\");\n\t\t\t\tthis.backend = this._recursive_op(this.backend, \"files/\" + directory, { type: \"write\", value: {} });\n\t\t\t},\n\t\t\tpermissions: async function(file) {\n\t\t\t\tfile = String(file);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet permissions = this.backend.permissions[properFile] || {};\n\t\t\t\treturn {\n\t\t\t\t\towner: permissions.owner || randomNames,\n\t\t\t\t\tgroup: permissions.group || randomNames,\n\t\t\t\t\tworld: permissions.world || \"\",\n\t\t\t\t\trandom: !(permissions.owner || permissions.group || permissions.world) ? true : undefined\n\t\t\t\t};\n\t\t\t},\n\t\t\tchown: async function(file, owner) {\n\t\t\t\tfile = String(file);\n\t\t\t\towner = String(owner);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tif (Object.prototype.hasOwnProperty(properFile)) throw new Error(\"TECHNICAL_LIMITATIONS\");\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.owner = owner;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tchgrp: async function(file, group) {\n\t\t\t\tfile = String(file);\n\t\t\t\tgroup = String(group);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tif (Object.prototype.hasOwnProperty(properFile)) throw new Error(\"TECHNICAL_LIMITATIONS\");\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.group = group;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tchmod: async function(file, permissions) {\n\t\t\t\tfile = String(file);\n\t\t\t\tpermissions = String(permissions);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tif (Object.prototype.hasOwnProperty(properFile)) throw new Error(\"TECHNICAL_LIMITATIONS\");\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.world = permissions;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tisDirectory: function(key) {\n\t\t\t\tkey = String(key);\n\t\t\t\tlet pathParts = key.split(\"/\").slice(0, -1);\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet basename = key.split(\"/\").slice(-1)[0];\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (!files.hasOwnProperty(basename)) throw new Error(\"NO_SUCH_FILE_DIR\");\n\t\t\t\tif (typeof files[basename] === \"object\") return true;\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\t_recursive_op: function(obj, path, action, stage = 0) {\n\t\t\t\tif (path.split(\"/\").length == (stage + 1)) {\n\t\t\t\t\tif (action.type == \"delete\") delete obj[path.split(\"/\").slice(-1)[0]];\n\t\t\t\t\tif (action.type == \"write\") obj[path.split(\"/\").slice(-1)[0]] = action.value;\n\t\t\t\t} else obj[path.split(\"/\")[stage]] = this._recursive_op(obj[path.split(\"/\")[stage]], path, action, stage + 1);\n\t\t\t\treturn obj;\n\t\t\t},\n\t\t\tsync: async function() {\n\t\t\t\treturn await modules.fs.write(options.srcFile, JSON.stringify({ ...file, backend: this.backend, files: this.files }));\n\t\t\t},\n\t\t\tunmount: () => true,\n\t\t\tdirectory_supported: true,\n\t\t\tread_only: !!options.read_only,\n\t\t\tfilesystem: \"filefs\",\n\t\t\tpermissions_supported: true,\n\t\t\tbackend: backend,\n\t\t\tfiles: files\n\t\t};\n\t}\n\n\tasync function overlayMount(options) {\n\t\treturn {\n\t\t\tread: function(key, token) {\n\t\t\t\treturn this._basic_first_op(\"read\", key, token);\n\t\t\t},\n\t\t\twrite: function(key, value, token) {\n\t\t\t\treturn this._basic_first_op(\"write\", key, value, token);\n\t\t\t},\n\t\t\trm: function(key, token) {\n\t\t\t\treturn this._basic_first_op(\"rm\", key, token);\n\t\t\t},\n\t\t\tls: async function(directory, token) {\n\t\t\t\tlet listing = [], commonErrorMessages = {}, errors = 0;\n\t\t\t\tfor (let mount of options.mounts) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlisting.push(...(await modules.fs.ls(mount + \"/\" + directory, token)));\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\terrors++;\n\t\t\t\t\t\tcommonErrorMessages[e.message] = (commonErrorMessages[e.message] || 0) + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (errors == options.mounts.length) throw new Error(Object.entries(commonErrorMessages).sort((a, b) => b[1] - a[1])[0][0]);\n\t\t\t\treturn Array.from(new Set(listing));\n\t\t\t},\n\t\t\tmkdir: function(directory, token) {\n\t\t\t\treturn this._basic_first_op(\"mkdir\", directory, token);\n\t\t\t},\n\t\t\tpermissions: async function(file, token) {\n\t\t\t\tlet commonErrorMessages = {}, checkedHowMany = 0;\n\t\t\t\tfor (let mount of options.mounts) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcheckedHowMany++;\n\t\t\t\t\t\tlet permissions = await modules.fs.permissions(mount + \"/\" + file, token);\n\t\t\t\t\t\tif (permissions.random && checkedHowMany != options.mounts.length)\n\t\t\t\t\t\t\tthrow new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\t\treturn permissions;\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tcommonErrorMessages[e.message] = (commonErrorMessages[e.message] || 0) + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow new Error(Object.entries(commonErrorMessages).sort((a, b) => b[1] - a[1])[0][0]);\n\t\t\t},\n\t\t\tchown: function(file, owner, token) {\n\t\t\t\treturn this._basic_first_op(\"chown\", file, owner, token);\n\t\t\t},\n\t\t\tchgrp: function(file, group, token) {\n\t\t\t\treturn this._basic_first_op(\"chgrp\", file, group, token);\n\t\t\t},\n\t\t\tchmod: function(file, permissions, token) {\n\t\t\t\treturn this._basic_first_op(\"chmod\", file, permissions, token);\n\t\t\t},\n\t\t\tisDirectory: function(key, token) {\n\t\t\t\treturn this._basic_first_op(\"isDirectory\", key, token);\n\t\t\t},\n\t\t\tsync: function(token) {\n\t\t\t\treturn this._every_op(\"sync\", token);\n\t\t\t},\n\t\t\tunmount: function(token) {\n\t\t\t\tif (options.autoManage) return this._every_op(\"unmount\", token);\n\t\t\t},\n\t\t\t_basic_first_op: async function(op, key, ...args) {\n\t\t\t\tlet pathParts = key.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tkey = pathParts.join(\"/\");\n\t\t\t\tlet previousKey = key.split(\"/\").slice(0, -1).join(\"/\");\n\t\t\t\tlet basename = key.split(\"/\").slice(-1).join(\"/\");\n\t\t\t\tlet lookedForMount;\n\t\t\t\tfor (let mount of options.mounts) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet listing = await modules.fs.ls(mount + \"/\" + previousKey, args[args.length - 1]);\n\t\t\t\t\t\tif (listing.includes(basename)) {\n\t\t\t\t\t\t\tlookedForMount = mount;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch {}\n\t\t\t\t}\n\t\t\t\tif (lookedForMount) return modules.fs[op](lookedForMount + \"/\" + key, ...args);\n\t\t\t\tlet commonErrorMessages = {};\n\t\t\t\tfor (let mount of options.mounts) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn await modules.fs[op](mount + \"/\" + key, ...args);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tcommonErrorMessages[e.message] = (commonErrorMessages[e.message] || 0) + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow new Error(Object.entries(commonErrorMessages).sort((a, b) => b[1] - a[1])[0][0]);\n\t\t\t},\n\t\t\t_every_op: async function(op) {\n\t\t\t\tlet commonErrorMessages = {}, gotError;\n\t\t\t\tfor (let mount of options.mounts) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait modules.fs[op](mount);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tgotError = true;\n\t\t\t\t\t\tcommonErrorMessages[e.message] = (commonErrorMessages[e.message] || 0) + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (gotError) throw new Error(Object.entries(commonErrorMessages).sort((a, b) => b[1] - a[1])[0][0]);\n\t\t\t},\n\t\t\tdirectory_supported: true,\n\t\t\tread_only: !!options.read_only,\n\t\t\tfilesystem: \"overlayfs\",\n\t\t\tpermissions_supported: true\n\t\t};\n\t}\n\n\tasync function hostOSMount(options) {\n\t\tlet dirHandle;\n\t\ttry {\n\t\t\tdirHandle = await window.showDirectoryPicker();\n\t\t} catch {\n\t\t\tthrow new Error(\"PERMISSION_DENIED\");\n\t\t}\n\t\tasync function resolvePath(path) {\n\t\t\tlet parts = path.split(\"/\").filter(p => p.length > 0);\n\t\t\tlet currentHandle = dirHandle;\n\t\t\tfor (let part of parts) {\n\t\t\t\ttry {\n\t\t\t\t\tcurrentHandle = await currentHandle.getDirectoryHandle(part);\n\t\t\t\t} catch {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn await currentHandle.getFileHandle(part);\n\t\t\t\t\t} catch {\n\t\t\t\t\t\tthrow new Error(\"NO_SUCH_FILE_DIR\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn currentHandle;\n\t\t}\n\n\t\treturn {\n\t\t\tread: async function(filePath) {\n\t\t\t\tlet handle = await resolvePath(filePath);\n\t\t\t\tif (handle.kind == \"directory\") throw new Error(\"IS_A_DIR\");\n\t\t\t\tlet file = await handle.getFile();\n\t\t\t\treturn await file.text();\n\t\t\t},\n\t\t\twrite: async function(filePath, data) {\n\t\t\t\tlet parts = filePath.split(\"/\").filter(p => p.length > 0);\n\t\t\t\tlet fileName = parts.pop();\n\t\t\t\tlet currentHandle = dirHandle;\n\t\t\t\tfor (let part of parts) currentHandle = await currentHandle.getDirectoryHandle(part);\n\t\t\t\tlet fileHandle = await currentHandle.getFileHandle(fileName, { create: true });\n\t\t\t\tlet writable = await fileHandle.createWritable();\n\t\t\t\tawait writable.write(data);\n\t\t\t\tawait writable.close();\n\t\t\t\treturn true;\n\t\t\t},\n\t\t\trm: async function(path) {\n\t\t\t\tlet parts = path.split(\"/\").filter(p => p.length > 0);\n\t\t\t\tlet targetName = parts.pop();\n\t\t\t\tlet currentHandle = dirHandle;\n\t\t\t\tfor (let part of parts) currentHandle = await currentHandle.getDirectoryHandle(part);\n\t\t\t\tawait currentHandle.removeEntry(targetName);\n\t\t\t\treturn true;\n\t\t\t},\n\t\t\tls: async function(directory) {\n\t\t\t\tlet handle = await resolvePath(directory);\n\t\t\t\tif (handle.kind != \"directory\") throw new Error(\"IS_A_FILE\");\n\t\t\t\tlet entries = [];\n\t\t\t\tfor await (let entry of handle.values()) entries.push(entry.name);\n\t\t\t\treturn entries;\n\t\t\t},\n\t\t\tmkdir: async function(directory) {\n\t\t\t\tlet parts = directory.split(\"/\").filter(p => p.length > 0);\n\t\t\t\tlet currentHandle = dirHandle;\n\t\t\t\tfor (let part of parts) try {\n\t\t\t\t\tcurrentHandle = await currentHandle.getDirectoryHandle(part);\n\t\t\t\t} catch {\n\t\t\t\t\tcurrentHandle = await currentHandle.getDirectoryHandle(part, { create: true });\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t},\n\t\t\tisDirectory: async function(path) {\n\t\t\t\tlet handle = await resolvePath(path);\n\t\t\t\treturn handle.kind == \"directory\";\n\t\t\t},\n\t\t\tsync: () => true,\n\t\t\tunmount: () => true,\n\t\t\tdirectory_supported: true,\n\t\t\tread_only: !!options.read_only,\n\t\t\tfilesystem: \"HostOS\",\n\t\t\tpermissions_supported: false,\n\t\t\t_dirHandle: dirHandle\n\t\t};\n\t}\n\t\n\tfs.mounts[\"ram\"] = ramMount({\n\t\ttype: \"run\"\n\t});\n\tmodules.mounts = {\n\t\tPCFSiDBMount,\n\t\tPCFSiDBAESCryptMount,\n\t\tramMount,\n\t\tpreferenceMount,\n\t\tSFSPMount,\n\t\tIPCMount,\n\t\tfileMount,\n\t\toverlayMount,\n\t\thostOSMount\n\t};\n\tmodules.fs = fs;\n\tmodules.defaultSystem = \"ram\";\n}\n\nloadFs();","5e4273a4b5124a28aa722d5a9ac554369573e0b10a872d6c6685bdca342a83121b51631d91885eeb310a61cf0daf834ad50d18aa8b5a0a96fcd7129a1e16c19b":"async function fsck() {\n\t// @pcos-app-mode native\n\tfunction println(str) {\n\t\tmodules.core.tty_bios_api.println(str);\n\t\treturn new Promise(function(resolve) {\n\t\t\trequestAnimationFrame(resolve);\n\t\t})\n\t}\n\tlet fsckMode;\n\ttry {\n\t\tfsckMode = await modules.fs.read(modules.defaultSystem + \"/.fsck\");\n\t\tawait modules.fs.rm(modules.defaultSystem + \"/.fsck\");\n\t} catch {\n\t\tawait println(\"Skipping file system checking.\");\n\t\treturn;\n\t}\n\tasync function scanLLDA() {\n\t\tlet fs = modules.fs;\n\t\tif (fs.mounts[modules.defaultSystem].read_only) {\n\t\t\tawait println(\"File system is read-only.\");\n\t\t\treturn { lldaPoints: \"abort\", lldaId: \"abort\" };\n\t\t}\n\t\tif (fs.mounts[modules.defaultSystem].partition.getData) {\n\t\t\tlet llda = fs.mounts[modules.defaultSystem].partition.getData().files;\n\t\t\tlet lldaId = fs.mounts[modules.defaultSystem].partition.getData().id;\n\t\t\tllda = Object.values(llda);\n\t\t\twhile (llda.some(a => typeof a === \"object\")) llda = llda.map(a => typeof a === \"object\" ? Object.values(a) : a).flat(); \n\t\t\treturn { lldaPoints: llda, lldaId: lldaId };\n\t\t} else {\n\t\t\tawait println(\"Low-level disk access is impossible.\");\n\t\t\treturn { lldaPoints: \"abort\", lldaId: \"abort\" };\n\t\t}\n\t}\n\tawait println(\"A file system check has been requested.\");\n\tawait println(\"Scanning for file points.\");\n\tlet { lldaPoints, lldaId } = await scanLLDA();\n\tif (lldaPoints === \"abort\") {\n\t\tawait println(\"Skipping file system checking.\");\n\t\treturn;\n\t}\n\tawait println(\"File points found: \" + lldaPoints.length);\n\tawait println(\"Reading indexedDB keys.\");\n\tlet idb_keys = modules.core.idb._db.transaction(\"disk\").objectStore(\"disk\").getAllKeys();\n\tidb_keys = await new Promise(function(resolve) {\n\t\tidb_keys.onsuccess = () => resolve(idb_keys.result);\n\t});\n\tidb_keys.splice(idb_keys.indexOf(\"disk\"), 1);\n\tawait println(\"IndexedDB keys found: \" + idb_keys.length);\n\tawait println(\"Filtering IndexedDB keys...\");\n\tif (fsckMode != \"discard-all\") idb_keys = idb_keys.filter(a => a.startsWith(lldaId + \"-\")).map(a => a.slice(lldaId.length + 1));\n\tawait println(\"Filtered keys: \" + idb_keys.length);\n\tlet missingFiles = idb_keys.filter(a => !lldaPoints.includes(a.slice(fsckMode == \"discard-all\" ? (lldaId + \"-\").length : 0)));\n\tawait println(\"Missing files: \" + missingFiles.length);\n\tlet llda = modules.fs.mounts[modules.defaultSystem].partition.getData();\n\tif (fsckMode == \"recover\") {\n\t\ttry {\n\t\t\tawait modules.fs.mkdir(modules.defaultSystem + \"/lost+found\");\n\t\t\tawait println(\"Created lost+found directory.\");\n\t\t} catch {\n\t\t\tawait println(\"Lost+found directory already exists.\");\n\t\t}\n\t\tfor (let file of missingFiles) {\n\t\t\tawait println(\"Moving \" + file + \" to lost+found.\");\n\t\t\tllda.files[\"lost+found\"][file] = file;\n\t\t}\n\t} else if (fsckMode == \"discard\" || fsckMode == \"discard-all\") {\n\t\tfor (let file of missingFiles) {\n\t\t\tawait println(\"Deleting \" + file + \".\");\n\t\t\tawait modules.core.idb.removePart((fsckMode == \"discard\" ? (lldaId + \"-\") : \"\") + file);\n\t\t}\n\t} else {\n\t\tawait println(\"Unsure what to do, not doing anything.\");\n\t}\n\tawait println(\"Saving modified file table.\");\n\tmodules.fs.mounts[modules.defaultSystem].partition.setData(llda);\n\tawait modules.core.idb.sync();\n\tawait println(\"File system check complete.\");\n}\nawait fsck();","d86b696d9abb61c82f81ec2e6ecfbc88fa72c2cf3dbeb2b5e680cdf32ebca6c1dccd6f1bbd268333a15d077bc490b3994cb2fac1a11232399cf77bbb5aca08b3":"async function loadModules() {\n\tlet hexToU8A = (hex) => Uint8Array.from(hex.match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\tlet khrlSignatures = [];\n\tlet mountpointList = [];\n\tlet module2point = {};\n\tasync function loadKHRL() {\n\t\tlet khrlFiles = await modules.fs.ls(module2point[\"00-keys.fs\"] + \"/etc/keys/khrl\");\n\t\tfor (let khrlFile of khrlFiles) {\n\t\t\tlet khrl = JSON.parse(await modules.fs.read(module2point[\"00-keys.fs\"] + \"/etc/keys/khrl/\" + khrlFile));\n\t\t\tif (await crypto.subtle.verify({ name: \"Ed25519\" }, modules.ksk_imported, hexToU8A(khrl.signature), new TextEncoder().encode(JSON.stringify(khrl.list)))) {\n\t\t\t\tkhrlSignatures.push(...khrl.list);\n\t\t\t}\n\t\t}\n\t}\n\tasync function recursiveKeyVerify(key, khrl) {\n\t\tif (!key) throw new Error(\"NO_KEY\");\n\t\tif (key.keyInfo.dates?.since > Date.now()) throw new Error(\"KEY_NOT_IN_TIME\");\n\t\tif (Date.now() > key.keyInfo.dates?.until) throw new Error(\"KEY_NOT_IN_TIME\");\n\t\tlet u8aToHex = (u8a) => Array.from(u8a).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\tlet hash = u8aToHex(new Uint8Array(await crypto.subtle.digest(\"SHA-256\", new TextEncoder().encode((key.keyInfo.key).x))));\n\t\tlet hexToU8A = (hex) => Uint8Array.from(hex.match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\tif (khrl.includes(hash)) throw new Error(\"KEY_REVOKED\");\n\t\tlet signedByKey = modules.ksk_imported;\n\t\tif (key.keyInfo.signedBy) {\n\t\t\tsignedByKey = JSON.parse(await modules.fs.read(module2point[\"00-keys.fs\"] + \"/etc/keys/\" + key.keyInfo.signedBy));\n\t\t\tif (!signedByKey.keyInfo.usages.includes(\"keyTrust\")) throw new Error(\"NOT_KEY_AUTHORITY\");\n\t\t\tawait recursiveKeyVerify(signedByKey, khrl);\n\t\t\tsignedByKey = await crypto.subtle.importKey(\"jwk\", signedByKey.keyInfo.key, { name: \"Ed25519\" }, false, [\"verify\"]);\n\t\t}\n\t\tif (!await crypto.subtle.verify({ name: \"Ed25519\" }, signedByKey, hexToU8A(key.signature), new TextEncoder().encode(JSON.stringify(key.keyInfo)))) throw new Error(\"KEY_SIGNATURE_VERIFICATION_FAILED\");\n\t\treturn true;\n\t}\n\ttry {\n\t\tlet moduleList = (await modules.fs.ls(modules.defaultSystem + \"/modules\")).sort((a, b) => a.localeCompare(b));\n\t\tfor (let moduleName of moduleList) {\n\t\t\tlet fullModuleFile = {};\n\t\t\ttry {\n\t\t\t\tfullModuleFile = JSON.parse(await modules.fs.read(modules.defaultSystem + \"/modules/\" + moduleName));\n\t\t\t} catch {}\n\t\t\tif (!fullModuleFile.buildInfo) continue;\n\t\t\tlet fullModuleSignature = fullModuleFile.buildInfo.signature;\n\t\t\tdelete fullModuleFile.buildInfo.signature;\n\t\t\tif (moduleName == \"00-keys.fs\") {\n\t\t\t\ttry {\n\t\t\t\t\tfullModuleFile = JSON.stringify(fullModuleFile);\n\t\t\t\t\tif (!(await crypto.subtle.verify({\n\t\t\t\t\t\tname: \"Ed25519\"\n\t\t\t\t\t}, modules.ksk_imported, hexToU8A(fullModuleSignature), new TextEncoder().encode(fullModuleFile)))) throw new Error(\"MODULE_SIGNATURE_VERIFICATION_FAILED\");\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (modules.core.bootMode != \"disable-harden\") await panic(\"KEYS_MODULE_VERIFICATION_FAILED\", {\n\t\t\t\t\t\tname: \"/modules/00-keys.fs\",\n\t\t\t\t\t\tparams: [modules.defaultSystem],\n\t\t\t\t\t\tunderlyingJS: e\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlet critical = fullModuleFile.buildInfo.critical;\n\t\t\t\ttry {\n\t\t\t\t\tlet signingKey = JSON.parse(await modules.fs.read(module2point[\"00-keys.fs\"] + \"/etc/keys/\" + fullModuleFile.buildInfo.signer));\n\t\t\t\t\tawait recursiveKeyVerify(signingKey, khrlSignatures);\n\t\t\t\t\tif (!signingKey.keyInfo.usages.includes(\"moduleTrust\")) throw new Error(\"NOT_MODULE_SIGNING_KEY\");\n\t\t\t\t\tlet importSigningKey = await crypto.subtle.importKey(\"jwk\", signingKey.keyInfo.key, { name: \"Ed25519\" }, false, [\"verify\"]);\n\t\t\t\t\tfullModuleFile = JSON.stringify(fullModuleFile);\n\t\t\t\t\tif (!await crypto.subtle.verify({\n\t\t\t\t\t\tname: \"Ed25519\"\n\t\t\t\t\t}, importSigningKey, hexToU8A(fullModuleSignature), new TextEncoder().encode(fullModuleFile))) throw new Error(\"MODULE_SIGNATURE_VERIFICATION_FAILED\");\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(\"Failed to verify module:\", e);\n\t\t\t\t\tif (critical && modules.core.bootMode != \"disable-harden\") await panic(\"CRITICAL_MODULE_VERIFICATION_FAILED\", {\n\t\t\t\t\t\tname: \"/modules/\" + moduleName,\n\t\t\t\t\t\tparams: [modules.defaultSystem],\n\t\t\t\t\t\tunderlyingJS: e\n\t\t\t\t\t});\n\t\t\t\t\tif (modules.core.bootMode != \"disable-harden\") continue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet mountpoint = \".\" + crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\tmountpointList.push(mountpoint);\n\t\t\tmodule2point[moduleName] = mountpoint;\n\t\t\tmodules.fs.mounts[mountpoint] = await modules.mounts.fileMount({\n\t\t\t\tsrcFile: modules.defaultSystem + \"/modules/\" + moduleName,\n\t\t\t\tread_only: true\n\t\t\t});\n\t\t\tif (moduleName == \"00-keys.fs\") await loadKHRL();\n\t\t\tif (modules.core.bootMode == \"logboot\") modules.core.tty_bios_api.println(\"\\t../modules/\" + moduleName);\n\t\t}\n\t\tmodules.fs.mounts.system = await modules.mounts.overlayMount({\n\t\t\tmounts: [ modules.defaultSystem, ...mountpointList ]\n\t\t});\n\t\tawait modules.fs.write(\"ram/run/moduleSystem.json\", JSON.stringify({\n\t\t\tsystem: [ modules.defaultSystem, ...mountpointList ]\n\t\t}));\n\t\tmodules.defaultSystem = \"system\";\n\t} catch (e) {\n\t\tconsole.error(\"Module system failed:\", e);\n\t}\n}\nawait loadModules();","f6761d3ce5899ce9a66d354627cb50a399a4b8cb5457ca9023c84c20ded708120de10f829234c32a2ba85797ba69d4b3aa816d15d7849a476bfe4d29949af011":"function loadUi() {\n\t// @pcos-app-mode native\n\tlet uiStyle = document.createElement(\"style\");\n\tuiStyle.innerHTML = `body {\n\t\toverflow: hidden;\n\t\tbackground: black;\n\t\tcursor: none;\n\t\tfont-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n\t}\n\n\t.taskbar {\n\t\tbackground: ${modules.core.bootMode == \"safe\" ? \"rgb(128, 128, 128)\" : \"rgba(128, 128, 128, 0.85)\"};\n\t\tpadding: 4px;\n\t\tborder-radius: 4px;\n\t\tdisplay: flex;\n\t\tmargin: 2px;\n\t}\n\n\t.taskbar .clock {\n\t\tmargin-right: 4px;\n\t}\n\n\t.taskbar .icon {\n\t\twidth: 23px;\n\t\theight: 23px;\n\t\tbackground-size: contain;\n\t\tbackground-repeat: no-repeat;\n\t\tmargin: 0 2px;\n\t\tdisplay: inline-block;\n\t}\n\t\n\t.taskbar .tbicons {\n\t\tdisplay: flex;\n\t}\n\n\t.filler {\n\t\tflex: 1;\n\t}\n\t\n\t.desktop {\n\t\tposition: relative;\n\t\tflex: 1;\n\t}\n\n\t.window {\n\t\tposition: absolute;\n\t\ttop: 50%;\n\t\tleft: 50%;\n\t\ttransform: translate(-50%, -50%);\n\t\tbackground-color: ${modules.core.bootMode == \"safe\" ? \"rgb(240, 240, 240)\" : \"rgba(240, 240, 240, 0.5)\"};\n\t\tborder: 1px solid #ccc;\n\t\tbox-shadow: ${modules.core.bootMode == \"safe\" ? \"none\" : \"0 0 5px rgba(0, 0, 0, 0.3)\"};\n\t\tz-index: 1;\n\t\tresize: both;\n\t\twidth: 320px;\n\t\theight: 180px;\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t\toverflow: auto;\n\t\tbackdrop-filter: ${modules.core.bootMode == \"safe\" ? \"none\" : \"blur(8px)\"};\n\t\tanimation: ${modules.core.bootMode == \"safe\" ? \"none\" : \"fade-in 0.1s ease-in forwards\"};\n\t\tborder-radius: 4px;\n\t}\n\n\n\t.window.icon {\n\t\ttop: 72px;\n\t\tleft: 72px;\n\t\tresize: none;\n\t\twidth: 128px;\n\t\theight: 128px;\n\t}\n\n\t.window.dark {\n\t\tbackground-color: ${modules.core.bootMode == \"safe\" ? \"rgb(55, 55, 55)\" : \"rgba(55, 55, 55, 0.5)\"};\n\t\tcolor: white;\n\t\tborder: 1px solid #1b1b1b;\n\t}\n\n\t.window .title-bar {\n\t\tpadding: 6px;\n\t\tbackground-color: ${modules.core.bootMode == \"safe\" ? \"rgb(204, 204, 204)\" : \"rgba(204, 204, 204, 0.5)\"};\n\t\tcursor: move;\n\t\tdisplay: flex;\n\t\tflex: 1;\n\t\tuser-select: none;\n\t}\n\n\t.window.dark .title-bar {\n\t\tbackground-color: ${modules.core.bootMode == \"safe\" ? \"rgb(27, 27, 27)\" : \"rgba(27, 27, 27, 0.5)\"};\n\t}\n\n\t.window .button {\n\t\tcursor: pointer;\n\t\tpadding: 4px;\n\t\tborder: none;\n\t\tflex: 1;\n\t\tmargin: 0 0 0 2px;\n\t\tborder-radius: 4px;\n\t}\n\n\t.window .button:hover {\n\t\topacity: 75%;\n\t}\n\n\t.window .close-button {\n\t\tbackground: red;\n\t\tcolor: white;\n\t}\n\n\t.window .title-displayer {\n\t\tflex: 100;\n\t}\n\n\t.window .close-button:disabled {\n\t\topacity: 25%;\n\t}\n\n\t.window.fullscreen .resize-handle {\n\t\tdisplay: none;\n\t}\n\n\t.window.fullscreen {\n\t\twidth: 100% !important;\n\t\theight: 100% !important;\n\t\ttop: 0 !important;\n\t\tleft: 0 !important;\n\t\ttransform: none;\n\t\tresize: none;\n\t\tborder: none;\n\t\tbox-shadow: none;\n\t}\n\n\t.window.fullscreen .title-bar {\n\t\tcursor: default;\n\t}\n\n\t.window .content {\n\t\tflex: 100;\n\t\toverflow: auto;\n\t\tposition: relative;\n\t\tbackground-color: #f0f0f0;\n\t}\n\n\t.window.dark .content {\n\t\tbackground-color: #373737;\n\t}\n\n\t.session {\n\t\tposition: fixed;\n\t\ttop: 0;\n\t\tleft: 0;\n\t\twidth: 100%;\n\t\theight: 100%;\n\t\tbackground: black;\n\t\tcursor: default;\n\t\tanimation: ${modules.core.bootMode == \"safe\" ? \"none\" : \"fade-in 0.1s ease-in forwards\"};\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t}\n\n\t.session.secure {\n\t\tbackground: none${modules.core.bootMode == \"safe\" ? \" !important\" : \"\"};\n\t\tbackdrop-filter: ${modules.core.bootMode == \"safe\" ? \"none\" : \"blur(8px) brightness(50%)\"};\n\t\tanimation: ${modules.core.bootMode == \"safe\" ? \"none\" : \"fade 0.1s ease-out forwards\"};\n\t\tz-index: -1;\n\t}\n\n\t.hidden {\n\t\tdisplay: none;\n\t}\n\t\n\t@keyframes fade-in {\n\t\t0% {\n\t\t\topacity: 0;\n\t\t}\n\n\t\t100% {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\n\t@keyframes fade {\n\t\t0% {\n\t\t\tbackdrop-filter: blur(0px) brightness(100%);\n\t\t}\n\n\t\t100% {\n\t\t\tbackdrop-filter: blur(8px) brightness(50%);\n\t\t}\n\t}\n\t\n\t.warning {\n\t\tposition: absolute;\n\t\ttop: 8px;\n\t\tright: 8px;\n\t\tbackground: #2a2a2a;\n\t\tcolor: white;\n\t\tborder-radius: 4px;\n\t\topacity: 60%;\n\t\tpointer-events: none;\n\t\tuser-select: none;\n\t\tpadding: 8px;\n\t\tz-index: 256;\n\t}`;\n\tdocument.head.appendChild(uiStyle);\n\n\tfunction createWindow(sessionId, makeFullscreenOnAllScreens, asIconWindow, reportMovement) {\n\t\tlet fullscreen = makeFullscreenOnAllScreens || matchMedia(\"(max-width: 600px)\").matches;\n\t\tif (asIconWindow) fullscreen = false;\n\t\tlet id = crypto.getRandomValues(new Uint8Array(64)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\tlet windowDiv = document.createElement('div');\n\t\twindowDiv.className = 'window ' + (fullscreen ? \"fullscreen \" : \"\") + \" \" + (asIconWindow ? \"icon\" : \"\");\n\t\tif (session.attrib(sessionId, \"dark\")) windowDiv.classList.add(\"dark\");\n\t\twindowDiv.id = 'window-' + id;\n\t\tlet titleBar = document.createElement('div');\n\t\ttitleBar.className = 'title-bar';\n\t\tlet title = document.createElement('span');\n\t\ttitle.className = 'title-displayer';\n\t\tlet closeButton = document.createElement('button');\n\t\tcloseButton.className = 'button close-button';\n\t\tcloseButton.innerHTML = '&#10005;';\n\t\ttitleBar.appendChild(title);\n\t\tif (!fullscreen && !asIconWindow) {\n\t\t\tlet fullscreenButton = document.createElement('button');\n\t\t\tfullscreenButton.className = 'button';\n\t\t\tfullscreenButton.innerHTML = '&#x25a1;';\n\t\t\tfullscreenButton.onclick = function() {\n\t\t\t\twindowDiv.classList.toggle(\"fullscreen\");\n\t\t\t}\n\t\t\ttitleBar.appendChild(fullscreenButton);\n\t\t}\n\t\tif (!asIconWindow) titleBar.appendChild(closeButton);\n\t\twindowDiv.appendChild(titleBar);\n\t\tlet content = document.createElement('div');\n\t\tcontent.className = 'content';\n\t\twindowDiv.appendChild(content);\n\t\tsession.tracker[sessionId].extendedHTML.desktop.appendChild(windowDiv);\n\t\tif (!asIconWindow) {\n\t\t\tlet openWins = session.attrib(sessionId, \"openWins\") || [];\n\t\t\topenWins = openWins.filter(a => a.parentElement).sort((a, b) => a.style.zIndex - b.style.zIndex);\n\t\t\topenWins.map((a, i) => a.style.zIndex = i);\n\t\t\twindowDiv.style.zIndex = openWins.length;\n\t\t\topenWins.push(windowDiv);\n\t\t\tsession.attrib(sessionId, \"openWins\", openWins);\n\t\t} else windowDiv.style.zIndex = \"0\";\n\t\tif (!fullscreen) makeDraggable(windowDiv, titleBar, reportMovement, asIconWindow ? false : sessionId);\n\t\treturn {\n\t\t\twindowDiv,\n\t\t\ttitle,\n\t\t\tcloseButton,\n\t\t\tcontent,\n\t\t\tsessionId\n\t\t};\n\t}\n\n\tfunction makeDraggable(windowDiv, titleBar, reportMovement, sessionId) {\n\t\tlet pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;\n\n\t\ttitleBar.onmousedown = dragMouseDown;\n\t\ttitleBar.ontouchstart = dragMouseDown;\n\n\t\tfunction dragMouseDown(e) {\n\t\t\tif (e.type != \"touchstart\") e.preventDefault();\n\t\t\tif (e.type == \"touchstart\") e = e.touches[0];\n\t\t\tpos3 = e.clientX;\n\t\t\tpos4 = e.clientY;\n\n\t\t\tif (sessionId) {\n\t\t\t\tlet openWins = session.attrib(sessionId, \"openWins\") || [];\n\t\t\t\twindowDiv.style.zIndex = openWins.length;\n\t\t\t\topenWins = openWins.filter(a => a.parentElement).sort((a, b) => a.style.zIndex - b.style.zIndex);\n\t\t\t\topenWins.map((a, i) => a.style.zIndex = i);\n\t\t\t\tsession.attrib(sessionId, \"openWins\", openWins);\n\t\t\t}\n\n\t\t\tdocument.onmouseup = closeDragElement;\n\t\t\tdocument.ontouchend = closeDragElement;\n\t\t\tdocument.ontouchcancel = closeDragElement;\n\t\t\tdocument.onmousemove = elementDrag;\n\t\t\tdocument.ontouchmove = elementDrag;\n\t\t}\n\n\t\tfunction elementDrag(e) {\n\t\t\te.preventDefault();\n\t\t\tif (e.type == \"touchmove\") e = e.touches[0];\n\t\t\tpos1 = pos3 - e.clientX;\n\t\t\tpos2 = pos4 - e.clientY;\n\t\t\tpos3 = e.clientX;\n\t\t\tpos4 = e.clientY;\n\n\t\t\tif (!windowDiv.classList.contains(\"fullscreen\")) {\n\t\t\t\tif (reportMovement) reportMovement(windowDiv.offsetLeft - pos1, windowDiv.offsetTop - pos2);\n\t\t\t\twindowDiv.style.top = windowDiv.offsetTop - pos2 + 'px';\n\t\t\t\twindowDiv.style.left = windowDiv.offsetLeft - pos1 + 'px';\n\t\t\t}\n\t\t}\n\n\t\tfunction closeDragElement() {\n\t\t\tdocument.onmouseup = null;\n\t\t\tdocument.ontouchend = null;\n\t\t\tdocument.ontouchcancel = null;\n\t\t\tdocument.onmousemove = null;\n\t\t\tdocument.ontouchmove = null;\n\t\t}\n\t}\n\n\tlet session = {\n\t\tmksession: function() {\n\t\t\tif (modules.shuttingDown) throw new Error(\"SYSTEM_SHUTDOWN_REQUESTED\");\n\t\t\tlet identifier = crypto.getRandomValues(new Uint8Array(64)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\tlet sessionDiv = document.createElement(\"div\");\n\t\t\tlet desktop = document.createElement(\"div\");\n\t\t\tlet taskbar = document.createElement(\"div\");\n\t\t\tlet startButton = document.createElement(\"button\");\n\t\t\tlet taskList = document.createElement(\"div\");\n\t\t\tlet filler = document.createElement(\"div\");\n\t\t\tlet icons = document.createElement(\"div\");\n\t\t\tlet clock = document.createElement(\"div\");\n\n\t\t\tsessionDiv.className = \"session hidden\";\n\t\t\tdesktop.className = \"desktop\";\n\t\t\ttaskbar.className = \"taskbar\";\n\t\t\ticons.className = \"tbicons\";\n\t\t\tfiller.className = \"filler\";\n\t\t\tstartButton.disabled = true;\n\n\t\t\ttaskbar.append(startButton, taskList, filler, icons, clock);\n\t\t\tsessionDiv.append(desktop, taskbar);\n\t\t\tdocument.body.appendChild(sessionDiv);\n\n\t\t\tlet clockToggled = false;\n\t\t\tclock.addEventListener(\"click\", _ => clockToggled = !clockToggled);\n\t\t\tlet updateTaskbar = () => {\n\t\t\t\tif (!sessionDiv.parentElement) return;\n\t\t\t\tlet locale = session.tracker[identifier].attrib.language || modules.locales?.defaultLocale || \"en\";\n\t\t\t\tlet clockLocale = modules.locales?.get(\"OS_LOCALE\", locale)?.replace(\"OS_LOCALE\", \"\") || undefined;\n\t\t\t\tstartButton.innerText = modules.locales?.get(\"START_MENU_BTN\", locale);\n\t\t\t\tclock.innerText = Intl.DateTimeFormat(clockLocale, { timeStyle: clockToggled ? undefined : \"medium\" }).format();\n\t\t\t\tsetTimeout(updateTaskbar, 500);\n\t\t\t};\n\n\t\t\tif ([ \"safe\", \"disable-harden\" ].includes(modules.core.bootMode)) {\n\t\t\t\tlet warning = document.createElement(\"span\");\n\t\t\t\twarning.className = \"warning\";\n\t\t\t\tif (modules.core.bootMode == \"disable-harden\") {\n\t\t\t\t\twarning.innerText = modules.locales?.get(\"INSECURE_MODE_MSG\") || \"Reduced security!\";\n\t\t\t\t\twarning.style.background = \"#7f0000\";\n\t\t\t\t} else if (modules.core.bootMode == \"safe\") warning.innerText = modules.locales?.get(\"SAFE_MODE_MSG\") || \"Safe mode\";\n\t\t\t\tsessionDiv.appendChild(warning);\n\t\t\t}\n\n\t\t\tthis.tracker[identifier] = {\n\t\t\t\thtml: sessionDiv,\n\t\t\t\textendedHTML: { desktop, taskbar, startButton, taskList, filler, icons, clock },\n\t\t\t\tattrib: {}\n\t\t\t};\n\t\t\tupdateTaskbar();\n\n\t\t\treturn identifier;\n\t\t},\n\t\trmsession: function(session) {\n\t\t\tthis.tracker[session].html.remove();\n\t\t\tdelete this.tracker[session];\n\t\t},\n\t\tmuteAllSessions: function() {\n\t\t\tfor (let session in this.tracker) this.tracker[session].html.classList.add(\"hidden\");\n\t\t\tthis.active = null;\n\t\t},\n\t\tactivateSession: function(session) {\n\t\t\tthis.tracker[this.active]?.html?.classList?.add(\"hidden\");\n\t\t\tthis.tracker[session].html.classList.remove(\"hidden\");\n\t\t\tthis.active = session;\n\t\t},\n\t\tattrib: function(session, key, val) {\n\t\t\tif (val !== undefined) this.tracker[session].attrib[key] = val;\n\t\t\tif (key !== undefined) return this.tracker[session].attrib[key];\n\t\t\treturn this.tracker[session].attrib;\n\t\t},\n\t\tdestroy: function() {\n\t\t\tfor (let session in this.tracker) this.rmsession(session);\n\t\t\tthis.tracker = {};\n\t\t\tdelete this.systemSession;\n\t\t\tdelete modules.liu;\n\t\t\tdelete modules.serviceSession;\n\t\t\tuiStyle.remove();\n\t\t\tdelete modules.uiStyle;\n\t\t},\n\t\ttracker: {},\n\t\tactive: null\n\t}\n\n\tmodules.window = createWindow;\n\tmodules.session = session;\n\tmodules.uiStyle = uiStyle;\n\n\tmodules.session.systemSession = session.mksession();\n\tsession.muteAllSessions();\n\tsession.activateSession(modules.session.systemSession);\n\tmodules.startupWindow = modules.window(modules.session.systemSession);\n\tmodules.startupWindowProgress = document.createElement(\"progress\");\n\tmodules.startupWindow.title.innerText = \"PCOS 3\";\n\tmodules.startupWindow.content.style.padding = \"8px\";\n\tmodules.startupWindow.closeButton.classList.toggle(\"hidden\", true);\n\tmodules.startupWindow.content.innerText = \"PCOS is starting...\";\n\tmodules.startupWindow.content.appendChild(document.createElement(\"br\"));\n\tmodules.startupWindow.content.appendChild(modules.startupWindowProgress);\n}\n\nloadUi();","a95238a321eb52b2b138d2ab2e6c834e832398d84f262a7ca4c00902edfac5edc9e559f7cb297b8177e189fe49e76aa5907ca5b4b9f47ecae9c1e35fdccc355c":"function loadIpc() {\n\t// @pcos-app-mode native\n\tmodules.ipc = {\n\t\tcreate: function() {\n\t\t\tlet id = crypto.getRandomValues(new Uint8Array(64)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\tthis._ipc[id] = { owner: \"root\", group: \"root\", world: false, _listeners: [] };\n\t\t\treturn id;\n\t\t},\n\t\tdeclareAccess: function(id, access) {\n\t\t\tthis._ipc[id] = { ...this._ipc[id], ...access };\n\t\t},\n\t\tlistenFor: function(id) {\n\t\t\tlet thatIPC = this._ipc;\n\t\t\treturn new Promise(function(resolve) {\n\t\t\t\tlet hasResolved = false;\n\t\t\t\treturn thatIPC[id]._listeners.push(function e(d) {\n\t\t\t\t\tif (hasResolved) return;\n\t\t\t\t\thasResolved = true;\n\t\t\t\t\treturn resolve(d);\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\t\tsend: function(id, data) {\n\t\t\ttry {\n\t\t\t\tthis._ipc[id]._listeners.forEach(listener => listener(data));\n\t\t\t} catch {}\n\t\t},\n\t\tgetIPC: function(id) {\n\t\t\tlet ipc = { ...this._ipc[id] };\n\t\t\tipc._listeners = ipc._listeners.length;\n\t\t\treturn ipc;\n\t\t},\n\t\t_ipc: {}\n\t}\n}\nloadIpc();","acd051885a9d2fd67087dd1e6ae5387aa4f4a2e93948bc721d75960c30ee7eb3be9301db71a2be82561ad858f0f48bcef1a3aad425f5c2f7cd70799cc1f8f371":"function loadWebsocketSupport() {\n\tlet websocketAPI = {\n\t\tgetHandle: function(url) {\n\t\t\tlet handle = Array.from(crypto.getRandomValues(new Uint8Array(64))).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\tlet websocket = new WebSocket(url);\n\t\t\twebsocket.binaryType = \"arraybuffer\";\n\t\t\twebsocketAPI._handles[handle] = {\n\t\t\t\tws: websocket,\n\t\t\t\tacl: {\n\t\t\t\t\towner: handle.slice(0, 16),\n\t\t\t\t\tgroup: handle.slice(0, 16),\n\t\t\t\t\tworld: true\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn handle;\n\t\t},\n\t\tsend: (arg) => websocketAPI._handles[arg.handle].ws.send(arg.data),\n\t\tclose: function(handle) {\n\t\t\tif (websocketAPI._handles.hasOwnProperty(handle)) websocketAPI._handles[handle].ws.close();\n\t\t\tdelete websocketAPI._handles[handle];\n\t\t},\n\t\tgetInfo: function(handle) {\n\t\t\treturn {\n\t\t\t\tbufferedAmount: websocketAPI._handles[handle].ws.bufferedAmount,\n\t\t\t\textensions: websocketAPI._handles[handle].ws.extensions,\n\t\t\t\tprotocol: websocketAPI._handles[handle].ws.protocol,\n\t\t\t\treadyState: websocketAPI._handles[handle].ws.readyState,\n\t\t\t\turl: websocketAPI._handles[handle].ws.url\n\t\t\t}\n\t\t},\n\t\twaitForEvent: function(arg) {\n\t\t\treturn new Promise(function(resolve) {\n\t\t\t\twebsocketAPI._handles[arg.handle].ws.addEventListener(arg.eventName, function meName(arg2) {\n\t\t\t\t\tif (arg.eventName == \"message\") resolve(arg2.data);\n\t\t\t\t\telse if (arg.eventName == \"error\") resolve({\n\t\t\t\t\t\tcode: arg2.code,\n\t\t\t\t\t\treason: arg2.reason,\n\t\t\t\t\t\twasClean: arg2.wasClean\n\t\t\t\t\t});\n\t\t\t\t\telse resolve(arg.eventName);\n\t\t\t\t\ttry {\n\t\t\t\t\t\twebsocketAPI._handles[arg.handle].ws.removeEventListener(arg.eventName, meName);\n\t\t\t\t\t} catch {}\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\t\tassertAccess: function(arg) {\n\t\t\tif (arg.newACL) websocketAPI._handles[arg.handle].acl = arg.newACL;\n\t\t\treturn websocketAPI._handles[arg.handle].acl;\n\t\t},\n\t\twebsocketState: (handle) => websocketAPI._handles[handle].ws.readyState,\n\t\t_handles: {}\n\t}\n\tmodules.websocket = websocketAPI;\n}\n\nloadWebsocketSupport();","d68ccb58bb95628dd5f222979a1a49f2c4c1ddde14880551ac2787803c151fddd461f89ded1ee0534f6fb26b659bd40d34ff843625e8f3a2f7fe6be8b5bf9a5e":"function loadLull() {\n\tlet lullSession;\n\tmodules.lull = function() {\n\t\tif (lullSession) return;\n\t\tlet style = document.createElement(\"style\");\n\t\tstyle.innerHTML = `* { cursor: none !important; }\n\t\t.taskbar { display: none !important; }\n\t\t.warning { display: none !important; }`;\n\t\tdocument.head.appendChild(style);\n\t\tlullSession = modules.session.mksession();\n\t\tmodules.session.muteAllSessions();\n\t\tmodules.session.activateSession(lullSession);\n\t\tfunction wake() {\n\t\t\tremoveEventListener(\"mousemove\", wake);\n\t\t\tremoveEventListener(\"click\", wake);\n\t\t\tremoveEventListener(\"keydown\", wake);\n\t\t\tstyle.remove();\n\t\t\tmodules.session.muteAllSessions();\n\t\t\tmodules.session.activateSession(modules.session.systemSession);\n\t\t\tmodules.session.rmsession(lullSession);\n\t\t\tlullSession = null;\n\t\t}\n\t\taddEventListener(\"mousemove\", wake);\n\t\taddEventListener(\"click\", wake);\n\t\taddEventListener(\"keydown\", wake);\n\t}\n}\nloadLull();","10d8259d75df6d9d7ab9dd45a0730d732c99bace58f0e99830519f27c372c87ca8d3ede6c77fe162d0982e486b8761ca048701affae925ad94f4a7cdc38acfec":"async function networkd() {\n\tlet u8aToHex = (u8a) => Array.from(u8a).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\tmodules.network = { connected: false, address: null, ws: null, runOnClose: Promise.resolve(), _runOnClose: _ => 1 };\n\ttry {\n\t\tlet config = await modules.fs.read(modules.defaultSystem + \"/etc/network.json\");\n\t\tconfig = JSON.parse(config);\n\t\tmodules.network.reloadConfig = async function() {\n\t\t\tconfig = JSON.parse(await modules.fs.read(modules.defaultSystem + \"/etc/network.json\"));\n\t\t\tmodules.network.updates = config.updates;\n\t\t\ttry {\n\t\t\t\tws.close();\n\t\t\t} catch {\n\t\t\t\tonclose();\n\t\t\t}\n\t\t}\n\t\tmodules.network.updates = config.updates;\n\t\tlet pukey = (modules.core.prefs.read(\"system_id\") || {}).public;\n\t\tlet importedKey = await crypto.subtle.importKey(\"jwk\", (modules.core.prefs.read(\"system_id\") || {}).private, { name: \"Ed25519\" }, true, [\"sign\"]);\n\t\tlet ws = new WebSocket(config.url);\n\t\tws.binaryType = \"arraybuffer\";\n\t\tlet handle = Array.from(crypto.getRandomValues(new Uint8Array(64))).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\tlet gateway;\n\t\tlet systemIDEncode = sysIDc => Uint8Array.from(atob(sysIDc.replaceAll(\"-\", \"+\").replaceAll(\"_\", \"/\")).split(\"\").map(a => a.charCodeAt()));\n\t\tmodules.network.runOnClose = new Promise(a => modules.network._runOnClose = a);\n\t\tasync function onclose() {\n\t\t\ttry {\n\t\t\t\tws.close();\n\t\t\t} catch {}\n\t\t\tmodules.network.connected = false;\n\t\t\tmodules.network.address = null;\n\t\t\tmodules.network.hostname = null;\n\t\t\tmodules.network.ws = null;\n\t\t\tmodules.network._runOnClose();\n\t\t\tws = new WebSocket(config.url);\n\t\t\tws.binaryType = \"arraybuffer\";\n\t\t\tws.onmessage = onmessage;\n\t\t\tws.onclose = onclose;\n\t\t\tmodules.network.runOnClose = new Promise(a => modules.network._runOnClose = a);\n\t\t}\n\t\tfunction completeConnection(messageData) {\n\t\t\tmodules.websocket._handles[handle] = {\n\t\t\t\tws: ws,\n\t\t\t\tacl: {\n\t\t\t\t\towner: handle.slice(0, 16),\n\t\t\t\t\tgroup: handle.slice(0, 16),\n\t\t\t\t\tworld: true\n\t\t\t\t}\n\t\t\t}\n\t\t\tmodules.network.connected = true;\n\t\t\tmodules.network.address = u8aToHex(messageData.slice(16, 32));\n\t\t\tmodules.network.hostname = new TextDecoder().decode(messageData.slice(53, 53 + messageData[52]));\n\t\t\tmodules.network.ws = handle;\n\t\t}\n\t\tasync function onmessage(e) {\n\t\t\tlet messageData = new Uint8Array(e.data);\n\t\t\tif (messageData[48] == 0 && !modules.network.connected) { // Control protocol\n\t\t\t\tif (messageData[49] == 0) { // Connected\n\t\t\t\t\tgateway = messageData.slice(0, 16);\n\t\t\t\t\tif (messageData[50] == 1) { // Public key authentication\n\t\t\t\t\t\tlet hostname = new TextEncoder().encode(config.hostname || \"\");\n\t\t\t\t\t\tif (hostname.length > 255) hostname = hostname.slice(0, 255);\n\t\t\t\t\t\tlet replyPacket = new Uint8Array(87 + hostname.length);\n\t\t\t\t\t\treplyPacket.set(messageData.slice(16, 32), 0);\n\t\t\t\t\t\treplyPacket.set(gateway, 16);\n\t\t\t\t\t\treplyPacket.set(messageData.slice(32, 48), 32);\n\t\t\t\t\t\treplyPacket.set(Uint8Array.from([ 0, 3 ]), 48); // Control Protocol; send public key\n\t\t\t\t\t\treplyPacket.set(systemIDEncode(pukey.x), 50);\n\t\t\t\t\t\treplyPacket.set(Uint8Array.from([ config.ucBits >>> 24 & 255, config.ucBits >>> 16 & 255, config.ucBits >>> 8 & 255, config.ucBits & 255 ]), 82);\n\t\t\t\t\t\treplyPacket.set(Uint8Array.from([ hostname.length ]), 86);\n\t\t\t\t\t\treplyPacket.set(hostname, 87);\n\t\t\t\t\t\tws.send(replyPacket);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcompleteConnection(messageData);\n\t\t\t\t\t}\n\t\t\t\t} else if (messageData[49] == 1) { // Auth failed\n\t\t\t\t\tonclose = null;\n\t\t\t\t\tws.close();\n\t\t\t\t\tmodules.network._runOnClose();\n\t\t\t\t\tmodules.core.tty_bios_api.println(\"network: invalid System ID data\");\n\t\t\t\t} else if (messageData[49] == 2) { // Signature request\n\t\t\t\t\tlet replyPacket = new Uint8Array(114);\n\t\t\t\t\treplyPacket.set(messageData.slice(16, 32), 0);\n\t\t\t\t\treplyPacket.set(gateway, 16);\n\t\t\t\t\treplyPacket.set(messageData.slice(32, 48), 32);\n\t\t\t\t\treplyPacket.set(Uint8Array.from([ 0, 4 ]), 48); // Control Protocol; send signature\n\t\t\t\t\treplyPacket.set(new Uint8Array(await crypto.subtle.sign({ name: \"Ed25519\" }, importedKey, messageData.slice(50, 82))), 50);\n\t\t\t\t\tws.send(replyPacket);\n\t\t\t\t} else if (messageData[49] == 6) { // Address conflict\n\t\t\t\t\tconfig.ucBits = Math.floor(Math.random() * (2 ** 32));\n\t\t\t\t\tws.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (messageData[48] == 1 && messageData[49] == 0) { // Ping Protocol; not a pong\n\t\t\t\tlet replyPacket = new Uint8Array(114);\n\t\t\t\treplyPacket.set(messageData.slice(16, 32), 0);\n\t\t\t\treplyPacket.set(messageData.slice(0, 16), 16);\n\t\t\t\treplyPacket.set(messageData.slice(32, 48), 32);\n\t\t\t\treplyPacket.set(Uint8Array.from([ 1, 255 ]), 48); // Ping Protocol; is a pong\n\t\t\t\treplyPacket.set(messageData.slice(50, 114), 50);\n\t\t\t\tws.send(replyPacket);\n\t\t\t}\n\t\t}\n\t\tws.onmessage = onmessage;\n\t\tws.onclose = onclose;\n\t} catch {\n\t\tmodules.network.serviceStopped = true;\n\t\tmodules.core.tty_bios_api.println(\"network: not starting network\");\n\t}\n}\nnetworkd();","19e6582838471318c6c625e64004a3a9ce845dd71d63d97a0de42e67906dfba2f1dda31d9a4bc153d18e77cea7866d0a7c855edd78d434c8d3eaedb67316acca":"function reeAPIs() {\n\t// @pcos-app-mode native\n\n\tasync function denyUnmanifested(list, token) {\n\t\tlet privileges = (await modules.tokens.info(token)).privileges;\n\t\tlet isAllowlist = list.some(a => a.lineType == \"allow\");\n\t\tif (isAllowlist) list = list.filter(a => a.lineType == \"allow\");\n\t\tlet disallowedRegistry = [];\n\t\tfor (let privilege of privileges) {\n\t\t\tif ((!list.some(x => x.data == privilege && x.lineType == \"allow\") && isAllowlist) || list.some(x => x.data == privilege && x.lineType == \"deny\")) {\n\t\t\t\tprivileges = privileges.filter(x => x != privilege);\n\t\t\t\tdisallowedRegistry.push(privilege);\n\t\t\t}\n\t\t}\n\t\tmodules.tokens.removePrivileges(token, disallowedRegistry);\n\t\treturn privileges;\n\t}\n\n\tmodules.reeAPIInstance = async function(opts) {\n\t\tlet {ree, ses, token, taskId, limitations, privateData} = opts;\n\t\tlet processToken = token;\n\t\tlet tokenInfo = await modules.tokens.info(token);\n\t\tlet user = tokenInfo.user;\n\t\tlet groups = tokenInfo.groups || [];\n\t\tlet privileges = tokenInfo.privileges;\n\t\tlet processPipes = [];\n\t\tlet websockets = [];\n\t\tlet automatedLogonSessions = {};\n\t\tlet networkListens = {};\n\t\tlet connections = {};\n\t\tlet language = modules.session.attrib(ses, \"language\") || undefined;\n\t\tlet hexToU8A = (hex) => Uint8Array.from(hex.match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\tlet u8aToHex = (u8a) => Array.from(u8a).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\tprivileges = await denyUnmanifested(limitations, token);\n\n\t\tasync function fs_action(action, privilegeCheck, path, ...xtra) {\n\t\t\tlet fsPermissions;\n\t\t\ttry {\n\t\t\t\tfsPermissions = await modules.fs.permissions(path);\n\t\t\t} catch (e) {\n\t\t\t\tif (e.name == \"Error\") throw e;\n\t\t\t\tthrow new Error(\"FS_ACTION_FAILED\");\n\t\t\t}\n\t\t\tif (!privilegeCheck(fsPermissions)) throw new Error(\"PERMISSION_DENIED\");\n\t\t\ttry {\n\t\t\t\tlet response = await modules.fs[action](path, ...xtra);\n\t\t\t\treturn response;\n\t\t\t} catch (e) {\n\t\t\t\tif (e.name == \"Error\") throw e;\n\t\t\t\tthrow new Error(\"FS_ACTION_FAILED\");\n\t\t\t}\n\t\t}\n\t\tasync function recursiveKeyVerify(key, khrl) {\n\t\t\tif (!key) throw new Error(\"NO_KEY\");\n\t\t\tif (key.keyInfo.dates?.since > Date.now()) throw new Error(\"KEY_NOT_IN_TIME\");\n\t\t\tif (Date.now() > key.keyInfo.dates?.until) throw new Error(\"KEY_NOT_IN_TIME\");\n\t\t\tlet hash = u8aToHex(new Uint8Array(await crypto.subtle.digest(\"SHA-256\", new TextEncoder().encode((key.keyInfo.key).x))));\n\t\t\tif (khrl.includes(hash)) throw new Error(\"KEY_REVOKED\");\n\t\t\tlet signedByKey = modules.ksk_imported;\n\t\t\tif (key.keyInfo.signedBy) {\n\t\t\t\tsignedByKey = JSON.parse(await modules.fs.read(modules.defaultSystem + \"/etc/keys/\" + key.keyInfo.signedBy, token));\n\t\t\t\tif (!signedByKey.keyInfo.usages.includes(\"keyTrust\")) throw new Error(\"NOT_KEY_AUTHORITY\");\n\t\t\t\tawait recursiveKeyVerify(signedByKey, khrl);\n\t\t\t\tsignedByKey = await crypto.subtle.importKey(\"jwk\", signedByKey.keyInfo.key, { name: \"Ed25519\" }, false, [\"verify\"]);\n\t\t\t}\n\t\t\tif (!await crypto.subtle.verify({ name: \"Ed25519\" }, signedByKey, hexToU8A(key.signature), new TextEncoder().encode(JSON.stringify(key.keyInfo)))) throw new Error(\"KEY_SIGNATURE_VERIFICATION_FAILED\");\n\t\t\treturn true;\n\t\t}\n\n\t\tasync function connfulConnect(connOpts) {\n\t\t\tlet { address, gate, key, private: privateKey, doNotVerifyServer, verifyByDomain } = connOpts;\n\t\t\tlet string_gate = gate;\n\t\t\tgate = new TextEncoder().encode(gate);\n\t\t\tif (gate.length < 1 || gate.length > 255) throw new Error(\"INVALID_GATE_PARAMETER\");\n\t\t\tlet websocketHandle = modules.network.ws;\n\t\t\tif (!websocketHandle) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\tlet websocket = modules.websocket._handles[websocketHandle].ws;\n\t\t\tif (websocket.readyState != 1) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\tlet networkListenID = Array.from(crypto.getRandomValues(new Uint8Array(64))).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\tlet packetConnectionID = crypto.getRandomValues(new Uint8Array(16)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\tlet newKeyKA, exportedKA;\n\t\t\tif (!key && !privateKey) {\n\t\t\t\tnewKeyKA = await crypto.subtle.generateKey({ name: \"Ed25519\" }, true, [\"sign\", \"verify\"]);\n\t\t\t\texportedKA = await crypto.subtle.exportKey(\"jwk\", newKeyKA.publicKey);\n\t\t\t\texportedKA = {\n\t\t\t\t\tkeyInfo: {\n\t\t\t\t\t\tusages: [\n\t\t\t\t\t\t\t\"connfulSecureClient:\" + modules.network.address,\n\t\t\t\t\t\t\t\"connfulSecureClient:\" + modules.network.address + \":\" + string_gate\n\t\t\t\t\t\t], key: exportedKA\n\t\t\t\t\t}, signature: null\n\t\t\t\t};\n\t\t\t\tnewKeyKA = newKeyKA.privateKey;\n\t\t\t} else {\n\t\t\t\tnewKeyKA = await crypto.subtle.importKey(\"jwk\", privateKey, { name: \"Ed25519\" }, true, [\"sign\"]);\n\t\t\t\texportedKA = key;\n\t\t\t}\n\t\t\tlet ephemeralKey = await crypto.subtle.generateKey({ name: \"X25519\" }, true, [\"deriveBits\"]);\n\t\t\tlet exported = await crypto.subtle.exportKey(\"jwk\", ephemeralKey.publicKey);\n\t\t\texported = { signedBy: \"clientKey\", usages: [\"connfulSecureEphemeral\"], key: exported };\n\t\t\tlet signature = u8aToHex(new Uint8Array(await crypto.subtle.sign({ name: \"Ed25519\" }, newKeyKA, new TextEncoder().encode(JSON.stringify(exported)))));\n\t\t\tlet _dataBufferPromise = null;\n\t\t\tlet _rejectDataPromise = null;\n\t\t\tlet dataBufferPromise = new Promise((r, e) => [_dataBufferPromise, _rejectDataPromise] = [r, e]);\n\t\t\tlet _settlePromise = null;\n\t\t\tlet _rejectPromise = null;\n\t\t\tlet settlePromise = new Promise((r, e) => [_settlePromise, _rejectPromise] = [r, e]);\n\t\t\tlet packetID = crypto.getRandomValues(new Uint8Array(16)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\tconnections[packetConnectionID + \":client\"] = {\n\t\t\t\tourKey: ephemeralKey,\n\t\t\t\tfrom: address,\n\t\t\t\ttheirMainKeyReceived: false,\n\t\t\t\ttheirKeyRaw: null,\n\t\t\t\taesUsableKey: null,\n\t\t\t\tnetworkListenID,\n\t\t\t\tdataBuffer: [],\n\t\t\t\tdataBufferPromise,\n\t\t\t\tsettlePromise\n\t\t\t}\n\t\t\tasync function eventListener(e) {\n\t\t\t\ttry {\n\t\t\t\t\tlet gotPacket = new Uint8Array(e.data);\n\t\t\t\t\tif (gotPacket[48] == 0 && u8aToHex(gotPacket.slice(32, 48)) == packetID) {\n\t\t\t\t\t\tdelete connections[packetConnectionID + \":client\"];\n\t\t\t\t\t\tdelete networkListens[networkListenID];\n\t\t\t\t\t\twebsocket.removeEventListener(\"message\", eventListener);\n\t\t\t\t\t\treturn _rejectPromise(new Error(\"ADDRESS_UNREACHABLE\"));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (gotPacket[48] != 3 || gotPacket[49] != 255 || u8aToHex(gotPacket.slice(50, 66)) != packetConnectionID) return; // Must be Connectionful Protocol, server, and match the connection ID\n\t\t\t\t\tif (gotPacket[66] == 0) { // Start\n\t\t\t\t\t\tif (connections[packetConnectionID + \":client\"].aesUsableKey) return;\n\t\t\t\t\t\tlet packetContent = JSON.parse(new TextDecoder().decode(gotPacket.slice(67)));\n\t\t\t\t\t\tlet theirUsableKey = await crypto.subtle.importKey(\"jwk\", packetContent.keyInfo.key, { name: \"X25519\" }, true, []);\n\t\t\t\t\t\tlet joinedKeys = await crypto.subtle.deriveBits({ name: \"X25519\", public: theirUsableKey }, ephemeralKey.privateKey, 256);\n\t\t\t\t\t\tlet aesUsableKey = await crypto.subtle.importKey(\"raw\", joinedKeys, {\n\t\t\t\t\t\t\tname: \"AES-GCM\"\n\t\t\t\t\t\t}, true, [\"encrypt\", \"decrypt\"]);\n\t\t\t\t\t\tconnections[packetConnectionID + \":client\"].aesUsableKey = aesUsableKey;\n\t\t\t\t\t\tconnections[packetConnectionID + \":client\"].theirKeyRaw = packetContent;\n\t\t\t\t\t\tlet iv = crypto.getRandomValues(new Uint8Array(12));\n\t\t\t\t\t\tlet ct = new Uint8Array(await crypto.subtle.encrypt({ name: \"AES-GCM\", iv }, aesUsableKey, new TextEncoder().encode(JSON.stringify(exportedKA))));\n\t\t\t\t\t\tlet packet = new Uint8Array(79 + ct.byteLength);\n\t\t\t\t\t\tpacket.set(hexToU8A(modules.network.address), 0);\n\t\t\t\t\t\tpacket.set(hexToU8A(address), 16);\n\t\t\t\t\t\tpacket.set(hexToU8A(packetID), 32);\n\t\t\t\t\t\tpacket.set(Uint8Array.from([ 3, 0 ]), 48); // Connectionful Protocol; not a server\n\t\t\t\t\t\tpacket.set(hexToU8A(packetConnectionID), 50);\n\t\t\t\t\t\tpacket.set(Uint8Array.from([ 1 ]), 66); // Xchange; gate length\n\t\t\t\t\t\tpacket.set(iv, 67);\n\t\t\t\t\t\tpacket.set(ct, 79);\n\t\t\t\t\t\twebsocket.send(packet);\n\t\t\t\t\t} else if (gotPacket[66] == 1) { // Xchange\n\t\t\t\t\t\tif (connections[packetConnectionID + \":client\"].theirMainKeyReceived) return;\n\t\t\t\t\t\tlet theirMainKeyDecrypt = JSON.parse(new TextDecoder().decode(await crypto.subtle.decrypt({\n\t\t\t\t\t\t\tname: \"AES-GCM\",\n\t\t\t\t\t\t\tiv: gotPacket.slice(67, 79)\n\t\t\t\t\t\t}, connections[packetConnectionID + \":client\"].aesUsableKey, gotPacket.slice(79))));\n\t\t\t\t\t\tlet usableMainKey = await crypto.subtle.importKey(\"jwk\", theirMainKeyDecrypt.keyInfo.key, { name: \"Ed25519\" }, true, [\"verify\"]);\n\t\t\t\t\t\tlet verifyKeySignature = await crypto.subtle.verify({ name: \"Ed25519\" }, usableMainKey, hexToU8A(connections[packetConnectionID + \":client\"].theirKeyRaw.signature), new TextEncoder().encode(JSON.stringify(connections[packetConnectionID + \":client\"].theirKeyRaw.keyInfo)));\n\t\t\t\t\t\tif (!doNotVerifyServer && verifyKeySignature) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlet khrlFiles = await modules.fs.ls(modules.defaultSystem + \"/etc/keys/khrl\", processToken);\n\t\t\t\t\t\t\t\tlet khrlSignatures = [];\n\t\t\t\t\t\t\t\tfor (let khrlFile of khrlFiles) {\n\t\t\t\t\t\t\t\t\tlet khrl = JSON.parse(await modules.fs.read(modules.defaultSystem + \"/etc/keys/khrl/\" + khrlFile, processToken));\n\t\t\t\t\t\t\t\t\tlet khrlSignature = khrl.signature;\n\t\t\t\t\t\t\t\t\tdelete khrl.signature;\n\t\t\t\t\t\t\t\t\tif (await crypto.subtle.verify({ name: \"Ed25519\" }, modules.ksk_imported, hexToU8A(khrlSignature), new TextEncoder().encode(JSON.stringify(khrl.list)))) {\n\t\t\t\t\t\t\t\t\t\tkhrlSignatures.push(...khrl.list);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tverifyKeySignature = await recursiveKeyVerify(theirMainKeyDecrypt, khrlSignatures);\n\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\tverifyKeySignature = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!verifyKeySignature || (!theirMainKeyDecrypt.keyInfo.usages.includes(\"connfulSecureServer:\" + address) &&\n\t\t\t\t\t\t\t!theirMainKeyDecrypt.keyInfo.usages.includes(\"connfulSecureServer:\" + verifyByDomain)) &&\n\t\t\t\t\t\t\t!theirMainKeyDecrypt.keyInfo.usages.includes(\"connfulSecureServer:\" + address + \":\" + string_gate) &&\n\t\t\t\t\t\t\t!theirMainKeyDecrypt.keyInfo.usages.includes(\"connfulSecureServer:\" + verifyByDomain + \":\" + string_gate)) {\n\t\t\t\t\t\t\t_rejectPromise(new Error(\"SERVER_SIGNATURE_VERIFICATION_FAILED\"));\n\t\t\t\t\t\t\twebsocket.removeEventListener(\"message\", eventListener);\n\t\t\t\t\t\t\tdelete connections[packetConnectionID + \":client\"];\n\t\t\t\t\t\t\tdelete networkListens[networkListenID];\n\t\t\t\t\t\t\tlet packet = new Uint8Array(67);\n\t\t\t\t\t\t\tpacket.set(hexToU8A(modules.network.address), 0);\n\t\t\t\t\t\t\tpacket.set(hexToU8A(address), 16);\n\t\t\t\t\t\t\tpacket.set(hexToU8A(packetID), 32);\n\t\t\t\t\t\t\tpacket.set(Uint8Array.from([ 3, 0 ]), 48); // Connectionful Protocol; not a server\n\t\t\t\t\t\t\tpacket.set(hexToU8A(packetConnectionID), 50);\n\t\t\t\t\t\t\tpacket.set(Uint8Array.from([ 2 ]), 66); // Drop\n\t\t\t\t\t\t\treturn websocket.send(packet);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconnections[packetConnectionID + \":client\"].theirMainKeyReceived = theirMainKeyDecrypt;\n\t\t\t\t\t\tlet packet = new Uint8Array(67);\n\t\t\t\t\t\tpacket.set(hexToU8A(modules.network.address), 0);\n\t\t\t\t\t\tpacket.set(hexToU8A(address), 16);\n\t\t\t\t\t\tpacket.set(hexToU8A(packetID), 32);\n\t\t\t\t\t\tpacket.set(Uint8Array.from([ 3, 0 ]), 48); // Connectionful Protocol; not a server\n\t\t\t\t\t\tpacket.set(hexToU8A(packetConnectionID), 50);\n\t\t\t\t\t\tpacket.set(Uint8Array.from([ 4 ]), 66); // Nice2meetu\n\t\t\t\t\t\twebsocket.send(packet);\n\t\t\t\t\t\t_settlePromise();\n\t\t\t\t\t} else if (gotPacket[66] == 2) {\n\t\t\t\t\t\tif (connections[packetConnectionID + \":client\"].dying) return;\n\t\t\t\t\t\t_rejectPromise(new Error(\"CONNECTION_DROPPED\"));\n\t\t\t\t\t\tif (_rejectDataPromise) _rejectDataPromise(new Error(\"CONNECTION_DROPPED\"));\n\t\t\t\t\t\tlet packet = new Uint8Array(67);\n\t\t\t\t\t\tpacket.set(hexToU8A(modules.network.address), 0);\n\t\t\t\t\t\tpacket.set(hexToU8A(address), 16);\n\t\t\t\t\t\tpacket.set(hexToU8A(packetID), 32);\n\t\t\t\t\t\tpacket.set(Uint8Array.from([ 3, 0 ]), 48); // Connectionful Protocol; not a server\n\t\t\t\t\t\tpacket.set(hexToU8A(packetConnectionID), 50);\n\t\t\t\t\t\tpacket.set(Uint8Array.from([ 2 ]), 66); // Drop\n\t\t\t\t\t\twebsocket.send(packet);\n\t\t\t\t\t\tconnections[packetConnectionID + \":client\"].dying = true;\n\t\t\t\t\t\twebsocket.removeEventListener(\"message\", eventListener);\n\t\t\t\t\t\tdelete networkListens[networkListenID];\n\t\t\t\t\t\tif (!connections[packetConnectionID + \":client\"].dataBuffer.length) delete connections[packetConnectionID + \":client\"];\n\t\t\t\t\t} else if (gotPacket[66] == 3) {\n\t\t\t\t\t\tif (!connections[packetConnectionID + \":client\"].aesUsableKey) return;\n\t\t\t\t\t\tif (!connections[packetConnectionID + \":client\"].theirMainKeyReceived) return;\n\t\t\t\t\t\tif (connections[packetConnectionID + \":client\"].writingLock) await connections[packetConnectionID + \":client\"].writingLock;\n\t\t\t\t\t\tlet writingLockRelease;\n\t\t\t\t\t\tlet writingLock = new Promise(r => writingLockRelease = r);\n\t\t\t\t\t\tconnections[packetConnectionID + \":client\"].writingLock = writingLock;\n\t\t\t\t\t\tconnections[packetConnectionID + \":client\"].dataBuffer.push(new Uint8Array(await crypto.subtle.decrypt({\n\t\t\t\t\t\t\tname: \"AES-GCM\",\n\t\t\t\t\t\t\tiv: gotPacket.slice(67, 79)\n\t\t\t\t\t\t}, connections[packetConnectionID + \":client\"].aesUsableKey, gotPacket.slice(79))));\n\t\t\t\t\t\tif (!(connections[packetConnectionID + \":client\"].dataBuffer.length - 1)) {\n\t\t\t\t\t\t\t_dataBufferPromise();\n\t\t\t\t\t\t\tdataBufferPromise = new Promise((r, e) => [_dataBufferPromise, _rejectDataPromise] = [r, e]);\n\t\t\t\t\t\t\tconnections[packetConnectionID + \":client\"].dataBufferPromise = dataBufferPromise;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twritingLockRelease();\n\t\t\t\t\t}\n\t\t\t\t} catch { }\n\t\t\t};\n\t\t\tnetworkListens[networkListenID] = { ws: websocket, gate: gate, fn: eventListener };\n\t\t\twebsocket.addEventListener(\"message\", eventListener);\n\t\t\tlet theKey = new TextEncoder().encode(JSON.stringify({ keyInfo: exported, signature }));\n\t\t\tlet packet = new Uint8Array(68 + theKey.length + gate.length);\n\t\t\tpacket.set(hexToU8A(modules.network.address), 0);\n\t\t\tpacket.set(hexToU8A(address), 16);\n\t\t\tpacket.set(hexToU8A(packetID), 32);\n\t\t\tpacket.set(Uint8Array.from([ 3, 0 ]), 48); // Connectionful Protocol; not a server\n\t\t\tpacket.set(hexToU8A(packetConnectionID), 50);\n\t\t\tpacket.set(Uint8Array.from([ 0, gate.length ]), 66); // Start; gate length\n\t\t\tpacket.set(gate, 68);\n\t\t\tpacket.set(theKey, 68 + gate.length); // The key\n\t\t\twebsocket.send(packet);\n\t\t\tmodules.network.runOnClose.then(function () {\n\t\t\t\tif (connections.hasOwnProperty(packetConnectionID + \":client\")) {\n\t\t\t\t\tconnections[packetConnectionID + \":client\"].dying = true;\n\t\t\t\t\tif (!connections[packetConnectionID + \":client\"].dataBuffer.length) delete connections[packetConnectionID + \":client\"];\n\t\t\t\t}\n\t\t\t\tdelete networkListens[networkListenID];\n\t\t\t\t_rejectPromise(new Error(\"NETWORK_CLOSED\"));\n\t\t\t\t_rejectDataPromise(new Error(\"NETWORK_CLOSED\"));\n\t\t\t});\n\t\t\treturn packetConnectionID + \":client\";\n\t\t}\n\n\t\tasync function connfulWrite(sendOpts) {\n\t\t\tif (!connections.hasOwnProperty(sendOpts.connectionID)) throw new Error(\"NO_SUCH_CONNECTION\");\n\t\t\tif (connections[sendOpts.connectionID].dying) throw new Error(\"CONNECTION_DROPPED\");\n\t\t\tlet iv = crypto.getRandomValues(new Uint8Array(12));\n\t\t\tlet ct = new Uint8Array(await crypto.subtle.encrypt({ name: \"AES-GCM\", iv }, connections[sendOpts.connectionID].aesUsableKey, sendOpts.data));\n\t\t\tlet packet = new Uint8Array(79 + ct.byteLength);\n\t\t\tpacket.set(hexToU8A(modules.network.address), 0);\n\t\t\tpacket.set(hexToU8A(connections[sendOpts.connectionID].from), 16);\n\t\t\tpacket.set(Uint8Array.from([ 3, sendOpts.connectionID.endsWith(\":client\") ? 0 : 255 ]), 48); // Connectionful Protocol; is/not a server\n\t\t\tpacket.set(hexToU8A(sendOpts.connectionID.slice(0, -7)), 50);\n\t\t\tpacket.set(Uint8Array.from([ 3 ]), 66); // Data\n\t\t\tpacket.set(iv, 67);\n\t\t\tpacket.set(ct, 79);\n\t\t\tnetworkListens[connections[sendOpts.connectionID].networkListenID].ws.send(packet);\n\t\t}\n\n\t\tasync function connfulRead(connectionID) {\n\t\t\tif (!connections.hasOwnProperty(connectionID)) throw new Error(\"NO_SUCH_CONNECTION\");\n\t\t\tif (!connections[connectionID].dataBuffer.length) await connections[connectionID].dataBufferPromise;\n\t\t\tlet data = connections[connectionID].dataBuffer.shift();\n\t\t\tif (connections[connectionID].dying && connections[connectionID].dataBuffer.length == 0) delete connections[connectionID]; \n\t\t\treturn data;\n\t\t}\n\n\t\tfunction connfulDisconnect(connectionID) {\n\t\t\tif (!connections.hasOwnProperty(connectionID)) throw new Error(\"NO_SUCH_CONNECTION\");\n\t\t\tif (connections[connectionID].dying) return;\n\t\t\tlet packet = new Uint8Array(67);\n\t\t\tpacket.set(hexToU8A(modules.network.address), 0);\n\t\t\tpacket.set(hexToU8A(connections[connectionID].from), 16);\n\t\t\tpacket.set(Uint8Array.from([ 3, connectionID.endsWith(\":client\") ? 0 : 255 ]), 48); // Connectionful Protocol; is/not a server\n\t\t\tpacket.set(hexToU8A(connectionID.slice(0, -7)), 50);\n\t\t\tpacket.set(Uint8Array.from([ 2 ]), 66); // Drop\n\t\t\tnetworkListens[connections[connectionID].networkListenID].ws.send(packet);\n\t\t}\n\n\t\tree.beforeCloseDown(async function() {\n\t\t\tfor (let processPipe of processPipes) delete modules.ipc._ipc[processPipe];\n\t\t\tfor (let connection in connections) try {\n\t\t\t\tlet packet = new Uint8Array(67);\n\t\t\t\tpacket.set(hexToU8A(modules.network.address), 0);\n\t\t\t\tpacket.set(hexToU8A(connections[connection].from), 16);\n\t\t\t\tpacket.set(Uint8Array.from([ 3, connection.endsWith(\":client\") ? 0 : 255 ]), 48); // Connectionful Protocol; is/not a server\n\t\t\t\tpacket.set(hexToU8A(connection.slice(0, -7)), 50);\n\t\t\t\tpacket.set(Uint8Array.from([ 2 ]), 66); // Drop\n\t\t\t\tnetworkListens[connections[connection].networkListenID].ws.send(packet);\n\t\t\t} catch {}\n\t\t\tfor (let networkListen in networkListens) networkListens[networkListen].ws.removeEventListener(\"message\", networkListens[networkListen].fn);\n\t\t\tfor (let websocket of websockets) modules.websocket.close(websocket);\n\t\t\tawait modules.tokens.revoke(token);\n\t\t\tfor (let i in modules.csps) if (modules.csps[i].hasOwnProperty(\"removeSameGroupKeys\")) modules.csps[i].removeSameGroupKeys(null, taskId);\n\t\t});\n\t\tlet apis = {\n\t\t\tprivate: {\n\t\t\t\tsetUser: async function(newUser) {\n\t\t\t\t\tuser = newUser;\n\t\t\t\t\tgroups = (await modules.users.getUserInfo(newUser, false, token || processToken)).groups || [];\n\t\t\t\t},\n\t\t\t\taddPrivilege: (newPrivilege) => !privileges.includes(newPrivilege) && privileges.push(newPrivilege),\n\t\t\t\trmPrivilege: (newPrivilege) => privileges.includes(newPrivilege) && privileges.splice(privileges.indexOf(newPrivilege), 1),\n\t\t\t\tsetPrivileges: (newPrivileges) => privileges = newPrivileges,\n\t\t\t\treauthorize: async function() {\n\t\t\t\t\tlet tokenInfo = await modules.tokens.info(token);\n\t\t\t\t\tuser = tokenInfo.user;\n\t\t\t\t\tgroups = tokenInfo.groups || [];\n\t\t\t\t\tprivileges = tokenInfo.privileges;\n\t\t\t\t\tprivileges = await denyUnmanifested(limitations, token);\n\t\t\t\t}\n\t\t\t},\n\t\t\tpublic: {\n\t\t\t\tgetUser: () => user,\n\t\t\t\tgetPrivileges: () => privileges,\n\t\t\t\tterminate: async function() {\n\t\t\t\t\tawait ree.closeDown();\n\t\t\t\t},\n\t\t\t\trmPrivilege: async function(privilege) {\n\t\t\t\t\tif (!privileges.includes(privilege)) throw new Error(\"NO_SUCH_PRIVILEGE\");\n\t\t\t\t\tprivileges.splice(privileges.indexOf(privilege), 1);\n\t\t\t\t\tawait modules.tokens.removePrivilege(token, privilege);\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\trmPrivileges: async function(privilegesRemoved) {\n\t\t\t\t\tprivileges = privileges.filter(x => !privilegesRemoved.includes(x));\n\t\t\t\t\tawait modules.tokens.removePrivileges(token, privilegesRemoved);\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tswitchUser: async function(desiredUser) {\n\t\t\t\t\tif (!privileges.includes(\"SWITCH_USERS_AUTOMATICALLY\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tawait modules.tokens.halfInitialize(token, desiredUser);\n\t\t\t\t\tlet tokenInfo = await modules.tokens.info(token);\n\t\t\t\t\tuser = tokenInfo.user;\n\t\t\t\t\tgroups = tokenInfo.groups || [];\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tshutdown: async function(arg) {\n\t\t\t\t\tlet {isKexec, isReboot, force, token} = arg;\n\t\t\t\t\tif (!privileges.includes(\"SYSTEM_SHUTDOWN\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (force) {\n\t\t\t\t\t\ttry { modules.websocket._handles[modules.network.ws].ws.close(); } catch {}\n\t\t\t\t\t\tmodules.session.destroy();\n\t\t\t\t\t\tif (isReboot) return location.reload();\n\t\t\t\t\t\treturn modules.killSystem();\n\t\t\t\t\t}\n\t\t\t\t\tawait modules.restart(!isReboot, token || processToken, isKexec);\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tfs_read: async function(arg) {\n\t\t\t\t\tlet {path, token} = arg;\n\t\t\t\t\tif (!privileges.includes(\"FS_READ\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn await fs_action(\"read\", (fsPermissions) => fsPermissions.owner == user || fsPermissions.world.includes(\"r\") || groups.includes(fsPermissions.group) || privileges.includes(\"FS_BYPASS_PERMISSIONS\"), path, token || processToken);\n\t\t\t\t},\n\t\t\t\tfs_ls: async function(arg) {\n\t\t\t\t\tlet {path, token} = arg;\n\t\t\t\t\tif (!privileges.includes(\"FS_READ\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn await fs_action(\"ls\",\n\t\t\t\t\t(fsPermissions) =>\n\t\t\t\t\t\tfsPermissions.owner == user ||\n\t\t\t\t\t\tgroups.includes(fsPermissions.group) ||\n\t\t\t\t\t\t(fsPermissions.world.includes(\"r\") &&\n\t\t\t\t\t\tfsPermissions.world.includes(\"x\")) || privileges.includes(\"FS_BYPASS_PERMISSIONS\"), path, token || processToken);\n\t\t\t\t},\n\t\t\t\tfs_write: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"FS_WRITE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet {path, data, token} = arg;\n\t\t\t\t\tlet pathParent = path.split(\"/\").slice(0, -1).join(\"/\");\n\t\t\t\t\tlet basename = path.split(\"/\").slice(-1)[0];\n\t\t\t\t\tlet isCreating = false;\n\t\t\t\t\tlet fsParentPermissions;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!(await modules.fs.ls(pathParent, token || processToken)).includes(basename)) isCreating = true;\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tthrow new Error(\"CREATION_CHECK_FAILED\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfsParentPermissions = await modules.fs.permissions(pathParent, token || processToken);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tthrow new Error(\"PERMISSION_CHECKING_FAILED\");\n\t\t\t\t\t}\n\t\t\t\t\tif (!fsParentPermissions.world.includes(\"w\") && fsParentPermissions.owner != user && !groups.includes(fsParentPermissions.group) && !privileges.includes(\"FS_BYPASS_PERMISSIONS\")) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\t\n\t\t\t\t\tif (isCreating) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait modules.fs.chown(path, user, token || processToken);\n\t\t\t\t\t\t\tawait modules.fs.chgrp(path, groups[0], token || processToken);\n\t\t\t\t\t\t\tawait modules.fs.chmod(path, \"r\", token || processToken);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tif (e.name == \"Error\") throw e;\n\t\t\t\t\t\t\tthrow new Error(\"PERMISSION_CHANGE_FAILED\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn await fs_action(\"write\", (fsPermissions) => fsPermissions.owner == user || groups.includes(fsPermissions.group) || fsPermissions.world.includes(\"w\") || privileges.includes(\"FS_BYPASS_PERMISSIONS\"), path, data, token || processToken);\n\t\t\t\t},\n\t\t\t\tfs_rm: async function(arg) {\n\t\t\t\t\tlet {path, token} = arg;\n\t\t\t\t\tif (!privileges.includes(\"FS_REMOVE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn await fs_action(\"rm\", (fsPermissions) => fsPermissions.owner == user || privileges.includes(\"FS_BYPASS_PERMISSIONS\"), path, token);\n\t\t\t\t},\n\t\t\t\tfs_mkdir: async function(arg) {\n\t\t\t\t\tlet {path, token} = arg;\n\t\t\t\t\tif (!privileges.includes(\"FS_WRITE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet pathParent = path.split(\"/\").slice(0, -1).join(\"/\");\n\t\t\t\t\tlet fsPermissions;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfsPermissions = await modules.fs.permissions(pathParent, token || processToken);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tthrow new Error(\"PERMISSION_CHECKING_FAILED\");\n\t\t\t\t\t}\n\t\t\t\t\tif (!fsPermissions.world.includes(\"w\") && fsPermissions.owner != user && !groups.includes(fsPermissions.group) && !privileges.includes(\"FS_BYPASS_PERMISSIONS\")) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait modules.fs.chown(path, user, token || processToken);\n\t\t\t\t\t\tawait modules.fs.chgrp(path, groups[0] || user, token || processToken);\n\t\t\t\t\t\tawait modules.fs.chmod(path, \"rx\", token || processToken);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (e.name == \"Error\") throw e;\n\t\t\t\t\t\tthrow new Error(\"PERMISSION_CHANGE_FAILED\");\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn await modules.fs.mkdir(path, token || processToken);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (e.name == \"Error\") throw e;\n\t\t\t\t\t\tthrow new Error(\"FS_ACTION_FAILED\");\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfs_chown: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"FS_CHANGE_PERMISSION\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet {path, newUser, token} = arg;\n\t\t\t\t\treturn await fs_action(\"chown\", (fsPermissions) => fsPermissions.owner == user || privileges.includes(\"FS_BYPASS_PERMISSIONS\"), path, newUser, token || processToken);\n\t\t\t\t},\n\t\t\t\tfs_chgrp: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"FS_CHANGE_PERMISSION\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet {path, newGrp, token} = arg;\n\t\t\t\t\treturn await fs_action(\"chgrp\", (fsPermissions) => fsPermissions.owner == user || privileges.includes(\"FS_BYPASS_PERMISSIONS\"), path, newGrp, token || processToken);\n\t\t\t\t},\n\t\t\t\tfs_chmod: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"FS_CHANGE_PERMISSION\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet {path, newPermissions, token} = arg;\n\t\t\t\t\treturn await fs_action(\"chmod\", (fsPermissions) => fsPermissions.owner == user || privileges.includes(\"FS_BYPASS_PERMISSIONS\"), path, newPermissions, token || processToken);\n\t\t\t\t},\n\t\t\t\tfs_permissions: async function(arg) {\n\t\t\t\t\tlet {path, token} = arg;\n\t\t\t\t\tif (!privileges.includes(\"FS_READ\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet pathParent = path.split(\"/\").slice(0, -1).join(\"/\");\n\t\t\t\t\tif (pathParent != \"\") {\n\t\t\t\t\t\tlet fsPermissions;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tfsPermissions = await modules.fs.permissions(pathParent, token || processToken);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tthrow new Error(\"PERMISSION_CHECKING_FAILED\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!fsPermissions.world.includes(\"r\") && fsPermissions.owner != user && !privileges.includes(\"FS_BYPASS_PERMISSIONS\")) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\t}\n\t\t\t\t\treturn await fs_action(\"permissions\", () => true, path, token || processToken);\n\t\t\t\t},\n\t\t\t\tfs_mounts: async function() {\n\t\t\t\t\tif (!privileges.includes(\"FS_LIST_PARTITIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn await modules.fs.lsmounts();\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (e.name == \"Error\") throw e;\n\t\t\t\t\t\tthrow new Error(\"FS_ACTION_FAILED\");\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfs_sync: async function(arg) {\n\t\t\t\t\tlet {mount, token} = arg;\n\t\t\t\t\tif (!privileges.includes(\"FS_UNMOUNT\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn await modules.fs.sync(mount, token || processToken);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (e.name == \"Error\") throw e;\n\t\t\t\t\t\tthrow new Error(\"FS_ACTION_FAILED\");\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfs_unmount: async function(arg) {\n\t\t\t\t\tlet {mount, token, force} = arg;\n\t\t\t\t\tif (!privileges.includes(\"FS_UNMOUNT\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn await modules.fs.unmount(mount, token || processToken, force);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (e.name == \"Error\") throw e;\n\t\t\t\t\t\tthrow new Error(\"FS_ACTION_FAILED\");\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfs_mountInfo: async function(mount) {\n\t\t\t\t\tif (!privileges.includes(\"FS_LIST_PARTITIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn await modules.fs.mountInfo(mount);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (e.name == \"Error\") throw e;\n\t\t\t\t\t\tthrow new Error(\"FS_ACTION_FAILED\");\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tgetSystemMount: async function() {\n\t\t\t\t\tif (!privileges.includes(\"FS_LIST_PARTITIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.defaultSystem;\n\t\t\t\t},\n\t\t\t\tcreatePipe: async function() {\n\t\t\t\t\tif (!privileges.includes(\"IPC_CREATE_PIPE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet pipe = await modules.ipc.create();\n\t\t\t\t\tmodules.ipc.declareAccess(pipe, {\n\t\t\t\t\t\towner: user,\n\t\t\t\t\t\tgroup: groups[0],\n\t\t\t\t\t\tworld: false\n\t\t\t\t\t});\n\t\t\t\t\tprocessPipes.push(pipe);\n\t\t\t\t\treturn pipe;\n\t\t\t\t},\n\t\t\t\tlistenToPipe: async function(pipe) {\n\t\t\t\t\tif (!privileges.includes(\"IPC_LISTEN_PIPE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet permissions = await modules.ipc.getIPC(pipe);\n\t\t\t\t\tif (permissions.owner != user && !groups.includes(permissions.group) && !permissions.world && !privileges.includes(\"IPC_BYPASS_PERMISSIONS\") && !processPipes.includes(pipe)) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\treturn await modules.ipc.listenFor(pipe);\n\t\t\t\t},\n\t\t\t\tsendToPipe: async function(dataSend) {\n\t\t\t\t\tif (!privileges.includes(\"IPC_SEND_PIPE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet {pipe, data} = dataSend;\n\t\t\t\t\tlet permissions = await modules.ipc.getIPC(pipe);\n\t\t\t\t\tif (permissions.owner != user && !groups.includes(permissions.group) && !permissions.world && !privileges.includes(\"IPC_BYPASS_PERMISSIONS\") && !processPipes.includes(pipe)) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\treturn await modules.ipc.send(pipe, data);\n\t\t\t\t},\n\t\t\t\tclosePipe: async function(pipe) {\n\t\t\t\t\tif (!processPipes.includes(pipe)) throw new Error(\"NOT_OWN_PIPE\");\n\t\t\t\t\tprocessPipes.splice(processPipes.indexOf(pipe), 1);\n\t\t\t\t\treturn delete modules.ipc._ipc[pipe];\n\t\t\t\t},\n\t\t\t\tsetPipePermissions: async function(opts) {\n\t\t\t\t\tif (!privileges.includes(\"IPC_CHANGE_PERMISSION\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet {pipe, newPermissions} = opts;\n\t\t\t\t\tlet permissions = await modules.ipc.getIPC(pipe);\n\t\t\t\t\tif (permissions.owner != user && !groups.includes(permissions.group) && !permissions.world && !privileges.includes(\"IPC_BYPASS_PERMISSIONS\") && !processPipes.includes(pipe)) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\treturn await modules.ipc.declareAccess(pipe, newPermissions);\n\t\t\t\t},\n\t\t\t\televate: async function(newPrivileges) {\n\t\t\t\t\tnewPrivileges = newPrivileges.filter(privilege => !privileges.includes(privilege));\n\t\t\t\t\tnewPrivileges = Array.from(new Set(newPrivileges));\n\t\t\t\t\tif (!privileges.includes(\"SWITCH_USERS_AUTOMATICALLY\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tprivileges.push(...newPrivileges);\n\t\t\t\t\tawait modules.tokens.addPrivileges(token, newPrivileges);\n\t\t\t\t\tprivileges = await denyUnmanifested(limitations, token);\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tgetVersion: function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_BUILD\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.pcos_version;\n\t\t\t\t},\n\t\t\t\tlocale: function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_LOCALE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn language || navigator.languages[0].split(\"-\")[0].toLowerCase();\n\t\t\t\t},\n\t\t\t\tosLocale: function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_LOCALE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.locales.get(\"OS_LOCALE\", language);\n\t\t\t\t},\n\t\t\t\tgetUserInfo: async function(arg) {\n\t\t\t\t\tlet {desiredUser, token, sensitive} = arg;\n\t\t\t\t\tif (!privileges.includes(\"GET_USER_INFO\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (desiredUser != user && !privileges.includes(\"USER_INFO_OTHERS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (sensitive && desiredUser != user && !privileges.includes(\"SENSITIVE_USER_INFO_OTHERS\")) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\treturn await modules.users.getUserInfo(desiredUser, sensitive, token || processToken);\n\t\t\t\t},\n\t\t\t\tsetUserInfo: async function(arg) {\n\t\t\t\t\tlet {desiredUser, token, info} = arg;\n\t\t\t\t\tif (!privileges.includes(\"SET_USER_INFO\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn await modules.users.moduser(desiredUser, info, token || processToken);\n\t\t\t\t},\n\t\t\t\tsetOwnSecurityChecks: async function(arg) {\n\t\t\t\t\tlet {token, checks} = arg;\n\t\t\t\t\tif (!privileges.includes(\"SET_SECURITY_CHECKS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet allowedTypes = [ \"pbkdf2\", \"informative\", \"informative_deny\", \"timeout\", \"timeout_deny\", \"serverReport\", \"pc-totp\", \"totp\", \"workingHours\", \"zkpp\", \"privrestrict\" ];\n\t\t\t\t\tlet sanitizedChecks = [];\n\t\t\t\t\tchecks.filter(a => allowedTypes.includes(a.type));\n\t\t\t\t\tfor (let checkIndex in checks) {\n\t\t\t\t\t\tlet check = checks[checkIndex];\n\t\t\t\t\t\tif (check.type == \"pbkdf2\") {\n\t\t\t\t\t\t\tif (!check.salt || !check.hash) continue;\n\t\t\t\t\t\t\tcheck = { type: \"pbkdf2\", salt: check.salt, hash: check.hash };\n\t\t\t\t\t\t} else if (check.type == \"informative\" || check.type == \"informative_deny\") {\n\t\t\t\t\t\t\tif (!check.message) continue;\n\t\t\t\t\t\t\tcheck = { type: check.type, message: check.message };\n\t\t\t\t\t\t} else if (check.type == \"timeout\" || check.type == \"timeout_deny\") {\n\t\t\t\t\t\t\tif (!check.timeout) continue;\n\t\t\t\t\t\t\tcheck = { type: check.type, timeout: check.timeout };\n\t\t\t\t\t\t} else if (check.type == \"serverReport\") {\n\t\t\t\t\t\t\tif (!check.url) continue;\n\t\t\t\t\t\t\tcheck = { type: \"serverReport\", url: check.url };\n\t\t\t\t\t\t} else if (check.type == \"pc-totp\" || check.type == \"totp\") {\n\t\t\t\t\t\t\tif (!check.secret) continue;\n\t\t\t\t\t\t\tcheck = { type: check.type, secret: check.secret };\n\t\t\t\t\t\t} else if (check.type == \"workingHours\") {\n\t\t\t\t\t\t\tif (!check.start || !check.end) continue;\n\t\t\t\t\t\t\tif (typeof check.start.hours !== \"number\" || typeof check.start.minutes !== \"number\" || typeof check.start.seconds !== \"number\") continue;\n\t\t\t\t\t\t\tif (typeof check.end.hours !== \"number\" || typeof check.end.minutes !== \"number\" || typeof check.end.seconds !== \"number\") continue;\n\t\t\t\t\t\t\tcheck = {\n\t\t\t\t\t\t\t\ttype: \"workingHours\",\n\t\t\t\t\t\t\t\tstart: {\n\t\t\t\t\t\t\t\t\thours: check.start.hours,\n\t\t\t\t\t\t\t\t\tminutes: check.start.minutes,\n\t\t\t\t\t\t\t\t\tseconds: check.start.seconds\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tend: {\n\t\t\t\t\t\t\t\t\thours: check.end.hours,\n\t\t\t\t\t\t\t\t\tminutes: check.end.minutes,\n\t\t\t\t\t\t\t\t\tseconds: check.end.seconds\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else if (check.type == \"zkpp\") {\n\t\t\t\t\t\t\tif (!check.publicKey) continue;\n\t\t\t\t\t\t\tcheck = { type: \"zkpp\", publicKey: check.publicKey };\n\t\t\t\t\t\t} else if (check.type == \"privrestrict\") check = { type: \"privrestrict\" };\n\t\t\t\t\t\tsanitizedChecks.push(check);\n\t\t\t\t\t}\n\t\t\t\t\tlet previousUserInfo = await modules.users.getUserInfo(user, false, token || processToken);\n\t\t\t\t\tawait modules.users.moduser(user, { ...previousUserInfo, securityChecks: sanitizedChecks }, token || processToken);\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tgetProcessToken: () => processToken,\n\t\t\t\tsetProcessToken: async function(desiredToken) {\n\t\t\t\t\tif (!privileges.includes(\"ELEVATE_PRIVILEGES\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet validation = await modules.tokens.validate(desiredToken, {});\n\t\t\t\t\tif (!validation) throw new Error(\"INVALID_TOKEN\");\n\t\t\t\t\ttoken = processToken = desiredToken;\n\t\t\t\t\tlet tokenInfo = await modules.tokens.info(token);\n\t\t\t\t\tuser = tokenInfo.user;\n\t\t\t\t\tgroups = tokenInfo.groups || [];\n\t\t\t\t\tprivileges = tokenInfo.privileges;\n\t\t\t\t\tprivileges = await denyUnmanifested(limitations, token);\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\trevokeToken: function(dt) {\n\t\t\t\t\tif (!privileges.includes(\"MANAGE_TOKENS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.tokens.revoke(dt || processToken);\n\t\t\t\t},\n\t\t\t\tforkToken: function(dt) {\n\t\t\t\t\tif (!privileges.includes(\"MANAGE_TOKENS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.tokens.fork(dt || processToken);\n\t\t\t\t},\n\t\t\t\tremoveTokenPrivilege: async function(arg) {\n\t\t\t\t\tlet {token, privilege} = arg;\n\t\t\t\t\tif (!privileges.includes(\"MANAGE_TOKENS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tawait modules.tokens.removePrivilege(token, privilege);\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tremoveTokenPrivileges: async function(arg) {\n\t\t\t\t\tlet {token} = arg;\n\t\t\t\t\tif (!privileges.includes(\"MANAGE_TOKENS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tawait modules.tokens.removePrivileges(token, arg.privileges);\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\testimateStorage: async function() {\n\t\t\t\t\tif (!privileges.includes(\"FS_LIST_PARTITIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet estimate = await navigator.storage.estimate();\n\t\t\t\t\treturn {\n\t\t\t\t\t\tinternal: {\n\t\t\t\t\t\t\tused: estimate.usage,\n\t\t\t\t\t\t\tfree: estimate.quota - estimate.usage,\n\t\t\t\t\t\t\ttotal: estimate.quota\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\tstartTask: async function(arg) {\n\t\t\t\t\tlet {file, argPassed, token, runInBackground, silent, privateData} = arg;\n\t\t\t\t\tif (!privileges.includes(\"START_TASK\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (runInBackground && !privileges.includes(\"START_BACKGROUND_TASK\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!token) token = await modules.tokens.fork(processToken);\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn await modules.tasks.exec(file, argPassed, modules.window(runInBackground ? modules.serviceSession : ses), token, silent, privateData);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (e.name == \"Error\") throw e;\n\t\t\t\t\t\tthrow new Error(\"UNABLE_TO_START_TASK\");\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tlistTasks: async function() {\n\t\t\t\t\tif (!privileges.includes(\"LIST_TASKS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.tasks.listPublicTasks();\n\t\t\t\t},\n\t\t\t\ttaskInfo: async function(taskId) {\n\t\t\t\t\tif (!privileges.includes(\"LIST_TASKS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn await modules.tasks.taskInfo(taskId);\n\t\t\t\t},\n\t\t\t\tsignalTask: async function(arg) {\n\t\t\t\t\tlet {taskId, signal} = arg;\n\t\t\t\t\tif (!privileges.includes(\"SIGNAL_TASK\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!privileges.includes(\"TASK_BYPASS_PERMISSIONS\")) {\n\t\t\t\t\t\tlet taskInfo = await modules.tasks.taskInfo(taskId);\n\t\t\t\t\t\tif (taskInfo.runBy != user) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\t}\n\t\t\t\t\treturn await modules.tasks.sendSignal(taskId, signal);\n\t\t\t\t},\n\t\t\t\tlookupLocale: function(key) {   \n\t\t\t\t\tif (!privileges.includes(\"GET_LOCALE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.locales.get(key, language);\n\t\t\t\t},\n\t\t\t\tlookupOtherLocale: function(arg) {\n\t\t\t\t\tlet {key, locale} = arg;   \n\t\t\t\t\tif (!privileges.includes(\"GET_LOCALE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.locales.get(key, locale);\n\t\t\t\t},\n\t\t\t\tufTimeInc: function(args) {\n\t\t\t\t\tif (!privileges.includes(\"GET_LOCALE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.userfriendliness.inconsiderateTime(language, ...args);\n\t\t\t\t},\n\t\t\t\tufInfoUnits: function(args) {\n\t\t\t\t\tif (!privileges.includes(\"GET_LOCALE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.userfriendliness.informationUnits(language, ...args)\n\t\t\t\t},\n\t\t\t\tisDesktopDarkThemed: function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_THEME\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.session.attrib(ses, \"dark\")\n\t\t\t\t},\n\t\t\t\tfetchSend: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"FETCH_SEND\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet {url, init} = arg;\n\t\t\t\t\tlet fetc = await fetch(url, init);\n\t\t\t\t\tlet responseAB;\n\t\t\t\t\tif (init.mode != \"no-cors\" && !init.noArrayBuffer) responseAB = await fetc.arrayBuffer();\n\t\t\t\t\treturn {\n\t\t\t\t\t\tstatus: fetc.status,\n\t\t\t\t\t\tstatusText: fetc.statusText,\n\t\t\t\t\t\tok: fetc.ok,\n\t\t\t\t\t\tredirected: fetc.redirected,\n\t\t\t\t\t\ttype: fetc.type,\n\t\t\t\t\t\turl: fetc.url,\n\t\t\t\t\t\theaders: Object.fromEntries(Array.from(fetc.headers)),\n\t\t\t\t\t\tarrayBuffer: responseAB,\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\tswitchUserWithSetup: async function(desiredUser) {\n\t\t\t\t\tif (!privileges.includes(\"SWITCH_USERS_AUTOMATICALLY\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tawait modules.tokens.userInitialize(token, desiredUser);\n\t\t\t\t\tlet tokenInfo = await modules.tokens.info(token);\n\t\t\t\t\tuser = tokenInfo.user;\n\t\t\t\t\tgroups = tokenInfo.groups || [];\n\t\t\t\t\tprivileges = tokenInfo.privileges;\n\t\t\t\t\tprivileges = await denyUnmanifested(limitations, token);\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\trunKlvlCode: async function(code) {\n\t\t\t\t\tif (!privileges.includes(\"RUN_KLVL_CODE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn eval(code);\n\t\t\t\t},\n\t\t\t\tcspOperation: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"CSP_OPERATIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.csps[arg.cspProvider][arg.operation](arg.cspArgument, taskId);\n\t\t\t\t},\n\t\t\t\tavailableCsps: async function() {\n\t\t\t\t\tif (!privileges.includes(\"CSP_OPERATIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn Object.keys(modules.csps);\n\t\t\t\t},\n\t\t\t\tufTimeCon: function(args) {\n\t\t\t\t\tif (!privileges.includes(\"GET_LOCALE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.userfriendliness.considerateTime(language, ...args);\n\t\t\t\t},\n\t\t\t\twebsocketOpen: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"WEBSOCKETS_OPEN\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet handle = await modules.websocket.getHandle(arg);\n\t\t\t\t\twebsockets.push(handle);\n\t\t\t\t\tmodules.websocket.assertAccess({ handle, newACL: {\n\t\t\t\t\t\towner: user,\n\t\t\t\t\t\tgroup: groups[0],\n\t\t\t\t\t\tworld: false\n\t\t\t\t\t}});\n\t\t\t\t\treturn handle;\n\t\t\t\t},\n\t\t\t\tlistenToWebsocket: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"WEBSOCKETS_LISTEN\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet permissions = modules.websocket.assertAccess({ handle: arg.handle });\n\t\t\t\t\tif (permissions.owner != user && !groups.includes(permissions.group) && !permissions.world && !privileges.includes(\"WEBSOCKET_BYPASS_PERMISSIONS\") && !websockets.includes(arg.handle)) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\treturn await modules.websocket.waitForEvent(arg);\n\t\t\t\t},\n\t\t\t\tsendToWebsocket: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"WEBSOCKETS_SEND\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet permissions = modules.websocket.assertAccess({ handle: arg.handle });\n\t\t\t\t\tif (permissions.owner != user && !groups.includes(permissions.group) && !permissions.world && !privileges.includes(\"WEBSOCKET_BYPASS_PERMISSIONS\") && !websockets.includes(arg.handle)) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\treturn await modules.websocket.send(arg);\n\t\t\t\t},\n\t\t\t\tcloseWebsocket: async function(websocket) {\n\t\t\t\t\tif (!websockets.includes(websocket)) throw new Error(\"NOT_OWN_WEBSOCKET\");\n\t\t\t\t\twebsockets.splice(websockets.indexOf(websocket), 1);\n\t\t\t\t\treturn modules.websocket.close(websocket);\n\t\t\t\t},\n\t\t\t\twebsocketInfo: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"WEBSOCKET_INFO\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet permissions = modules.websocket.assertAccess({ handle: arg.handle });\n\t\t\t\t\tif (permissions.owner != user && !groups.includes(permissions.group) && !permissions.world && !privileges.includes(\"WEBSOCKET_BYPASS_PERMISSIONS\") && !websockets.includes(arg.handle)) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\treturn await modules.websocket.getInfo(arg);\n\t\t\t\t},\n\t\t\t\tsetWebsocketPermissions: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"WEBSOCKET_SET_PERMISSIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet permissions = modules.websocket.assertAccess({ handle: arg.handle });\n\t\t\t\t\tif (permissions.owner != user && !groups.includes(permissions.group) && !permissions.world && !privileges.includes(\"WEBSOCKET_BYPASS_PERMISSIONS\") && !websockets.includes(arg.handle)) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\treturn await modules.websocket.assertAccess(arg);\n\t\t\t\t},\n\t\t\t\tgetPublicSystemID: async function() {\n\t\t\t\t\tif (!privileges.includes(\"IDENTIFY_SYSTEM\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn (modules.core.prefs.read(\"system_id\") || {}).public;\n\t\t\t\t},\n\t\t\t\tgetPrivateSystemID: async function() {\n\t\t\t\t\tif (!privileges.includes(\"IDENTIFY_SYSTEM_SENSITIVE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn (modules.core.prefs.read(\"system_id\") || {}).private;\n\t\t\t\t},\n\t\t\t\ttypeIntoOtherCLI: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"CLI_MODIFICATIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!modules.tasks.tracker.hasOwnProperty(arg.taskId)) throw new Error(\"TASK_NOT_FOUND\");\n\t\t\t\t\tlet bypassWorks = modules.tasks.tracker[arg.taskId].apis.public.getProcessToken() == arg.bypass;\n\t\t\t\t\tif (!bypassWorks) {\n\t\t\t\t\t\tlet taskInfo = await modules.tasks.taskInfo(arg.taskId);\n\t\t\t\t\t\tif (taskInfo.runBy != user && !privileges.includes(\"TASK_BYPASS_PERMISSIONS\")) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\t}\n\t\t\t\t\tif (!modules.tasks.tracker[arg.taskId].cliio) throw new Error(\"NO_CLI_ATTACHED\");\n\t\t\t\t\treturn await modules.tasks.tracker[arg.taskId].cliio.xtermInstance.input(arg.text, arg.human);\n\t\t\t\t},\n\t\t\t\tgetOtherCLIData: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"CLI_MODIFICATIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!modules.tasks.tracker.hasOwnProperty(arg.taskId)) throw new Error(\"TASK_NOT_FOUND\");\n\t\t\t\t\tlet bypassWorks = modules.tasks.tracker[arg.taskId].apis.public.getProcessToken() == arg.bypass;\n\t\t\t\t\tif (!bypassWorks) {\n\t\t\t\t\t\tlet taskInfo = await modules.tasks.taskInfo(arg.taskId);\n\t\t\t\t\t\tif (taskInfo.runBy != user && !privileges.includes(\"TASK_BYPASS_PERMISSIONS\")) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\t}\n\t\t\t\t\tif (!modules.tasks.tracker[arg.taskId].cliio) throw new Error(\"NO_CLI_ATTACHED\");\n\t\t\t\t\treturn await modules.tasks.tracker[arg.taskId].cliio.signup();\n\t\t\t\t},\n\t\t\t\twaitForOtherCLI: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"CLI_MODIFICATIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!modules.tasks.tracker.hasOwnProperty(arg.taskId)) throw new Error(\"TASK_NOT_FOUND\");\n\t\t\t\t\tlet bypassWorks = modules.tasks.tracker[arg.taskId].apis.public.getProcessToken() == arg.bypass;\n\t\t\t\t\tif (!bypassWorks) {\n\t\t\t\t\t\tlet taskInfo = await modules.tasks.taskInfo(arg.taskId);\n\t\t\t\t\t\tif (taskInfo.runBy != user && !privileges.includes(\"TASK_BYPASS_PERMISSIONS\")) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\t}\n\t\t\t\t\tif (modules.tasks.tracker[arg.taskId].cliio) return true;\n\t\t\t\t\treturn await modules.tasks.tracker[arg.taskId].cliio.attachedCLISignUp();\n\t\t\t\t},\n\t\t\t\tlldaRead: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"LLDISK_READ\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.core.disk.partition(arg.partition).getData();\n\t\t\t\t},\n\t\t\t\tlldaWrite: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"LLDISK_WRITE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.core.disk.partition(arg.partition).setData(arg.data);\n\t\t\t\t},\n\t\t\t\tlldaList: async function() {\n\t\t\t\t\tif (!privileges.includes(\"LLDISK_LIST_PARTITIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.core.disk.partitions();\n\t\t\t\t},\n\t\t\t\tlldaInitPartitions: async function() {\n\t\t\t\t\tif (!privileges.includes(\"LLDISK_INIT_PARTITIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.core.disk.insertPartitionTable();\n\t\t\t\t},\n\t\t\t\tlldaRemove: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"LLDISK_REMOVE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.core.disk.partition(arg.partition).remove();\n\t\t\t\t},\n\t\t\t\tlldaIDBRead: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"LLDISK_IDB_READ\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.core.idb.readPart(arg.key);\n\t\t\t\t},\n\t\t\t\tlldaIDBWrite: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"LLDISK_IDB_WRITE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tawait modules.core.idb.writePart(arg.key, arg.value);\n\t\t\t\t},\n\t\t\t\tlldaIDBRemove: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"LLDISK_IDB_REMOVE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tawait modules.core.idb.removePart(arg.key);\n\t\t\t\t},\n\t\t\t\tlldaIDBList: async function() {\n\t\t\t\t\tif (!privileges.includes(\"LLDISK_IDB_LIST\")) throw new Error(\"UNAUTHORIZED_ACTION\"); \n\t\t\t\t\treturn modules.core.idb.listParts(); \n\t\t\t\t},\n\t\t\t\tlldaIDBSync: async function() {\n\t\t\t\t\tif (!privileges.includes(\"LLDISK_IDB_SYNC\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tawait modules.core.idb.sync();\n\t\t\t\t},\n\t\t\t\tfs_mount: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"FS_MOUNT\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (modules.fs.mounts[arg.mountpoint]) throw new Error(\"MOUNT_EXISTS\");\n\t\t\t\t\tmodules.fs.mounts[arg.mountpoint] = await modules.mounts[arg.filesystem](arg.filesystemOptions);\n\t\t\t\t},\n\t\t\t\tsupportedFilesystems: async function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_FILESYSTEMS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn Object.keys(modules.mounts);\n\t\t\t\t},\n\t\t\t\tinstalledLocales: async function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_LOCALE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn Object.keys(modules.locales).filter(a => a != \"get\" && a != \"defaultLocale\");\n\t\t\t\t},\n\t\t\t\trunningServer: async function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_SERVER_URL\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn location.origin;\n\t\t\t\t},\n\t\t\t\tfs_isDirectory: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"FS_READ\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet {path, token} = arg;\n\t\t\t\t\treturn await fs_action(\"isDirectory\", (fsPermissions) => fsPermissions.owner == user || fsPermissions.world.includes(\"r\") || groups.includes(fsPermissions.group) || privileges.includes(\"FS_BYPASS_PERMISSIONS\"), path, token || processToken);\n\t\t\t\t},\n\t\t\t\tautomatedLogonCreate: async function(arg) {\n\t\t\t\t\tlet { desiredUser, token } = arg;\n\t\t\t\t\tif (!privileges.includes(\"ELEVATE_PRIVILEGES\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet automatedLogon = Array.from(crypto.getRandomValues(new Uint8Array(64))).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet access = await modules.users.access(desiredUser, token || processToken);\n\t\t\t\t\t\taccess = await access.getNextPrompt();\n\t\t\t\t\t\tautomatedLogonSessions[automatedLogon] = access;\n\t\t\t\t\t} catch {\n\t\t\t\t\t\tthrow new Error(\"AUTOMATED_LOGON_CREATE_FAILED\")\n\t\t\t\t\t}\n\t\t\t\t\treturn automatedLogon;\n\t\t\t\t},\n\t\t\t\tautomatedLogonGet: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"ELEVATE_PRIVILEGES\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet sharedObj = { ...automatedLogonSessions[arg] };\n\t\t\t\t\t\tdelete sharedObj.input;\n\t\t\t\t\t\treturn sharedObj;\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tthrow new Error(\"AUTOMATED_LOGON_GET_FAILED\");\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tautomatedLogonInput: async function(arg) {\n\t\t\t\t\tlet { session, input } = arg;\n\t\t\t\t\tif (!privileges.includes(\"ELEVATE_PRIVILEGES\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\tautomatedLogonSessions[session] = await automatedLogonSessions[session].input(input);\n\t\t\t\t\t} catch {\n\t\t\t\t\t\tthrow new Error(\"AUTOMATED_LOGON_INPUT_FAILED\");\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tautomatedLogonDelete: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"ELEVATE_PRIVILEGES\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tdelete automatedLogonSessions[arg];\n\t\t\t\t},\n\t\t\t\tsetSystemMount: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"SET_DEFAULT_SYSTEM\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tmodules.defaultSystem = arg;\n\t\t\t\t},\n\t\t\t\tusedRAM: async function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_SYSTEM_RESOURCES\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet mem = performance.memory;\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttotal: mem.jsHeapSizeLimit,\n\t\t\t\t\t\t\tused: mem.usedJSHeapSize,\n\t\t\t\t\t\t\tfree: mem.jsHeapSizeLimit - mem.usedJSHeapSize\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch {}\n\t\t\t\t\tlet mem = await performance.measureUserAgentSpecificMemory();\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttotal: Infinity,\n\t\t\t\t\t\tused: mem.bytes,\n\t\t\t\t\t\tfree: Infinity\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tcheckBootMode: async function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_BOOT_MODE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.core.bootMode || \"normal\";\n\t\t\t\t},\n\t\t\t\tgetScreenInfo: async function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_SCREEN_INFO\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn {\n\t\t\t\t\t\twidth: document.documentElement.clientWidth,\n\t\t\t\t\t\theight: document.documentElement.clientHeight,\n\t\t\t\t\t\tcolorDepth: screen.colorDepth,\n\t\t\t\t\t\torientation: {\n\t\t\t\t\t\t\ttype: screen.orientation.type,\n\t\t\t\t\t\t\tangle: screen.orientation.angle\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfullWidth: screen.width,\n\t\t\t\t\t\tfullHeight: screen.height,\n\t\t\t\t\t\tavailWidth: screen.availWidth,\n\t\t\t\t\t\tavailHeight: screen.availHeight,\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\twaitTermination: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"LIST_TASKS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.tasks.waitTermination(arg);\n\t\t\t\t},\n\t\t\t\tconsentGetToken: async function(params) {\n\t\t\t\t\tif (!privileges.includes(\"ELEVATE_PRIVILEGES\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (modules.session.attrib(ses, \"secureLock\")) await modules.session.attrib(ses, \"secureLock\");\n\t\t\t\t\tif (modules.session.active != ses) throw new Error(\"TRY_AGAIN_LATER\");\n\t\t\t\t\tlet { desiredUser, intent } = params;\n\t\t\t\t\tif (!intent) throw new Error(\"INTENT_REQUIRED\");\n\t\t\t\t\tlet releaseLock;\n\t\t\t\t\tlet lock = new Promise((resolve) => releaseLock = resolve);\n\t\t\t\t\tmodules.session.attrib(ses, \"secureLock\", lock);\n\t\t\t\t\tlet secureSession = await modules.session.mksession();\n\t\t\t\t\tmodules.session.attrib(ses, \"secureID\", secureSession);\n\t\t\t\t\tmodules.session.attrib(secureSession, \"language\", language);\n\n\t\t\t\t\tlet dom = modules.session.tracker[secureSession].html;\n\t\t\t\t\tlet ogDom = modules.session.tracker[ses].html;\n\t\t\t\t\tlet bgfx = document.createElement(\"div\");\n\t\t\t\t\tbgfx.classList.add(\"session\", \"secure\");\n\t\t\t\t\tdom.appendChild(bgfx);\n\t\t\t\t\tmodules.session.attrib(secureSession, \"dark\", modules.session.attrib(ses, \"dark\"));\n\t\t\t\t\tdom.style.background = ogDom.style.background;\n\t\t\t\t\tif (!dom.style.background) dom.style.background = \"black\";\n\t\t\t\t\tdom.style.backgroundSize = \"100% 100%\";\n\n\t\t\t\t\tmodules.session.muteAllSessions();\n\t\t\t\t\tmodules.session.activateSession(secureSession);\n\t\t\t\t\tlet task = await modules.tasks.taskInfo(taskId);\n\t\t\t\t\tlet preForked = undefined;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (privileges.includes(\"ELEVATE_PRIVILEGES_EZ\") && modules.liu[user]?.session == ses && desiredUser == user)\n\t\t\t\t\t\t\tpreForked = await modules.tokens.fork(modules.liu[user].logon.token);\n\t\t\t\t\t} catch {}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet logonUI = await modules.consentui(secureSession, {\n\t\t\t\t\t\t\tuser: desiredUser,\n\t\t\t\t\t\t\tpath: task.file,\n\t\t\t\t\t\t\targs: task.arg,\n\t\t\t\t\t\t\tintent,\n\t\t\t\t\t\t\tname: params.name,\n\t\t\t\t\t\t\tsessionToken: preForked\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn new Promise(function(resolve) {\n\t\t\t\t\t\t\tlogonUI.hook(async function(result) {\n\t\t\t\t\t\t\t\treleaseLock();\n\t\t\t\t\t\t\t\tmodules.session.attrib(ses, \"secureLock\", null);\n\t\t\t\t\t\t\t\tmodules.session.attrib(ses, \"secureID\", null);\n\t\t\t\t\t\t\t\tmodules.session.muteAllSessions();\n\t\t\t\t\t\t\t\tmodules.session.rmsession(secureSession);\n\t\t\t\t\t\t\t\tmodules.session.activateSession(ses);\n\t\t\t\t\t\t\t\tif (result.success == false) return resolve(false);\n\t\t\t\t\t\t\t\treturn resolve(result.token);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tconsole.error(\"consentui:\", e);\n\t\t\t\t\t\treleaseLock();\n\t\t\t\t\t\tmodules.session.attrib(ses, \"secureLock\", null);\n\t\t\t\t\t\tmodules.session.attrib(ses, \"secureID\", null);\n\t\t\t\t\t\tmodules.session.muteAllSessions();\n\t\t\t\t\t\tmodules.session.rmsession(secureSession);\n\t\t\t\t\t\tmodules.session.activateSession(ses);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tnetworkPing: async function(address) {\n\t\t\t\t\tif (!privileges.includes(\"PCOS_NETWORK_PING\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet websocketHandle = modules.network.ws;\n\t\t\t\t\tif (!websocketHandle) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\tlet websocket = modules.websocket._handles[websocketHandle].ws;\n\t\t\t\t\tif (websocket.readyState != 1) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\treturn Promise.race([ new Promise(async function(resolve, reject) {\n\t\t\t\t\t\tlet networkListenID = Array.from(crypto.getRandomValues(new Uint8Array(64))).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\t\tlet packetId = crypto.getRandomValues(new Uint8Array(16));\n\t\t\t\t\t\tlet resend = crypto.getRandomValues(new Uint8Array(64));\n\t\t\t\t\t\tfunction eventListener(e) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlet packet = new Uint8Array(e.data);\n\t\t\t\t\t\t\t\tif (u8aToHex(packet.slice(32, 48)) == u8aToHex(packetId)) {\n\t\t\t\t\t\t\t\t\tif (u8aToHex(packet.slice(0, 16)) == address && packet[48] == 1 && // Ping Protocol\n\t\t\t\t\t\t\t\t\t\tu8aToHex(packet.slice(50, 114)) == u8aToHex(resend)) resolve(\"success\");\n\t\t\t\t\t\t\t\t\telse reject(new Error(\"ADDRESS_UNREACHABLE\"));\n\t\t\t\t\t\t\t\t\tdelete networkListens[networkListenID];\n\t\t\t\t\t\t\t\t\twebsocket.removeEventListener(\"message\", eventListener);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnetworkListens[networkListenID] = { ws: websocket, fn: eventListener };\n\t\t\t\t\t\twebsocket.addEventListener(\"message\", eventListener);\n\t\t\t\t\t\tlet replyPacket = new Uint8Array(114);\n\t\t\t\t\t\treplyPacket.set(hexToU8A(modules.network.address), 0);\n\t\t\t\t\t\treplyPacket.set(hexToU8A(address), 16);\n\t\t\t\t\t\treplyPacket.set(packetId, 32);\n\t\t\t\t\t\treplyPacket.set(Uint8Array.from([ 1, 0 ]), 48); // Ping Protocol; not a pong\n\t\t\t\t\t\treplyPacket.set(resend, 50);\n\t\t\t\t\t\twebsocket.send(replyPacket);\n\t\t\t\t\t}), new Promise((_, reject) => modules.network.runOnClose.then(_ => reject(new Error(\"NETWORK_CLOSED\")))) ]);\n\t\t\t\t},\n\t\t\t\tlogOut: async function(desiredUser) {\n\t\t\t\t\tif (desiredUser != user && !privileges.includes(\"LOGOUT_OTHERS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (desiredUser == user && !privileges.includes(\"LOGOUT\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (modules.session.active != ses && !privileges.includes(\"LOGOUT_OTHERS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tawait modules.logOut(desiredUser);\n\t\t\t\t},\n\t\t\t\tlock: async function() {\n\t\t\t\t\tif (modules.session.active == ses && !privileges.includes(\"LOGOUT\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (modules.session.active != ses && !privileges.includes(\"LOGOUT_OTHERS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tmodules.session.muteAllSessions();\n\t\t\t\t\tmodules.session.activateSession(modules.session.systemSession);\n\t\t\t\t},\n\t\t\t\tgetPrivateData: () => privateData,\n\t\t\t\tlull: async function() {\n\t\t\t\t\tif (!privileges.includes(\"LULL_SYSTEM\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (modules.session.active != ses && !privileges.includes(\"LULL_SYSTEM_FORCE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tawait modules.lull();\n\t\t\t\t},\n\t\t\t\tconnlessListen: async function(gate) {\n\t\t\t\t\tif (!privileges.includes(\"CONNLESS_LISTEN\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!gate.startsWith(\"user_\") && !privileges.includes(\"CONNLESS_LISTEN_GLOBAL\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tgate = new TextEncoder().encode(gate);\n\t\t\t\t\tif (gate.length == 0 || gate.length > 255) throw new Error(\"INVALID_GATE_PARAMETER\");\n\t\t\t\t\tlet websocketHandle = modules.network.ws;\n\t\t\t\t\tif (!websocketHandle) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\tlet websocket = modules.websocket._handles[websocketHandle].ws;\n\t\t\t\t\tif (websocket.readyState != 1) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\treturn Promise.race([ new Promise(async function(resolve) {\n\t\t\t\t\t\tlet networkListenID = Array.from(crypto.getRandomValues(new Uint8Array(64))).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\t\tfunction eventListener(e) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlet packet = new Uint8Array(e.data);\n\t\t\t\t\t\t\t\tif (packet[48] == 2 && packet[49] == gate.length && u8aToHex(packet.slice(50, 50 + gate.length)) == u8aToHex(gate)) {\n\t\t\t\t\t\t\t\t\twebsocket.removeEventListener(\"message\", eventListener);\n\t\t\t\t\t\t\t\t\tdelete networkListens[networkListenID];\n\t\t\t\t\t\t\t\t\tresolve({\n\t\t\t\t\t\t\t\t\t\tfrom: u8aToHex(packet.slice(0, 16)),\n\t\t\t\t\t\t\t\t\t\tdata: packet.slice(50 + gate.length)\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnetworkListens[networkListenID] = { ws: websocket, fn: eventListener };\n\t\t\t\t\t\twebsocket.addEventListener(\"message\", eventListener);\n\t\t\t\t\t}), new Promise((_, reject) => modules.network.runOnClose.then(_ => reject(new Error(\"NETWORK_CLOSED\")))) ]);\n\t\t\t\t},\n\t\t\t\tconnlessSend: async function(sendOpts) {\n\t\t\t\t\tif (!privileges.includes(\"CONNLESS_SEND\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tsendOpts.gate = new TextEncoder().encode(sendOpts.gate);\n\t\t\t\t\tif (sendOpts.gate.length == 0 || sendOpts.gate.length > 255) throw new Error(\"INVALID_GATE_PARAMETER\");\n\t\t\t\t\tlet websocketHandle = modules.network.ws;\n\t\t\t\t\tif (!websocketHandle) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\tlet websocket = modules.websocket._handles[websocketHandle].ws;\n\t\t\t\t\tif (websocket.readyState != 1) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\tlet { gate, address, content } = sendOpts;\n\t\t\t\t\tlet packet = new Uint8Array(50 + gate.length + content.length);\n\t\t\t\t\tpacket.set(hexToU8A(modules.network.address), 0);\n\t\t\t\t\tpacket.set(hexToU8A(address), 16);\n\t\t\t\t\tpacket.set(Uint8Array.from([ 2, gate.length ]), 48); // Connectionless Protocol; gate length\n\t\t\t\t\tpacket.set(gate, 50);\n\t\t\t\t\tpacket.set(content, 50 + gate.length);\n\t\t\t\t\twebsocket.send(packet);\n\t\t\t\t},\n\t\t\t\tgetUsers: async function(token) {\n\t\t\t\t\tif (!privileges.includes(\"GET_USER_LIST\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn await modules.users.getUsers(token || processToken);\n\t\t\t\t},\n\t\t\t\tgetNetworkAddress: async function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_NETWORK_ADDRESS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.network.address;\n\t\t\t\t},\n\t\t\t\tconnfulListen: async function(listenOpts) {\n\t\t\t\t\tif (!privileges.includes(\"CONNFUL_LISTEN\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet { gate, key, private: privateKey, verifyClientKeyChain } = listenOpts;\n\t\t\t\t\tlet string_gate = gate;\n\t\t\t\t\tgate = new TextEncoder().encode(gate);\n\t\t\t\t\tif (gate.length < 1 || gate.length > 255) throw new Error(\"INVALID_GATE_PARAMETER\");\n\t\t\t\t\tif (!gate.startsWith(\"user_\") && !privileges.includes(\"CONNFUL_LISTEN_GLOBAL\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet websocketHandle = modules.network.ws;\n\t\t\t\t\tif (!websocketHandle) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\tlet websocket = modules.websocket._handles[websocketHandle].ws;\n\t\t\t\t\tif (websocket.readyState != 1) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\tlet networkListenID = Array.from(crypto.getRandomValues(new Uint8Array(64))).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\tlet usableKey = await crypto.subtle.importKey(\"jwk\", privateKey, { name: \"Ed25519\" }, true, [\"sign\"]);\n\t\t\t\t\tlet _connectionBufferReject = null;\n\t\t\t\t\tlet _connectionBufferPromise = null;\n\t\t\t\t\tlet connectionBufferPromise = new Promise((r, j) => [_connectionBufferPromise, _connectionBufferReject] = [r, j]);\n\t\t\t\t\tasync function eventListener(e) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlet gotPacket = new Uint8Array(e.data);\n\t\t\t\t\t\t\tif (gotPacket[48] != 3 || gotPacket[49] != 0) return; // Must be Connectionful Protocol and a client\n\t\t\t\t\t\t\tlet packetConnectionID = u8aToHex(gotPacket.slice(50, 66));\n\t\t\t\t\t\t\tif (gotPacket[66] == 0 && gotPacket[67] == gate.length && u8aToHex(gotPacket.slice(68, 68 + gotPacket[67])) == u8aToHex(gate)) {\n\t\t\t\t\t\t\t\t// Start, gate match\n\t\t\t\t\t\t\t\tif (connections[packetConnectionID + \":server\"]) return;\n\t\t\t\t\t\t\t\tlet ephemeralKey = await crypto.subtle.generateKey({ name: \"X25519\" }, true, [\"deriveBits\"]);\n\t\t\t\t\t\t\t\tlet exported = await crypto.subtle.exportKey(\"jwk\", ephemeralKey.publicKey);\n\t\t\t\t\t\t\t\texported = { signedBy: \"serverKey\", usages: [\"connfulSecureEphemeral\"], key: exported };\n\t\t\t\t\t\t\t\tlet signature = u8aToHex(new Uint8Array(await crypto.subtle.sign({\n\t\t\t\t\t\t\t\t\tname: \"Ed25519\"\n\t\t\t\t\t\t\t\t}, usableKey, new TextEncoder().encode(JSON.stringify(exported)))));\n\t\t\t\t\t\t\t\tlet packetContent = JSON.parse(new TextDecoder().decode(gotPacket.slice(68 + gate.length)));\n\t\t\t\t\t\t\t\tlet theirUsableKey = await crypto.subtle.importKey(\"jwk\", packetContent.keyInfo.key, { name: \"X25519\" }, true, []);\n\t\t\t\t\t\t\t\tlet joinedKeys = await crypto.subtle.deriveBits({ name: \"X25519\", public: theirUsableKey }, ephemeralKey.privateKey, 256);\n\t\t\t\t\t\t\t\tlet aesUsableKey = await crypto.subtle.importKey(\"raw\", joinedKeys, { name: \"AES-GCM\" }, true, [\"encrypt\", \"decrypt\"]);\n\t\t\t\t\t\t\t\tlet _dataBufferPromise = null, _rejectDataPromise = null;\n\t\t\t\t\t\t\t\tlet dataBufferPromise = new Promise((r, j) => [_dataBufferPromise, _rejectDataPromise] = [r, j]);\n\t\t\t\t\t\t\t\tconnections[packetConnectionID + \":server\"] = {\n\t\t\t\t\t\t\t\t\tourKey: ephemeralKey,\n\t\t\t\t\t\t\t\t\tfrom: u8aToHex(gotPacket.slice(0, 16)),\n\t\t\t\t\t\t\t\t\ttheirMainKeyReceived: false,\n\t\t\t\t\t\t\t\t\ttheirKeyRaw: packetContent,\n\t\t\t\t\t\t\t\t\taesUsableKey,\n\t\t\t\t\t\t\t\t\tdataBuffer: [],\n\t\t\t\t\t\t\t\t\tdataBufferPromise,\n\t\t\t\t\t\t\t\t\t_dataBufferPromise,\n\t\t\t\t\t\t\t\t\t_rejectDataPromise,\n\t\t\t\t\t\t\t\t\tnetworkListenID\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tlet theKey = new TextEncoder().encode(JSON.stringify({ keyInfo: exported, signature }));\n\t\t\t\t\t\t\t\tlet packet = new Uint8Array(67 + theKey.length);\n\t\t\t\t\t\t\t\tpacket.set(hexToU8A(modules.network.address), 0);\n\t\t\t\t\t\t\t\tpacket.set(gotPacket.slice(0, 16), 16);\n\t\t\t\t\t\t\t\tpacket.set(gotPacket.slice(32, 48), 32);\n\t\t\t\t\t\t\t\tpacket.set(Uint8Array.from([ 3, 255 ]), 48); // Connectionful Protocol; a server\n\t\t\t\t\t\t\t\tpacket.set(hexToU8A(packetConnectionID), 50);\n\t\t\t\t\t\t\t\tpacket.set(Uint8Array.from([ 0 ]), 66); // Start\n\t\t\t\t\t\t\t\tpacket.set(theKey, 67); // The key\n\t\t\t\t\t\t\t\twebsocket.send(packet);\n\t\t\t\t\t\t\t} else if (gotPacket[66] == 1) { // Xchange\n\t\t\t\t\t\t\t\tif (!connections.hasOwnProperty(packetConnectionID + \":server\")) return;\n\t\t\t\t\t\t\t\tif (connections[packetConnectionID + \":server\"].theirMainKeyReceived) return;\n\t\t\t\t\t\t\t\tif (connections[packetConnectionID + \":server\"].dying) return;\n\t\t\t\t\t\t\t\tlet theirMainKeyDecrypt = JSON.parse(new TextDecoder().decode(await crypto.subtle.decrypt({\n\t\t\t\t\t\t\t\t\tname: \"AES-GCM\",\n\t\t\t\t\t\t\t\t\tiv: gotPacket.slice(67, 79)\n\t\t\t\t\t\t\t\t}, connections[packetConnectionID + \":server\"].aesUsableKey, gotPacket.slice(79))));\n\t\t\t\t\t\t\t\tlet usableMainKey = await crypto.subtle.importKey(\"jwk\", theirMainKeyDecrypt.keyInfo.key, { name: \"Ed25519\" }, true, [\"verify\"]);\n\t\t\t\t\t\t\t\tlet verifyKeySignature = await crypto.subtle.verify({ name: \"Ed25519\" }, usableMainKey, hexToU8A(connections[packetConnectionID + \":server\"].theirKeyRaw.signature), new TextEncoder().encode(JSON.stringify(connections[packetConnectionID + \":server\"].theirKeyRaw.keyInfo)));\n\t\t\t\t\t\t\t\tif (verifyClientKeyChain && verifyKeySignature) {\n\t\t\t\t\t\t\t\t\tverifyKeySignature = false;\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tlet khrlFiles = await modules.fs.ls(modules.defaultSystem + \"/etc/keys/khrl\", processToken);\n\t\t\t\t\t\t\t\t\t\tlet khrlSignatures = [];\n\t\t\t\t\t\t\t\t\t\tfor (let khrlFile of khrlFiles) {\n\t\t\t\t\t\t\t\t\t\t\tlet khrl = JSON.parse(await modules.fs.read(modules.defaultSystem + \"/etc/keys/khrl/\" + khrlFile, processToken));\n\t\t\t\t\t\t\t\t\t\t\tlet khrlSignature = khrl.signature;\n\t\t\t\t\t\t\t\t\t\t\tdelete khrl.signature;\n\t\t\t\t\t\t\t\t\t\t\tif (await crypto.subtle.verify({ name: \"Ed25519\" }, modules.ksk_imported, hexToU8A(khrlSignature), new TextEncoder().encode(JSON.stringify(khrl.list)))) {\n\t\t\t\t\t\t\t\t\t\t\t\tkhrlSignatures.push(...khrl.list);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tverifyKeySignature = await recursiveKeyVerify(theirMainKeyDecrypt, khrlSignatures);\n\t\t\t\t\t\t\t\t\t} catch { }\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!verifyKeySignature || (!theirMainKeyDecrypt.keyInfo.usages.includes(\"connfulSecureClient:\" + connections[packetConnectionID + \":server\"].from) && \n\t\t\t\t\t\t\t\t\t\t!theirMainKeyDecrypt.keyInfo.usages.includes(\"connfulSecureClient:\" + connections[packetConnectionID + \":server\"].from + \":\" + string_gate))) {\n\t\t\t\t\t\t\t\t\tdelete connections[packetConnectionID + \":server\"];\n\t\t\t\t\t\t\t\t\tlet packet = new Uint8Array(67);\n\t\t\t\t\t\t\t\t\tpacket.set(hexToU8A(modules.network.address), 0);\n\t\t\t\t\t\t\t\t\tpacket.set(gotPacket.slice(0, 16), 16);\n\t\t\t\t\t\t\t\t\tpacket.set(gotPacket.slice(32, 48), 32);\n\t\t\t\t\t\t\t\t\tpacket.set(Uint8Array.from([ 3, 255 ]), 48); // Connectionful Protocol; a server\n\t\t\t\t\t\t\t\t\tpacket.set(hexToU8A(packetConnectionID), 50);\n\t\t\t\t\t\t\t\t\tpacket.set(Uint8Array.from([ 2 ]), 66); // Drop\n\t\t\t\t\t\t\t\t\treturn websocket.send(packet);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconnections[packetConnectionID + \":server\"].theirMainKeyReceived = theirMainKeyDecrypt;\n\t\t\t\t\t\t\t\tlet iv = crypto.getRandomValues(new Uint8Array(12));\n\t\t\t\t\t\t\t\tlet ct = new Uint8Array(await crypto.subtle.encrypt({\n\t\t\t\t\t\t\t\t\tname: \"AES-GCM\",\n\t\t\t\t\t\t\t\t\tiv\n\t\t\t\t\t\t\t\t}, connections[packetConnectionID + \":server\"].aesUsableKey, new TextEncoder().encode(JSON.stringify(key))));\n\t\t\t\t\t\t\t\tlet packet = new Uint8Array(79 + ct.byteLength);\n\t\t\t\t\t\t\t\tpacket.set(hexToU8A(modules.network.address), 0);\n\t\t\t\t\t\t\t\tpacket.set(gotPacket.slice(0, 16), 16);\n\t\t\t\t\t\t\t\tpacket.set(gotPacket.slice(32, 48), 32);\n\t\t\t\t\t\t\t\tpacket.set(Uint8Array.from([ 3, 255 ]), 48); // Connectionful Protocol; a server\n\t\t\t\t\t\t\t\tpacket.set(hexToU8A(packetConnectionID), 50);\n\t\t\t\t\t\t\t\tpacket.set(Uint8Array.from([ 1 ]), 66); // Xchange\n\t\t\t\t\t\t\t\tpacket.set(iv, 67);\n\t\t\t\t\t\t\t\tpacket.set(ct, 79);\n\t\t\t\t\t\t\t\twebsocket.send(packet);\n\t\t\t\t\t\t\t} else if (gotPacket[66] == 2) { // drop\n\t\t\t\t\t\t\t\tif (!connections.hasOwnProperty(packetConnectionID + \":server\")) return;\n\t\t\t\t\t\t\t\tif (connections[packetConnectionID + \":server\"].dying) return;\n\t\t\t\t\t\t\t\tlet packet = new Uint8Array(67);\n\t\t\t\t\t\t\t\tpacket.set(hexToU8A(modules.network.address), 0);\n\t\t\t\t\t\t\t\tpacket.set(gotPacket.slice(0, 16), 16);\n\t\t\t\t\t\t\t\tpacket.set(gotPacket.slice(32, 48), 32);\n\t\t\t\t\t\t\t\tpacket.set(Uint8Array.from([ 3, 255 ]), 48); // Connectionful Protocol; a server\n\t\t\t\t\t\t\t\tpacket.set(hexToU8A(packetConnectionID), 50);\n\t\t\t\t\t\t\t\tpacket.set(Uint8Array.from([ 2 ]), 66); // Drop\n\t\t\t\t\t\t\t\twebsocket.send(packet);\n\t\t\t\t\t\t\t\tif (connections[packetConnectionID + \":server\"]._rejectDataPromise)\n\t\t\t\t\t\t\t\t\tconnections[packetConnectionID + \":server\"]._rejectDataPromise(new Error(\"CONNECTION_DROPPED\"));\n\t\t\t\t\t\t\t\tconnections[packetConnectionID + \":server\"].dying = true;\n\t\t\t\t\t\t\t\tif (!connections[packetConnectionID + \":server\"].dataBuffer.length)\n\t\t\t\t\t\t\t\t\tdelete connections[packetConnectionID + \":server\"];\n\t\t\t\t\t\t\t} else if (gotPacket[66] == 4) {\n\t\t\t\t\t\t\t\tif (!connections.hasOwnProperty(packetConnectionID + \":server\")) return;\n\t\t\t\t\t\t\t\tif (!connections[packetConnectionID + \":server\"].theirMainKeyReceived) return;\n\t\t\t\t\t\t\t\tif (!connections[packetConnectionID + \":server\"].aesUsableKey) return;\n\t\t\t\t\t\t\t\tif (connections[packetConnectionID + \":server\"].dying) return;\n\t\t\t\t\t\t\t\tnetworkListens[networkListenID].connectionBuffer.push(packetConnectionID + \":server\");\n\t\t\t\t\t\t\t\tlet _curcbp = _connectionBufferPromise;\n\t\t\t\t\t\t\t\tconnectionBufferPromise = new Promise((r, j) => [_connectionBufferPromise, _connectionBufferReject] = [r, j]);\n\t\t\t\t\t\t\t\tnetworkListens[networkListenID].connectionBufferPromise = connectionBufferPromise;\n\t\t\t\t\t\t\t\t_curcbp();\n\t\t\t\t\t\t\t} else if (gotPacket[66] == 3) {\n\t\t\t\t\t\t\t\tif (!connections.hasOwnProperty(packetConnectionID + \":server\")) return;\n\t\t\t\t\t\t\t\tif (!connections[packetConnectionID + \":server\"].aesUsableKey) return;\n\t\t\t\t\t\t\t\tif (!connections[packetConnectionID + \":server\"].theirMainKeyReceived) return;\n\t\t\t\t\t\t\t\tif (connections[packetConnectionID + \":server\"].dying) return;\n\t\t\t\t\t\t\t\tif (connections[packetConnectionID + \":server\"].writingLock) await connections[packetConnectionID + \":server\"].writingLock;\n\t\t\t\t\t\t\t\tlet writingLockRelease;\n\t\t\t\t\t\t\t\tlet writingLock = new Promise(r => writingLockRelease = r);\n\t\t\t\t\t\t\t\tconnections[packetConnectionID + \":server\"].writingLock = writingLock;\n\t\t\t\t\t\t\t\tconnections[packetConnectionID + \":server\"].dataBuffer.push(new Uint8Array(await crypto.subtle.decrypt({\n\t\t\t\t\t\t\t\t\tname: \"AES-GCM\",\n\t\t\t\t\t\t\t\t\tiv: gotPacket.slice(67, 79)\n\t\t\t\t\t\t\t\t}, connections[packetConnectionID + \":server\"].aesUsableKey, gotPacket.slice(79))));\n\t\t\t\t\t\t\t\tif (!(connections[connID + \":server\"].dataBuffer.length - 1)) {\n\t\t\t\t\t\t\t\t\tlet _curdbp = connections[packetConnectionID + \":server\"].dataBufferPromise;\n\t\t\t\t\t\t\t\t\tlet _dataBufferPromise = null, _rejectDataPromise = null;\n\t\t\t\t\t\t\t\t\tlet dataBufferPromise = new Promise((r, e) => [_dataBufferPromise, _rejectDataPromise] = [r, e]);\n\t\t\t\t\t\t\t\t\tconnections[packetConnectionID + \":server\"].dataBufferPromise = dataBufferPromise;\n\t\t\t\t\t\t\t\t\tconnections[packetConnectionID + \":server\"]._dataBufferPromise = _dataBufferPromise;\n\t\t\t\t\t\t\t\t\tconnections[packetConnectionID + \":server\"]._rejectDataPromise = _rejectDataPromise;\n\t\t\t\t\t\t\t\t\t_curdbp();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twritingLockRelease();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch { }\n\t\t\t\t\t}\n\t\t\t\t\tnetworkListens[networkListenID] = { ws: websocket, gate: gate, fn: eventListener, connectionBuffer: [], connectionBufferPromise }\n\t\t\t\t\tmodules.network.runOnClose.then(function () {\n\t\t\t\t\t\tfor (let connectionID in connections) if (connections[connectionID].networkListenID == networkListenID) {\n\t\t\t\t\t\t\tconnections[connectionID].dying = true;\n\t\t\t\t\t\t\tconnections[connectionID]._rejectDataPromise(new Error(\"NETWORK_CLOSED\"));\n\t\t\t\t\t\t\tif (!connections[connectionID].dataBuffer.length) delete connections[connectionID];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdelete networkListens[networkListenID];\n\t\t\t\t\t\t_connectionBufferReject(new Error(\"NETWORK_CLOSED\"));\n\t\t\t\t\t});\n\t\t\t\t\twebsocket.addEventListener(\"message\", eventListener);\n\t\t\t\t\treturn networkListenID;\n\t\t\t\t},\n\t\t\t\tconnfulListenConnections: async function(networkListenID) {\n\t\t\t\t\tif (!privileges.includes(\"CONNFUL_LISTEN\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!networkListens.hasOwnProperty(networkListenID)) throw new Error(\"INVALID_LISTEN_ID\");\n\t\t\t\t\tif (!networkListens[networkListenID].connectionBuffer.length) await networkListens[networkListenID].connectionBufferPromise;\n\t\t\t\t\tlet connectionID = networkListens[networkListenID].connectionBuffer[0];\n\t\t\t\t\tnetworkListens[networkListenID].connectionBuffer = networkListens[networkListenID].connectionBuffer.slice(1);\n\t\t\t\t\treturn connectionID;\n\t\t\t\t},\n\t\t\t\tgetBuildTime: function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_BUILD\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.build_time;\n\t\t\t\t},\n\t\t\t\tconnfulConnect: async function(connOpts) {\n\t\t\t\t\tif (!privileges.includes(\"CONNFUL_CONNECT\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn connfulConnect(connOpts);\n\t\t\t\t},\n\t\t\t\tconnfulConnectionSettled: async function(connectionID) {\n\t\t\t\t\tif (!privileges.includes(\"CONNFUL_CONNECT\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!connections.hasOwnProperty(connectionID)) throw new Error(\"NO_SUCH_CONNECTION\");\n\t\t\t\t\tawait connections[connectionID].settlePromise;\n\t\t\t\t},\n\t\t\t\tconnfulDisconnect: async function(connectionID) {\n\t\t\t\t\tif (!privileges.includes(\"CONNFUL_DISCONNECT\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn connfulDisconnect(connectionID);\n\t\t\t\t},\n\t\t\t\tconnfulForceDisconnect: async function(connectionID) {\n\t\t\t\t\tif (!privileges.includes(\"CONNFUL_DISCONNECT\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tdelete connections[connectionID];\n\t\t\t\t},\n\t\t\t\tconnfulWrite: async function(sendOpts) {\n\t\t\t\t\tif (!privileges.includes(\"CONNFUL_WRITE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn connfulWrite(sendOpts);\n\t\t\t\t},\n\t\t\t\tconnfulRead: async function(connectionID) {\n\t\t\t\t\tif (!privileges.includes(\"CONNFUL_READ\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn connfulRead(connectionID);\n\t\t\t\t},\n\t\t\t\tconnfulAddressGet: async function(connectionID) {\n\t\t\t\t\tif (!privileges.includes(\"CONNFUL_ADDRESS_GET\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!connections.hasOwnProperty(connectionID)) throw new Error(\"NO_SUCH_CONNECTION\");\n\t\t\t\t\treturn connections[connectionID].from;\n\t\t\t\t},\n\t\t\t\tconnfulIdentityGet: async function(connectionID) {\n\t\t\t\t\tif (!privileges.includes(\"CONNFUL_IDENTITY_GET\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!connections.hasOwnProperty(connectionID)) throw new Error(\"NO_SUCH_CONNECTION\");\n\t\t\t\t\treturn connections[connectionID].theirMainKeyReceived;\n\t\t\t\t},\n\t\t\t\tsystemUptime: async function() {\n\t\t\t\t\tif (!privileges.includes(\"SYSTEM_UPTIME\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn Math.floor(performance.now());\n\t\t\t\t},\n\t\t\t\tnetworkRawWrite: function(data) {\n\t\t\t\t\tif (!privileges.includes(\"NETWORK_RAW_WRITE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet websocketHandle = modules.network.ws;\n\t\t\t\t\tif (!websocketHandle) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\tlet websocket = modules.websocket._handles[websocketHandle].ws;\n\t\t\t\t\tif (websocket.readyState != 1) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\twebsocket.send(data);\n\t\t\t\t},\n\t\t\t\tnetworkRawRead: function() {\n\t\t\t\t\tif (!privileges.includes(\"NETWORK_RAW_READ\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet websocketHandle = modules.network.ws;\n\t\t\t\t\tif (!websocketHandle) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\tlet websocket = modules.websocket._handles[websocketHandle].ws;\n\t\t\t\t\tif (websocket.readyState != 1) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\treturn Promise.race([ new Promise(async function(resolve) {\n\t\t\t\t\t\tnetworkListens[networkListenID] = { ws: websocket, fn: _ => resolve(_.data) };\n\t\t\t\t\t\twebsocket.addEventListener(\"message\", eventListener);\n\t\t\t\t\t}), new Promise((_, reject) => modules.network.runOnClose.then(_ => reject(new Error(\"NETWORK_CLOSED\")))) ]);\n\t\t\t\t},\n\t\t\t\tgetHostname: async function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_HOSTNAME\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.network.hostname;\n\t\t\t\t},\n\t\t\t\tresolve: async function(name) {\n\t\t\t\t\tif (!privileges.includes(\"RESOLVE_NAME\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet websocketHandle = modules.network.ws;\n\t\t\t\t\tif (!websocketHandle) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\tlet websocket = modules.websocket._handles[websocketHandle].ws;\n\t\t\t\t\tif (websocket.readyState != 1) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\tlet tlds = JSON.parse(await modules.fs.read(modules.defaultSystem + \"/etc/tlds.json\"));\n\t\t\t\t\tasync function resolveRecursive(name, address) {\n\t\t\t\t\t\tif (tlds.hasOwnProperty(name)) return tlds[name];\n\t\t\t\t\t\tif (address == null) return null;\n\t\t\t\t\t\tlet connectionID = await connfulConnect({\n\t\t\t\t\t\t\taddress, gate: \"resolve\",\n\t\t\t\t\t\t\tverifyByDomain: name.split(\".\").slice(1).join(\".\")\n\t\t\t\t\t\t});\n\t\t\t\t\t\tawait connections[connectionID].settlePromise;\n\t\t\t\t\t\tawait connfulWrite({ connectionID, data: new TextEncoder().encode(name) });\n\t\t\t\t\t\tlet resultAddress = u8aToHex(await connfulRead(connectionID)) || null;\n\t\t\t\t\t\tconnfulDisconnect(connectionID);\n\t\t\t\t\t\treturn resultAddress;\n\t\t\t\t\t}\n\t\t\t\t\tlet nameParts = name.split(\".\").reverse();\n\t\t\t\t\tlet currentResolve;\n\t\t\t\t\tfor (let part = 0; part < nameParts.length; part++) currentResolve = await resolveRecursive(nameParts.slice(0, part + 1).reverse().join(\".\"), currentResolve);\n\t\t\t\t\treturn currentResolve;\n\t\t\t\t},\n\t\t\t\tpatchDiff: function(libraryOptions) {\n\t\t\t\t\tif (!privileges.includes(\"PATCH_DIFF\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!window.diff) throw new Error(\"MODULE_REQUIRED\");\n\t\t\t\t\tlet operations = { diff_core, diff, lcs, calcPatch, applyPatch, calcSlices };\n\t\t\t\t\treturn [ ...operations[libraryOptions.operation](...libraryOptions.args) ];\n\t\t\t\t},\n\t\t\t\tsetFirmware: async function(new_flash) {\n\t\t\t\t\tif (!privileges.includes(\"SET_FIRMWARE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (modules.core.setFW) {\n\t\t\t\t\t\tawait modules.core.setFW(new_flash);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tlocalStorage.setItem(\"runtime_flash\", new_flash);\n\t\t\t\t},\n\t\t\t\treloadNetworkConfig: async function() {\n\t\t\t\t\tif (!privileges.includes(\"RELOAD_NETWORK_CONFIG\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tawait modules.network.reloadConfig();\n\t\t\t\t},\n\t\t\t\tbatteryStatus: async function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_BATTERY_STATUS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet battery = await navigator.getBattery();\n\t\t\t\t\treturn {\n\t\t\t\t\t\tcharging: battery.charging,\n\t\t\t\t\t\tlevel: battery.level,\n\t\t\t\t\t\tchargingTime: battery.chargingTime,\n\t\t\t\t\t\tdischargingTime: battery.dischargingTime\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\tgetUpdateService: async function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_UPDATE_SERVICE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.network.updates;\n\t\t\t\t},\n\t\t\t\tgetRootKey: function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_ROOT_KEY\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.ksk;\n\t\t\t\t},\n\t\t\t\tdesktopDark: function(desiredMode) {\n\t\t\t\t\tif (!privileges.includes(\"GRAB_ATTENTION\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tmodules.session.attrib(ses, \"dark\", !!desiredMode);\n\t\t\t\t},\n\t\t\t\tsetWallpaper: function(wallpaperString) {\n\t\t\t\t\tif (!privileges.includes(\"GRAB_ATTENTION\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet dom = modules.session.tracker[ses].html;\n\t\t\t\t\tdom.style.background = \"url(\" + JSON.stringify(wallpaperString) + \")\";\n\t\t\t\t\tif (!dom.style.background) dom.style.background = \"black\";\n\t\t\t\t\tdom.style.backgroundSize = \"100% 100%\";\n\t\t\t\t},\n\t\t\t\tsetWinLocale: function(desiredLanguage) {\n\t\t\t\t\tif (!privileges.includes(\"GET_LOCALE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlanguage = desiredLanguage;\n\t\t\t\t},\n\t\t\t\tsetUILocale: function(desiredLanguage) {\n\t\t\t\t\tif (!privileges.includes(\"GRAB_ATTENTION\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tmodules.session.attrib(ses, \"language\", desiredLanguage);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlet customAPIs = modules.customAPIs;\n\t\tif (customAPIs) {\n\t\t\tfor (let api in (customAPIs.public || {})) apis.public[api] = async (...args) => customAPIs.public[api](processToken, ...args);\n\t\t\tfor (let api in (customAPIs.private || {})) apis.private[api] = async (...args) => customAPIs.private[api](processToken, ...args);\n\t\t}\n\t\treturn apis;\n\t}\n}\nreeAPIs();","2027051c071bf8b2c212789a7e0e38262bc353340b87d477ff7391a2ad0320f182dceeae68c0cc5d5621d2739ad8ed369d7bb62ba8bfb2c01ad75d022a01c517":"function loadBasicCSP() {\n\tmodules.csps = {};\n\tlet cryptoKeys = {};\n\tfunction cryptoKeyIntoKeyObject(ck, groupBy) {\n\t\tif (ck.privateKey && ck.publicKey) return {\n\t\t\tprivateKey: cryptoKeyIntoKeyObject(ck.privateKey, groupBy),\n\t\t\tpublicKey: cryptoKeyIntoKeyObject(ck.publicKey, groupBy),\n\t\t};\n\t\tlet keyID = crypto.getRandomValues(new Uint8Array(64)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\tif (!cryptoKeys.hasOwnProperty(groupBy)) cryptoKeys[groupBy] = {};\n\t\tcryptoKeys[groupBy][keyID] = ck;\n\t\treturn {\n\t\t\ttype: ck.type,\n\t\t\textractable: ck.extractable,\n\t\t\talgorithm: ck.algorithm,\n\t\t\tusages: ck.usages,\n\t\t\tkeyID: keyID\n\t\t}\n\t}\n\tmodules.csps.basic = {\n\t\tcspMetadata: function() {\n\t\t\treturn {\n\t\t\t\tname: \"Basic Cryptographic Provider\",\n\t\t\t\tversion: modules.pcos_version,\n\t\t\t\tdeveloper: \"PCsoft\",\n\t\t\t\tfeatures: Object.keys(modules.csps.basic)\n\t\t\t}\n\t\t},\n\t\trandom: async function(typedArray) {\n\t\t\treturn crypto.getRandomValues(typedArray);\n\t\t},\n\t\timportKey: async function(arg, groupBy) {\n\t\t\treturn cryptoKeyIntoKeyObject(await crypto.subtle.importKey(arg.format, arg.keyData, arg.algorithm, arg.extractable, arg.keyUsages), groupBy);\n\t\t},\n\t\tgenerateKey: async function(arg, groupBy) {\n\t\t\treturn cryptoKeyIntoKeyObject(await crypto.subtle.generateKey(arg.algorithm, arg.extractable, arg.keyUsages), groupBy);\n\t\t},\n\t\tderiveBits: async function(arg, groupBy) {\n\t\t\targ.baseKey = cryptoKeys[groupBy][arg.baseKey.keyID];\n\t\t\tif (arg.algorithm.public) arg.algorithm.public = cryptoKeys[groupBy][arg.algorithm.public.keyID];\n\t\t\treturn crypto.subtle.deriveBits(arg.algorithm, arg.baseKey, arg.length);\n\t\t},\n\t\tderiveKey: async function(arg, groupBy) {\n\t\t\targ.baseKey = cryptoKeys[groupBy][arg.baseKey.keyID];\n\t\t\tif (arg.algorithm.public) arg.algorithm.public = cryptoKeys[groupBy][arg.algorithm.public.keyID];\n\t\t\treturn cryptoKeyIntoKeyObject(await crypto.subtle.deriveKey(arg.algorithm, arg.baseKey, arg.derivedKeyType, arg.extractable, arg.keyUsages), groupBy);\n\t\t},\n\t\twrapKey: async function(arg, groupBy) {\n\t\t\targ.key = cryptoKeys[groupBy][arg.key.keyID];\n\t\t\targ.wrappingKey = cryptoKeys[groupBy][arg.wrappingKey.keyID];\n\t\t\treturn crypto.subtle.wrapKey(arg.format, arg.key, arg.wrappingKey, arg.wrapAlgorithm);\n\t\t},\n\t\tdigest: async function(arg) {\n\t\t\treturn crypto.subtle.digest(arg.algorithm, arg.data);\n\t\t},\n\t\tencrypt: async function(arg, groupBy) {\n\t\t\targ.key = cryptoKeys[groupBy][arg.key.keyID];\n\t\t\treturn crypto.subtle.encrypt(arg.algorithm, arg.key, arg.data);\n\t\t},\n\t\tsign: async function(arg, groupBy) {\n\t\t\targ.key = cryptoKeys[groupBy][arg.key.keyID];\n\t\t\treturn crypto.subtle.sign(arg.algorithm, arg.key, arg.data);\n\t\t},\n\t\texportKey: async function(arg, groupBy) {\n\t\t\targ.key = cryptoKeys[groupBy][arg.key.keyID];\n\t\t\treturn crypto.subtle.exportKey(arg.format, arg.key);\n\t\t},\n\t\tunwrapKey: async function(arg, groupBy) {\n\t\t\targ.unwrappingKey = cryptoKeys[groupBy][arg.unwrappingKey.keyID];\n\t\t\treturn cryptoKeyIntoKeyObject(await crypto.subtle.unwrapKey(arg.format, arg.keyData, arg.unwrappingKey, arg.unwrapAlgorithm, arg.unwrappedKeyAlgorithm, arg.extractable, arg.keyUsages), groupBy);\n\t\t},\n\t\tdecrypt: async function(arg, groupBy) {\n\t\t\targ.key = cryptoKeys[groupBy][arg.key.keyID];\n\t\t\treturn crypto.subtle.decrypt(arg.algorithm, arg.key, arg.data);\n\t\t},\n\t\tverify: async function(arg, groupBy) {\n\t\t\targ.key = cryptoKeys[groupBy][arg.key.keyID];\n\t\t\treturn crypto.subtle.verify(arg.algorithm, arg.key, arg.signature, arg.data);\n\t\t},\n\t\tunloadKey: (key, groupBy) => delete cryptoKeys[groupBy][key.keyID],\n\t\tremoveSameGroupKeys: (_, groupBy) => delete cryptoKeys[groupBy]\n\t}\n\tif (window.nacl) {\n\t\tmodules.csps.tweetnacl = {\n\t\t\tcspMetadata: function() {\n\t\t\t\treturn {\n\t\t\t\t\tname: \"TweetNaCl Cryptographic Provider\",\n\t\t\t\t\tversion: \"1.0.3\",\n\t\t\t\t\tdeveloper: \"TweetNaCl.js developers (https://github.com/dchest/tweetnacl-js)\",\n\t\t\t\t\tfeatures: Object.keys(modules.csps.tweetnacl)\n\t\t\t\t}\n\t\t\t},\n\t\t\trandom: typedArray => nacl.randomBytes(typedArray.length),\n\t\t\tgenerateKey: type => nacl[type].keyPair(),\n\t\t\tderiveKey: arg => nacl[arg.type].keyPair.fromSeed(arg.seed),\n\t\t\tdigest: message => nacl.hash(message),\n\t\t\tencrypt: arg => nacl[arg.type](arg.message, arg.nonce, arg.key1, arg.key2),\n\t\t\tsign: arg => nacl.sign.detached(arg.message, arg.secretKey),\n\t\t\tdecrypt: arg => nacl[arg.type].open(arg.box, arg.nonce, arg.key1, arg.key2),\n\t\t\tverify: arg => nacl.sign.detached.verify(arg.message, arg.signature, arg.publicKey)\n\t\t};\n\t}\n}\nloadBasicCSP();","713bf8a46ba4d7e575011798d624d29832ea66ad2c06ea2f6dce99348226d82629aca81cee1036c731f9c3f640f9bd1112d568183bb2760b57e47ae977edc4a1":"function localization() {\n\t// @pcos-app-mode native\n\tlet locales = {\n\t\tget: function(key, lang) {\n\t\t\tlang = lang || locales.defaultLocale || navigator.languages[0].split(\"-\")[0].toLowerCase();\n\t\t\tlet locale = locales[lang];\n\t\t\tif (!locale) locale = locales[locales.defaultLocale || \"en\"];\n\t\t\tif (!locale) locale = {};\n\t\t\tif (!locale.hasOwnProperty(key)) locale = locales[locales.defaultLocale || \"en\"] || {};\n\t\t\treturn locale.hasOwnProperty(key) ? locale[key] : key;\n\t\t},\n\t\tdefaultLocale: navigator.languages[0].split(\"-\")[0].toLowerCase()\n\t}\n\tmodules.locales = locales;\n}\nlocalization();","7d115335d9e4d96d74b8a56d393179b0d0a0c8ff760d5dfb0177e79a61ec757c677f3f8230fd2d184a61943fef53c2378e0dcc40af484b33824fd63982011328":"function loadTasks() {\n\t// @pcos-app-mode native\n\tmodules.startupWindow.content.innerText = modules.locales.get(\"PCOS_STARTING\");\n\tlet tasks = {\n\t\texec: async function(file, arg, windowObject, token, silent, privateData) {\n\t\t\tlet errorAudio = new Audio();\n\t\t\ttry {\n\t\t\t\tlet errorSoundPerm = await modules.fs.permissions(modules.defaultSystem + \"/etc/sounds/error.aud\", token);\n\t\t\t\tif (!errorSoundPerm.world.includes(\"r\")) throw new Error(\"Not allowed to read error.aud\");\n\t\t\t\tlet errorSound = await modules.fs.read(modules.defaultSystem + \"/etc/sounds/error.aud\", token);\n\t\t\t\terrorAudio.src = errorSound;\n\t\t\t} catch {}\n\t\t\tif (modules.session.attrib(windowObject.sessionId, \"loggingOut\")) throw new Error(\"LOGGING_OUT\");\n\t\t\tlet language = modules.session.attrib(windowObject.sessionId, \"language\") || undefined;\n\t\t\tif (modules.shuttingDown) {\n\t\t\t\twindowObject.windowDiv.remove();\n\t\t\t\tthrow new Error(\"SYSTEM_SHUTDOWN_REQUESTED\");\n\t\t\t}\n\t\t\tlet appRedirecting = {};\n\t\t\ttry {\n\t\t\t\tappRedirecting = JSON.parse(await this.fs.read(modules.defaultSystem + \"/etc/appRedir\", token));\n\t\t\t} catch {}\n\t\t\tif (modules.core.bootMode == \"safe\") appRedirecting = {};\n\t\t\tif (appRedirecting.hasOwnProperty(file)) file = appRedirecting[file];\n\t\t\twindowObject.title.innerText = modules.locales.get(\"UNTITLED_APP\", language);\n\t\t\twindowObject.content.innerText = \"\";\n\t\t\twindowObject.content.style = \"\";\n\t\t\tlet taskId = crypto.getRandomValues(new Uint8Array(64)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\tlet executablePermissions, executable;\n\t\t\ttry {\n\t\t\t\texecutablePermissions = await this.fs.permissions(file, token);\n\t\t\t\texecutable = await this.fs.read(file, token);\n\t\t\t} catch (e) {\n\t\t\t\twindowObject.title.innerText = modules.locales.get(\"APP_STARTUP_CRASH_TITLE\", language);\n\t\t\t\twindowObject.content.innerText = modules.locales.get(\"APP_STARTUP_CRASH\", language);\n\t\t\t\twindowObject.content.style.padding = \"8px\";\n\t\t\t\twindowObject.closeButton.disabled = false;\n\t\t\t\twindowObject.closeButton.onclick = (e) => windowObject.windowDiv.remove() && e.stopPropagation();\n\t\t\t\tif (silent) windowObject.windowDiv.remove();\n\t\t\t\tif (!silent) errorAudio.play();\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\tif (!executablePermissions.world.includes(\"r\") || !executablePermissions.world.includes(\"x\")) {\n\t\t\t\twindowObject.title.innerText = modules.locales.get(\"PERMISSION_DENIED\", language);\n\t\t\t\twindowObject.content.innerText = modules.locales.get(\"MORE_PERMISSION_DENIED\", language);\n\t\t\t\twindowObject.content.style.padding = \"8px\";\n\t\t\t\twindowObject.closeButton.disabled = false;\n\t\t\t\twindowObject.closeButton.onclick = (e) => windowObject.windowDiv.remove() && e.stopPropagation();\n\t\t\t\tif (silent) windowObject.windowDiv.remove();\n\t\t\t\tif (!silent) errorAudio.play();\n\t\t\t\tthrow new Error(\"MORE_PERMISSION_DENIED\", language);\n\t\t\t}\n\t\t\tif (!executable.includes(\"// @pcos-app-mode isolat\" + \"able\")) {\n\t\t\t\twindowObject.title.innerText = modules.locales.get(\"COMPATIBILITY_ISSUE_TITLE\", language);\n\t\t\t\twindowObject.content.innerText = modules.locales.get(\"COMPATIBILITY_ISSUE\", language);\n\t\t\t\twindowObject.content.style.padding = \"8px\";\n\t\t\t\twindowObject.closeButton.disabled = false;\n\t\t\t\twindowObject.closeButton.onclick = (e) => windowObject.windowDiv.remove() && e.stopPropagation();\n\t\t\t\tif (silent) windowObject.windowDiv.remove();\n\t\t\t\tif (!silent) errorAudio.play();\n\t\t\t\tthrow new Error(\"COMPATIBILITY_ISSUE\");\n\t\t\t}\n\t\t\tlet appHardening = {overridable:true};\n\t\t\ttry {\n\t\t\t\tappHardening = JSON.parse(await this.fs.read(modules.defaultSystem + \"/etc/appHarden\", token));\n\t\t\t} catch {}\n\t\t\tlet disableHarden = appHardening.overridable && modules.core.bootMode == \"disable-harden\";\n\t\t\tif (disableHarden) appHardening = {overridable:true};\n\t\t\tlet limitations = [];\n\t\t\tlet execSignature = {};\n\t\t\tif (executable.includes(\"// =====BEGIN MANIFEST=====\")) {\n\t\t\t\tlet parsingLines = executable.split(\"\\n\");\n\t\t\t\tlet parsingBoundStart = parsingLines.indexOf(\"// =====BEGIN MANIFEST=====\");\n\t\t\t\tlet parsingBoundEnd = parsingLines.indexOf(\"// =====END MANIFEST=====\");\n\t\t\t\tlet upToParse = parsingLines.slice(parsingBoundStart, parsingBoundEnd + 1);\n\t\t\t\tlet knownLineTypes = [\"allow\", \"deny\"];\n\t\t\t\tfor (let line of upToParse) {\n\t\t\t\t\tlet lineType = line.split(\": \")[0].replace(\"// \", \"\");\n\t\t\t\t\tlet lineData = line.replace(\"// \" + lineType + \": \", \"\");\n\t\t\t\t\tif (lineType == \"signature\") {\n\t\t\t\t\t\texecSignature.signature = lineData;\n\t\t\t\t\t\texecutable = executable.replace(line + \"\\n\", \"\");\n\t\t\t\t\t}\n\t\t\t\t\tif (lineType == \"signer\") execSignature.signer = lineData;\n\t\t\t\t\tif (lineType == \"asck\") execSignature.selfContainedSigner = lineData;\n\t\t\t\t\tif (knownLineTypes.includes(lineType)) {\n\t\t\t\t\t\tlet dataParts = lineData.split(\", \");\n\t\t\t\t\t\tfor (let data of dataParts) limitations.push({ lineType, data });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (disableHarden) limitations = [];\n\t\t\tlet hexToU8A = (hex) => Uint8Array.from(hex.match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\tlet u8aToHex = (u8a) => Array.from(u8a).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\tif (!limitations.some(lim => lim.lineType == \"allow\") && appHardening.requireAllowlist && !disableHarden) {\n\t\t\t\twindowObject.title.innerText = modules.locales.get(\"PERMISSION_DENIED\", language);\n\t\t\t\twindowObject.content.innerText = modules.locales.get(\"NO_APP_ALLOWLIST\", language);\n\t\t\t\twindowObject.content.style.padding = \"8px\";\n\t\t\t\twindowObject.closeButton.disabled = false;\n\t\t\t\twindowObject.closeButton.onclick = (e) => windowObject.windowDiv.remove() && e.stopPropagation();\n\t\t\t\tif (silent) windowObject.windowDiv.remove();\n\t\t\t\tif (!silent) errorAudio.play();\n\t\t\t\tthrow new Error(\"NO_APP_ALLOWLIST\");\n\t\t\t}\n\n\t\t\tasync function recursiveKeyVerify(key, khrl) {\n\t\t\t\tif (!key) throw new Error(\"NO_KEY\");\n\t\t\t\tif (key.keyInfo.dates?.since > Date.now()) throw new Error(\"KEY_NOT_IN_TIME\");\n\t\t\t\tif (Date.now() > key.keyInfo.dates?.until) throw new Error(\"KEY_NOT_IN_TIME\");\n\t\t\t\tlet u8aToHex = (u8a) => Array.from(u8a).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\tlet hash = u8aToHex(new Uint8Array(await crypto.subtle.digest(\"SHA-256\", new TextEncoder().encode((key.keyInfo.key).x))));\n\t\t\t\tlet hexToU8A = (hex) => Uint8Array.from(hex.match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\t\tif (khrl.includes(hash)) throw new Error(\"KEY_REVOKED\");\n\t\t\t\tlet signedByKey = modules.ksk_imported;\n\t\t\t\tif (key.keyInfo.signedBy) {\n\t\t\t\t\tsignedByKey = JSON.parse(await modules.fs.read(modules.defaultSystem + \"/etc/keys/\" + key.keyInfo.signedBy, token));\n\t\t\t\t\tif (!signedByKey.keyInfo.usages.includes(\"keyTrust\")) throw new Error(\"NOT_KEY_AUTHORITY\");\n\t\t\t\t\tawait recursiveKeyVerify(signedByKey, khrl);\n\t\t\t\t\tsignedByKey = await crypto.subtle.importKey(\"jwk\", signedByKey.keyInfo.key, { name: \"Ed25519\" }, false, [\"verify\"]);\n\t\t\t\t}\n\t\t\t\tif (!await crypto.subtle.verify({ name: \"Ed25519\" }, signedByKey, hexToU8A(key.signature), new TextEncoder().encode(JSON.stringify(key.keyInfo)))) throw new Error(\"KEY_SIGNATURE_VERIFICATION_FAILED\");\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tlet friendlyName;\n\t\t\tif ((execSignature.signer || appHardening.requireSignature || execSignature.selfContainedSigner) && !disableHarden) {\n\t\t\t\ttry {\n\t\t\t\t\tlet khrlFiles = await this.fs.ls(modules.defaultSystem + \"/etc/keys/khrl\", token);\n\t\t\t\t\tlet khrlSignatures = [];\n\t\t\t\t\tfor (let khrlFile of khrlFiles) {\n\t\t\t\t\t\tlet khrl = JSON.parse(await this.fs.read(modules.defaultSystem + \"/etc/keys/khrl/\" + khrlFile, token));\n\t\t\t\t\t\tlet khrlSignature = khrl.signature;\n\t\t\t\t\t\tdelete khrl.signature;\n\t\t\t\t\t\tif (await crypto.subtle.verify({ name: \"Ed25519\" }, modules.ksk_imported, hexToU8A(khrlSignature), new TextEncoder().encode(JSON.stringify(khrl.list)))) {\n\t\t\t\t\t\t\tkhrlSignatures.push(...khrl.list);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlet signingKey = JSON.parse(execSignature.selfContainedSigner || \"null\");\n\t\t\t\t\tif (!signingKey || appHardening.disableASCK) signingKey = JSON.parse(await this.fs.read(modules.defaultSystem + \"/etc/keys/\" + execSignature.signer, token));\n\t\t\t\t\tfriendlyName = (signingKey.keyInfo.friendlyNameDB || {})[modules.locales.get(\"OS_LOCALE\", language)] || signingKey.keyInfo.friendlyName;\n\t\t\t\t\tawait recursiveKeyVerify(signingKey, khrlSignatures);\n\t\t\t\t\tif (signingKey.keyInfo) if (!signingKey.keyInfo.usages.includes(\"appTrust\")) throw new Error(\"NOT_APP_SIGNING_KEY\");\n\t\t\t\t\tlet importSigningKey = await crypto.subtle.importKey(\"jwk\", signingKey.keyInfo.key, { name: \"Ed25519\" }, false, [\"verify\"]);\n\t\t\t\t\tif (!await crypto.subtle.verify({ name: \"Ed25519\" }, importSigningKey, hexToU8A(execSignature.signature), new TextEncoder().encode(executable))) throw new Error(\"APP_SIGNATURE_VERIFICATION_FAILED\");\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(\"Failed to verify app signature:\", e);\n\t\t\t\t\twindowObject.title.innerText = modules.locales.get(\"PERMISSION_DENIED\", language);\n\t\t\t\t\twindowObject.content.innerText = modules.locales.get(\"SIGNATURE_VERIFICATION_FAILED\", language).replace(\"%s\", (friendlyName ? (friendlyName + \" (\") : \"\") + (execSignature.signer || modules.locales.get(\"UNSIGNED_CELL\", language)) + (friendlyName ? \")\" : \"\"));\n\t\t\t\t\twindowObject.content.style.padding = \"8px\";\n\t\t\t\t\twindowObject.closeButton.disabled = false;\n\t\t\t\t\twindowObject.closeButton.onclick = (e) => windowObject.windowDiv.remove() && e.stopPropagation();\n\t\t\t\t\tif (silent) windowObject.windowDiv.remove();\n\t\t\t\t\tif (!silent) errorAudio.play();\n\t\t\t\t\tthrow new Error(\"APP_OR_KEY_SIGNATURE_VERIFICATION_FAILED\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet ree = await this.ree(windowObject.content, token);\n\t\t\ttry {\n\t\t\t\tmodules.session.attrib(windowObject.sessionId, \"openReeWindows\", [ ...(modules.session.attrib(windowObject.sessionId, \"openReeWindows\") || []), taskId ]);\n\t\t\t\targ = arg || [];\n\t\t\t\tif (!(arg instanceof Array)) arg = [];\n\t\t\t\targ = arg.map(a => String(a));\n\t\t\t\tlet that = this;\n\t\t\t\tree.iframe.style = \"width: 100%; height: 100%; border: none; top: 0; left: 0; position: absolute;\";\n\t\t\t\tlet reeAPIInstance = await modules.reeAPIInstance({ ree, ses: windowObject.sessionId, token, taskId, limitations, privateData });\n\t\t\t\tfor (let action in reeAPIInstance.public) ree.exportAPI(action, (e) => reeAPIInstance.public[action](e.arg));\n\t\t\t\tthis.tracker[taskId] = {\n\t\t\t\t\tree,\n\t\t\t\t\tfile: file,\n\t\t\t\t\targ: arg,\n\t\t\t\t\tapis: reeAPIInstance,\n\t\t\t\t\tcritical: false,\n\t\t\t\t\tcliio: {\n\t\t\t\t\t\tattached: false,\n\t\t\t\t\t\tattachedCLISignUp: function() {\n\t\t\t\t\t\t\treturn new Promise(a => attachedCLIRegistrations.push(a));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tlet registrations = [];\n\t\t\t\tlet attachedCLIRegistrations = [];\n\t\t\t\tlet cliCache = [];\n\t\t\t\twindowObject.closeButton.addEventListener(\"click\", () => that.sendSignal(taskId, 15));\n\t\t\t\tree.exportAPI(\"attachCLI\", async function() {\n\t\t\t\t\tif (that.tracker[taskId].cliio.attached) return true;\n\t\t\t\t\tif (!window.Terminal) return false;\n\t\t\t\t\tfor (let registration of attachedCLIRegistrations) registration();\n\t\t\t\t\tattachedCLIRegistrations = [];\n\t\t\t\t\tlet signup = () => new Promise((resolve) => registrations.push(resolve));\n\t\t\t\t\tree.iframe.hidden = true;\n\t\t\t\t\tlet termDiv = document.createElement(\"div\");\n\t\t\t\t\ttermDiv.style = \"position: absolute; top: 0; left: 0; width: 100%; height: 100%;\";\n\t\t\t\t\tlet fitAddon = new FitAddon.FitAddon();\n\t\t\t\t\tlet termInstance = new Terminal();\n\t\t\t\t\ttermInstance.loadAddon(fitAddon);\n\t\t\t\t\ttermInstance.open(termDiv);\n\t\t\t\t\twindowObject.content.appendChild(termDiv);\n\t\t\t\t\tthat.tracker[taskId].cliio.attached = true;\n\t\t\t\t\tthat.tracker[taskId].cliio.xtermInstance = termInstance;\n\t\t\t\t\tlet onresizeFn = () => fitAddon.fit();\n\t\t\t\t\tonresizeFn();\n\t\t\t\t\tlet robs = new ResizeObserver(onresizeFn);\n\t\t\t\t\tthat.tracker[taskId].cliio.robsInstance = robs;\n\t\t\t\t\trobs.observe(windowObject.windowDiv);\n\t\t\t\t\tthat.tracker[taskId].cliio.signup = signup;\n\t\t\t\t\tthat.tracker[taskId].cliio.xtermInstance.onData(e => cliCache.push(e));\n\t\t\t\t\ttermInstance.clear();\n\t\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, 8));\n\t\t\t\t\treturn true;  \n\t\t\t\t});\n\t\t\t\tree.exportAPI(\"toMyCLI\", async function(apiArg) {\n\t\t\t\t\tif (that.tracker[taskId].cliio.attached) {\n\t\t\t\t\t\tthat.tracker[taskId].cliio.xtermInstance.write(apiArg.arg);\n\t\t\t\t\t\tfor (let registered in registrations) {\n\t\t\t\t\t\t\tawait registrations[registered]({ type: \"write\", data: apiArg.arg });\n\t\t\t\t\t\t\tregistrations.splice(0, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tree.exportAPI(\"fromMyCLI\", async function() {\n\t\t\t\t\tif (!that.tracker[taskId].cliio.attached) return false;\n\t\t\t\t\tlet ti = that.tracker[taskId].cliio.xtermInstance;\n\t\t\t\t\treturn new Promise(async function(resolve) {\n\t\t\t\t\t\tif (cliCache.length) {\n\t\t\t\t\t\t\tlet element = cliCache[0];\n\t\t\t\t\t\t\tcliCache = cliCache.slice(1);\n\t\t\t\t\t\t\tresolve(element);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet d = ti.onData(async function(e) {\n\t\t\t\t\t\t\tcliCache = cliCache.slice(1);\n\t\t\t\t\t\t\tresolve(e);\n\t\t\t\t\t\t\td.dispose();\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\tree.exportAPI(\"clearMyCLI\", async function() {\n\t\t\t\t\tif (that.tracker[taskId].cliio.attached) that.tracker[taskId].cliio.xtermInstance.clear();\n\t\t\t\t\tfor (let registered in registrations) {\n\t\t\t\t\t\tawait registrations[registered]({ type: \"consoleClear\" });\n\t\t\t\t\t\tregistrations.splice(registered, 1);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tree.exportAPI(\"cliSize\", function() {\n\t\t\t\t\tif (!that.tracker[taskId].cliio.attached) return [ 0, 0 ];\n\t\t\t\t\treturn [ that.tracker[taskId].cliio.xtermInstance.cols, that.tracker[taskId].cliio.xtermInstance.rows ];\n\t\t\t\t});\n\t\t\t\tree.exportAPI(\"detachCLI\", function() {\n\t\t\t\t\tif (!that.tracker[taskId].cliio.attached) return true;\n\t\t\t\t\tthat.tracker[taskId].cliio.attached = false;\n\t\t\t\t\tthat.tracker[taskId].cliio.xtermInstance.clear();\n\t\t\t\t\tthat.tracker[taskId].cliio.robsInstance.disconnect();\n\t\t\t\t\tdelete that.tracker[taskId].cliio.robsInstance;\n\t\t\t\t\tthat.tracker[taskId].cliio.xtermInstance.dispose();\n\t\t\t\t\tdelete that.tracker[taskId].cliio.xtermInstance;\n\t\t\t\t\tdelete that.tracker[taskId].cliio.signup;\n\t\t\t\t\tregistrations = [];\n\t\t\t\t\tree.iframe.hidden = false;\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t\tree.exportAPI(\"windowVisibility\", (apiArg) => windowObject.windowDiv.classList.toggle(\"hidden\", !apiArg.arg));\n\t\t\t\tree.exportAPI(\"windowTitleSet\", (apiArg) => windowObject.title.innerText = apiArg.arg);\n\t\t\t\tree.exportAPI(\"windowResize\", function(apiArg) {\n\t\t\t\t\tif (reeAPIInstance.public.getPrivileges().includes(\"GRAB_ATTENTION\")) {\n\t\t\t\t\t\twindowObject.windowDiv.style.width = apiArg.arg[0] + \"px\";\n\t\t\t\t\t\twindowObject.windowDiv.style.height = apiArg.arg[1] + \"px\";\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tree.exportAPI(\"windowSize\", function() {\n\t\t\t\t\treturn {\n\t\t\t\t\t\twidth: windowObject.windowDiv.clientWidth,\n\t\t\t\t\t\theight: windowObject.windowDiv.clientHeight\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tree.exportAPI(\"windowRelocate\", function(apiArg) {\n\t\t\t\t\tif (reeAPIInstance.public.getPrivileges().includes(\"GRAB_ATTENTION\")) {\n\t\t\t\t\t\twindowObject.windowDiv.style.top = apiArg.arg[0] + \"px\";\n\t\t\t\t\t\twindowObject.windowDiv.style.left = apiArg.arg[1] + \"px\";\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tree.exportAPI(\"windowFullscreen\", function(apiArg) {\n\t\t\t\t\tif (reeAPIInstance.public.getPrivileges().includes(\"GRAB_ATTENTION\"))\n\t\t\t\t\t\twindowObject.windowDiv.classList.toggle(\"fullscreen\", apiArg.arg);\n\t\t\t\t});\n\t\t\t\tree.exportAPI(\"windowFocus\", function() {\n\t\t\t\t\tif (reeAPIInstance.public.getPrivileges().includes(\"GRAB_ATTENTION\")) {\n\t\t\t\t\t\tlet openWins = modules.session.attrib(windowObject.sessionId, \"openWins\") || [];\n\t\t\t\t\t\twindowObject.windowDiv.style.zIndex = openWins.length;\n\t\t\t\t\t\topenWins = openWins.filter(a => a.parentElement).sort((a, b) => a.style.zIndex - b.style.zIndex);\n\t\t\t\t\t\topenWins.map((a, i) => a.style.zIndex = i);\n\t\t\t\t\t\tmodules.session.attrib(windowObject.sessionId, \"openWins\", openWins);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tree.exportAPI(\"isDarkThemed\", function() {\n\t\t\t\t\tif (!reeAPIInstance.public.getPrivileges().includes(\"GET_THEME\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn windowObject.windowDiv.classList.contains(\"dark\")\n\t\t\t\t});\n\t\t\t\tree.exportAPI(\"windowDark\", function(apiArg) {\n\t\t\t\t\twindowObject.windowDiv.classList.toggle(\"dark\", apiArg.arg);\n\t\t\t\t});\n\t\t\t\tree.exportAPI(\"closeability\", (apiArg) => windowObject.closeButton.classList.toggle(\"hidden\", !apiArg.arg));\n\t\t\t\tree.exportAPI(\"critical\", function(apiArg) {\n\t\t\t\t\tif (reeAPIInstance.public.getPrivileges().includes(\"SYSTEM_STABILITY\")) {\n\t\t\t\t\t\tthat.tracker[taskId].critical = !!apiArg.arg;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tawait ree.eval(\"taskId = \" + JSON.stringify(taskId) + \";\");\n\t\t\t\tawait ree.eval(\"exec_args = \" + JSON.stringify(arg) + \";\");\n\t\t\t\tree.beforeCloseDown(function() {\n\t\t\t\t\tlet orw = modules.session.attrib(windowObject.sessionId, \"openReeWindows\");\n\t\t\t\t\torw.splice(orw.indexOf(taskId), 1);\n\t\t\t\t\tmodules.session.attrib(windowObject.sessionId, \"openReeWindows\", orw);\n\t\t\t\t\tif (that.tracker[taskId].cliio.attached) {    \n\t\t\t\t\t\tthat.tracker[taskId].cliio.attached = false;\n\t\t\t\t\t\tthat.tracker[taskId].cliio.xtermInstance.clear();\n\t\t\t\t\t\tthat.tracker[taskId].cliio.robsInstance.disconnect();\n\t\t\t\t\t\tthat.tracker[taskId].cliio.robsInstance = null;\n\t\t\t\t\t\tthat.tracker[taskId].cliio.xtermInstance.dispose();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tree.beforeCloseDown(() => windowObject.windowDiv.remove());\n\t\t\t\tree.beforeCloseDown(() => delete that.tracker[taskId]);\n\t\t\t\tawait ree.eval(executable);\n\t\t\t} catch (e) {\n\t\t\t\tree.closeDown();\n\t\t\t\twindowObject.title.innerText = modules.locales.get(\"APP_STARTUP_CRASH_TITLE\", language);\n\t\t\t\twindowObject.content.innerText = modules.locales.get(\"APP_STARTUP_CRASH\", language);\n\t\t\t\twindowObject.content.style.padding = \"8px\";\n\t\t\t\twindowObject.closeButton.disabled = false;\n\t\t\t\twindowObject.windowDiv.classList.toggle(\"hidden\", false);\n\t\t\t\twindowObject.closeButton.onclick = (e) => windowObject.windowDiv.remove() && e.stopPropagation();\n\t\t\t\tif (silent) windowObject.windowDiv.remove();\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\treturn taskId;\n\t\t},\n\t\tsendSignal: async function(taskId, signal, bypassCritical) {\n\t\t\tif (signal == 9) {\n\t\t\t\tif (this.tracker[taskId].critical && !bypassCritical) {\n\t\t\t\t\tlet memory = this.tracker[taskId];\n\t\t\t\t\tawait memory.ree.closeDown();\n\t\t\t\t\tawait panic(\"CRITICAL_TASK_FAILED\", {\n\t\t\t\t\t\tname: memory.file,\n\t\t\t\t\t\tparams: memory.arg\n\t\t\t\t\t});\n\t\t\t\t\tthrow new Error(\"CRITICAL_TASK_FAILED\");\n\t\t\t\t}\n\t\t\t\treturn await this.tracker[taskId].ree.closeDown();\n\t\t\t}\n\t\t\treturn await this.tracker[taskId].ree.eval(\"dispatchEvent(new CustomEvent(\\\"signal\\\", { detail: \" + JSON.stringify(signal) + \", bubbles: true }));\");\n\t\t},\n\t\trunsProperly: async function(taskId) {\n\t\t\ttry {\n\t\t\t\treturn await this.tracker[taskId].ree.eval(\"true\");\n\t\t\t} catch (e) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tlistPublicTasks: () => Object.keys(tasks.tracker),\n\t\twaitTermination: async function(taskId) {\n\t\t\tif (!this.tracker.hasOwnProperty(taskId)) return;\n\t\t\treturn new Promise((resolve) => this.tracker[taskId].ree.beforeCloseDown(() => resolve()));\n\t\t},\n\t\ttaskInfo: async function(taskId) {\n\t\t\tif (!this.tracker.hasOwnProperty(taskId)) return null;\n\t\t\tlet info = await modules.tokens.info(this.tracker[taskId].apis.public.getProcessToken());\n\t\t\tif (!info) info = { user: taskId.slice(0, 16) };\n\t\t\treturn {\n\t\t\t\tfile: this.tracker[taskId].file,\n\t\t\t\targ: this.tracker[taskId].arg,\n\t\t\t\trunBy: info.user,\n\t\t\t\tcliio: this.tracker[taskId].cliio.attached\n\t\t\t}\n\t\t},\n\t\ttracker: {},\n\t\tfs: modules.fs,\n\t\tree: modules.core.createREE\n\t};\n\t\n\tmodules.tasks = tasks;\n}\nloadTasks();","2bf1c89a2309e4998aeac94fa9b6412b044a6e321a607dd86be0991372879dfd2b6c51e9df6d1101167bea4f22968d5fd12add3f518b8f0df9095de6ec94b5a8":"async function logOut(target) {\n\tlet liu = modules.liu;\n\tif (!liu.hasOwnProperty(target)) throw new Error(\"USER_NOT_LOGGED_IN\");\n\tlet session = liu[target].session;\n\tlet token = liu[target].logon.token;\n\tlet secureSession = modules.session.attrib(session, \"secureID\");\n\tawait modules.session.attrib(session, \"loggingOut\", true);\n\tclearInterval(liu[target].clockInterval);\n\tif (modules.session.active == session || (secureSession && modules.session.active == secureSession)) await modules.session.muteAllSessions();\n\tawait modules.session.activateSession(modules.session.systemSession);\n\tlet loggingOutWindow = modules.window(modules.session.systemSession, true);\n\tloggingOutWindow.title.innerText = modules.locales.get(\"LOGGING_OUT\");\n\tloggingOutWindow.content.style.padding = \"8px\";\n\tloggingOutWindow.closeButton.disabled = true;\n\tloggingOutWindow.content.innerText = modules.locales.get(\"LOGGING_OUT\");\n\tlet taskList = modules.session.attrib(session, \"openReeWindows\") || [];\n\tlet timeout = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n\tfunction allProcessesClosed() {\n\t\treturn new Promise(function(resolve) {\n\t\t\tlet int = setInterval(function() {\n\t\t\t\ttry {\n\t\t\t\t\ttaskList = modules.session.attrib(session, \"openReeWindows\") || [];\n\t\t\t\t\tif (Object.keys(taskList).length == 0) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t\tclearInterval(int);\n\t\t\t\t\t}\n\t\t\t\t} catch {\n\t\t\t\t\tresolve();\n\t\t\t\t\tclearInterval(int);\n\t\t\t\t}\n\t\t\t})\n\t\t});\n\t}\n\tloggingOutWindow.content.innerText = modules.locales.get(\"POLITE_CLOSE_SIGNAL\");\n\tfor (let taskId of taskList) modules.tasks.sendSignal(taskId, 15);\n\tawait Promise.race([\n\t\ttimeout(5000),\n\t\tallProcessesClosed()\n\t]);\n\tloggingOutWindow.content.innerText = modules.locales.get(\"ABRUPT_CLOSE_SIGNAL\");\n\tif (secureSession) {\n\t\ttaskList = modules.session.attrib(secureSession, \"openReeWindows\") || [];\n\t\tfor (let taskId of taskList) modules.tasks.sendSignal(taskId, 9);\n\t}\n\ttaskList = modules.session.attrib(session, \"openReeWindows\") || [];\n\tfor (let taskId of taskList) modules.tasks.sendSignal(taskId, 9);\n\tawait allProcessesClosed();\n\tloggingOutWindow.windowDiv.remove();\n\tdelete modules.liu[target];\n\tawait modules.tokens.revoke(token);\n\tif (secureSession) await modules.session.rmsession(secureSession);\n\tawait modules.session.rmsession(session);\n}\n\nmodules.logOut = logOut;","057f807b158093bd2a57c5251a3368b096800e80bcab9f57becf67c482d1cb48d8ad569342141d282a523be0b9a101e81e1631b9ad86f0a32794ee99313b0f90":"function restartLoad() {\n\t// @pcos-app-mode native\n\tfunction timeout(ms) {\n\t\treturn new Promise(resolve => setTimeout(resolve, ms));\n\t}\n\tfunction allProcessesClosed() {\n\t\treturn new Promise(function(resolve) {\n\t\t\tlet int = setInterval(function() {\n\t\t\t\tif (Object.keys(modules.tasks.tracker).length == 0) {\n\t\t\t\t\tresolve();\n\t\t\t\t\tclearInterval(int);\n\t\t\t\t}\n\t\t\t})\n\t\t});\n\t}\n\t\n\tasync function restart(noAutomaticReload = false, token, kexec) {\n\t\ttry {\n\t\t\tlet shutdownSoundPerm = await modules.fs.permissions(modules.defaultSystem + \"/etc/sounds/shutdown.aud\");\n\t\t\tif (!shutdownSoundPerm.world.includes(\"r\")) throw new Error(\"Not allowed to read shutdown.aud\");\n\t\t\tlet shutdownSound = await modules.fs.read(modules.defaultSystem + \"/etc/sounds/shutdown.aud\");\n\t\t\tlet shutdownAudio = new Audio();\n\t\t\tshutdownAudio.src = shutdownSound;\n\t\t\tshutdownAudio.play();\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to play shutdown.aud:\", e);\n\t\t}\n\t\tmodules.shuttingDown = true;\n\t\tlet window = modules.window;\n\t\tlet fs = modules.fs;\n\t\tlet tasks = modules.tasks;\n\t\tmodules.session.muteAllSessions();\n\t\tmodules.session.activateSession(modules.session.systemSession);\n\t\tlet windowDiv = window(modules.session.systemSession, true);\n\t\twindowDiv.closeButton.classList.toggle(\"hidden\", true);\n\t\twindowDiv.title.innerText = modules.locales.get(\"PCOS_RESTARTING\").replace(\"%s\", \"\");\n\t\twindowDiv.content.style.padding = \"8px\";\n\t\tlet description = document.createElement(\"p\");\n\t\tdescription.innerText = modules.locales.get(\"PCOS_RESTARTING\").replace(\"%s\", modules.locales.get(\"PLEASE_WAIT\"));\n\t\twindowDiv.content.appendChild(description);\n\t\tdescription.innerText = modules.locales.get(\"PCOS_RESTARTING\").replace(\"%s\", modules.locales.get(\"POLITE_CLOSE_SIGNAL\"));\n\t\tfor (let taskId in tasks.tracker) tasks.sendSignal(taskId, 15);\n\t\tawait Promise.race([\n\t\t\ttimeout(5000),\n\t\t\tallProcessesClosed()\n\t\t]);\n\t\ttry {\n\t\t\tmodules.websocket._handles[modules.network.ws].send(JSON.stringify({\n\t\t\t\tfinalProxyPacket: true\n\t\t\t}));\n\t\t} catch {}\n\t\tdescription.innerText = modules.locales.get(\"PCOS_RESTARTING\").replace(\"%s\", modules.locales.get(\"ABRUPT_CLOSE_SIGNAL\"));\n\t\tfor (let taskId in tasks.tracker) tasks.sendSignal(taskId, 9, true);\n\t\tawait allProcessesClosed();\n\t\ttry {\n\t\t\tmodules.websocket._handles[modules.network.ws].ws.onclose = null;\n\t\t\tmodules.websocket._handles[modules.network.ws].ws.close();\n\t\t\tdelete modules.websocket._handles[modules.network.ws];\n\t\t} catch {}\n\t\tdescription.innerText = modules.locales.get(\"PCOS_RESTARTING\").replace(\"%s\", modules.locales.get(\"UNMOUNTING_MOUNTS\"));\n\t\tfor (let mount in fs.mounts) try { await fs.sync(mount, token); } catch {}\n\t\tfor (let mount in fs.mounts) try { await fs.umount(mount, token); } catch {}\n\t\tfor (let mount in fs.mounts) try { await fs.umount(mount, token, true); } catch {}\n\t\tdescription.innerText = modules.locales.get(\"PCOS_RESTARTING\").replace(\"%s\", modules.locales.get(\"RESTARTING\"));\n\t\tif (!noAutomaticReload) {\n\t\t\tif (kexec) {\n\t\t\t\ttry {\n\t\t\t\t\tmodules.session.destroy();\n\t\t\t\t\tawait new ((async _=>0).constructor)(\n\t\t\t\t\t\tmodules.core.disk.partition(\"boot\").getData()\n\t\t\t\t\t)();\n\t\t\t\t\treturn modules.killSystem();\n\t\t\t\t} catch (e) {\n\t\t\t\t\tawait panic(\"KEXEC_FAILED\", {\n\t\t\t\t\t\tname: \"kexec\",\n\t\t\t\t\t\tunderlyingJS: e\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn location.reload();\n\t\t}\n\t\tmodules.killSystem();\n\t\tdescription.innerText = modules.locales.get(\"SAFE_TO_CLOSE\");\n\t\tlet button = document.createElement(\"button\");\n\t\tbutton.innerText = modules.locales.get(\"RESTART_BUTTON\");\n\t\tbutton.onclick = function() {\n\t\t\tdescription.innerText = modules.locales.get(\"PCOS_RESTARTING\").replace(\"%s\", modules.locales.get(\"RESTARTING\"));\n\t\t\tbutton.remove();\n\t\t\tlocation.reload();\n\t\t}\n\t\twindowDiv.content.appendChild(button);\n\t}\n\t\n\tmodules.restart = restart;\n}\n\nrestartLoad();","8e1cefc8590ea2effcbbb6ac1323831d9fcf850eea99d5804f2ef6d1fe525fae8a9f389047658da2bd939adeb92d0b0e5f6e99377535f6daef71d1a0f2030a6e":"function loadUserFriendly() {\n\t// @pcos-app-mode native\n\tmodules.userfriendliness = {\n\t\tinconsiderateTime: function(language, ms, majorUnitsOnly, displayMs) {\n\t\t\tlet string = \"\";\n\t\t\tlet days = Math.floor(ms / 86400000);\n\t\t\tlet hours = Math.floor(ms / 3600000) % 24;\n\t\t\tlet minutes = Math.floor(ms / 60000) % 60;\n\t\t\tlet seconds = Math.floor(ms / 1000) % 60;\n\t\t\tif (days) string = string + modules.locales.get(\"SHORT_DAYS\", language).replace(\"%s\", days) + \" \";\n\t\t\tif (days && majorUnitsOnly) return string;\n\t\t\tif (hours) string = string + modules.locales.get(\"SHORT_HOURS\", language).replace(\"%s\", hours) + \" \";\n\t\t\tif (hours && majorUnitsOnly) return string;\n\t\t\tif (minutes) string = string + modules.locales.get(\"SHORT_MINUTES\", language).replace(\"%s\", minutes) + \" \";\n\t\t\tif (minutes && majorUnitsOnly) return string;\n\t\t\tif (seconds) string = string + modules.locales.get(\"SHORT_SECONDS\", language).replace(\"%s\", seconds) + \" \";\n\t\t\tif (displayMs && (ms % 1000)) {\n\t\t\t\tif (seconds && majorUnitsOnly) return string;\n\t\t\t\tstring = string + modules.locales.get(\"SHORT_MILLISECONDS\", language).replace(\"%s\", (ms % 1000)) + \" \";\n\t\t\t}\n\t\t\treturn string;\n\t\t},\n\t\tinformationUnits: function(language, bytes, majorUnitsOnly) {\n\t\t\tlet string = \"\";\n\t\t\tlet tb = Math.floor(bytes / (1024 * 1024 * 1024 * 1024));\n\t\t\tlet gb = Math.floor(bytes / (1024 * 1024 * 1024)) % 1024;\n\t\t\tlet mb = Math.floor(bytes / (1024 * 1024)) % 1024;\n\t\t\tlet kb = Math.floor(bytes / 1024) % 1024;\n\t\t\tlet b = bytes % 1024;\n\t\t\tif (tb) string = string + modules.locales.get(\"SHORT_TERABYTES\", language).replace(\"%s\", tb) + \" \";\n\t\t\tif (tb && majorUnitsOnly) return string;\n\t\t\tif (gb) string = string + modules.locales.get(\"SHORT_GIGABYTES\", language).replace(\"%s\", gb) + \" \";\n\t\t\tif (gb && majorUnitsOnly) return string;\n\t\t\tif (mb) string = string + modules.locales.get(\"SHORT_MEGABYTES\", language).replace(\"%s\", mb) + \" \";\n\t\t\tif (mb && majorUnitsOnly) return string;\n\t\t\tif (kb) string = string + modules.locales.get(\"SHORT_KILOBYTES\", language).replace(\"%s\", kb) + \" \";\n\t\t\tif (kb && majorUnitsOnly) return string;\n\t\t\tif (b) string = string + modules.locales.get(\"SHORT_BYTES\", language).replace(\"%s\", b);\n\t\t\tif (b && majorUnitsOnly) return string;\n\t\t\treturn string;\n\t\t},\n\t\tconsiderateTime: function(language, ms, majorUnitsOnly, displayMs) {\n\t\t\tlet dateObject = new Date(ms);\n\t\t\tlet string = \"\";\n\t\t\tlet years = dateObject.getUTCFullYear() - 1970;\n\t\t\tlet months = dateObject.getUTCMonth();\n\t\t\tlet days = dateObject.getUTCDate() - 1;\n\t\t\tlet hours = dateObject.getUTCHours();\n\t\t\tlet minutes = dateObject.getUTCMinutes();\n\t\t\tlet seconds = dateObject.getUTCSeconds();\n\t\t\tlet millisec = dateObject.getUTCMilliseconds();\n\t\t\tif (years) string = string + modules.locales.get(\"SHORT_YEARS\", language).replace(\"%s\", years) + \" \";\n\t\t\tif (years && majorUnitsOnly) return string;\n\t\t\tif (months) string = string + modules.locales.get(\"SHORT_MONTHS\", language).replace(\"%s\", months) + \" \";\n\t\t\tif (months && majorUnitsOnly) return string;\n\t\t\tif (days) string = string + modules.locales.get(\"SHORT_DAYS\", language).replace(\"%s\", days) + \" \";\n\t\t\tif (days && majorUnitsOnly) return string;\n\t\t\tif (hours) string = string + modules.locales.get(\"SHORT_HOURS\", language).replace(\"%s\", hours) + \" \";\n\t\t\tif (hours && majorUnitsOnly) return string;\n\t\t\tif (minutes) string = string + modules.locales.get(\"SHORT_MINUTES\", language).replace(\"%s\", minutes) + \" \";\n\t\t\tif (minutes && majorUnitsOnly) return string;\n\t\t\tif (seconds) string = string + modules.locales.get(\"SHORT_SECONDS\", language).replace(\"%s\", seconds) + \" \";\n\t\t\tif (displayMs && millisec) {\n\t\t\t\tif (seconds && majorUnitsOnly) return string;\n\t\t\t\tstring = string + modules.locales.get(\"SHORT_MILLISECONDS\", language).replace(\"%s\", (millisec % 1000)) + \" \";\n\t\t\t}\n\t\t\treturn string;\n\t\t}\n\t}\n}\nloadUserFriendly();","031000dd0bf460735a7e9548ef0a85498a0d76469f5074b8a19c3ce6c91a1a8c0b39e7eebaeb424399110df360516963a43b9a4572e3f4ee768f173d4eb55d2b":"function setupTokens() {\n\t// @pcos-app-mode native\n\tmodules.tokens = {\n\t\tgenerate: async function() {\n\t\t\tlet rng = crypto.getRandomValues(new Uint8Array(64));\n\t\t\tlet token = Array.from(rng).map(x => x.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\tthis._tokens[token] = { privileges: [], user: \"nobody\", groups: [] };\n\t\t\treturn token;\n\t\t},\n\t\trevoke: async function(token) {\n\t\t\tdelete this._tokens[token];\n\t\t},\n\t\tsetPrivileges: async function(token, privileges) {\n\t\t\tthis._tokens[token].privileges = privileges;\n\t\t},\n\t\taddPrivilege: async function(token, privilege) {\n\t\t\tthis._tokens[token].privileges.push(privilege);\n\t\t},\n\t\taddPrivileges: async function(token, privileges) {\n\t\t\tthis._tokens[token].privileges.push(...privileges);\n\t\t},\n\t\tremovePrivilege: async function(token, privilege) {\n\t\t\tthis._tokens[token].privileges = this._tokens[token].privileges.filter(x => x != privilege);\n\t\t},\n\t\tremovePrivileges: async function(token, privileges) {\n\t\t\tthis._tokens[token].privileges = this._tokens[token].privileges.filter(x => !privileges.includes(x));\n\t\t},\n\t\tuserInitialize: async function(token, user) {\n\t\t\tthis._tokens[token].user = user;\n\t\t\tthis._tokens[token].groups = (await modules.users.getUserInfo(user, token)).groups || [];\n\t\t\tthis._tokens[token].privileges = [\"FS_READ\", \"FS_WRITE\", \"FS_REMOVE\", \"FS_CHANGE_PERMISSION\", \"FS_LIST_PARTITIONS\", \"IPC_CREATE_PIPE\", \"IPC_LISTEN_PIPE\", \"IPC_SEND_PIPE\", \"IPC_CHANGE_PERMISSION\", \"ELEVATE_PRIVILEGES\", \"GET_USER_INFO\", \"SET_SECURITY_CHECKS\", \"START_TASK\", \"LIST_TASKS\", \"SIGNAL_TASK\", \"FETCH_SEND\", \"CSP_OPERATIONS\", \"IDENTIFY_SYSTEM\", \"WEBSOCKETS_OPEN\", \"WEBSOCKETS_LISTEN\", \"WEBSOCKETS_SEND\", \"WEBSOCKET_SET_PERMISSIONS\", \"MANAGE_TOKENS\", \"WEBSOCKET_INFO\", \"GRAB_ATTENTION\", \"CLI_MODIFICATIONS\", \"GET_THEME\", \"GET_LOCALE\", \"GET_FILESYSTEMS\", \"GET_BUILD\", \"GET_SERVER_URL\", \"START_BACKGROUND_TASK\", \"GET_BOOT_MODE\", \"GET_SCREEN_INFO\", \"PCOS_NETWORK_PING\", \"LOGOUT\", \"LULL_SYSTEM\", \"CONNLESS_LISTEN\", \"CONNLESS_SEND\", \"GET_NETWORK_ADDRESS\", \"CONNFUL_LISTEN\", \"CONNFUL_CONNECT\", \"CONNFUL_DISCONNECT\", \"CONNFUL_WRITE\", \"CONNFUL_READ\", \"CONNFUL_ADDRESS_GET\", \"SYSTEM_UPTIME\", \"GET_HOSTNAME\", \"RESOLVE_NAME\", \"PATCH_DIFF\", \"GET_BATTERY_STATUS\", \"CONNFUL_IDENTITY_GET\", \"GET_UPDATE_SERVICE\", \"GET_ROOT_KEY\", \"ELEVATE_PRIVILEGES_EZ\"];\n\t\t\tif (user == \"root\") this._tokens[token].privileges.push(\"FS_UNMOUNT\", \"SYSTEM_SHUTDOWN\", \"SWITCH_USERS_AUTOMATICALLY\", \"USER_INFO_OTHERS\", \"SET_USER_INFO\", \"FS_BYPASS_PERMISSIONS\", \"IPC_BYPASS_PERMISSIONS\", \"TASK_BYPASS_PERMISSIONS\", \"SENSITIVE_USER_INFO_OTHERS\", \"SYSTEM_STABILITY\", \"RUN_KLVL_CODE\", \"IDENTIFY_SYSTEM_SENSITIVE\", \"WEBSOCKET_BYPASS_PERMISSIONS\", \"LLDISK_READ\", \"LLDISK_WRITE\", \"LLDISK_LIST_PARTITIONS\", \"LLDISK_REMOVE\", \"LLDISK_IDB_READ\", \"LLDISK_IDB_WRITE\", \"LLDISK_IDB_REMOVE\", \"LLDISK_IDB_LIST\", \"LLDISK_IDB_SYNC\", \"FS_MOUNT\", \"SET_DEFAULT_SYSTEM\", \"GET_SYSTEM_RESOURCES\", \"LLDISK_INIT_PARTITIONS\", \"LOGOUT_OTHERS\", \"LULL_SYSTEM_FORCE\", \"CONNLESS_LISTEN_GLOBAL\", \"GET_USER_LIST\", \"CONNFUL_LISTEN_GLOBAL\", \"NETWORK_RAW_WRITE\", \"NETWORK_RAW_READ\", \"SET_FIRMWARE\", \"RELOAD_NETWORK_CONFIG\");\n\t\t\tif ((await modules.users.getUserInfo(user, token)).blankPrivileges) this._tokens[token].privileges = [];\n\t\t\tthis._tokens[token].privileges.push(...((await modules.users.getUserInfo(user, token)).additionalPrivilegeSet || []));\n\t\t\tthis._tokens[token].privileges = Array.from(new Set(this._tokens[token].privileges));\n\t\t},\n\t\thalfInitialize: async function(token, user) {\n\t\t\tthis._tokens[token].user = user;\n\t\t\tthis._tokens[token].groups = (await modules.users.getUserInfo(user, token)).groups || [];\n\t\t},\n\t\tinfo: async function(token) {\n\t\t\treturn this._tokens[token];\n\t\t},\n\t\tvalidate: async function(token, criteria) {\n\t\t\tif (!this._tokens.hasOwnProperty(token)) return false;\n\t\t\tif (criteria.user && this._tokens[token].user != criteria.user) return false;\n\t\t\tif (criteria.group && !this._tokens[token].groups.includes(criteria.group)) return false;\n\t\t\tif (criteria.privilege && !this._tokens[token].privileges.includes(criteria.privilege)) return false;\n\t\t\treturn true;\n\t\t},\n\t\tfork: async function(token) {\n\t\t\tlet rng = crypto.getRandomValues(new Uint8Array(64));\n\t\t\tlet newToken = Array.from(rng).map(x => x.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\tthis._tokens[newToken] = JSON.parse(JSON.stringify(this._tokens[token]));\n\t\t\treturn newToken;  \n\t\t},\n\t\t_tokens: {}\n\t}\n}\nsetupTokens();","50cf5614f6b4552fd200c14075fdccb48e5a754887fa5485251213f8225d707f0ea46c7e2f184c406896c3e11a4775a76c80c8bce0d3bd4366f9e773925a7f5b":"async function setupUsers() {\n\t// @pcos-app-mode native\n\tasync function handleAuthentication(user, prompts, finishFunction) {\n\t\tlet currentPromptIndex = 0;\n\t\tlet destroyed = false;\n\t\tlet cut = [];\n\n\t\treturn {\n\t\t\tgetNextPrompt: async function() {\n\t\t\t\tif (destroyed) return {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: modules.locales.get(\"AUTH_FAILED_NEW\")\n\t\t\t\t};\n\t\t\t\tif (currentPromptIndex >= prompts.length) {\n\t\t\t\t\tif (finishFunction) await finishFunction(true);\n\t\t\t\t\tlet token = await modules.tokens.generate();\n\t\t\t\t\tawait modules.tokens.userInitialize(token, user);\n\t\t\t\t\tawait modules.tokens.removePrivileges(token, cut);\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: true,\n\t\t\t\t\t\tmessage: modules.locales.get(\"AUTH_SUCCESS\"),\n\t\t\t\t\t\ttoken: token\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tlet that = this;\n\t\t\t\tlet currentPrompt = prompts[currentPromptIndex];\n\t\t\t\tlet used = false;\n\t\t\t\t\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: \"intermediate\",\n\t\t\t\t\ttype: currentPrompt.type,\n\t\t\t\t\tmessage: currentPrompt.message,\n\t\t\t\t\twantsUserInput: currentPrompt.userInput,\n\t\t\t\t\tchallenge: currentPrompt.challenge,\n\t\t\t\t\tinput: async function(input) {\n\t\t\t\t\t\tif (used || destroyed) return that.getNextPrompt();\n\t\t\t\t\t\tif (!used) used = true;\n\t\t\t\t\t\tlet verified;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tverified = await currentPrompt.verify(input);\n\t\t\t\t\t\t\tif (verified instanceof Array) {\n\t\t\t\t\t\t\t\tcut.push(...verified);\n\t\t\t\t\t\t\t\tcut = Array.from(new Set(cut));\n\t\t\t\t\t\t\t\tverified = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\tverified = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!verified) {\n\t\t\t\t\t\t\tdestroyed = true;\n\t\t\t\t\t\t\tif (finishFunction) await finishFunction(false);\n\t\t\t\t\t\t\treturn { success: false, message: modules.locales.get(\"AUTH_FAILED\") };\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcurrentPromptIndex++;\n\t\t\t\t\t\treturn that.getNextPrompt();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\t}\n\n\tlet test = \"{}\";\n\ttry {\n\t\ttest = await modules.fs.read(modules.defaultSystem + \"/etc/security/users\");\n\t} catch {\n\t\tif (!modules.settingUp) test = \"systemStatusInvalid\";\n\t}\n\ttry {\n\t\tJSON.parse(test);\n\t} catch (e) {\n\t\tif (!modules.settingUp) await panic(\"USER_SYSTEM_CORRUPTED\", {\n\t\t\tname: \"/etc/security/users\",\n\t\t\tparams: [modules.defaultSystem],\n\t\t\tunderlyingJS: e\n\t\t})\n\t}\n\n\tmodules.users = {\n\t\tinit: async function(token) {\n\t\t\tawait this.mkrecursive(modules.defaultSystem + \"/etc/security\", token);\n\t\t\tawait modules.fs.chmod(modules.defaultSystem + \"/etc\", \"rx\", token);\n\t\t\tawait this.mkrecursive(modules.defaultSystem + \"/root\", token);\n\t\t\tawait modules.fs.write(modules.defaultSystem + \"/etc/security/users\", JSON.stringify({root: {\n\t\t\t\tsecurityChecks: [],\n\t\t\t\tgroups: [\"root\"],\n\t\t\t\thomeDirectory: modules.defaultSystem + \"/root\"\n\t\t\t},\n\t\t\tauthui: {\n\t\t\t\tsecurityChecks: [],\n\t\t\t\tgroups: [\"authui\"],\n\t\t\t\thomeDirectory: modules.defaultSystem,\n\t\t\t\tblankPrivileges: true,\n\t\t\t\tadditionalPrivilegeSet:  [ \"IPC_SEND_PIPE\", \"GET_LOCALE\", \"GET_THEME\", \"ELEVATE_PRIVILEGES\", \"FS_READ\", \"FS_LIST_PARTITIONS\", \"CSP_OPERATIONS\" ]\n\t\t\t}}), token);\n\t\t},\n\t\tmkrecursive: async function(dir, token) {\n\t\t\tlet slices = dir.split(\"/\");\n\t\t\tfor (let slice in slices) {\n\t\t\t\tlet previousParts = slices.slice(0, slice).join(\"/\");\n\t\t\t\tif (!previousParts) continue;\n\t\t\t\tlet currentPart = slices[slice];\n\t\t\t\tlet check = await modules.fs.ls(previousParts, token);\n\t\t\t\tpreviousParts += \"/\";\n\t\t\t\tif (!check.includes(currentPart)) await modules.fs.mkdir(previousParts + currentPart, token);\n\t\t\t}\n\t\t},\n\t\tmoduser: async function(user, data, token) {\n\t\t\tlet userDB = JSON.parse(await modules.fs.read(modules.defaultSystem + \"/etc/security/users\"), token);\n\t\t\tuserDB[user] = data;\n\t\t\tawait modules.fs.write(modules.defaultSystem + \"/etc/security/users\", JSON.stringify(userDB), token);\n\t\t},\n\t\tgetUserInfo: async function(user, sensitive = false, token) {\n\t\t\tlet userDB = JSON.parse(await modules.fs.read(modules.defaultSystem + \"/etc/security/users\"), token);\n\t\t\tif (!userDB.hasOwnProperty(user)) return null;\n\t\t\tuserDB = userDB[user];\n\t\t\tif (!sensitive) delete userDB.securityChecks;\n\t\t\treturn userDB;\n\t\t},\n\t\tconfigured: async function(token) {\n\t\t\ttry {\n\t\t\t\tJSON.parse(await modules.fs.read(modules.defaultSystem + \"/etc/security/users\"), token);\n\t\t\t\treturn true;\n\t\t\t} catch {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\taccess: async function(user, token) {\n\t\t\tlet userDB = JSON.parse(await modules.fs.read(modules.defaultSystem + \"/etc/security/users\"), token);\n\t\t\tlet credentials = userDB[user].securityChecks;\n\t\t\tfor (let check in credentials) {\n\t\t\t\tif (credentials[check].type == \"pbkdf2\") {\n\t\t\t\t\tcredentials[check].userInput = true;\n\t\t\t\t\tcredentials[check].type = \"password\";\n\t\t\t\t\tcredentials[check].message = modules.locales.get(\"PASSWORD_PROMPT\");\n\t\t\t\t\tcredentials[check].verify = async function(input) {\n\t\t\t\t\t\treturn (await modules.core.pbkdf2(input, credentials[check].salt)) == credentials[check].hash;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (credentials[check].type == \"informative\" || credentials[check].type == \"informative_deny\") {\n\t\t\t\t\tcredentials[check].verify = () => credentials[check].type == \"informative\";\n\t\t\t\t\tcredentials[check].type = \"informative\";\n\t\t\t\t\tcredentials[check].userInput = false;\n\t\t\t\t}\n\t\t\t\tif (credentials[check].type == \"timeout\" || credentials[check].type == \"timeout_deny\") {\n\t\t\t\t\tlet isTimeout = credentials[check].type == \"timeout\";\n\t\t\t\t\tcredentials[check].message = modules.locales.get(\"PLEASE_WAIT_TIME\").replace(\"%s\", modules.userfriendliness.inconsiderateTime(credentials[check].timeout));\n\t\t\t\t\tcredentials[check].verify = () => new Promise(resolve => setTimeout(resolve, credentials[check].timeout, isTimeout));\n\t\t\t\t\tcredentials[check].type = \"promise\";\n\t\t\t\t\tcredentials[check].userInput = false;\n\t\t\t\t}\n\t\t\t\tif (credentials[check].type == \"serverReport\") {\n\t\t\t\t\tcredentials[check].message = modules.locales.get(\"REPORTING_LOGON\");\n\t\t\t\t\tcredentials[check].type = \"promise\";\n\t\t\t\t\tcredentials[check].verify = async function() {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlet response = await fetch(credentials[check].url);\n\t\t\t\t\t\t\tif (!response.ok) return false;\n\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcredentials[check].userInput = false;\n\t\t\t\t}\n\t\t\t\tif (credentials[check].type == \"pc-totp\") {\n\t\t\t\t\tcredentials[check].message = modules.locales.get(\"TOTP_PC_PROMPT\");\n\t\t\t\t\tcredentials[check].type = \"text\";\n\t\t\t\t\tcredentials[check].userInput = true;\n\t\t\t\t\tcredentials[check].verify = async function(input) {\n\t\t\t\t\t\tlet sha256 = async b => Array.from(new Uint8Array(await crypto.subtle.digest(\"SHA-256\", new TextEncoder().encode(b)))).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\t\tlet c = Math.floor((Math.floor(Date.now() / 1000)) / 30);\n\t\t\t\t\t\tlet hash = await sha256(credentials[check].secret + c);\n\t\t\t\t\t\thash = parseInt(hash, 16);\n\t\t\t\t\t\thash = hash % 60466176;\n\t\t\t\t\t\thash = hash.toString();\n\t\t\t\t\t\thash = hash.split(\"\", 6);\n\t\t\t\t\t\thash = hash.join(\"\");\n\t\t\t\t\t\treturn hash == input;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (credentials[check].type == \"totp\") {\n\t\t\t\t\tcredentials[check].message = modules.locales.get(\"TOTP_PROMPT\");\n\t\t\t\t\tcredentials[check].type = \"text\";\n\t\t\t\t\tcredentials[check].userInput = true;\n\t\t\t\t\tlet hexToU8A = (hex) => Uint8Array.from(hex.match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\t\t\tlet keyImport = await crypto.subtle.importKey(\"raw\", hexToU8A(credentials[check].secret?.padStart(20, \"0\")), {\n\t\t\t\t\t\tname: \"HMAC\",\n\t\t\t\t\t\thash: \"SHA-1\"\n\t\t\t\t\t}, true, [ \"sign\" ]);\n\t\t\t\t\t\n\t\t\t\t\tcredentials[check].verify = async function(input) {\n\t\t\t\t\t\tlet counter = hexToU8A(Math.floor(Date.now() / 30000).toString(16).padStart(16, \"0\"));\n\t\t\t\t\t\tlet hmacSign = await crypto.subtle.sign(\"HMAC\", keyImport, counter);\n\t\t\t\t\t\thmacSign = Array.from(new Uint8Array(hmacSign));\n\t\t\t\t\t\tlet offset = hmacSign[19] & 0xf; // https://datatracker.ietf.org/doc/html/rfc4226#section-5.4\n\t\t\t\t\t\tlet code = (hmacSign[offset] & 0x7f) << 24\n\t\t\t\t\t\t\t| (hmacSign[offset + 1] & 0xff) << 16\n\t\t\t\t\t\t\t| (hmacSign[offset + 2] & 0xff) << 8\n\t\t\t\t\t\t\t| (hmacSign[offset + 3] & 0xff);\n\t\t\t\t\t\tcode = code % 1000000;\n\t\t\t\t\t\treturn (code.toString() == input) || (code.toString().padStart(6, \"0\") == input);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (credentials[check].type == \"workingHours\") {\n\t\t\t\t\tlet workingHourStarts = new Date();\n\t\t\t\t\tworkingHourStarts.setHours(credentials[check].start.hours || 0, credentials[check].start.minutes || 0, credentials[check].start.seconds || 0);\n\t\t\t\t\tlet workingHourEnds = new Date();\n\t\t\t\t\tworkingHourEnds.setHours(credentials[check].end.hours || 0, credentials[check].end.minutes || 0, credentials[check].end.seconds || 0);\n\t\t\t\t\t\n\t\t\t\t\tif (new Date() > workingHourEnds || new Date() < workingHourStarts) {\n\t\t\t\t\t\tcredentials[check].message = modules.locales.get(\"WORKING_HOURS_UNMET\");\n\t\t\t\t\t\tcredentials[check].type = \"informative\";\n\t\t\t\t\t\tcredentials[check].userInput = false;\n\t\t\t\t\t\tcredentials[check].verify = () => false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcredentials[check].message = modules.locales.get(\"AUTH_SUCCESS\");\n\t\t\t\t\t\tcredentials[check].type = \"promise\";\n\t\t\t\t\t\tcredentials[check].userInput = false;\n\t\t\t\t\t\tcredentials[check].verify = () => true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (credentials[check].type == \"zkpp\") {\n\t\t\t\t\tcredentials[check].message = modules.locales.get(\"MODULE_REQUIRED\").replace(\"%s\", \"tweetnacl\");\n\t\t\t\t\tcredentials[check].type = \"informative\";\n\t\t\t\t\tcredentials[check].userInput = false;\n\t\t\t\t\tcredentials[check].verify = () => false;\n\t\t\t\t\tif (window.nacl) {\n\t\t\t\t\t\tlet hexToU8A = (hex) => Uint8Array.from(hex.match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\t\t\t\tlet randomChallenge = crypto.getRandomValues(new Uint8Array(64)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\t\t\tcredentials[check].message = modules.locales.get(\"PASSWORD_PROMPT\");\n\t\t\t\t\t\tcredentials[check].type = \"zkpp_password\";\n\t\t\t\t\t\tcredentials[check].userInput = true;\n\t\t\t\t\t\tcredentials[check].challenge = randomChallenge;\n\t\t\t\t\t\tcredentials[check].verify = input => nacl.sign.detached.verify(hexToU8A(credentials[check].challenge), hexToU8A(input), hexToU8A(credentials[check].publicKey));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (credentials[check].type == \"privrestrict\") {\n\t\t\t\t\tcredentials[check].message = modules.locales.get(\"RESTRICT_PROMPT\");\n\t\t\t\t\tcredentials[check].type = \"input\";\n\t\t\t\t\tcredentials[check].userInput = true;\n\t\t\t\t\tcredentials[check].verify = function(input) {\n\t\t\t\t\t\tlet admin = [ \"FS_UNMOUNT\", \"SWITCH_USERS_AUTOMATICALLY\", \"USER_INFO_OTHERS\", \"SET_USER_INFO\", \"FS_BYPASS_PERMISSIONS\", \"IPC_BYPASS_PERMISSIONS\", \"TASK_BYPASS_PERMISSIONS\", \"SENSITIVE_USER_INFO_OTHERS\", \"SYSTEM_STABILITY\", \"RUN_KLVL_CODE\", \"IDENTIFY_SYSTEM_SENSITIVE\", \"WEBSOCKET_BYPASS_PERMISSIONS\", \"LLDISK_READ\", \"LLDISK_WRITE\", \"LLDISK_LIST_PARTITIONS\", \"LLDISK_REMOVE\", \"LLDISK_IDB_READ\", \"LLDISK_IDB_WRITE\", \"LLDISK_IDB_REMOVE\", \"LLDISK_IDB_LIST\", \"LLDISK_IDB_SYNC\", \"FS_MOUNT\", \"SET_DEFAULT_SYSTEM\", \"GET_SYSTEM_RESOURCES\", \"LLDISK_INIT_PARTITIONS\", \"LOGOUT_OTHERS\", \"LULL_SYSTEM_FORCE\", \"CONNLESS_LISTEN_GLOBAL\", \"GET_USER_LIST\", \"CONNFUL_LISTEN_GLOBAL\", \"NETWORK_RAW_WRITE\", \"NETWORK_RAW_READ\", \"SET_FIRMWARE\", \"RELOAD_NETWORK_CONFIG\" ];\n\t\t\t\t\t\tlet write = [ \"FS_WRITE\", \"FS_REMOVE\", \"FS_CHANGE_PERMISSION\", \"SET_SECURITY_CHECKS\" ];\n\t\t\t\t\t\tif (input == \"full\") return [];\n\t\t\t\t\t\tif (input == \"ro\") return [ ...admin, ...write ];\n\t\t\t\t\t\treturn admin;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (credentials.length == 0) {\n\t\t\t\tcredentials.push({\n\t\t\t\t\ttype: \"informative\",\n\t\t\t\t\tmessage: modules.locales.get(\"ACCESS_NOT_SETUP\"),\n\t\t\t\t\tuserInput: false,\n\t\t\t\t\tverify: () => false\n\t\t\t\t})\n\t\t\t}\n\t\t\treturn handleAuthentication(user, credentials);\n\t\t},\n\t\tgetUsers: async function(token) {\n\t\t\tlet userDB = JSON.parse(await modules.fs.read(modules.defaultSystem + \"/etc/security/users\"), token);\n\t\t\treturn Object.keys(userDB);\n\t\t}\n\t}\n}\nawait setupUsers();","6421cb64b14363f98f07e9de6b6b3a1aa0bbe0f1a783f72288b6893fb45b93aacfad188b34a01e2ec85d4ade78810b6ad176bb5f39cb46bb5c16f0468497de6b":"async function authui(ses = modules.session.active, user, token, isLogonScreen) {\n\t// @pcos-app-mode native\n\tif (modules.shuttingDown) return { hook: _ => _ };\n\tlet appToken;\n\tif (token) appToken = modules.tokens.fork(token);\n\telse {\n\t\tappToken = await modules.tokens.generate();\n\t\tawait modules.tokens.userInitialize(appToken, \"authui\");\n\t}\n\tlet hook = new Function();\n\tlet ipc = await modules.ipc.create();\n\tmodules.ipc.declareAccess(ipc, { owner: \"authui\", group: \"authui\", world: false });\n\tlet windowObject = modules.window(ses);\n\tif (isLogonScreen) windowObject.closeButton.classList.toggle(\"hidden\", true);\n\tlet authTask = await modules.tasks.exec(modules.defaultSystem + \"/apps/authui.js\", [], windowObject, appToken, false, [ ipc, user || \"\" ]);\n\tasync function waitForIt() {\n\t\tlet msg = await Promise.race([\n\t\t\tmodules.ipc.listenFor(ipc),\n\t\t\tmodules.tasks.waitTermination(authTask)\n\t\t]);\n\t\tdelete modules.ipc._ipc[ipc];\n\t\ttry {\n\t\t\tawait modules.tasks.sendSignal(authTask, 9);\n\t\t\thook(msg);\n\t\t} catch {\n\t\t\thook({\n\t\t\t\tsuccess: false,\n\t\t\t\tcancelled: true\n\t\t\t});\n\t\t}\n\t}\n\twaitForIt();\n\treturn { hook: (e) => hook = e };\n}\nmodules.authui = authui;","e2f516d6ed2a8c0757f401cb47b80bbc0cc23a1e92cabbe5243801205f51ac99b4e69130c96c46b95761bb5c5d2ce1c75802c7a2674bb9de0133631a4ffca17d":"async function consentui(ses = modules.session.active, config, token) {\n\t// @pcos-app-mode native\n\tif (modules.shuttingDown) return { hook: _ => _ };\n\tlet appToken;\n\tif (token) appToken = modules.tokens.fork(token);\n\telse {\n\t\tappToken = await modules.tokens.generate();\n\t\tawait modules.tokens.userInitialize(appToken, \"authui\");\n\t}\n\tlet hook = new Function();\n\tlet ipc = await modules.ipc.create();\n\tmodules.ipc.declareAccess(ipc, { owner: \"authui\", group: \"authui\", world: false });\n\tlet windowObject = modules.window(ses);\n\tlet authTask = await modules.tasks.exec(modules.defaultSystem + \"/apps/consentui.js\", [], windowObject, appToken, false, [\n\t\tipc,\n\t\tconfig.user || \"\",\n\t\tJSON.stringify({\n\t\t\tpath: config.path,\n\t\t\targs: config.args,\n\t\t\tsubmittedIntent: config.intent,\n\t\t\tsubmittedName: config.name\n\t\t}),\n\t\tconfig.sessionToken || \"\"\n\t]);\n\tasync function waitForIt() {\n\t\tlet msg = await Promise.race([\n\t\t\tmodules.ipc.listenFor(ipc),\n\t\t\tmodules.tasks.waitTermination(authTask)\n\t\t]);\n\t\tdelete modules.ipc._ipc[ipc];\n\t\ttry {\n\t\t\tawait modules.tasks.sendSignal(authTask, 9);\n\t\t\thook(msg);\n\t\t} catch {\n\t\t\thook({\n\t\t\t\tsuccess: false,\n\t\t\t\tcancelled: true\n\t\t\t});\n\t\t}\n\t}\n\twaitForIt();\n\treturn { hook: (e) => hook = e };\n}\nmodules.consentui = consentui;","467c549fde5d1ebe135a3b1492f87b08623fea900121a34b3412ecd1bdce2f217fbdd2fc6e72d1fa1b78319b50c58f85c60f502f0e5fff38354fbb4a5a50cc88":"async function requireLogon() {\n\t// @pcos-app-mode native\n\ttry {\n\t\tlet startupSoundPerm = await modules.fs.permissions(modules.defaultSystem + \"/etc/sounds/startup.aud\");\n\t\tif (!startupSoundPerm.world.includes(\"r\")) throw new Error(\"Not allowed to read startup.aud\");\n\t\tlet startupSound = await modules.fs.read(modules.defaultSystem + \"/etc/sounds/startup.aud\");\n\t\tlet startupAudio = new Audio();\n\t\tstartupAudio.src = startupSound;\n\t\tstartupAudio.play();\n\t} catch (e) {\n\t\tconsole.error(\"Failed to play startup sound:\", e);\n\t}\n\tlet liu = {};\n\tmodules.liu = liu;\n\tserviceLogon();\n\tasync function handleLogin(resolvedLogon, liu) {\n\t\tmodules.session.muteAllSessions();\n\t\tlet userInfo = await modules.tokens.info(resolvedLogon.token);\n\t\tlet session;\n\t\tlet liuUser = userInfo.user;\n\t\tlet wasLiuLoaded = false;\n\t\tif (liu.hasOwnProperty(userInfo.user)) {\n\t\t\tsession = liu[userInfo.user].session;\n\t\t\tawait modules.tokens.revoke(resolvedLogon.token);\n\t\t\tresolvedLogon = liu[userInfo.user].logon;\n\t\t\tuserInfo = await modules.tokens.info(resolvedLogon.token);\n\t\t\twasLiuLoaded = true;\n\t\t} else {\n\t\t\tsession = modules.session.mksession();\n\t\t\tliu[userInfo.user] = {\n\t\t\t\tsession,\n\t\t\t\tlogon: resolvedLogon,\n\t\t\t}\n\t\t}\n\t\tif (modules.session.attrib(session, \"secureID\")) return modules.session.activateSession(modules.session.attrib(session, \"secureID\"));\n\t\tmodules.session.activateSession(session);\n\t\tlet dom = modules.session.tracker[session].html;\n\t\tlet bgPic = \"\";\n\t\tlet isDark = false;\n\t\tlet locale;\n\t\tlet basicPrivilegeChecklist = [ \"FS_READ\", \"FS_LIST_PARTITIONS\", \"IPC_SEND_PIPE\", \"IPC_LISTEN_PIPE\", \"START_TASK\", \"GET_LOCALE\", \"GET_THEME\", \"LOGOUT\" ];\n\t\tif (!basicPrivilegeChecklist.every(privilege => userInfo.privileges.includes(privilege))) {\n\t\t\tlet failureMessage = modules.window(session);\n\t\t\tfailureMessage.title.innerText = \"Permission denied\";\n\t\t\tfailureMessage.content.style.padding = \"8px\";\n\t\t\tfailureMessage.content.innerText = \"There were not enough privileges to log you in. Please contact your system administrator.\";\n\t\t\tfailureMessage.closeButton.onclick = async function() {\n\t\t\t\tfailureMessage.windowDiv.remove();\n\t\t\t\tawait modules.logOut(userInfo.user);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tlet permissions = await modules.fs.permissions((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.wallpaper\", resolvedLogon.token);\n\t\t\tif (permissions.owner != userInfo.user && !userInfo.groups.includes(permissions.group) && !(permissions.world.includes(\"r\") && permissions.world.includes(\"x\")) && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\tthrow new Error(\"Permission denied reading wallpaper\");\n\t\t\t}\n\t\t\tbgPic = await modules.fs.read((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.wallpaper\", resolvedLogon.token);\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to read wallpaper:\", e);\n\t\t}\n\t\ttry {\n\t\t\tlet permissionsdm = await modules.fs.permissions((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.darkmode\", resolvedLogon.token);\n\t\t\tif (permissionsdm.owner != userInfo.user && !userInfo.groups.includes(permissionsdm.group) && !(permissionsdm.world.includes(\"r\") && permissionsdm.world.includes(\"x\")) && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\tthrow new Error(\"Permission denied reading dark mode preference\");\n\t\t\t}\n\t\t\tisDark = (await modules.fs.read((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.darkmode\", resolvedLogon.token)) == \"true\";\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to read dark mode preference:\", e);\n\t\t}\n\t\ttry {\n\t\t\tlet permissionsloc = await modules.fs.permissions((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.locale\", resolvedLogon.token);\n\t\t\tif (permissionsloc.owner != userInfo.user && !userInfo.groups.includes(permissionsloc.group) && !(permissionsloc.world.includes(\"r\") && permissionsloc.world.includes(\"x\")) && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\tthrow new Error(\"Permission denied reading locale preference\");\n\t\t\t}\n\t\t\tlocale = await modules.fs.read((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.locale\", resolvedLogon.token);\n\t\t\tmodules.session.attrib(session, \"language\", locale);\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to read dark mode preference:\", e);\n\t\t}\n\t\tif (modules.core.bootMode == \"safe\") {\n\t\t\tisDark = true;\n\t\t\tbgPic = \"\";\n\t\t}\n\t\tmodules.session.attrib(session, \"dark\", isDark);\n\t\tdom.style.background = bgPic ? \"url(\" + JSON.stringify(bgPic) + \")\" : \"black\";\n\t\tif (!dom.style.background) dom.style.background = \"black\";\n\t\tdom.style.backgroundSize = \"100% 100%\";\n\t\tif (!wasLiuLoaded) {\n\t\t\tlet autoRunNecessities = [];\n\t\t\ttry {\n\t\t\t\tlet autoRunPermissions = await modules.fs.permissions((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.autorunNecessity\", resolvedLogon.token);\n\t\t\t\tif (autoRunPermissions.owner != userInfo.user && !userInfo.groups.includes(autoRunPermissions.group) && !(autoRunPermissions.world.includes(\"r\") && autoRunPermissions.world.includes(\"x\")) && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\t\tthrow new Error(\"Permission denied reading autorun necessities\");\n\t\t\t\t}\n\t\t\t\tif (modules.core.bootMode != \"safe\") autoRunNecessities = await modules.fs.ls((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.autorunNecessity\", resolvedLogon.token);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(\"Failed to read autorun necessities:\", e);\n\t\t\t}\n\t\t\tfunction breakNecessityFailure() {\n\t\t\t\tlet failureMessage = modules.window(session);\n\t\t\t\tfailureMessage.title.innerText = modules.locales.get(\"PERMISSION_DENIED\", locale);\n\t\t\t\tfailureMessage.content.style.padding = \"8px\";\n\t\t\t\tfailureMessage.content.innerText = modules.locales.get(\"AUTORUN_NECESSITIES_FAILED\", locale);\n\t\t\t\tfailureMessage.closeButton.onclick = async function() {\n\t\t\t\t\tfailureMessage.windowDiv.remove();\n\t\t\t\t\tawait modules.logOut(userInfo.user);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let autoRunNecessity of autoRunNecessities) {\n\t\t\t\tlet necessityPermissions = await modules.fs.permissions((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.autorunNecessity/\" + autoRunNecessity, resolvedLogon.token);\n\t\t\t\tif (necessityPermissions.owner != userInfo.user && !userInfo.groups.includes(necessityPermissions.group) && !(necessityPermissions.world.includes(\"r\") && necessityPermissions.world.includes(\"x\")) && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\t\treturn breakNecessityFailure();\n\t\t\t\t}\n\t\t\t\tlet link = await modules.fs.read((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.autorunNecessity/\" + autoRunNecessity, resolvedLogon.token);\n\t\t\t\ttry {\n\t\t\t\t\tlink = JSON.parse(link);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(\"Failed to parse autorun necessity:\", e);\n\t\t\t\t\treturn breakNecessityFailure();\n\t\t\t\t}\n\t\t\t\tif (link.disabled) continue;\n\t\t\t\ttry {\n\t\t\t\t\tlet ipcPipe = modules.ipc.create();\n\t\t\t\t\tmodules.ipc.declareAccess(ipcPipe, {\n\t\t\t\t\t\towner: userInfo.user,\n\t\t\t\t\t\tgroup: userInfo.groups[0],\n\t\t\t\t\t\tworld: false\n\t\t\t\t\t});\n\t\t\t\t\tlet forkedToken;\n\t\t\t\t\tif (link.automaticLogon) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlet logon = await modules.users.access(link.automaticLogon.username, resolvedLogon.token);\n\t\t\t\t\t\t\tlogon = await logon.getNextPrompt();\n\t\t\t\t\t\t\tfor (let response of link.automaticLogon.responses)\n\t\t\t\t\t\t\t\tif (logon.success == \"intermediate\") logon = await logon.input(response);\n\t\t\t\t\t\t\tif (!logon.success) throw new Error(logon.message);\n\t\t\t\t\t\t\tforkedToken = logon.token;\n\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\tif (necessityPermissions.world.includes(\"r\") && forkedToken) {\n\t\t\t\t\t\t\tlet ownUser = await modules.tokens.info(forkedToken);\n\t\t\t\t\t\t\tlet ownUserInfo = await modules.users.getUserInfo(ownUser.user, true, forkedToken);\n\t\t\t\t\t\t\townUserInfo.securityChecks = [];\n\t\t\t\t\t\t\tawait modules.users.moduser(ownUser.user, ownUserInfo, forkedToken);\n\t\t\t\t\t\t\tawait modules.tokens.revoke(forkedToken);\n\t\t\t\t\t\t\tforkedToken = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!forkedToken) forkedToken = await modules.tokens.fork(resolvedLogon.token);\n\t\t\t\t\tlet appWindow = modules.window(session);\n\t\t\t\t\tlet ipcResult = modules.ipc.listenFor(ipcPipe);\n\t\t\t\t\tlet taskId = await modules.tasks.exec(link.path, [ ...(link.args || []), ipcPipe ], appWindow, forkedToken, true);\n\t\t\t\t\tlet finishTaskPromise = new Promise(function(resolve) {\n\t\t\t\t\t\tmodules.tasks.tracker[taskId].ree.beforeCloseDown(() => resolve());\n\t\t\t\t\t})\n\t\t\t\t\tipcResult = await Promise.race([ipcResult, finishTaskPromise]);\n\t\t\t\t\tif (!ipcResult) throw new Error(\"Software rejected autorun necessity.\");\n\t\t\t\t\tif (modules.tasks.tracker.hasOwnProperty(taskId)) await modules.tasks.sendSignal(taskId, 9);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(\"Failed to execute autorun necessity:\", e);\n\t\t\t\t\treturn breakNecessityFailure();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlet autoRun = [];\n\t\t\ttry {\n\t\t\t\tlet autoRunPermissions = await modules.fs.permissions((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.autorun\", resolvedLogon.token);\n\t\t\t\tif (autoRunPermissions.owner != userInfo.user && !userInfo.groups.includes(autoRunPermissions.group) && !(autoRunPermissions.world.includes(\"r\") && autoRunPermissions.world.includes(\"x\")) && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\t\tthrow new Error(\"Permission denied reading autorun\");\n\t\t\t\t}\n\t\t\t\tif (modules.core.bootMode != \"safe\") autoRun = await modules.fs.ls((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.autorun\", resolvedLogon.token);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(\"Failed to read autorun:\", e);\n\t\t\t}\n\t\t\tfor (let autoRunFile of autoRun) {\n\t\t\t\tlet autoRunItemPermissions = await modules.fs.permissions((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.autorun/\" + autoRunFile, resolvedLogon.token);\n\t\t\t\tif (autoRunItemPermissions.owner != userInfo.user && !userInfo.groups.includes(autoRunItemPermissions.group) && !(autoRunItemPermissions.world.includes(\"r\") && autoRunItemPermissions.world.includes(\"x\")) && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) continue;\n\t\t\t\tlet link = await modules.fs.read((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.autorun/\" + autoRunFile, resolvedLogon.token);\n\t\t\t\ttry {\n\t\t\t\t\tlink = JSON.parse(link);\n\t\t\t\t} catch {}\n\t\t\t\tif (link.disabled) continue;\n\t\t\t\ttry {\n\t\t\t\t\tlet forkedToken;\n\t\t\t\t\tif (link.automaticLogon) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlet logon = await modules.users.access(link.automaticLogon.username, resolvedLogon.token);\n\t\t\t\t\t\t\tlogon = await logon.getNextPrompt();\n\t\t\t\t\t\t\tfor (let response of link.automaticLogon.responses)\n\t\t\t\t\t\t\t\tif (logon.success == \"intermediate\") logon = await logon.input(response);\n\t\t\t\t\t\t\tif (!logon.success) throw new Error(logon.message);\n\t\t\t\t\t\t\tforkedToken = logon.token;\n\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\tif (autoRunItemPermissions.world.includes(\"r\") && forkedToken) {\n\t\t\t\t\t\t\tlet ownUser = await modules.tokens.info(forkedToken);\n\t\t\t\t\t\t\tlet ownUserInfo = await modules.users.getUserInfo(ownUser.user, true, forkedToken);\n\t\t\t\t\t\t\townUserInfo.securityChecks = [];\n\t\t\t\t\t\t\tawait modules.users.moduser(ownUser.user, ownUserInfo, forkedToken);\n\t\t\t\t\t\t\tawait modules.tokens.revoke(forkedToken);\n\t\t\t\t\t\t\tforkedToken = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!forkedToken) forkedToken = await modules.tokens.fork(resolvedLogon.token);\n\t\t\t\t\tlet appWindow = modules.window(session);\n\t\t\t\t\tawait modules.tasks.exec(link.path, [ ...(link.args || []) ], appWindow, forkedToken);\n\t\t\t\t} catch {}\n\t\t\t}\n\n\t\t\tlet icons = [];\n\t\t\tlet lastIconPlacement = [ 72, 72 ];\n\t\t\ttry {\n\t\t\t\tlet permissions = await modules.fs.permissions((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/desktop\", resolvedLogon.token);\n\t\t\t\tif (permissions.owner != userInfo.user && !userInfo.groups.includes(permissions.group) && !(permissions.world.includes(\"r\") && permissions.world.includes(\"x\")) && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\t\tthrow new Error(\"Permission denied reading desktop icons\");\n\t\t\t\t}\n\t\t\t\ticons = await modules.fs.ls((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/desktop\", resolvedLogon.token);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(\"Failed to read desktop icons:\", e);\n\t\t\t}\n\t\t\tfor (let icon of icons) {\n\t\t\t\tif (icon.split(\"/\").slice(-1)[0].startsWith(\".\")) continue;\n\t\t\t\ttry {\n\t\t\t\t\tlet iconPath = (await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/desktop/\" + icon;\n\t\t\t\t\tlet permissions = await modules.fs.permissions(iconPath, resolvedLogon.token);\n\t\t\t\t\tif (permissions.owner != userInfo.user && !userInfo.groups.includes(permissions.group) && !permissions.world.includes(\"r\") && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\t\t\tthrow new Error(\"Permission denied reading desktop icon\");\n\t\t\t\t\t}\n\t\t\t\t\tlet isDir = await modules.fs.isDirectory(iconPath, resolvedLogon.token);\n\t\t\t\t\tlet linkName = iconPath.split(\"/\").slice(-1)[0];\n\t\t\t\t\tlet appLink = { path: modules.defaultSystem + \"/apps/explorer.js\", args: [ iconPath ], name: linkName, placed: lastIconPlacement, icon: modules.defaultSystem + \"/etc/icons/fileicon.pic\" };\n\t\t\t\t\tif (!isDir) {\n\t\t\t\t\t\tif (linkName.endsWith(\".lnk\")) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tappLink = { placed: lastIconPlacement, icon: modules.defaultSystem + \"/etc/icons/lnk.pic\", ...(JSON.parse(await modules.fs.read(iconPath, resolvedLogon.token))) };\n\t\t\t\t\t\t\t\tappLink._isRealLink = true;\n\t\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\t} else if (linkName.endsWith(\".js\")) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tappLink = { path: iconPath, args: [], name: linkName, placed: lastIconPlacement, icon: modules.defaultSystem + \"/etc/icons/js.pic\" };\n\t\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet ext = linkName.split(\".\").slice(-1)[0];\n\t\t\t\t\t\t\tlet assocsPermissions = await modules.fs.permissions(modules.defaultSystem + \"/apps/associations\", resolvedLogon.token);\n\t\t\t\t\t\t\tif (assocsPermissions.owner != userInfo.user && !userInfo.groups.includes(assocsPermissions.group) && !(assocsPermissions.world.includes(\"r\") && assocsPermissions.world.includes(\"x\")) && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\t\t\t\t\tthrow new Error(\"Permission denied reading associations\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet associations = await modules.fs.ls(modules.defaultSystem + \"/apps/associations\", resolvedLogon.token);\n\t\t\t\t\t\t\tif (!associations.includes(ext)) appLink.disabled = true;\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tlet associationPermissions = await modules.fs.permissions(modules.defaultSystem + \"/apps/associations/\" + ext, resolvedLogon.token);\n\t\t\t\t\t\t\t\tif (!associationPermissions.world.includes(\"r\") && !userInfo.groups.includes(associationPermissions.group) && associationPermissions.owner != userInfo.user && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\t\t\t\t\t\tthrow new Error(\"Permission denied reading association\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tappLink = { placed: lastIconPlacement, icon: appLink.icon, ...(JSON.parse(await modules.fs.read(modules.defaultSystem + \"/apps/associations/\" + ext, resolvedLogon.token))) };\n\t\t\t\t\t\t\t\tappLink.args = [ ...(appLink.args || []), iconPath ];\n\t\t\t\t\t\t\t\tappLink.name = linkName;\n\t\t\t\t\t\t\t\tdelete appLink.localeDatabaseName;\n\t\t\t\t\t\t\t\tdelete appLink.localeReferenceName;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (appLink.disabled) continue;\n\t\t\t\t\tif (isDir) appLink.icon = modules.defaultSystem + \"/etc/icons/foldericon.pic\";\n\t\t\t\t\tlet iconWindow = modules.window(session, false, true, async function(newx, newy) {\n\t\t\t\t\t\tif (appLink._isRealLink) {\n\t\t\t\t\t\t\tappLink.placed = [ newx, newy ];\n\t\t\t\t\t\t\tdelete appLink._isRealLink;\n\t\t\t\t\t\t\tif (permissions.owner != userInfo.user && !userInfo.groups.includes(permissions.group) && !permissions.world.includes(\"w\") && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\t\t\t\t\tthrow new Error(\"Permission denied writing desktop icon\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tawait modules.fs.write(iconPath, JSON.stringify(appLink), resolvedLogon.token);\n\t\t\t\t\t\t\tappLink._isRealLink = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\ticonWindow.title.innerText = (appLink.localeReferenceName ? modules.locales.get(appLink.localeReferenceName, locale) : null) || (appLink.localeDatabaseName ? (appLink.localeDatabaseName[locale] || appLink.localeDatabaseName[modules.locales.defaultLocale] || appLink.localeDatabaseName[navigator.language.slice(0, 2).toLowerCase()]) : null) || appLink.name;\n\t\t\t\t\tlet iconEl = document.createElement(\"img\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet permissions = await modules.fs.permissions(appLink.icon, resolvedLogon.token);\n\t\t\t\t\t\tif (permissions.owner != userInfo.user && !userInfo.groups.includes(permissions.group) && !permissions.world.includes(\"r\") && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\t\t\t\tthrow new Error(\"Permission denied reading desktop icon picture\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\ticonEl.src = await modules.fs.read(appLink.icon, resolvedLogon.token);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tconsole.error(\"Failed to read desktop icon picture:\", e);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\ticonEl.style = \"width: 100%; height: 100%; position: absolute;\";\n\t\t\t\t\ticonWindow.content.appendChild(iconEl);\n\t\t\t\t\ticonWindow.windowDiv.style.top = appLink.placed[1] + \"px\";\n\t\t\t\t\ticonWindow.windowDiv.style.left = appLink.placed[0] + \"px\";\n\t\t\t\t\ticonEl.addEventListener(\"click\", async function() {\n\t\t\t\t\t\tlet forkedToken;\n\t\t\t\t\t\tif (appLink.automaticLogon) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlet logon = await modules.users.access(appLink.automaticLogon.username, resolvedLogon.token);\n\t\t\t\t\t\t\t\tlogon = await logon.getNextPrompt();\n\t\t\t\t\t\t\t\tfor (let response of appLink.automaticLogon.responses)\n\t\t\t\t\t\t\t\t\tif (logon.success == \"intermediate\") logon = await logon.input(response);\n\t\t\t\t\t\t\t\tif (!logon.success) throw new Error(logon.message);\n\t\t\t\t\t\t\t\tforkedToken = logon.token;\n\t\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!forkedToken) forkedToken = await modules.tokens.fork(resolvedLogon.token);\n\t\t\t\t\t\tlet appWindow = modules.window(session);\n\t\t\t\t\t\tawait modules.tasks.exec(appLink.path, [ ...(appLink.args || []) ], appWindow, forkedToken);\n\t\t\t\t\t});\n\t\t\t\t\tlastIconPlacement = appLink.placed;\n\t\t\t\t\tlastIconPlacement[1] += 136;\n\t\t\t\t\tif (lastIconPlacement[1] > (dom.clientHeight - 136)) {\n\t\t\t\t\t\tlastIconPlacement[0] += 136;\n\t\t\t\t\t\tlastIconPlacement[1] = 72;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(\"Failed to read desktop icon:\", e);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet startMenuChannel = modules.ipc.create();\n\t\t\tmodules.ipc.declareAccess(startMenuChannel, {\n\t\t\t\towner: userInfo.user,\n\t\t\t\tgroup: userInfo.groups[0],\n\t\t\t\tworld: false\n\t\t\t});\n\t\t\tlet { taskbar, icons: taskbarIcons, startButton } = modules.session.tracker[session].extendedHTML;\n\t\t\tlet startMenu = modules.window(session);\n\t\t\tlet forkedStartMenuToken = await modules.tokens.fork(resolvedLogon.token);\n\n\t\t\tfunction startMenuStub() {\n\t\t\t\tif (startMenu.windowDiv.parentElement == null) startMenu = modules.window(session);\n\t\t\t\tstartMenu.windowDiv.classList.toggle(\"hidden\", true);\n\t\t\t\tstartMenu.title.innerText = modules.locales.get(\"START_MENU\", locale);\n\t\t\t\tstartMenu.content.style.padding = \"8px\";\n\t\t\t\tstartMenu.content.innerText = \"\";\n\t\t\t\tlet description = document.createElement(\"span\");\n\t\t\t\tlet logout = document.createElement(\"button\");\n\t\t\t\tdescription.innerText = modules.locales.get(\"START_MENU_FAILED\", locale);\n\t\t\t\tlogout.innerText = modules.locales.get(\"LOG_OUT_BUTTON\", locale).replace(\"%s\", userInfo.user);\n\t\t\t\tlogout.onclick = _ => modules.logOut(userInfo.user);\n\t\t\t\tstartMenu.content.appendChild(description);\n\t\t\t\tstartMenu.content.appendChild(document.createElement(\"br\"));\n\t\t\t\tstartMenu.content.appendChild(logout);\n\t\t\t\tstartMenu.closeButton.onclick = () => startMenu.windowDiv.classList.toggle(\"hidden\", true);\n\t\t\t\tstartButton.onclick = _ => startMenu.windowDiv.classList.toggle(\"hidden\");\n\t\t\t}\n\n\t\t\tstartMenuStub();\n\t\t\tstartButton.disabled = false;\n\t\t\ttry {\n\t\t\t\tawait modules.tasks.exec(modules.defaultSystem + \"/apps/startMenu.js\", [], startMenu, forkedStartMenuToken, true, startMenuChannel);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(\"Failed to start start menu:\", e);\n\t\t\t\tstartMenuStub();\n\t\t\t}\n\n\t\t\t(async function() {\n\t\t\t\twhile (true) {\n\t\t\t\t\tlet listen = await modules.ipc.listenFor(startMenuChannel);\n\t\t\t\t\tif (listen.run) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlet forkedToken;\n\t\t\t\t\t\t\tif (listen.run.automaticLogon) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tlet logon = await modules.users.access(listen.run.automaticLogon.username, resolvedLogon.token);\n\t\t\t\t\t\t\t\t\tlogon = await logon.getNextPrompt();\n\t\t\t\t\t\t\t\t\tfor (let response of listen.run.automaticLogon.responses)\n\t\t\t\t\t\t\t\t\t\tif (logon.success == \"intermediate\") logon = await logon.input(response);\n\t\t\t\t\t\t\t\t\tif (!logon.success) throw new Error(logon.message);\n\t\t\t\t\t\t\t\t\tforkedToken = logon.token;\n\t\t\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!forkedToken) forkedToken = await modules.tokens.fork(resolvedLogon.token);\n\t\t\t\t\t\t\tlet appWindow = modules.window(session);\n\t\t\t\t\t\t\tawait modules.tasks.exec(listen.run.path, [ ...(listen.run.args || []) ], appWindow, forkedToken);\n\t\t\t\t\t\t} catch {}\n\t\t\t\t\t} else if (listen.success) {\n\t\t\t\t\t\tstartButton.onclick = () => modules.ipc.send(startMenuChannel, { open: true });\n\t\t\t\t\t} else if (listen.dying) {\n\t\t\t\t\t\tstartMenu = modules.window(session);\n\t\t\t\t\t\tstartMenuStub();\n\t\t\t\t\t\tforkedStartMenuToken = await modules.tokens.fork(resolvedLogon.token);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait modules.tasks.exec(modules.defaultSystem + \"/apps/startMenu.js\", [], startMenu, forkedStartMenuToken, true, startMenuChannel);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tconsole.error(\"Failed to start start menu:\", e);\n\t\t\t\t\t\t\tstartMenuStub();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})();\n\n\t\t\tlet battery = document.createElement(\"div\");\n\t\t\tlet networkIcon = document.createElement(\"div\");\n\t\t\tlet pcosNetworkIcon = document.createElement(\"div\");\n\t\t\tlet iconCache = {};\n\t\t\tfor (let iconFile of [\"network_\", \"network_offline_\", \"pcos_network_\", \"pcos_network_offline_\", \"readyToPlay_\", \"batteryChargeFinished_\", \"dying_\", \"charging_\"]) {\n\t\t\t\ttry {\n\t\t\t\t\tlet permissions = await modules.fs.permissions(modules.defaultSystem + \"/etc/icons/\" + iconFile + \"icon.pic\", resolvedLogon.token);\n\t\t\t\t\tif (permissions.owner != userInfo.user && !userInfo.groups.includes(permissions.group) && !permissions.world.includes(\"r\") && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\t\t\tthrow new Error(\"Permission denied reading taskbar icon picture\");\n\t\t\t\t\t}\n\t\t\t\t\ticonCache[iconFile] = await modules.fs.read(modules.defaultSystem + \"/etc/icons/\" + iconFile + \"icon.pic\", resolvedLogon.token);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(\"Failed to read taskbar icon picture:\", e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tliu[liuUser].clockInterval = setInterval(async function() {\n\t\t\t\tnetworkIcon.style.backgroundImage = \"url(\" + JSON.stringify(navigator.onLine ? iconCache.network_ : iconCache.network_offline_) + \")\";\n\t\t\t\tnetworkIcon.title = modules.locales.get(\"NETWORK_STATUS_\" + (navigator.onLine ? \"ONLINE\" : \"OFFLINE\"), locale)\n\t\t\t\tpcosNetworkIcon.style.backgroundImage = \"url(\" + JSON.stringify(modules.network.connected ? iconCache.pcos_network_ : iconCache.pcos_network_offline_) + \")\";\n\t\t\t\tpcosNetworkIcon.title = modules.locales.get(\"PCOS_NETWORK_STATUS_\" + (modules.network.connected ? \"ONLINE\" : \"OFFLINE\"), locale).replace(\"%s\", userInfo.privileges.includes(\"GET_HOSTNAME\") ? (modules.network.hostname || modules.locales.get(\"UNKNOWN_PLACEHOLDER\", locale)) : modules.locales.get(\"UNKNOWN_PLACEHOLDER\", locale)).replace(\"%s\", userInfo.privileges.includes(\"GET_NETWORK_ADDRESS\") ? (modules.network.address || \"0\").match(/.{1,4}/g).join(\":\") : modules.locales.get(\"UNKNOWN_PLACEHOLDER\", locale));\n\t\t\t\tif (modules.network.serviceStopped) pcosNetworkIcon.title = modules.locales.get(\"PCOS_NETWORK_STATUS_STOPPED\", locale);\n\t\t\t\tlet batteryStatus = {charging: true, chargingTime: 0, dischargingTime: 0, level: 1};\n\t\t\t\tlet batteryStatusIcon = iconCache.readyToPlay_;\n\t\t\t\tlet batteryStatusDescription = modules.locales.get(\"BATTERY_STATUS_UNAVAILABLE\", locale);\n\t\t\t\tif (navigator.getBattery && userInfo.privileges.includes(\"GET_BATTERY_STATUS\")) {\n\t\t\t\t\tbatteryStatus = await navigator.getBattery();\n\t\t\t\t\tbatteryStatusDescription = modules.locales.get(\"BATTERY_STATUS_\" + (batteryStatus.charging ? \"CHARGING\" : \"DISCHARGING\"), locale)\n\t\t\t\t\t\t.replace(\"%s\", (batteryStatus.level * 100).toFixed(2))\n\t\t\t\t\t\t.replace(\"%s\", modules.userfriendliness.inconsiderateTime(\n\t\t\t\t\t\t\t(batteryStatus.charging ? batteryStatus.chargingTime : batteryStatus.dischargingTime) * 1000\n\t\t\t\t\t\t));\n\t\t\t\t\tif (batteryStatus.level < 0.2) batteryStatusIcon = iconCache.dying_;\n\t\t\t\t\tif (batteryStatus.charging) batteryStatusIcon = batteryStatus.level == 1 ? iconCache.batteryChargeFinished_ : iconCache.charging_;\n\t\t\t\t}\n\t\t\t\tbattery.style.backgroundImage = \"url(\" + JSON.stringify(batteryStatusIcon) + \")\";\n\t\t\t\tbattery.title = batteryStatusDescription;\n\t\t\t}, 500);\n\t\t\t\n\t\t\tbattery.className = \"icon\";\n\t\t\tnetworkIcon.className = \"icon\";\n\t\t\tpcosNetworkIcon.className = \"icon\";\n\t\t\ttaskbarIcons.appendChild(battery);\n\t\t\ttaskbarIcons.appendChild(networkIcon);\n\t\t\ttaskbarIcons.appendChild(pcosNetworkIcon);\n\t\t\tdom.appendChild(taskbar);\n\t\t}\n\t}\n\twhile (!modules.shuttingDown) {\n\t\tlet useDefaultUser = await modules.fs.permissions(modules.defaultSystem + \"/etc/security/automaticLogon\");\n\t\tuseDefaultUser = !useDefaultUser.world.includes(\"w\");\n\t\tlet defaultUser;\n\t\ttry {\n\t\t\tif (useDefaultUser) defaultUser = await modules.fs.read(modules.defaultSystem + \"/etc/security/automaticLogon\");\n\t\t} catch {}\n\t\tlet sysDom = modules.session.tracker[modules.session.systemSession].html;\n\t\tlet lockWallpaper = \"\";\n\t\tlet lockIsDark = false;\n\t\ttry {\n\t\t\tlockWallpaper = await modules.fs.read(modules.defaultSystem + \"/etc/wallpapers/lockscreen.pic\");\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to read lockscreen.pic:\", e);\n\t\t}\n\t\ttry {\n\t\t\tlockIsDark = (await modules.fs.read(modules.defaultSystem + \"/etc/darkLockScreen\")) == \"true\";\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to read darkLockScreen:\", e);\n\t\t}\n\t\tif (modules.core.bootMode == \"safe\") {\n\t\t\tlockIsDark = true;\n\t\t\tlockWallpaper = \"\";\n\t\t}\n\t\tsysDom.style.background = lockWallpaper ? \"url(\" + JSON.stringify(lockWallpaper) + \")\" : \"black\";\n\t\tif (!sysDom.style.background) sysDom.style.background = \"black\";\n\t\tsysDom.style.backgroundSize = \"100% 100%\";\n\t\tmodules.session.attrib(modules.session.systemSession, \"dark\", lockIsDark);\n\t\tlet logon, resolvedLogon;\n\t\twhile (!modules.shuttingDown) {\n\t\t\tlogon = await modules.authui(modules.session.systemSession, defaultUser, undefined, true);\n\t\t\tresolvedLogon = await waitForLogon(logon);\n\t\t\tif (resolvedLogon.success) break;\n\t\t}\n\t\tif (!resolvedLogon.success) break;\n\t\thandleLogin(resolvedLogon, liu);\n\t\tif (useDefaultUser && defaultUser) {\n\t\t\tlet newWindow = modules.window(modules.session.systemSession);\n\t\t\tnewWindow.title.innerText = modules.locales.get(\"LOG_IN_INVITATION\");\n\t\t\tlet button = document.createElement(\"button\");\n\t\t\tbutton.innerText = modules.locales.get(\"LOG_IN_INVITATION\");\n\t\t\tnewWindow.content.appendChild(button);\n\t\t\tnewWindow.closeButton.classList.toggle(\"hidden\", true);\n\t\t\tawait hookButtonClick(button);\n\t\t\tnewWindow.windowDiv.remove();\n\t\t}\n\t}\n}\n\nasync function serviceLogon() {\n\tlet session = modules.session.mksession();\n\tmodules.session.attrib(session, \"dark\", true);\n\tlet dom = modules.session.tracker[session].html;\n\tdom.style.backgroundColor = \"black\";\n\tlet message = document.createElement(\"span\");\n\tmessage.innerText = \"Service Desktop\";\n\tmessage.style = \"position: absolute; right: 8px; bottom: 8px; color: white;\";\n\tdom.appendChild(message);\n\tlet startButton = document.createElement(\"button\");\n\tstartButton.innerText = modules.locales.get(\"START_MENU_BTN\");\n\tstartButton.style = \"padding: 4px;\";\n\tstartButton.onclick = async function() {\n\t\tlet startMenu = modules.window(session);\n\t\tstartMenu.title.innerText = modules.locales.get(\"START_MENU\");\n\t\tstartMenu.content.style.padding = \"8px\";\n\t\tstartMenu.closeButton.onclick = () => startMenu.windowDiv.remove();\n\t\tlet lockButton = document.createElement(\"button\");\n\t\tlockButton.innerText = modules.locales.get(\"LOCK_BUTTON\");\n\t\tstartMenu.content.appendChild(lockButton);\n\t\tlockButton.onclick = async function() {\n\t\t\tstartMenu.windowDiv.remove();\n\t\t\tawait modules.session.muteAllSessions();\n\t\t\tawait modules.session.activateSession(modules.session.systemSession);\n\t\t}\n\t}\n\tlet taskbar = modules.session.tracker[session].extendedHTML.taskbar;\n\n\ttaskbar.appendChild(startButton);\n\tdom.appendChild(taskbar);\n\tmodules.serviceSession = session;\n\tif (modules.core.bootMode != \"safe\") {\n\t\tlet serviceList = [];\n\t\ttry {\n\t\t\tserviceList = await modules.fs.ls(modules.defaultSystem + \"/apps/services\");\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to list services:\", e);\n\t\t}\n\t\tfor (let service of serviceList) {\n\t\t\tlet serviceConfig;\n\t\t\tlet triggerPasswordReset = false;\n\t\t\ttry {\n\t\t\t\tlet permissions = await modules.fs.permissions(modules.defaultSystem + \"/apps/services/\" + service);\n\t\t\t\tif (permissions.world.includes(\"r\")) triggerPasswordReset = true;\n\t\t\t} catch {}\n\t\t\ttry {\n\t\t\t\tserviceConfig = await modules.fs.read(modules.defaultSystem + \"/apps/services/\" + service);\n\t\t\t\tserviceConfig = JSON.parse(serviceConfig);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(\"Failed to read service config of\", service, \":\", e);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (serviceConfig.disabled) continue;p\n\t\t\tlet serviceName = (serviceConfig.localeReferenceName ? modules.locales.get(serviceConfig.localeReferenceName) : null) || (serviceConfig.localeDatabaseName ? (serviceConfig.localeDatabaseName[navigator.language.slice(0, 2).toLowerCase()] || serviceConfig.localeDatabaseName[modules.locales.defaultLocale]) : null) || serviceConfig.name;\n\t\t\tif (!serviceConfig.automaticLogon) {\n\t\t\t\tconsole.error(\"Service\", serviceName, \"(\", service, \") does not have logon credentials set\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet forkedToken;\n\t\t\ttry {\n\t\t\t\tlet logon = await modules.users.access(serviceConfig.automaticLogon.username);\n\t\t\t\tlogon = await logon.getNextPrompt();\n\t\t\t\tfor (let response of serviceConfig.automaticLogon.responses)\n\t\t\t\t\tif (logon.success == \"intermediate\") logon = await logon.input(response);\n\t\t\t\tif (!logon.success) throw new Error(logon.message);\n\t\t\t\tforkedToken = logon.token;\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(\"Failed to create a logon session for\", serviceName, \"(\", service, \"):\", e);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (triggerPasswordReset) {\n\t\t\t\tlet ownUser = await modules.tokens.info(forkedToken);\n\t\t\t\tlet ownUserInfo = await modules.users.getUserInfo(ownUser.user, true, forkedToken);\n\t\t\t\townUserInfo.securityChecks = [];\n\t\t\t\tawait modules.users.moduser(ownUser.user, ownUserInfo, forkedToken);\n\t\t\t\tawait modules.tokens.revoke(forkedToken);\n\t\t\t\tconsole.error(\"Exposed credentials for\", serviceName, \"(\", service, \") have been made invalid\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tawait modules.tasks.exec(serviceConfig.path, [ ...(serviceConfig.args || []) ], modules.window(session), forkedToken, true);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(\"Failed to start service\", serviceName, \"(\", service, \"):\", e);\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction waitForLogon(toHook) {\n\treturn new Promise(function(resolve) {\n\t\ttoHook.hook(resolve);\n\t});\n}\n\nasync function hookButtonClick(button) {\n\treturn new Promise(function(resolve) {\n\t\tbutton.onclick = (e) => resolve(e);\n\t});\n}","9b1c4b3ed1290ed2df63237ec11e469307e894aa2a614a74aef0c6cfcd98780c4799a25818e1e27c4789b8c11e416b1cbd8d53a9e68e18241c2425b77c7d9411":"requireLogon();","0ad3288505ad576eb0e2db2de7c8f25d3161a738573357566c18a4af17b04b5c1f6de395822023b14950dc3f4d3b50be9ea087fdfa9779ef528d64f970b1135a":"function systemKillWaiter() {\n\t// @pcos-app-mode native\n\tmodules.startupWindow.windowDiv.remove();\n\treturn new Promise(function(resolve) {\n\t\tmodules.killSystem = resolve;\n\t});\n}\nreturn await systemKillWaiter();"},"buildInfo":{"for":"1580","version":1580,"when":1766238578353,"signer":"moduleSigner","critical":true,"bootOrder":"50","commonName":"bootable","friendlyNameRef":"BOOTABLE_MODULE_NAME","signature":"1b9af7dea69fa65c9dc306485321be15d1032f35ceee3d96ba943ec236b43d484f835d9ccdc86a8f7f8b384d21e17dfa5ba4e2556354d69542626225ef0f7705"}},"50-core.fs":{"backend":{"files":{"apps":{"associations":{"txt":"854b26f05d7098f12646dbea9f178fa2f1a050a12270a51840da2e6f668ad49622b81ed07e6141de5f4a3189d03c30e898aa154ed4a95fb0a8b1714cc897a42c"},"authui.js":"6f71f90d01e29806838b5d39b02589709a9ed9dc6c4b8ba98198e20a1aa5b092cf02db7f7cdf305a98766c592387de426fa87ec906b4f46b74c4edb56c85c7ad","consentui.js":"f02ec035fbd3276c0eddfdb98383ee1f8c57f0c38f066b3ec95ee51d1539e7d18a0e47dac15587b4de9cf6184845d74872124f38a2b7aa6b3f08d4ae741d8191","explorer.js":"a3ed637c98f6faa79a837e0b798ca1e5aeb87732cc73b6b4f265bfb48123ef43a04397aba36b4ad5185c422bfac3a5ed762d12f0aa80487d62088033b22c9efd","filePicker.js":"cdc73dc251bcf81b3073b2df3712ac1a8472a6d162e912c6ed98167ff5141ad2278c9360604f4e2a80edb239b7faf8b2f14aad442ac7bb590da0b3a8dd716519","links":{"explorer.lnk":"4c65fdac558812659c79be137b525a5982b44892a5ce532b0eadbd9ada35658625af52588f044ca19d776a9f1c23f80f82d8ebead319c8a3956730845edbbaa9","textEditor.lnk":"7d06a753bf0e328de8fbfdc46219a5c3085c0a44e4ca322f2e4e2b98fe4c7dee83230f9f0cec0e7b3e124cd259e7f4b57c8103e0e7798c6572201af64e9fdf02"},"startMenu.js":"abf9ece8043f4d880551e79043fc07e95b8445b5d36d25f6b12fdf1da0f94f9e04d6d72ec4527055e9b4e579f52907912b7b4c151bfbcf633ad29a4b15b18f30","textEditor.js":"0b264a96efc4c43c035a15ac796012a0f2bbdae56d6834c4e2b8c47978ce16cd77ee00c1a7b7541eadd11d5061c79f3494c7da68724fa55ed2bdd84aaa86f908"},"etc":{"tlds.json":"a864983c462aa5ce602586598dd963444425223190554c36d74075f59a332c93cc12f6edd22b6a391d6034b8a66a225f13dae54000e45ba5c870f2813ae11f14"}},"permissions":{"apps/associations/txt":{"world":"rx"},"apps/associations/":{"world":"rx"},"apps/authui.js":{"world":"rx"},"apps/consentui.js":{"world":"rx"},"apps/explorer.js":{"world":"rx"},"apps/filePicker.js":{"world":"rx"},"apps/links/explorer.lnk":{"world":"rx"},"apps/links/textEditor.lnk":{"world":"rx"},"apps/links/":{"world":"rx"},"apps/startMenu.js":{"world":"rx"},"apps/textEditor.js":{"world":"rx"},"apps/":{"world":"rx"},"etc/tlds.json":{"world":"rx"},"etc/":{"world":"rx"},"":{"world":"rx"}}},"files":{"854b26f05d7098f12646dbea9f178fa2f1a050a12270a51840da2e6f668ad49622b81ed07e6141de5f4a3189d03c30e898aa154ed4a95fb0a8b1714cc897a42c":"{\"path\":\"system/apps/textEditor.js\",\"localeReferenceName\":\"TEXT_EDITOR\",\"icon\":\"system/etc/icons/txt.pic\"}","6f71f90d01e29806838b5d39b02589709a9ed9dc6c4b8ba98198e20a1aa5b092cf02db7f7cdf305a98766c592387de426fa87ec906b4f46b74c4edb56c85c7ad":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: IPC_SEND_PIPE, GET_LOCALE, GET_THEME, ELEVATE_PRIVILEGES, CSP_OPERATIONS\n// signature: 0019e2811eb72fd03404480d896f3e8460d63f6b63b92db572329449b74bd59f81fafe5a20629176f47ebd4a3db6bbb7b0dddfeeb86960066f8c9d8e61a10d01\n// =====END MANIFEST=====\n\nlet ipc;\n(async function() {\n\t// @pcos-app-mode isolatable\n\texec_args = await availableAPIs.getPrivateData() || [];\n\tif (!(exec_args instanceof Array)) return availableAPIs.terminate();\n\tipc = exec_args[0];\n\tif (!ipc) return availableAPIs.terminate();\n\tlet user = exec_args[1];\n\tawait availableAPIs.windowTitleSet(await availableAPIs.lookupLocale(\"LOG_IN_INVITATION\"));\n\tlet checklist = [ \"IPC_SEND_PIPE\", \"GET_LOCALE\", \"GET_THEME\", \"ELEVATE_PRIVILEGES\", \"CSP_OPERATIONS\" ];\n\tlet privileges = await availableAPIs.getPrivileges();\n\tif (!checklist.every(p => privileges.includes(p))) {\n\t\tif (privileges.includes(\"IPC_SEND_PIPE\")) await availableAPIs.sendToPipe({ pipe: ipc, data: { success: false, cancelled: false } });\n\t\treturn availableAPIs.terminate();\n\t}\n\tdocument.body.style.fontFamily = \"'Segoe UI', Tahoma, Geneva, Verdana, sans-serif\";\n\tif (await availableAPIs.isDarkThemed()) document.body.style.color = \"white\";\n\tlet describe = document.createElement(\"b\");\n\tlet form = document.createElement(\"form\");\n\tlet input = document.createElement(\"input\");\n\tlet submit = document.createElement(\"button\");\n\tdocument.body.appendChild(describe);\n\tdocument.body.appendChild(document.createElement(\"br\"));\n\tdocument.body.appendChild(form);\n\tform.appendChild(input);\n\tform.appendChild(submit);\n\tsubmit.innerText = await availableAPIs.lookupLocale(\"ENTER_BUTTON\");\n\tdescribe.innerText = await availableAPIs.lookupLocale(\"USERNAME_PROMPT\");\n\tinput.placeholder = await availableAPIs.lookupLocale(\"USERNAME\");\n\tasync function userSubmit(e) {\n\t\te.stopImmediatePropagation();\n\t\te.preventDefault();\n\t\te.stopPropagation();\n\t\tlet userLogonSession;\n\t\tlet userLogonID;\n\t\tlet desired_username = input.value;\n\t\ttry {\n\t\t\tuserLogonID = await availableAPIs.automatedLogonCreate({ desiredUser: desired_username });\n\t\t\tuserLogonSession = await availableAPIs.automatedLogonGet(userLogonID);\n\t\t} catch {\n\t\t\tdescribe.innerText = await availableAPIs.lookupLocale(\"AUTH_FAILED\") + \" \" + await availableAPIs.lookupLocale(\"USERNAME_PROMPT\");\n\t\t\tinput.placeholder = await availableAPIs.lookupLocale(\"USERNAME\");\n\t\t\tinput.type = \"text\";\n\t\t\tinput.disabled = !!user;\n\t\t\tsubmit.disabled = false;\n\t\t\tinput.value = user || \"\";\n\t\t\tsubmit.addEventListener(\"click\", userSubmit);\n\t\t\treturn;\n\t\t}\n\t\tasync function updateProgress() {\n\t\t\tsubmit.removeEventListener(\"click\", userSubmit);\n\t\t\tinput.value = \"\";\n\t\t\tsubmit.innerText = await availableAPIs.lookupLocale(\"ENTER_BUTTON\");\n\t\t\tif (userLogonSession.success != \"intermediate\") await availableAPIs.automatedLogonDelete(userLogonID);\n\t\t\tif (userLogonSession.success == true) {\n\t\t\t\tawait availableAPIs.sendToPipe({ pipe: ipc, data: userLogonSession });\n\t\t\t\tawait availableAPIs.terminate();\n\t\t\t}\n\t\t\tif (userLogonSession.success == false) {\n\t\t\t\tdescribe.innerText = await availableAPIs.lookupLocale(\"AUTH_FAILED\") + \" \" + await availableAPIs.lookupLocale(\"USERNAME_PROMPT\");\n\t\t\t\tinput.placeholder = await availableAPIs.lookupLocale(\"USERNAME\");\n\t\t\t\tinput.type = \"text\";\n\t\t\t\tinput.disabled = !!user;\n\t\t\t\tsubmit.disabled = false;\n\t\t\t\tinput.value = user || \"\";\n\t\t\t\tsubmit.addEventListener(\"click\", userSubmit);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdescribe.innerText = \"[\" + desired_username + \"] \" + userLogonSession.message;\n\t\t\tinput.placeholder = await availableAPIs.lookupLocale(\"RESPONSE_PLACEHOLDER\");\n\t\t\tinput.type = userLogonSession.type == \"password\" ? \"password\" : \"text\";\n\t\t\tinput.disabled = !userLogonSession.wantsUserInput;\n\t\t\tsubmit.disabled = !userLogonSession.wantsUserInput;\n\t\t\tif (userLogonSession.type == \"zkpp_password\") input.type = \"password\";\n\t\t\tif (userLogonSession.type == \"promise\") {\n\t\t\t\ttry {\n\t\t\t\t\tinput.disabled = true;\n\t\t\t\t\tsubmit.disabled = true;\n\t\t\t\t\tawait availableAPIs.automatedLogonInput({ session: userLogonID });\n\t\t\t\t\tuserLogonSession = await availableAPIs.automatedLogonGet(userLogonID);\n\t\t\t\t} catch {}\n\t\t\t\treturn await updateProgress();\n\t\t\t}\n\t\t\tif (userLogonSession.type == \"informative\") {\n\t\t\t\tinput.disabled = true;\n\t\t\t\tsubmit.disabled = false;\n\t\t\t\tsubmit.innerText = \"OK\";\n\t\t\t\tinput.placeholder = \"--->\";\n\t\t\t}\n\t\t\tsubmit.addEventListener(\"click\", async function updater(e) {\n\t\t\t\te.stopImmediatePropagation();\n\t\t\t\tsubmit.removeEventListener(\"click\", updater);\n\t\t\t\te.preventDefault();\n\t\t\t\te.stopPropagation();\n\t\t\t\ttry {\n\t\t\t\t\tinput.disabled = true;\n\t\t\t\t\tsubmit.disabled = true;\n\t\t\t\t\tif (userLogonSession.type == \"zkpp_password\") {\n\t\t\t\t\t\tlet passwordAsKey = await availableAPIs.cspOperation({\n\t\t\t\t\t\t\tcspProvider: \"basic\",\n\t\t\t\t\t\t\toperation: \"importKey\",\n\t\t\t\t\t\t\tcspArgument: {\n\t\t\t\t\t\t\t\tformat: \"raw\",\n\t\t\t\t\t\t\t\tkeyData: new TextEncoder().encode(input.value),\n\t\t\t\t\t\t\t\talgorithm: \"PBKDF2\",\n\t\t\t\t\t\t\t\textractable: false,\n\t\t\t\t\t\t\t\tkeyUsages: [\"deriveBits\"]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t\tlet rngSeed = await availableAPIs.cspOperation({\n\t\t\t\t\t\t\tcspProvider: \"basic\",\n\t\t\t\t\t\t\toperation: \"deriveBits\",\n\t\t\t\t\t\t\tcspArgument: {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"PBKDF2\",\n\t\t\t\t\t\t\t\t\tsalt: new Uint8Array(32),\n\t\t\t\t\t\t\t\t\titerations: 100000,\n\t\t\t\t\t\t\t\t\thash: \"SHA-256\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tbaseKey: passwordAsKey,\n\t\t\t\t\t\t\t\tlength: 256\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tawait availableAPIs.cspOperation({\n\t\t\t\t\t\t\tcspProvider: \"basic\",\n\t\t\t\t\t\t\toperation: \"unloadKey\",\n\t\t\t\t\t\t\tcspArgument: passwordAsKey\n\t\t\t\t\t\t});\n\t\t\t\t\t\tlet u8aToHex = (u8a) => Array.from(u8a).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\t\tlet hexToU8A = (hex) => Uint8Array.from(hex.match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\t\t\t\tawait availableAPIs.automatedLogonInput({ session: userLogonID, input: u8aToHex(await availableAPIs.cspOperation({\n\t\t\t\t\t\t\tcspProvider: \"tweetnacl\",\n\t\t\t\t\t\t\toperation: \"sign\",\n\t\t\t\t\t\t\tcspArgument: {\n\t\t\t\t\t\t\t\tsecretKey: (await availableAPIs.cspOperation({\n\t\t\t\t\t\t\t\t\tcspProvider: \"tweetnacl\",\n\t\t\t\t\t\t\t\t\toperation: \"deriveKey\",\n\t\t\t\t\t\t\t\t\tcspArgument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"sign\",\n\t\t\t\t\t\t\t\t\t\tseed: new Uint8Array(rngSeed)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t})).secretKey,\n\t\t\t\t\t\t\t\tmessage: hexToU8A(userLogonSession.challenge)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}))});\n\t\t\t\t\t} else await availableAPIs.automatedLogonInput({ session: userLogonID, input: input.value });\n\t\t\t\t\tuserLogonSession = await availableAPIs.automatedLogonGet(userLogonID);\n\t\t\t\t} catch {}\n\t\t\t\treturn await updateProgress();\n\t\t\t});\n\t\t}\n\t\tawait updateProgress();\n\t\treturn false;\n\t}\n\tsubmit.addEventListener(\"click\", userSubmit);\n\tif (user) {\n\t\tinput.disabled = true;\n\t\tinput.value = user;\n\t\tuserSubmit({ preventDefault: () => {}, stopImmediatePropagation: () => {}, stopPropagation: () => {} });\n\t}\n})();\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) {\n\t\ttry {\n\t\t\tawait availableAPIs.sendToPipe({ pipe: ipc, data: { success: false, cancelled: true } });\n\t\t} catch {}\n\t\tawait window.availableAPIs.terminate();\n\t}\n}); null;","f02ec035fbd3276c0eddfdb98383ee1f8c57f0c38f066b3ec95ee51d1539e7d18a0e47dac15587b4de9cf6184845d74872124f38a2b7aa6b3f08d4ae741d8191":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: IPC_SEND_PIPE, GET_LOCALE, GET_THEME, ELEVATE_PRIVILEGES, FS_READ, FS_LIST_PARTITIONS, CSP_OPERATIONS\n// signature: 05b0a08e26d7250b646d00d79a06769596d7dce62497e6a14f149ed1aba99e9fe70aafdbc8322382c65b6f30e0f06dca8569f66fa57c6dc771fcc4836fd7e70f\n// =====END MANIFEST=====\n\nlet ipc;\n(async function() {\n\t// @pcos-app-mode isolatable\n\texec_args = await availableAPIs.getPrivateData() || [];\n\tif (!(exec_args instanceof Array)) return availableAPIs.terminate();\n\tipc = exec_args[0];\n\tif (!ipc) return availableAPIs.terminate();\n\tlet user = exec_args[1];\n\ttry {\n\t\tnew Audio(await availableAPIs.fs_read({ path: (await availableAPIs.getSystemMount()) + \"/etc/sounds/ask.aud\" })).play();\n\t} catch (e) {\n\t\tconsole.error(e);\n\t}\n\tawait availableAPIs.windowTitleSet(await availableAPIs.lookupLocale(\"ACCESS_REQUEST_TITLE\"));\n\tlet checklist = [ \"IPC_SEND_PIPE\", \"GET_LOCALE\", \"GET_THEME\", \"ELEVATE_PRIVILEGES\", \"CSP_OPERATIONS\" ];\n\tlet privileges = await availableAPIs.getPrivileges();\n\tif (!checklist.every(p => privileges.includes(p))) {\n\t\tif (privileges.includes(\"IPC_SEND_PIPE\")) await availableAPIs.sendToPipe({ pipe: ipc, data: { success: false, cancelled: false } });\n\t\treturn availableAPIs.terminate();\n\t}\n\tdocument.body.style.fontFamily = \"'Segoe UI', Tahoma, Geneva, Verdana, sans-serif\";\n\tif (await availableAPIs.isDarkThemed()) document.body.style.color = \"white\";\n\tlet describe = document.createElement(\"span\");\n\tlet form = document.createElement(\"form\");\n\tlet input = document.createElement(\"input\");\n\tlet decline = document.createElement(\"button\");\n\tlet submit = document.createElement(\"button\");\n\tlet metadata = JSON.parse(exec_args[2]);\n\tdecline.type = \"button\";\n\tsubmit.type = \"submit\";\n\tdocument.body.appendChild(describe);\n\tdocument.body.appendChild(document.createElement(\"hr\"));\n\tdocument.body.appendChild(form);\n\tform.appendChild(input);\n\tform.appendChild(document.createElement(\"br\"));\n\tform.appendChild(decline);\n\tform.appendChild(submit);\n\tdescribe.innerText = (await availableAPIs.lookupLocale(\"DESCRIBE_TEMPLATE\")).replace(\"%s\", metadata.path.split(\"/\").pop()).replace(\"%s\", metadata.submittedName || metadata.path.split(\"/\").pop()).replace(\"%s\", metadata.submittedIntent);\n\tinput.placeholder = await availableAPIs.lookupLocale(\"USERNAME\");\n\tdecline.innerText = await availableAPIs.lookupLocale(\"DECLINE\");\n\tsubmit.innerText = await availableAPIs.lookupLocale(\"NEXT\");\n\n\tasync function extraData(e) {\n\t\te.stopImmediatePropagation();\n\t\te.preventDefault();\n\t\te.stopPropagation();\n\t\tdescribe.innerText = (await availableAPIs.lookupLocale(\"EXTRA_DESCRIBE_TEMPLATE\")).replace(\"%s\", metadata.path).replace(\"%s\", metadata.submittedName || metadata.path.split(\"/\").pop()).replace(\"%s\", JSON.stringify(metadata.args)).replace(\"%s\", metadata.submittedIntent);\n\t\tdescribe.removeEventListener(\"contextmenu\", extraData);\n\t}\n\n\tdescribe.addEventListener(\"contextmenu\", extraData);\n\n\tasync function userSubmit(e) {\n\t\tdescribe.removeEventListener(\"contextmenu\", extraData);\n\t\te.stopImmediatePropagation();\n\t\te.preventDefault();\n\t\te.stopPropagation();\n\t\ttry {\n\t\t\tif (exec_args[3]) {\n\t\t\t\tawait availableAPIs.sendToPipe({ pipe: ipc, data: { success: true, token: exec_args[3] } });\n\t\t\t\treturn await availableAPIs.terminate();\n\t\t\t}\n\t\t} catch {\n\t\t\texec_args[3] = null;\n\t\t}\n\t\tlet userLogonSession;\n\t\tlet userLogonID;\n\t\tlet desired_username = input.value;\n\t\ttry {\n\t\t\tuserLogonID = await availableAPIs.automatedLogonCreate({ desiredUser: desired_username });\n\t\t\tuserLogonSession = await availableAPIs.automatedLogonGet(userLogonID);\n\t\t} catch {\n\t\t\tdescribe.innerText = await availableAPIs.lookupLocale(\"AUTH_FAILED\") + \" \" + await availableAPIs.lookupLocale(\"USERNAME_PROMPT\");\n\t\t\tinput.placeholder = await availableAPIs.lookupLocale(\"USERNAME\");\n\t\t\tinput.type = \"text\";\n\t\t\tinput.disabled = !!user;\n\t\t\tsubmit.disabled = false;\n\t\t\tinput.value = user || \"\";\n\t\t\tsubmit.addEventListener(\"click\", userSubmit);\n\t\t\treturn;\n\t\t}\n\t\tasync function updateProgress() {\n\t\t\tsubmit.removeEventListener(\"click\", userSubmit);\n\t\t\tinput.value = \"\";\n\t\t\tif (userLogonSession.success != \"intermediate\") await availableAPIs.automatedLogonDelete(userLogonID);\n\t\t\tif (userLogonSession.success == true) {\n\t\t\t\tawait availableAPIs.sendToPipe({ pipe: ipc, data: userLogonSession });\n\t\t\t\tawait availableAPIs.terminate();\n\t\t\t}\n\t\t\tif (userLogonSession.success == false) {\n\t\t\t\tdescribe.innerText = await availableAPIs.lookupLocale(\"AUTH_FAILED\") + \" \" + await availableAPIs.lookupLocale(\"USERNAME_PROMPT\");\n\t\t\t\tinput.placeholder = await availableAPIs.lookupLocale(\"USERNAME\");\n\t\t\t\tinput.type = \"text\";\n\t\t\t\tinput.disabled = !!user;\n\t\t\t\tsubmit.disabled = false;\n\t\t\t\tinput.value = user || \"\";\n\t\t\t\tsubmit.addEventListener(\"click\", userSubmit);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdescribe.innerText = \"[\" + desired_username + \"] \" + userLogonSession.message;\n\t\t\tinput.placeholder = await availableAPIs.lookupLocale(\"RESPONSE_PLACEHOLDER\");\n\t\t\tinput.type = userLogonSession.type == \"password\" ? \"password\" : \"text\";\n\t\t\tinput.disabled = !userLogonSession.wantsUserInput;\n\t\t\tsubmit.disabled = !userLogonSession.wantsUserInput;\n\t\t\tif (userLogonSession.type == \"zkpp_password\") input.type = \"password\";\n\t\t\tif (userLogonSession.type == \"promise\") {\n\t\t\t\ttry {\n\t\t\t\t\tinput.disabled = true;\n\t\t\t\t\tsubmit.disabled = true;\n\t\t\t\t\tawait availableAPIs.automatedLogonInput({ session: userLogonID });\n\t\t\t\t\tuserLogonSession = await availableAPIs.automatedLogonGet(userLogonID);\n\t\t\t\t} catch {}\n\t\t\t\treturn await updateProgress();\n\t\t\t}\n\t\t\tif (userLogonSession.type == \"informative\") {\n\t\t\t\tinput.disabled = true;\n\t\t\t\tsubmit.disabled = false;\n\t\t\t\tinput.placeholder = \"\";\n\t\t\t}\n\t\t\tsubmit.addEventListener(\"click\", async function updater(e) {\n\t\t\t\te.stopImmediatePropagation();\n\t\t\t\tsubmit.removeEventListener(\"click\", updater);\n\t\t\t\te.preventDefault();\n\t\t\t\te.stopPropagation();\n\t\t\t\ttry {\n\t\t\t\t\tinput.disabled = true;\n\t\t\t\t\tsubmit.disabled = true;\n\t\t\t\t\tif (userLogonSession.type == \"zkpp_password\") {\n\t\t\t\t\t\tlet passwordAsKey = await availableAPIs.cspOperation({\n\t\t\t\t\t\t\tcspProvider: \"basic\",\n\t\t\t\t\t\t\toperation: \"importKey\",\n\t\t\t\t\t\t\tcspArgument: {\n\t\t\t\t\t\t\t\tformat: \"raw\",\n\t\t\t\t\t\t\t\tkeyData: new TextEncoder().encode(input.value),\n\t\t\t\t\t\t\t\talgorithm: \"PBKDF2\",\n\t\t\t\t\t\t\t\textractable: false,\n\t\t\t\t\t\t\t\tkeyUsages: [\"deriveBits\"]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t\tlet rngSeed = await availableAPIs.cspOperation({\n\t\t\t\t\t\t\tcspProvider: \"basic\",\n\t\t\t\t\t\t\toperation: \"deriveBits\",\n\t\t\t\t\t\t\tcspArgument: {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"PBKDF2\",\n\t\t\t\t\t\t\t\t\tsalt: new Uint8Array(32),\n\t\t\t\t\t\t\t\t\titerations: 100000,\n\t\t\t\t\t\t\t\t\thash: \"SHA-256\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tbaseKey: passwordAsKey,\n\t\t\t\t\t\t\t\tlength: 256\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tawait availableAPIs.cspOperation({\n\t\t\t\t\t\t\tcspProvider: \"basic\",\n\t\t\t\t\t\t\toperation: \"unloadKey\",\n\t\t\t\t\t\t\tcspArgument: passwordAsKey\n\t\t\t\t\t\t});\n\t\t\t\t\t\tlet u8aToHex = (u8a) => Array.from(u8a).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\t\tlet hexToU8A = (hex) => Uint8Array.from(hex.match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\t\t\t\tawait availableAPIs.automatedLogonInput({ session: userLogonID, input: u8aToHex(await availableAPIs.cspOperation({\n\t\t\t\t\t\t\tcspProvider: \"tweetnacl\",\n\t\t\t\t\t\t\toperation: \"sign\",\n\t\t\t\t\t\t\tcspArgument: {\n\t\t\t\t\t\t\t\tsecretKey: (await availableAPIs.cspOperation({\n\t\t\t\t\t\t\t\t\tcspProvider: \"tweetnacl\",\n\t\t\t\t\t\t\t\t\toperation: \"deriveKey\",\n\t\t\t\t\t\t\t\t\tcspArgument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"sign\",\n\t\t\t\t\t\t\t\t\t\tseed: new Uint8Array(rngSeed)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t})).secretKey,\n\t\t\t\t\t\t\t\tmessage: hexToU8A(userLogonSession.challenge)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}))});\n\t\t\t\t\t} else await availableAPIs.automatedLogonInput({ session: userLogonID, input: input.value });\n\t\t\t\t\tuserLogonSession = await availableAPIs.automatedLogonGet(userLogonID);\n\t\t\t\t} catch {}\n\t\t\t\treturn await updateProgress();\n\t\t\t});\n\t\t}\n\t\tawait updateProgress();\n\t\treturn false;\n\t}\n\tsubmit.addEventListener(\"click\", userSubmit);\n\tdecline.addEventListener(\"click\", async function() {\n\t\tawait availableAPIs.sendToPipe({ pipe: ipc, data: { success: false, cancelled: true } });\n\t\tawait availableAPIs.terminate();\n\t});\n\tif (user) {\n\t\tinput.disabled = true;\n\t\tinput.value = user;\n\t}\n})();\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) {\n\t\ttry {\n\t\t\tawait availableAPIs.sendToPipe({ pipe: ipc, data: { success: false, cancelled: true } });\n\t\t} catch {}\n\t\tawait window.availableAPIs.terminate();\n\t}\n}); null;","a3ed637c98f6faa79a837e0b798ca1e5aeb87732cc73b6b4f265bfb48123ef43a04397aba36b4ad5185c422bfac3a5ed762d12f0aa80487d62088033b22c9efd":"// =====BEGIN MANIFEST=====\n// link: lrn:FILE_EXPLORER\n// signer: automaticSigner\n// allow: FS_READ, FS_LIST_PARTITIONS, ELEVATE_PRIVILEGES, ELEVATE_PRIVILEGES_EZ, START_TASK, GET_LOCALE, GET_THEME, MANAGE_TOKENS, FS_REMOVE, FS_BYPASS_PERMISSIONS, FS_UNMOUNT, FS_CHANGE_PERMISSION, FS_MOUNT, GET_FILESYSTEMS, FS_WRITE, LLDISK_LIST_PARTITIONS, GET_USER_INFO\n// signature: 446c3caa9f033bc8bcd98793213ca88193bf3a5d759c4e36f0250c127b84c472e183e0aeb0d779d78a874c5a05dbdd9a4a1e133fbf3aab26c662b180ba6b1109\n// =====END MANIFEST=====\nlet globalToken;\nlet cachedIcons = {};\nlet cachedAssocs = {};\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.windowTitleSet(await availableAPIs.lookupLocale(\"FILE_EXPLORER\"));\n\tdocument.body.style.fontFamily = \"'Segoe UI', Tahoma, Geneva, Verdana, sans-serif\";\n\tif (await availableAPIs.isDarkThemed()) document.body.style.color = \"white\";\n\tlet privileges = await availableAPIs.getPrivileges();\n\tlet checklist = [ \"FS_READ\", \"FS_LIST_PARTITIONS\" ];\n\tif (!checklist.every(p => privileges.includes(p))) {\n\t\tdocument.body.innerText = await availableAPIs.lookupLocale(\"GRANT_FEXP_PERM\");\n\t\tlet button = document.createElement(\"button\");\n\t\tbutton.innerText = await availableAPIs.lookupLocale(\"GRANT_PERM\");\n\t\tdocument.body.appendChild(button);\n\t\tif (!privileges.includes(\"ELEVATE_PRIVILEGES\")) {\n\t\t\tbutton.disabled = true;\n\t\t\tdocument.body.innerText = await availableAPIs.lookupLocale(\"GRANT_FEXP_PERM_ADM\");\n\t\t\treturn;\n\t\t}\n\t\tawait new Promise(function(resolve) {\n\t\t\tbutton.onclick = async function() {\n\t\t\t\tbutton.disabled = true;\n\t\t\t\tlet currentToken = await availableAPIs.getProcessToken();\n\t\t\t\tlet newToken = await availableAPIs.consentGetToken({\n\t\t\t\t\tintent: await availableAPIs.lookupLocale(\"FILE_EXPLORER_FULL_INTENT\"),\n\t\t\t\t\tname: await availableAPIs.lookupLocale(\"FILE_EXPLORER\")\n\t\t\t\t});\n\t\t\t\tbutton.disabled = false;\n\t\t\t\tif (!newToken) return;\n\t\t\t\tif (privileges.includes(\"MANAGE_TOKENS\")) globalToken = await availableAPIs.forkToken(newToken);\n\t\t\t\tawait availableAPIs.setProcessToken(newToken);\n\t\t\t\tawait availableAPIs.revokeToken(currentToken);\n\t\t\t\tprivileges = await availableAPIs.getPrivileges();\n\t\t\t\tif (checklist.every(p => privileges.includes(p))) resolve();\n\t\t\t\telse document.body.innerText = await availableAPIs.lookupLocale(\"GRANT_FEXP_PERM_USR\");\n\t\t\t}\n\t\t});\n\t}\n\tlet hideHiddenFiles = true;\n\ttry {\n\t\tlet homedir = (await availableAPIs.getUserInfo({ desiredUser: await availableAPIs.getUser() })).homeDirectory;\n\t\thideHiddenFiles = (await availableAPIs.fs_read({\n\t\t\tpath: homedir + \"/.hiddenFiles\",\n\t\t})) != \"show\";\n\t} catch {}\n\tdocument.body.innerText = \"\";\n\tlet mainComponent = document.createElement(\"div\");\n\tlet pathInputForm = document.createElement(\"form\");\n\tlet pathElement = document.createElement(\"input\");\n\tlet browseButton = document.createElement(\"button\");\n\tlet displayResult = document.createElement(\"div\");\n\tlet previousDirectory = \"\";\n\tlet clipboard = {\n\t\tpath: \"\",\n\t\tcut: false,\n\t\tselected: false\n\t};\n\tmainComponent.style.display = \"flex\";\n\tmainComponent.style.flexDirection = \"column\";\n\tmainComponent.style.width = \"100%\";\n\tmainComponent.style.height = \"100%\";\n\tmainComponent.style.position = \"absolute\";\n\tmainComponent.style.top = \"0\";\n\tmainComponent.style.left = \"0\";\n\tmainComponent.style.padding = \"8px\";\n\tmainComponent.style.boxSizing = \"border-box\";\n\tdisplayResult.style.flex = \"1\";\n\tbrowseButton.innerText = await availableAPIs.lookupLocale(\"BROWSE_FEXP\");\n\tpathInputForm.appendChild(pathElement);\n\tpathInputForm.appendChild(browseButton);\n\tmainComponent.appendChild(pathInputForm);\n\tmainComponent.appendChild(displayResult);\n\tdocument.body.appendChild(mainComponent);\n\tlet availableAssocs = [];\n\ttry {\n\t\tavailableAssocs = await availableAPIs.fs_ls({ path: await availableAPIs.getSystemMount() + \"/apps/associations\" });\n\t} catch {}\n\tdisplayResult.oncontextmenu = async function(e) {\n\t\te.stopImmediatePropagation();\n\t\te.preventDefault();\n\t\te.stopPropagation();\n\t\tdisplayResult.innerText = \"\";\n\t\tlet showHiddenFilesToggle = document.createElement(\"button\");\n\t\tshowHiddenFilesToggle.innerText = await availableAPIs.lookupLocale(\"TOGGLE_HIDDEN_FILES\");\n\t\tshowHiddenFilesToggle.addEventListener(\"click\", async function() {\n\t\t\thideHiddenFiles = !hideHiddenFiles;\n\t\t\ttry {\n\t\t\t\tlet homedir = (await availableAPIs.getUserInfo({ desiredUser: await availableAPIs.getUser() })).homeDirectory;\n\t\t\t\tavailableAPIs.fs_write({\n\t\t\t\t\tpath: homedir + \"/.hiddenFiles\",\n\t\t\t\t\tdata: (hideHiddenFiles ? \"hide\" : \"show\")\n\t\t\t\t});\n\t\t\t} catch {}\n\t\t\tbrowse();\n\t\t});\n\t\tdisplayResult.appendChild(showHiddenFilesToggle);\n\t\tdisplayResult.appendChild(document.createElement(\"hr\"));\n\t\tif (previousDirectory == \"\") {\n\t\t\tlet mountForm = document.createElement(\"form\");\n\t\t\tlet mountpoint = document.createElement(\"input\");\n\t\t\tlet filesystemOptions = document.createElement(\"select\");\n\t\t\tlet autoGenMountOptions = document.createElement(\"select\");\n\t\t\tlet mountOptions = document.createElement(\"textarea\");\n\t\t\tlet mountButton = document.createElement(\"button\");\n\t\t\tmountpoint.placeholder = await availableAPIs.lookupLocale(\"MOUNTPOINT\");\n\t\t\tlet availableFilesystems = await availableAPIs.supportedFilesystems();\n\t\t\tfor (let filesystem of availableFilesystems) {\n\t\t\t\tlet option = document.createElement(\"option\");\n\t\t\t\toption.value = filesystem;\n\t\t\t\toption.innerText = filesystem;\n\t\t\t\tfilesystemOptions.appendChild(option);\n\t\t\t}\n\t\t\tlet availablePartitions = [];\n\t\t\ttry {\n\t\t\t\tavailablePartitions = await availableAPIs.lldaList();\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(e);\n\t\t\t}\n\t\t\tlet defaultPartitionOption = document.createElement(\"option\");\n\t\t\tdefaultPartitionOption.value = \"\";\n\t\t\tdefaultPartitionOption.innerText = await availableAPIs.lookupLocale(\"GENERATE_PROMPT\");\n\t\t\tdefaultPartitionOption.selected = true;\n\t\t\tdefaultPartitionOption.disabled = true;\n\t\t\tdefaultPartitionOption.hidden = true;\n\t\t\tautoGenMountOptions.appendChild(defaultPartitionOption);\n\t\t\tfor (let partition of availablePartitions) {\n\t\t\t\tlet option = document.createElement(\"option\");\n\t\t\t\toption.value = partition;\n\t\t\t\toption.innerText = partition;\n\t\t\t\tautoGenMountOptions.appendChild(option);\n\t\t\t}\n\t\t\tautoGenMountOptions.onchange = function() {\n\t\t\t\tmountOptions.value = JSON.stringify({ partition: autoGenMountOptions.value });\n\t\t\t}\n\t\t\tmountOptions.value = \"{}\";\n\t\t\tmountButton.innerText = await availableAPIs.lookupLocale(\"MOUNT_BUTTON\");\n\t\t\tmountButton.onclick = async function() {\n\t\t\t\ttry {\n\t\t\t\t\tlet options = JSON.parse(mountOptions.value);\n\t\t\t\t\tawait availableAPIs.fs_mount({ mountpoint: mountpoint.value, filesystem: filesystemOptions.value, filesystemOptions: options });\n\t\t\t\t\tbrowse();\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(e);\n\t\t\t\t\tdisplayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", e.name + \": \" + e.message);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmountForm.appendChild(mountpoint);\n\t\t\tmountForm.appendChild(document.createElement(\"br\"));\n\t\t\tmountForm.appendChild(filesystemOptions);\n\t\t\tmountForm.appendChild(document.createElement(\"hr\"));\n\t\t\tmountForm.appendChild(autoGenMountOptions);\n\t\t\tmountForm.appendChild(document.createElement(\"br\"));\n\t\t\tmountForm.appendChild(mountOptions);\n\t\t\tmountForm.appendChild(document.createElement(\"hr\"));\n\t\t\tmountForm.appendChild(mountButton);\n\t\t\tdisplayResult.appendChild(mountForm);\n\t\t} else {\n\t\t\tlet makeDirectoryForm = document.createElement(\"form\");\n\t\t\tlet makeDirectoryInput = document.createElement(\"input\");\n\t\t\tlet makeDirectoryButton = document.createElement(\"button\");\n\t\t\tmakeDirectoryInput.pattern = \"[!-.0-~]+\";\n\t\t\tmakeDirectoryInput.placeholder = await availableAPIs.lookupLocale(\"NEW_DIR_NAME\");\n\t\t\tmakeDirectoryForm.appendChild(makeDirectoryInput);\n\t\t\tmakeDirectoryForm.appendChild(makeDirectoryButton);\n\t\t\tdisplayResult.appendChild(makeDirectoryForm);\n\t\t\tmakeDirectoryButton.innerText = await availableAPIs.lookupLocale(\"MKDIR_BUTTON\");\n\t\t\tmakeDirectoryButton.onclick = async function() {\n\t\t\t\tlet dirName = makeDirectoryInput.value;\n\t\t\t\tif (dirName == \"\") return;\n\t\t\t\ttry {\n\t\t\t\t\tawait availableAPIs.fs_mkdir({ path: previousDirectory + \"/\" + dirName });\n\t\t\t\t\tbrowse();\n\t\t\t\t} catch (e) {\n\t\t\t\t\tdisplayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", await availableAPIs.lookupLocale(e.message));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (clipboard.selected) {\n\t\t\t\tdisplayResult.appendChild(document.createElement(\"hr\"));\n\t\t\t\tlet pasteButton = document.createElement(\"button\");\n\t\t\t\tpasteButton.innerText = await availableAPIs.lookupLocale(\"CLIPBOARD_PASTE\");\n\t\t\t\tpasteButton.onclick = async function() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet copyAllowed = await isDirectory(clipboard.path) == \"file\";\n\t\t\t\t\t\tif (!copyAllowed) throw new Error(await availableAPIs.lookupLocale(\"CLIPBOARD_SOURCE_GONE\"));\n\t\t\t\t\t\tlet readFile = await availableAPIs.fs_read({ path: clipboard.path });\n\t\t\t\t\t\tlet basename = clipboard.path.split(\"/\").slice(-1)[0];\n\t\t\t\t\t\tcopyAllowed = await isDirectory(previousDirectory + \"/\" + basename) == \"unknown\";\n\t\t\t\t\t\tif (!copyAllowed) throw new Error(await availableAPIs.lookupLocale(\"CLIPBOARD_CONFLICT\"));\n\t\t\t\t\t\tawait availableAPIs.fs_write({ path: previousDirectory + \"/\" + basename, data: readFile });\n\t\t\t\t\t\tif (clipboard.cut) await availableAPIs.fs_rm({ path: clipboard.path });\n\t\t\t\t\t\tbrowse();\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tdisplayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", await availableAPIs.lookupLocale(e.message));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdisplayResult.appendChild(pasteButton);\n\t\t\t}\n\t\t}\n\t}\n\tasync function browse() {\n\t\tlet path = pathElement.value;\n\t\tif (path.endsWith(\"/\")) path = path.substring(0, path.length - 1);\n\t\tdisplayResult.innerText = \"\";\n\t\tif (path == \"\") {\n\t\t\tlet partitions = (await availableAPIs.fs_mounts()).sort((a, b) => a.localeCompare(b));\n\t\t\tfor (let partition of partitions) {\n\t\t\t\tif (partition.startsWith(\".\") && hideHiddenFiles) continue;\n\t\t\t\tlet openButton = document.createElement(\"button\");\n\t\t\t\topenButton.innerText = partition;\n\t\t\t\topenButton.onclick = function() {\n\t\t\t\t\tpathElement.value = partition;\n\t\t\t\t\tbrowse();\n\t\t\t\t}\n\t\t\t\topenButton.oncontextmenu = async function(e) {\n\t\t\t\t\te.stopImmediatePropagation();\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\te.stopPropagation();\n\t\t\t\t\tdisplayResult.innerText = \"\";\n\t\t\t\t\tlet unmountButton = document.createElement(\"button\");\n\t\t\t\t\tunmountButton.innerText = await availableAPIs.lookupLocale(\"UNMOUNT_BTN\");\n\t\t\t\t\tunmountButton.onclick = async function() {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait availableAPIs.fs_unmount({ mount: partition });\n\t\t\t\t\t\t\tbrowse();\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tdisplayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", await availableAPIs.lookupLocale(e.message));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tunmountButton.oncontextmenu = async function(e) {\n\t\t\t\t\t\te.stopImmediatePropagation();\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\te.stopPropagation();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait availableAPIs.fs_unmount({ mount: partition, force: true });\n\t\t\t\t\t\t\tbrowse();\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tdisplayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", await availableAPIs.lookupLocale(e.message));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdisplayResult.appendChild(unmountButton);\n\t\t\t\t\tdisplayResult.appendChild(document.createElement(\"hr\"));\n\n\t\t\t\t\tlet deleteButton = document.createElement(\"button\");\n\t\t\t\t\tlet deleteConfirm = false;\n\t\t\t\t\tdeleteButton.innerText = await availableAPIs.lookupLocale(\"REMOVE_BTN\");\n\t\t\t\t\tdeleteButton.onclick = async function() {\n\t\t\t\t\t\tif (!deleteConfirm) {\n\t\t\t\t\t\t\tdeleteButton.style.fontWeight = \"bold\";\n\t\t\t\t\t\t\tdeleteConfirm = true;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait recursiveRemove(partition);\n\t\t\t\t\t\t\tbrowse();\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tdisplayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", await availableAPIs.lookupLocale(e.message));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdisplayResult.appendChild(deleteButton);\n\n\t\t\t\t\tdisplayResult.appendChild(document.createElement(\"br\"));\n\t\t\t\t\tlet permissions = { owner: \"nobody\", group: \"nobody\", world: \"rx\" };\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpermissions = await availableAPIs.fs_permissions({ path: partition });\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tconsole.error(e);\n\t\t\t\t\t}\n\t\t\t\t\tlet chownForm = document.createElement(\"form\");\n\t\t\t\t\tlet chownInput = document.createElement(\"input\");\n\t\t\t\t\tlet chownButton = document.createElement(\"button\");\n\t\t\t\t\tchownInput.value = permissions.owner;\n\t\t\t\t\tchownButton.innerText = await availableAPIs.lookupLocale(\"CHOWN_BUTTON\");\n\t\t\t\t\tchownForm.appendChild(chownInput);\n\t\t\t\t\tchownForm.appendChild(chownButton);\n\t\t\t\t\tdisplayResult.appendChild(chownForm);\n\t\t\t\t\tchownButton.onclick = async function() {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait availableAPIs.fs_chown({ path: partition, newUser: chownInput.value });\n\t\t\t\t\t\t\tbrowse();\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tdisplayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", await availableAPIs.lookupLocale(e.message));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlet chgrpForm = document.createElement(\"form\");\n\t\t\t\t\tlet chgrpInput = document.createElement(\"input\");\n\t\t\t\t\tlet chgrpButton = document.createElement(\"button\");\n\t\t\t\t\tchgrpInput.value = permissions.group;\n\t\t\t\t\tchgrpButton.innerText = await availableAPIs.lookupLocale(\"CHGRP_BUTTON\");\n\t\t\t\t\tchgrpForm.appendChild(chgrpInput);\n\t\t\t\t\tchgrpForm.appendChild(chgrpButton);\n\t\t\t\t\tdisplayResult.appendChild(chgrpForm);\n\t\t\t\t\tchgrpButton.onclick = async function() {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait availableAPIs.fs_chgrp({ path: partition, newGrp: chgrpInput.value });\n\t\t\t\t\t\t\tbrowse();\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tdisplayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", await availableAPIs.lookupLocale(e.message));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlet chmodForm = document.createElement(\"form\");\n\t\t\t\t\tlet chmodInput = document.createElement(\"input\");\n\t\t\t\t\tlet chmodButton = document.createElement(\"button\");\n\t\t\t\t\tchmodInput.value = permissions.world;\n\t\t\t\t\tchownInput.pattern = \"[rwx]+\";\n\t\t\t\t\tchmodButton.innerText = await availableAPIs.lookupLocale(\"CHMOD_BUTTON\");\n\t\t\t\t\tchmodForm.appendChild(chmodInput);\n\t\t\t\t\tchmodForm.appendChild(chmodButton);\n\t\t\t\t\tdisplayResult.appendChild(chmodForm);\n\t\t\t\t\tchmodButton.onclick = async function() {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait availableAPIs.fs_chmod({ path: partition, newPermissions: chmodInput.value });\n\t\t\t\t\t\t\tbrowse();\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tdisplayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", await availableAPIs.lookupLocale(e.message));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdisplayResult.appendChild(openButton);\n\t\t\t}\n\t\t\tdisplayResult.appendChild(document.createElement(\"hr\"));\n\t\t\tlet spaceDisplayer = document.createElement(\"div\");\n\t\t\tlet spaces = await availableAPIs.estimateStorage();\n\t\t\tfor (let space in spaces) {\n\t\t\t\tlet newSpace = document.createElement(\"div\");\n\t\t\t\tnewSpace.innerText = (await availableAPIs.lookupLocale(\"SPACE_SHOWER\")).replace(\"%s\", space).replace(\"%s\", await availableAPIs.ufInfoUnits([spaces[space].used])).replace(\"%s\", await availableAPIs.ufInfoUnits([spaces[space].total])).replace(\"%s\", (spaces[space].used / spaces[space].total * 100).toFixed(2));\n\t\t\t\tspaceDisplayer.appendChild(newSpace);\n\t\t\t}\n\t\t\tdisplayResult.appendChild(spaceDisplayer);\n\t\t\tpreviousDirectory = path;\n\t\t\treturn \"browsed\";\n\t\t}\n\t\ttry {\n\t\t\tlet type = await isDirectory(path);\n\t\t\tif (type == \"directory\") {\n\t\t\t\tlet ls = (await availableAPIs.fs_ls({ path: path })).sort((a, b) => a.localeCompare(b));\n\t\t\t\tfor (let file of ls) {\n\t\t\t\t\tif (file.startsWith(\".\") && hideHiddenFiles) continue;\n\t\t\t\t\tlet openButton = document.createElement(\"button\");\n\t\t\t\t\tlet fileIcon = document.createElement(\"img\");\n\t\t\t\t\tfileIcon.style.width = \"12px\";\n\t\t\t\t\tfileIcon.style.height = \"12px\";\n\t\t\t\t\tlet fileType = file.split(\".\").slice(-1)[0];\n\t\t\t\t\tlet isDir = await isDirectory(path + \"/\" + file);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet wantedIcon;\n\t\t\t\t\t\tif (isDir == \"directory\") wantedIcon = await availableAPIs.getSystemMount() + \"/etc/icons/foldericon.pic\";\n\t\t\t\t\t\telse wantedIcon = await availableAPIs.getSystemMount() + \"/etc/icons/fileicon.pic\";\n\t\t\t\t\t\tif (fileType == \"js\") wantedIcon = await availableAPIs.getSystemMount() + \"/etc/icons/js.pic\";\n\t\t\t\t\t\telse if (fileType == \"lnk\") wantedIcon = await availableAPIs.getSystemMount() + \"/etc/icons/lnk.pic\";\n\t\t\t\t\t\telse if (availableAssocs.includes(fileType)) {\n\t\t\t\t\t\t\tif (!cachedAssocs[fileType]) cachedAssocs[fileType] = JSON.parse(await availableAPIs.fs_read({ path: await availableAPIs.getSystemMount() + \"/apps/associations/\" + fileType }));\n\t\t\t\t\t\t\twantedIcon = cachedAssocs[fileType].icon;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!cachedIcons[wantedIcon]) cachedIcons[wantedIcon] = await availableAPIs.fs_read({ path: wantedIcon });\n\t\t\t\t\t\tfileIcon.src = cachedIcons[wantedIcon];\n\t\t\t\t\t} catch {}\n\t\t\t\t\topenButton.innerText = file;\n\t\t\t\t\topenButton.insertAdjacentElement(\"afterbegin\", fileIcon);\n\t\t\t\t\topenButton.onclick = function() {\n\t\t\t\t\t\tpathElement.value = path + \"/\" + file;\n\t\t\t\t\t\tbrowse();\n\t\t\t\t\t}\n\t\t\t\t\topenButton.oncontextmenu = async function(e) {\n\t\t\t\t\t\te.stopImmediatePropagation();\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\te.stopPropagation();\n\t\t\t\t\t\tdisplayResult.innerText = \"\";\n\t\t\t\t\t\tlet copyAllow = false;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tcopyAllow = isDir == \"file\";\n\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\tif (copyAllow) {\n\t\t\t\t\t\t\tlet copyButton = document.createElement(\"button\");\n\t\t\t\t\t\t\tcopyButton.innerText = await availableAPIs.lookupLocale(\"CLIPBOARD_COPY\");\n\t\t\t\t\t\t\tcopyButton.onclick = async function() {\n\t\t\t\t\t\t\t\tclipboard = {\n\t\t\t\t\t\t\t\t\tpath: path + \"/\" + file,\n\t\t\t\t\t\t\t\t\tselected: true,\n\t\t\t\t\t\t\t\t\tcut: false\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tbrowse();\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tdisplayResult.appendChild(copyButton);\n\n\t\t\t\t\t\t\tlet cutButton = document.createElement(\"button\");\n\t\t\t\t\t\t\tcutButton.innerText = await availableAPIs.lookupLocale(\"CLIPBOARD_CUT\");\n\t\t\t\t\t\t\tcutButton.onclick = async function() {\n\t\t\t\t\t\t\t\tclipboard = {\n\t\t\t\t\t\t\t\t\tpath: path + \"/\" + file,\n\t\t\t\t\t\t\t\t\tselected: true,\n\t\t\t\t\t\t\t\t\tcut: true\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tbrowse();\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tdisplayResult.appendChild(cutButton);\n\t\t\t\t\t\t\tdisplayResult.appendChild(document.createElement(\"hr\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet deleteButton = document.createElement(\"button\");\n\t\t\t\t\t\tlet deleteConfirm = false;\n\t\t\t\t\t\tdeleteButton.innerText = await availableAPIs.lookupLocale(\"REMOVE_BTN\");\n\t\t\t\t\t\tdeleteButton.onclick = async function() {\n\t\t\t\t\t\t\tif (!deleteConfirm) {\n\t\t\t\t\t\t\t\tdeleteButton.style.fontWeight = \"bold\";\n\t\t\t\t\t\t\t\tdeleteConfirm = true;\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlet isDir = await isDirectory(path + \"/\" + file);\n\t\t\t\t\t\t\t\tif (isDir == \"directory\") await recursiveRemove(path + \"/\" + file);\n\t\t\t\t\t\t\t\telse if (isDir == \"file\") await availableAPIs.fs_rm({ path: path + \"/\" + file });\n\t\t\t\t\t\t\t\tbrowse();\n\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\tdisplayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", await availableAPIs.lookupLocale(e.message));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdisplayResult.appendChild(deleteButton);\n\t\t\t\t\t\tdisplayResult.appendChild(document.createElement(\"br\"));\n\t\t\t\t\t\tlet permissions = { owner: \"nobody\", group: \"nobody\", world: \"rx\" };\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tpermissions = await availableAPIs.fs_permissions({ path: path + \"/\" + file });\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tconsole.error(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet chownForm = document.createElement(\"form\");\n\t\t\t\t\t\tlet chownInput = document.createElement(\"input\");\n\t\t\t\t\t\tlet chownButton = document.createElement(\"button\");\n\t\t\t\t\t\tchownInput.value = permissions.owner;\n\t\t\t\t\t\tchownButton.innerText = await availableAPIs.lookupLocale(\"CHOWN_BUTTON\");\n\t\t\t\t\t\tchownForm.appendChild(chownInput);\n\t\t\t\t\t\tchownForm.appendChild(chownButton);\n\t\t\t\t\t\tdisplayResult.appendChild(chownForm);\n\t\t\t\t\t\tchownButton.onclick = async function() {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tawait availableAPIs.fs_chown({ path: path + \"/\" + file, newUser: chownInput.value });\n\t\t\t\t\t\t\t\tbrowse();\n\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\tdisplayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", await availableAPIs.lookupLocale(e.message));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet chgrpForm = document.createElement(\"form\");\n\t\t\t\t\t\tlet chgrpInput = document.createElement(\"input\");\n\t\t\t\t\t\tlet chgrpButton = document.createElement(\"button\");\n\t\t\t\t\t\tchgrpInput.value = permissions.group;\n\t\t\t\t\t\tchgrpButton.innerText = await availableAPIs.lookupLocale(\"CHGRP_BUTTON\");\n\t\t\t\t\t\tchgrpForm.appendChild(chgrpInput);\n\t\t\t\t\t\tchgrpForm.appendChild(chgrpButton);\n\t\t\t\t\t\tdisplayResult.appendChild(chgrpForm);\n\t\t\t\t\t\tchgrpButton.onclick = async function() {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tawait availableAPIs.fs_chgrp({ path: path + \"/\" + file, newGrp: chgrpInput.value });\n\t\t\t\t\t\t\t\tbrowse();\n\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\tdisplayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", await availableAPIs.lookupLocale(e.message));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet chmodForm = document.createElement(\"form\");\n\t\t\t\t\t\tlet chmodInput = document.createElement(\"input\");\n\t\t\t\t\t\tlet chmodButton = document.createElement(\"button\");\n\t\t\t\t\t\tchmodInput.value = permissions.world;\n\t\t\t\t\t\tchownInput.pattern = \"[rwx]+\";\n\t\t\t\t\t\tchmodButton.innerText = await availableAPIs.lookupLocale(\"CHMOD_BUTTON\");\n\t\t\t\t\t\tchmodForm.appendChild(chmodInput);\n\t\t\t\t\t\tchmodForm.appendChild(chmodButton);\n\t\t\t\t\t\tdisplayResult.appendChild(chmodForm);\n\t\t\t\t\t\tchmodButton.onclick = async function() {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tawait availableAPIs.fs_chmod({ path: path + \"/\" + file, newPermissions: chmodInput.value });\n\t\t\t\t\t\t\t\tbrowse();\n\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\tdisplayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", await availableAPIs.lookupLocale(e.message));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdisplayResult.appendChild(openButton);\n\t\t\t\t}\n\t\t\t\tpreviousDirectory = path;\n\t\t\t} else if (type == \"file\") {\n\t\t\t\tlet hasError = false;\n\t\t\t\tpathElement.value = previousDirectory;\n\t\t\t\tif (path.endsWith(\".js\")) {\n\t\t\t\t\tif (privileges.includes(\"START_TASK\") && privileges.includes(\"ELEVATE_PRIVILEGES\") && privileges.includes(\"MANAGE_TOKENS\")) {\n\t\t\t\t\t\tif (!globalToken) globalToken = await availableAPIs.consentGetToken({\n\t\t\t\t\t\t\tintent: await availableAPIs.lookupLocale(\"FILE_EXPLORER_INTENT\"),\n\t\t\t\t\t\t\tname: await availableAPIs.lookupLocale(\"FILE_EXPLORER\"),\n\t\t\t\t\t\t\tdesiredUser: await availableAPIs.getUser()\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (globalToken) {\n\t\t\t\t\t\t\tlet newToken = await availableAPIs.forkToken(globalToken);\n\t\t\t\t\t\t\tawait availableAPIs.startTask({ file: path, token: newToken });\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdisplayResult.innerText = await availableAPIs.lookupLocale(\"MORE_PERMISSION_DENIED\");\n\t\t\t\t\t\thasError = true;\n\t\t\t\t\t}\n\t\t\t\t} else if (path.endsWith(\".lnk\") && privileges.includes(\"ELEVATE_PRIVILEGES\") && privileges.includes(\"MANAGE_TOKENS\")) {\n\t\t\t\t\tlet file = await availableAPIs.fs_read({ path: path });\n\t\t\t\t\tfile = JSON.parse(file);\n\t\t\t\t\tif (privileges.includes(\"START_TASK\")) {\n\t\t\t\t\t\tif (!globalToken) globalToken = await availableAPIs.consentGetToken({\n\t\t\t\t\t\t\tintent: await availableAPIs.lookupLocale(\"FILE_EXPLORER_INTENT\"),\n\t\t\t\t\t\t\tname: await availableAPIs.lookupLocale(\"FILE_EXPLORER\"),\n\t\t\t\t\t\t\tdesiredUser: await availableAPIs.getUser()\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (globalToken) {\n\t\t\t\t\t\t\tlet newToken = await availableAPIs.forkToken(globalToken);\n\t\t\t\t\t\t\tawait availableAPIs.startTask({ file: file.path, argPassed: [ ...(file.args || []) ], token: newToken });\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdisplayResult.innerText = await availableAPIs.lookupLocale(\"MORE_PERMISSION_DENIED\");\n\t\t\t\t\t\thasError = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet fileType = path.split(\".\").slice(-1)[0];\n\t\t\t\t\tif (!availableAssocs.includes(fileType)) return displayResult.innerText = await availableAPIs.lookupLocale(\"UNKNOWN_FILE_TYPE\");\n\t\t\t\t\tlet file = await availableAPIs.fs_read({ path: await availableAPIs.getSystemMount() + \"/apps/associations/\" + fileType });\n\t\t\t\t\tlet fileLink = JSON.parse(file);\n\t\t\t\t\tif (privileges.includes(\"START_TASK\") && privileges.includes(\"ELEVATE_PRIVILEGES\") && privileges.includes(\"MANAGE_TOKENS\")) {\n\t\t\t\t\t\tif (!globalToken) globalToken = await availableAPIs.consentGetToken({\n\t\t\t\t\t\t\tintent: await availableAPIs.lookupLocale(\"FILE_EXPLORER_INTENT\"),\n\t\t\t\t\t\t\tname: await availableAPIs.lookupLocale(\"FILE_EXPLORER\"),\n\t\t\t\t\t\t\tdesiredUser: await availableAPIs.getUser()\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (globalToken) {\n\t\t\t\t\t\t\tlet newToken = await availableAPIs.forkToken(globalToken);\n\t\t\t\t\t\t\tawait availableAPIs.startTask({ file: fileLink.path, argPassed: [ ...(fileLink.args || []), path ], token: newToken });\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdisplayResult.innerText = await availableAPIs.lookupLocale(\"MORE_PERMISSION_DENIED\");\n\t\t\t\t\t\thasError = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!hasError) await browse();\n\t\t\t} else {\n\t\t\t\tdisplayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", (await availableAPIs.lookupLocale(\"UNKNOWN_FS_STRUCT\")).replace(\"%s\", type));\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tdisplayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", await availableAPIs.lookupLocale(e.message));\n\t\t}\n\t}\n\tif (exec_args[0]) pathElement.value = exec_args[0];\n\tbrowse();\n\tbrowseButton.onclick = browse;\n})();\nasync function recursiveRemove(path) {\n\tlet dirList = await availableAPIs.fs_ls({ path });\n\tfor (let fileIndex in dirList) {\n\t\tlet file = dirList[fileIndex];\n\t\tif (await availableAPIs.fs_isDirectory({ path: path + \"/\" + file })) await recursiveRemove(path + \"/\" + file);\n\t\telse await availableAPIs.fs_rm({ path: path + \"/\" + file });\n\t}\n\tawait availableAPIs.fs_rm({ path });\n}\nasync function isDirectory(path) {\n\ttry {\n\t\tlet isDirectoryVar = await availableAPIs.fs_isDirectory({ path });\n\t\treturn isDirectoryVar ? \"directory\" : \"file\";\n\t} catch {\n\t\treturn \"unknown\";\n\t}\n}\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) {\n\t\ttry {\n\t\t\tif (globalToken) await availableAPIs.revokeToken(globalToken);\n\t\t} catch {}\n\t\tawait window.availableAPIs.terminate();\n\t}\n}); null;","cdc73dc251bcf81b3073b2df3712ac1a8472a6d162e912c6ed98167ff5141ad2278c9360604f4e2a80edb239b7faf8b2f14aad442ac7bb590da0b3a8dd716519":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: FS_READ, FS_LIST_PARTITIONS, IPC_SEND_PIPE, GET_LOCALE, GET_THEME, FS_BYPASS_PERMISSIONS, GET_USER_INFO\n// signature: ea6228fcad8ff9208d24d788e81cb81673e4d55501736b5bc481e3ff1e1f0be473f21c9cfb38b82f6689cc4abf5a2edcd6b2dc8b43036e87b1ab6492771f2c03\n// =====END MANIFEST=====\nlet ipcChannel = exec_args[0];\n(async function() {\n\t// @pcos-app-mode isolatable\n\tif (!ipcChannel) return availableAPIs.terminate();\n\tawait availableAPIs.windowTitleSet(await availableAPIs.lookupLocale(\"FILE_PICKER\"));\n\tdocument.body.style.fontFamily = \"'Segoe UI', Tahoma, Geneva, Verdana, sans-serif\";\n\tif (await availableAPIs.isDarkThemed()) document.body.style.color = \"white\";\n\tlet privileges = await availableAPIs.getPrivileges();\n\tlet checklist = [ \"FS_READ\", \"FS_LIST_PARTITIONS\", \"IPC_SEND_PIPE\" ];\n\tif (!checklist.every(p => privileges.includes(p))) {\n\t\tif (privileges.includes(\"IPC_SEND_PIPE\")) await availableAPIs.sendToPipe({ pipe: ipcChannel, data: { success: false, reason: \"permissions\" } });\n\t\treturn availableAPIs.terminate();\n\t}\n\tlet hideHiddenFiles = false;\n\ttry {\n\t\tlet homedir = (await availableAPIs.getUserInfo({ desiredUser: await availableAPIs.getUser() })).homeDirectory;\n\t\thideHiddenFiles = true;\n\t\thideHiddenFiles = (await availableAPIs.fs_read({\n\t\t\tpath: homedir + \"/.hiddenFiles\",\n\t\t})) != \"show\";\n\t} catch {}\n\tdocument.body.innerText = \"\";\n\tlet mainComponent = document.createElement(\"div\");\n\tlet pathInputForm = document.createElement(\"form\");\n\tlet pathElement = document.createElement(\"input\");\n\tpathElement.value = exec_args[2] || \"\";\n\tlet browseButton = document.createElement(\"button\");\n\tlet displayResult = document.createElement(\"div\");\n\tlet newItemInput = document.createElement(\"input\");\n\tlet newItemBrowse = document.createElement(\"button\");\n\tlet newItemContainer = document.createElement(\"div\");\n\tlet previousDirectory = \"\";\n\tlet isDefaultChoice = true;\n\tmainComponent.style.display = \"flex\";\n\tmainComponent.style.flexDirection = \"column\";\n\tmainComponent.style.width = \"100%\";\n\tmainComponent.style.height = \"100%\";\n\tmainComponent.style.position = \"absolute\";\n\tmainComponent.style.top = \"0\";\n\tmainComponent.style.left = \"0\";\n\tmainComponent.style.padding = \"8px\";\n\tmainComponent.style.boxSizing = \"border-box\";\n\tdisplayResult.style.flex = \"1\";\n\tnewItemBrowse.innerText = await availableAPIs.lookupLocale(\"SAVE_BTN\");\n\tnewItemContainer.appendChild(document.createElement(\"hr\"));\n\tnewItemContainer.appendChild(newItemInput);\n\tbrowseButton.innerText = await availableAPIs.lookupLocale(\"BROWSE_FEXP\");\n\tnewItemContainer.appendChild(newItemBrowse);\n\tpathInputForm.appendChild(pathElement);\n\tpathInputForm.appendChild(browseButton);\n\tmainComponent.appendChild(pathInputForm);\n\tmainComponent.appendChild(displayResult);\n\tmainComponent.appendChild(newItemContainer);\n\tdocument.body.appendChild(mainComponent);\n\tnewItemContainer.hidden = exec_args[1] != \"save\";\n\tasync function browse() {\n\t\tlet path = pathElement.value;\n\t\tif (path.endsWith(\"/\")) path = path.substring(0, path.length - 1);\n\t\tdisplayResult.innerText = \"\";\n\t\tif (path == \"\") {\n\t\t\tlet partitions = (await availableAPIs.fs_mounts()).sort((a, b) => a.localeCompare(b));\n\t\t\tfor (let partition of partitions) {\n\t\t\t\tif (partition.startsWith(\".\") && hideHiddenFiles) continue;\n\t\t\t\tlet openButton = document.createElement(\"button\");\n\t\t\t\topenButton.innerText = partition;\n\t\t\t\topenButton.onclick = function() {\n\t\t\t\t\tpathElement.value = partition;\n\t\t\t\t\tbrowse();\n\t\t\t\t}\n\t\t\t\tdisplayResult.appendChild(openButton);\n\t\t\t}\n\t\t\tpreviousDirectory = path;\n\t\t\treturn \"browsed\";\n\t\t}\n\t\ttry {\n\t\t\tlet type = await isDirectory(path);\n\t\t\tif (type == \"directory\") {\n\t\t\t\tlet ls = (await availableAPIs.fs_ls({ path: path })).sort((a, b) => a.localeCompare(b));\n\t\t\t\tfor (let file of ls) {\n\t\t\t\t\tif (file.startsWith(\".\") && hideHiddenFiles) continue;\n\t\t\t\t\tlet openButton = document.createElement(\"button\");\n\t\t\t\t\topenButton.innerText = file;\n\t\t\t\t\topenButton.onclick = function() {\n\t\t\t\t\t\tpathElement.value = path + \"/\" + file;\n\t\t\t\t\t\tbrowse();\n\t\t\t\t\t}\n\t\t\t\t\tdisplayResult.appendChild(openButton);\n\t\t\t\t}\n\t\t\t\tpreviousDirectory = path;\n\t\t\t} else if (type == \"file\" || (type == \"unknown\" && exec_args[1] == \"save\")) {\n\t\t\t\tif (isDefaultChoice) {\n\t\t\t\t\tpathElement.value = path.split(\"/\").slice(0, -1).join(\"/\");\n\t\t\t\t\tnewItemInput.value = path.split(\"/\").slice(-1)[0];\n\t\t\t\t\treturn browse();\n\t\t\t\t}\n\t\t\t\tdisplayResult.innerText = \"\";\n\t\t\t\tawait availableAPIs.sendToPipe({ pipe: ipcChannel, data: { success: true, selected: path } });\n\t\t\t\tawait availableAPIs.terminate();\n\t\t\t} else {\n\t\t\t\tdisplayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", (await availableAPIs.lookupLocale(\"UNKNOWN_FS_STRUCT\")).replace(\"%s\", type));\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tdisplayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", await availableAPIs.lookupLocale(e.message));\n\t\t}\n\t\tisDefaultChoice = false;\n\t}\n\tbrowse();\n\tbrowseButton.onclick = browse;\n\tnewItemBrowse.onclick = async function() {\n\t\tif (previousDirectory == \"\") return displayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", await availableAPIs.lookupLocale(\"NO_SAVE_IN_MTN\"));\n\t\tpathElement.value = previousDirectory + \"/\" + newItemInput.value;\n\t\tbrowse();\n\t}\n})();\nasync function isDirectory(path) {\n\ttry {\n\t\tlet isDirectoryVar = await availableAPIs.fs_isDirectory({ path });\n\t\treturn isDirectoryVar ? \"directory\" : \"file\";\n\t} catch {\n\t\treturn \"unknown\";\n\t}\n}\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) {\n\t\ttry {\n\t\t\tawait availableAPIs.sendToPipe({ pipe: ipcChannel, data: { success: false, reason: \"closed\" } });\n\t\t} catch {}\n\t\tawait window.availableAPIs.terminate();\n\t}\n}); null;","4c65fdac558812659c79be137b525a5982b44892a5ce532b0eadbd9ada35658625af52588f044ca19d776a9f1c23f80f82d8ebead319c8a3956730845edbbaa9":"{\"path\":\"system/apps/explorer.js\",\"localeReferenceName\":\"FILE_EXPLORER\"}","7d06a753bf0e328de8fbfdc46219a5c3085c0a44e4ca322f2e4e2b98fe4c7dee83230f9f0cec0e7b3e124cd259e7f4b57c8103e0e7798c6572201af64e9fdf02":"{\"path\":\"system/apps/textEditor.js\",\"localeReferenceName\":\"TEXT_EDITOR\"}","abf9ece8043f4d880551e79043fc07e95b8445b5d36d25f6b12fdf1da0f94f9e04d6d72ec4527055e9b4e579f52907912b7b4c151bfbcf633ad29a4b15b18f30":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: FS_READ, FS_LIST_PARTITIONS, IPC_SEND_PIPE, IPC_LISTEN_PIPE, GET_LOCALE, GET_THEME, FS_BYPASS_PERMISSIONS, SYSTEM_SHUTDOWN, GET_USER_INFO, LOGOUT, GET_SCREEN_INFO, GRAB_ATTENTION, LULL_SYSTEM\n// signature: 6f10f2523bd44155216a5378e9fb92ba81c1d3e15cfdfcbae54d72da20065e60e01705819c1cd7d512f23d2f1bd43250a2d2ca37c4b42fa8de40786277d1ea0e\n// =====END MANIFEST=====\nlet ipcChannel;\nlet shouldShutdown = false;\nlet visibilityState = true;\nlet hexToU8A = (hex) => Uint8Array.from(hex.match(/.{1,2}/g).map(a => parseInt(a, 16)));\nlet u8aToHex = (u8a) => Array.from(u8a).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n(async function() {\n\t// @pcos-app-mode isolatable\n\tipcChannel = await availableAPIs.getPrivateData();\n\tif (!ipcChannel) return availableAPIs.terminate();\n\tawait visibility(false);\n\tawait window.availableAPIs.windowTitleSet(await window.availableAPIs.lookupLocale(\"START_MENU\"));\n\tdocument.body.style.fontFamily = \"'Segoe UI', Tahoma, Geneva, Verdana, sans-serif\";\n\tif (await availableAPIs.isDarkThemed()) document.body.style.color = \"white\";\n\tlet privileges = await availableAPIs.getPrivileges();\n\tlet checklist = [ \"FS_READ\", \"FS_LIST_PARTITIONS\", \"IPC_SEND_PIPE\", \"IPC_LISTEN_PIPE\" ];\n\tif (!checklist.every(p => privileges.includes(p))) return availableAPIs.terminate();\n\tawait availableAPIs.sendToPipe({ pipe: ipcChannel, data: { success: true } });\n\tdocument.body.innerText = \"\";\n\tlet logoutButton = document.createElement(\"button\");\n\tlogoutButton.innerText = (await availableAPIs.lookupLocale(\"LOG_OUT_BUTTON\")).replace(\"%s\", await availableAPIs.getUser());\n\tdocument.body.appendChild(logoutButton);\n\tlogoutButton.onclick = async function() {\n\t\tshouldShutdown = true;\n\t\tawait visibility(false);\n\t\tawait availableAPIs.logOut(await availableAPIs.getUser());\n\t}\n\tlet lockButton = document.createElement(\"button\");\n\tlockButton.innerText = await availableAPIs.lookupLocale(\"LOCK_BUTTON\");\n\tdocument.body.appendChild(lockButton);\n\tlockButton.onclick = async function() {\n\t\tawait visibility(false);\n\t\tawait availableAPIs.lock();\n\t}\n\tif (privileges.includes(\"SYSTEM_SHUTDOWN\")) {\n\t\tlet shutoff = document.createElement(\"button\");\n\t\tshutoff.innerText = await availableAPIs.lookupLocale(\"TURN_OFF_BUTTON\");\n\t\tdocument.body.appendChild(shutoff);\n\t\tshutoff.onclick = async function() {\n\t\t\tshouldShutdown = true;\n\t\t\tawait visibility(false);\n\t\t\tawait availableAPIs.shutdown({ isReboot: false });\n\t\t}\n\t\tlet reboot = document.createElement(\"button\");\n\t\treboot.innerText = await availableAPIs.lookupLocale(\"RESTART_BUTTON\");\n\t\tdocument.body.appendChild(reboot);\n\t\treboot.onclick = async function() {\n\t\t\tshouldShutdown = true;\n\t\t\tawait visibility(false);\n\t\t\tawait availableAPIs.shutdown({ isReboot: true, isKexec: true });\n\t\t}\n\t\treboot.oncontextmenu = async function(e) {\n\t\t\te.stopImmediatePropagation();\n\t\t\te.stopPropagation();\n\t\t\te.preventDefault();\n\t\t\tshouldShutdown = true;\n\t\t\tawait visibility(false);\n\t\t\tawait availableAPIs.shutdown({ isReboot: true, isKexec: false });\n\t\t}\n\t}\n\tif (privileges.includes(\"LULL_SYSTEM\")) {\n\t\tlet lull = document.createElement(\"button\");\n\t\tlull.innerText = await availableAPIs.lookupLocale(\"LULL_SYSTEM\");\n\t\tdocument.body.appendChild(lull);\n\t\tlull.onclick = async function() {\n\t\t\tawait visibility(false);\n\t\t\tawait availableAPIs.lull();\n\t\t}\n\t}\n\ttry {\n\t\tlet enumeration = (await availableAPIs.fs_ls({ path: (await availableAPIs.getSystemMount()) + \"/apps/links\" })).sort((a, b) => a.localeCompare(b));\n\t\tfor (let app of enumeration) {\n\t\t\tlet appLink = await availableAPIs.fs_read({ path: (await availableAPIs.getSystemMount()) + \"/apps/links/\" + app });\n\t\t\tappLink = JSON.parse(appLink);\n\t\t\tif (appLink.disabled) continue;\n\t\t\tlet appBtn = document.createElement(\"button\");\n\t\t\tappBtn.innerText = (appLink.localeReferenceName ? await availableAPIs.lookupLocale(appLink.localeReferenceName) : null) || (appLink.localeDatabaseName ? (appLink.localeDatabaseName[navigator.language.slice(0, 2).toLowerCase()] || appLink.localeDatabaseName[await availableAPIs.osLocale()]) : null) || appLink.name;\n\t\t\tappBtn.title = await availableAPIs.lookupLocale(\"PROVISIONED_PREFERENCE\");\n\t\t\tappBtn.onclick = async function() {\n\t\t\t\tawait visibility(false);\n\t\t\t\tawait availableAPIs.sendToPipe({ pipe: ipcChannel, data: { run: appLink } });\n\t\t\t}\n\t\t\tdocument.body.appendChild(appBtn);\n\t\t}\n\t} catch (e) {\n\t\tconsole.error(\"Failed to enumerate system app links\", e);\n\t}\n\ttry {\n\t\tlet enumeration = await availableAPIs.fs_ls({ path: (await availableAPIs.getUserInfo({ desiredUser: await availableAPIs.getUser() })).homeDirectory + \"/.applinks\" });\n\t\tfor (let app of enumeration) {\n\t\t\tlet appLink = await availableAPIs.fs_read({ path: (await availableAPIs.getUserInfo({ desiredUser: await availableAPIs.getUser() })).homeDirectory + \"/.applinks/\" + app });\n\t\t\tappLink = JSON.parse(appLink);\n\t\t\tif (appLink.disabled) continue;\n\t\t\tlet appBtn = document.createElement(\"button\");\n\t\t\tappBtn.innerText = (appLink.localeReferenceName ? await availableAPIs.lookupLocale(appLink.localeReferenceName) : null) || (appLink.localeDatabaseName ? (appLink.localeDatabaseName[navigator.language.slice(0, 2).toLowerCase()] || appLink.localeDatabaseName[await availableAPIs.osLocale()]) : null) || appLink.name;\n\t\t\tappBtn.onclick = async function() {\n\t\t\t\tawait visibility(false);\n\t\t\t\tawait availableAPIs.sendToPipe({ pipe: ipcChannel, data: { run: appLink } });\n\t\t\t}\n\t\t\tdocument.body.appendChild(appBtn);\n\t\t}\n\t} catch (e) {\n\t\tconsole.error(\"Failed to enumerate user app links\", e);\n\t}\n\n\tonresize = shapeshift;\n\n\twhile (true) {\n\t\tlet listen = await availableAPIs.listenToPipe(ipcChannel);\n\t\tif (listen.open) {\n\t\t\tawait visibility();\n\t\t\tshapeshift();\n\t\t}\n\t}\n})();\n\nasync function visibility(wantedState) {\n\tif (!wantedState) wantedState = !visibilityState;\n\tif (wantedState == visibilityState) return;\n\tawait availableAPIs.windowVisibility(wantedState);\n\tvisibilityState = wantedState;\n}\n\nasync function shapeshift() {\n\tlet screenInfo = await availableAPIs.getScreenInfo();\n\tlet winSize = await availableAPIs.windowSize();\n\tawait availableAPIs.windowRelocate([ screenInfo.height - (winSize.height / 2) - 31 - 8, winSize.width / 2 + 8 ]);\n\tawait availableAPIs.windowFocus();\n}\n\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) {\n\t\tawait visibility(false);\n\t\tawait availableAPIs.sendToPipe({ pipe: ipcChannel, data: { dying: true } });\n\t\tawait availableAPIs.terminate();\n\t}\n}); null;","0b264a96efc4c43c035a15ac796012a0f2bbdae56d6834c4e2b8c47978ce16cd77ee00c1a7b7541eadd11d5061c79f3494c7da68724fa55ed2bdd84aaa86f908":"// =====BEGIN MANIFEST=====\n// link: lrn:TEXT_EDITOR\n// association: txt\n// signer: automaticSigner\n// allow: FS_READ, FS_WRITE, FS_LIST_PARTITIONS, IPC_CREATE_PIPE, IPC_LISTEN_PIPE, GET_LOCALE, GET_THEME, START_TASK, IPC_SEND_PIPE, FS_BYPASS_PERMISSIONS, GET_USER_INFO\n// signature: e9ad0f530dd0fde2e47b6a333a796d1e3caffb162a07b28052b5ea182eea00b1e8d10d82c553de364af48fdf9eadb10bacac949d7e30e4bce37392b86df56408\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.windowTitleSet(await availableAPIs.lookupLocale(\"TEXT_EDITOR\"));\n\tdocument.body.style.fontFamily = \"'Segoe UI', Tahoma, Geneva, Verdana, sans-serif\";\n\tif (await availableAPIs.isDarkThemed()) document.body.style.color = \"white\";\n\tdocument.documentElement.style.height = \"100%\";\n\tdocument.documentElement.style.width = \"100%\";\n\tdocument.body.style.height = \"100%\";\n\tdocument.body.style.width = \"100%\";\n\tdocument.body.style.margin = \"0\";\n\tlet flexContainer = document.createElement(\"div\");\n\tlet buttonContainer = document.createElement(\"div\");\n\tlet loadButton = document.createElement(\"button\");\n\tlet saveButton = document.createElement(\"button\");\n\tlet statusMessage = document.createElement(\"span\");\n\tlet data = document.createElement(\"textarea\");\n\tlet hr = document.createElement(\"hr\");\n\tlet hrContainer = document.createElement(\"div\");\n\tlet lastFile = \"\";\n\tloadButton.innerText = await availableAPIs.lookupLocale(\"LOAD_BTN\");\n\tsaveButton.innerText = await availableAPIs.lookupLocale(\"SAVE_BTN\");\n\tflexContainer.style.display = \"flex\";\n\tflexContainer.style.flexDirection = \"column\";\n\tflexContainer.style.width = \"100%\";\n\tflexContainer.style.height = \"100%\";\n\tdata.style.flexGrow = 1000;\n\tdata.style.resize = \"none\";\n\tif (await availableAPIs.isDarkThemed()) {\n\t\tdata.style.backgroundColor = \"#2b2a33\";\n\t\tdata.style.color = \"white\";\n\t}\n\tbuttonContainer.appendChild(loadButton);\n\tbuttonContainer.appendChild(saveButton);\n\tbuttonContainer.appendChild(statusMessage);\n\thrContainer.appendChild(hr);\n\tflexContainer.appendChild(buttonContainer);\n\tflexContainer.appendChild(hrContainer);\n\tflexContainer.appendChild(data);\n\tdocument.body.appendChild(flexContainer);\n\ttry {\n\t\tif (exec_args[0]) {\n\t\t\tdata.value = await availableAPIs.fs_read({ path: exec_args[0] });\n\t\t\tlastFile = exec_args[0];\n\t\t\tstatusMessage.innerText = exec_args[0].split(\"/\").pop();\n\t\t}\n\t} catch (e) {\n\t\tstatusMessage.innerText = e.name + \": \" + e.message;\n\t}\n\tloadButton.onclick = async function() {\n\t\tlet ipcPipe = await availableAPIs.createPipe();\n\t\tawait availableAPIs.windowVisibility(false);\n\t\tawait availableAPIs.startTask({ file: (await availableAPIs.getSystemMount()) + \"/apps/filePicker.js\", argPassed: [ipcPipe, \"load\", lastFile] });\n\t\tlet result = await availableAPIs.listenToPipe(ipcPipe);\n\t\tawait availableAPIs.closePipe(ipcPipe);\n\t\tawait availableAPIs.windowVisibility(true);\n\t\ttry {\n\t\t\tif (result.success) {\n\t\t\t\tdata.value = await availableAPIs.fs_read({ path: result.selected });\n\t\t\t\tlastFile = result.selected;\n\t\t\t\tstatusMessage.innerText = result.selected.split(\"/\").pop();\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tstatusMessage.innerText = e.name + \": \" + e.message;\n\t\t}\n\t}\n\tsaveButton.onclick = async function() {\n\t\tlet ipcPipe = await availableAPIs.createPipe();\n\t\tawait availableAPIs.windowVisibility(false);\n\t\tawait availableAPIs.startTask({ file: (await availableAPIs.getSystemMount()) + \"/apps/filePicker.js\", argPassed: [ipcPipe, \"save\", lastFile] });\n\t\tlet result = await availableAPIs.listenToPipe(ipcPipe);\n\t\tawait availableAPIs.closePipe(ipcPipe);\n\t\tawait availableAPIs.windowVisibility(true);\n\t\ttry {\n\t\t\tif (result.success) {\n\t\t\t\tawait availableAPIs.fs_write({ path: result.selected, data: data.value });\n\t\t\t\tlastFile = result.selected;\n\t\t\t\tstatusMessage.innerText = result.selected.split(\"/\").pop();\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tstatusMessage.innerText = e.name + \": \" + e.message;\n\t\t}\n\t}\n})();\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); null;","a864983c462aa5ce602586598dd963444425223190554c36d74075f59a332c93cc12f6edd22b6a391d6034b8a66a225f13dae54000e45ba5c870f2813ae11f14":"{\n\t\"basic\": \"abcdefc792c6abcdefc792c600000001\",\n\t\"pc\": \"abcdefc792c6abcdefc792c600000001\"\n}"},"buildInfo":{"for":"1580","version":1580,"when":1766238578377,"signer":"moduleSigner","critical":true,"bootOrder":"50","commonName":"core","friendlyNameRef":"CORE_MODULE_NAME","signature":"b81142d3e826942ec04bb4a1cfd6c6137b441e80fc772e9dd2250fed52b78872ba6b8d6b84f4bfd642b8f11f46276eedfd4feeb95b248ce35597a71ec8cb5804"}},"50-locale-en.fs":{"backend":{"files":{"boot":{"06-localesappend-en.js":"4b5576d59d7ac4eed138e63ca8a359a771a15ab3f6681f2167cd4e668d3db6e0de07db327d5661ccbaff4f36acf844a5ea61de17f28e9fd435198d028ff182ef"}},"permissions":{"boot/06-localesappend-en.js":{"world":"rx"},"boot/":{"world":"rx"},"":{"world":"rx"}}},"files":{"4b5576d59d7ac4eed138e63ca8a359a771a15ab3f6681f2167cd4e668d3db6e0de07db327d5661ccbaff4f36acf844a5ea61de17f28e9fd435198d028ff182ef":"modules.locales.en = {\n\t\"UNTITLED_APP\": \"Untitled program\",\n\t\"PERMISSION_DENIED\": \"Permission denied\",\n\t\"MORE_PERMISSION_DENIED\": \"There are not enough permissions to run this program.\",\n\t\"COMPATIBILITY_ISSUE_TITLE\": \"Compatibility issue\",\n\t\"COMPATIBILITY_ISSUE\": \"This program cannot run on this computer as a task. Check the program modes to include \\\"isolatable\\\".\",\n\t\"APP_STARTUP_CRASH_TITLE\": \"Something went wrong\",\n\t\"APP_STARTUP_CRASH\": \"The system failed to execute this program.\",\n\t\"JS_TERMINAL\": \"JavaScript Terminal\",\n\t\"TERMINAL_INVITATION\": \"PCOS 3, build %s\",\n\t\"PCOS_RESTARTING\": \"PCOS is restarting. %s\",\n\t\"PLEASE_WAIT\": \"Please wait.\",\n\t\"POLITE_CLOSE_SIGNAL\": \"Sending polite close.\",\n\t\"ABRUPT_CLOSE_SIGNAL\": \"Sending abrupt close.\",\n\t\"UNMOUNTING_MOUNTS\": \"Unmounting mounts.\",\n\t\"SAFE_TO_CLOSE\": \"It is now safe to close this tab.\",\n\t\"RESTART_BUTTON\": \"Reboot\",\n\t\"RESTARTING\": \"Restarting.\",\n\t\"INSTALL_PCOS\": \"Install PCOS\",\n\t\"INSTALLER_TITLE\": \"PCOS 3 Installer\",\n\t\"CLOSE_INSTALLER_CONFIRMATION\": \"Are you sure you want to stop the installation process? This computer will restart.\",\n\t\"YES\": \"Yes\",\n\t\"NO\": \"No\",\n\t\"INSTALLER_INVITATION\": \"You are installing PCOS 3 build %s on this computer.\",\n\t\"INSTALL_BUTTON\": \"Install\",\n\t\"LIVE_BUTTON\": \"Try out\",\n\t\"INSTALLER_PARTITIONING\": \"Select the boot and data partitions you would like to use.\",\n\t\"PARTITIONING_USE\": \"Use partitions\",\n\t\"PARTITION_DATA\": \"Data partition\",\n\t\"PARTITION_BOOT\": \"Boot partition\",\n\t\"FORMAT_DATA\": \"Format to PCFS\",\n\t\"DATA_INPUT_ALERT\": \"Please enter a data partition name.\",\n\t\"PROMPT_PARTITION_TABLE\": \"This disk does not seem to contain a valid partition table. Do you want to insert a partition table?\",\n\t\"CONFIRM_PARTITION_ERASE\": \"All data on that partition will be erased. Continue?\",\n\t\"BOOT_INPUT_ALERT\": \"Please enter a boot partition name.\",\n\t\"CANNOT_FIND_PARTITION\": \"Can't find a disk partition. Please try formatting the data partition to PCFS.\",\n\t\"PCFS_DETECTION_ERROR\": \"The data partition doesn't seem to contain PCFS. Do you still want to use it?\",\n\t\"INSTALLING_PCOS\": \"Installing PCOS: %s\",\n\t\"CREATING_BOOT_PARTITION\": \"Creating boot partition\",\n\t\"MOUNTING_DATA_PARTITION\": \"Mounting data partition as 'target'\",\n\t\"CHANGING_ROOT_PERMISSIONS\": \"Changing / permissions\",\n\t\"COPYING_FOLDERS\": \"Copying directories\",\n\t\"PATCHING_FS\": \"Patching for data mount\",\n\t\"INSTALLATION_SUCCESSFUL\": \"Successful installation. Close window to reboot.\",\n\t\"INSTALLATION_FAILED\": \"Installation of PCOS failed. Please try again. Close window to reboot.\",\n\t\"SHORT_DAYS\": \"%sd\",\n\t\"SHORT_HOURS\": \"%sh\",\n\t\"SHORT_MINUTES\": \"%smin\",\n\t\"SHORT_SECONDS\": \"%ss\",\n\t\"SHORT_MILLISECONDS\": \"%sms\",\n\t\"SHORT_TERABYTES\": \"%sTB\",\n\t\"SHORT_GIGABYTES\": \"%sGB\",\n\t\"SHORT_MEGABYTES\": \"%sMB\",\n\t\"SHORT_KILOBYTES\": \"%sKB\",\n\t\"SHORT_BYTES\": \"%sB\",\n\t\"AUTH_FAILED_NEW\": \"Authentication failed, please use a new instance!\",\n\t\"AUTH_SUCCESS\": \"Authentication successful.\",\n\t\"AUTH_FAILED\": \"Authentication failed.\",\n\t\"PLEASE_WAIT_TIME\": \"Please wait %s\",\n\t\"REPORTING_LOGON\": \"Reporting logon to server...\",\n\t\"TOTP_PC_PROMPT\": \"Enter TOTP-PC code\",\n\t\"TOTP_PROMPT\": \"Enter TOTP code\",\n\t\"ACCESS_NOT_SETUP\": \"Access to this user is not set up\",\n\t\"PASSWORD_PROMPT\": \"Enter password\",\n\t\"ENTER_BUTTON\": \"Enter\",\n\t\"USERNAME_PROMPT\": \"Enter an username.\",\n\t\"USERNAME\": \"Username\",\n\t\"ACCESS_FN_FAIL\": \"No such user.\",\n\t\"RESPONSE_PLACEHOLDER\": \"Response...\",\n\t\"START_MENU_BTN\": \"Start\",\n\t\"START_MENU\": \"Start menu\",\n\t\"LOG_IN_INVITATION\": \"Log in\",\n\t\"LOG_OUT_BUTTON\": \"Log out (%s)\",\n\t\"LOCK_BUTTON\": \"Lock\",\n\t\"TURN_OFF_BUTTON\": \"Turn off\",\n\t\"PASSWORD\": \"Password\",\n\t\"LET_CREATE_ACCOUNT\": \"Let's create your own user account.\",\n\t\"CREATE\": \"Create\",\n\t\"PASSWORD_INPUT_ALERT\": \"Please enter a password!\",\n\t\"CREATING_USER_STRUCTURE\": \"Creating user structure\",\n\t\"CREATING_USER\": \"Creating user\",\n\t\"INSTALLING_WP2U\": \"Installing wallpaper to user\",\n\t\"CONFIRM\": \"Confirm\",\n\t\"RIGHT_REVIEW\": \"Let's review your rights.\",\n\t\"RIGHT_REVIEW_BTN\": \"Accept license\",\n\t\"DARK_MODE\": \"Dark mode\",\n\t\"INSTALLING_DARKMODE\": \"Installing dark mode preference\",\n\t\"CREATING_USER_HOME\": \"Creating user home directory\",\n\t\"PROVISIONED_PREFERENCE\": \"This setting is managed by the system administrator.\",\n\t\"USERNAME_EXISTS\": \"This user already exists in the system.\",\n\t\"VIDEO_PLAYER\": \"Video player\",\n\t\"INACCESSIBLE_FILE\": \"%s is inaccessible. Ensure you have permissions to access it, and that the object exists.\",\n\t\"FILE_NOT_SPECIFIED\": \"No file specified.\",\n\t\"PICTURE_VIEWER\": \"Picture viewer\",\n\t\"API_TEST_TERM\": \"API Developer's Terminal\",\n\t\"HELP_TERMINAL_APITEST\": \"help - Display help menu\\r\\nclear - Clear terminal\\r\\njs_ree - Execute JavaScript code\\r\\n--- REE API EXPORTS ---\\r\\n\",\n\t\"TERM_COMMAND_NOT_FOUND\": \"%s: command not found\",\n\t\"FILE_EXPLORER\": \"File explorer\",\n\t\"GRANT_FEXP_PERM\": \"Please grant permissions to read file structures and list partitions.\",\n\t\"GRANT_PERM\": \"Grant permissions\",\n\t\"GRANT_FEXP_PERM_ADM\": \"Please consult the administrator to grant privileges to this program to read file structures and list partitions. (FS_READ, FS_LIST_PARTITIONS)\",\n\t\"GRANT_FEXP_PERM_USR\": \"Please grant permissions to read file structures and list partitions using a different user.\",\n\t\"BROWSE_FEXP\": \"Browse\",\n\t\"SPACE_SHOWER\": \"Space in \\\"%s\\\": %s used of %s (%s%)\",\n\t\"FILE_STRUCT_BROWSE_FAIL\": \"Could not browse to this structure:\\n%s\",\n\t\"UNKNOWN_FS_STRUCT\": \"Unknown filesystem structure \\\"%s\\\"\",\n\t\"UNKNOWN_FILE_TYPE\": \"This is an unknown file type.\",\n\t\"TMGR_PERMISSION\": \"Task manager was not permitted to run under this condition. Please contact the system administrator.\\nRequired privileges: %s\",\n\t\"TASK_MANAGER\": \"Task manager\",\n\t\"BASENAME_TASK\": \"Basename\",\n\t\"USER_TASK\": \"User\",\n\t\"TERMINATE_TASK\": \"Terminate\",\n\t\"FULL_PATH_TASK\": \"Full path\",\n\t\"ARGUMENTS_TASK\": \"Arguments\",\n\t\"LOGGING_OUT\": \"Logging out...\",\n\t\"PANIC_LINE1\": \"A critical problem has been detected while using the operating system. Its stability is at risk now.\",\n\t\"PANIC_LINE2\": \"Problem code: %s\",\n\t\"PANIC_UNSPECIFIED_ERROR\": \"UNSPECIFIED_ERROR\",\n\t\"PROBLEMATIC_COMPONENT\": \"Problematic component: %s\",\n\t\"PROBLEMATIC_PARAMS\": \"Problematic parameters: %s\",\n\t\"PROBLEMATIC_JS\": \"Problematic JavaScript: %s: %s\",\n\t\"PANIC_LINE3\": \"If you have seen this error message the first time, attempt rebooting.\",\n\t\"PANIC_LINE4\": \"If you see this error message once more, there is something wrong with the system.\",\n\t\"PANIC_LINE5\": \"You can try repairing the system by using the installer to repair install or clean install PCOS 3.\",\n\t\"PANIC_LINE6\": \"Proper shutdown procedure follows now:\",\n\t\"PANIC_TASK_KILLED\": \"task:%s: killed\",\n\t\"PANIC_MOUNT_UNMOUNTED\": \"mount:%s: unmounted\",\n\t\"PANIC_MOUNT_FAILED\": \"mount:%s: %s: %s\",\n\t\"SHORT_YEARS\": \"%sy\",\n\t\"SHORT_MONTHS\": \"%smo\",\n\t\"SYSADMIN_TOOLS_TITLE\": \"Sysadmin Tools\",\n\t\"SYSADMIN_TOOLS_PRIVFAIL\": \"You are not a system administrator.\",\n\t\"FSCK_BUTTON\": \"Recover lost files\",\n\t\"SWIPE_BUTTON\": \"Wipe system securely\",\n\t\"SETTING_FSCK_FLAG\": \"Creating .fsck file\",\n\t\"SETTING_FSCK_FLAG_FAILED\": \"Failed to create .fsck file.\",\n\t\"WIPING_SYSTEM\": \"Securely wiping system...\",\n\t\"WIPING_SYSTEM_FAILED\": \"Failed to securely wipe system.\",\n\t\"WORKING_HOURS_UNMET\": \"You attempted to log in outside of your working hours. Try again later.\",\n\t\"NETCONFIG_TITLE\": \"PCOS Network configurator\",\n\t\"NETCONFIG_DENY\": \"There are not enough permissions to configure PCOS Network.\",\n\t\"NETCONFIG_URLF\": \"Proxy URL: \",\n\t\"NETCONFIG_UC\": \"Customizable: \",\n\t\"NETCONFIG_SAVE\": \"Save config\",\n\t\"NETCONFIG_PREDICT\": \"Predict address\",\n\t\"EMPTY_STATUSBAR\": \"Status\",\n\t\"NETCONFIG_SAVE_OK\": \"Configuration saved successfully\",\n\t\"NETCONFIG_SAVE_FAIL\": \"Failed to save config\",\n\t\"PCOS_STARTING\": \"PCOS is starting...\",\n\t\"FILE_PICKER\": \"File picker\",\n\t\"TEXT_EDITOR\": \"Text editor\",\n\t\"LOAD_BTN\": \"Load\",\n\t\"SAVE_BTN\": \"Save\",\n\t\"NETCONFIG_SYSIDM\": \"No System ID available\",\n\t\"NO_SAVE_IN_MTN\": \"You can't save in the mountpoint directory.\",\n\t\"INSTALLING_WP2L\": \"Installing wallpaper to lock screen\",\n\t\"EXIT\": \"Exit\",\n\t\"REMOVE_BTN\": \"Remove\",\n\t\"UNMOUNT_BTN\": \"Unmount\",\n\t\"INSTALLING_DARKMODE2L\": \"Installing dark mode preference to lock screen\",\n\t\"MESSAGE_ENTER\": \"Enter a message to display\",\n\t\"TIMEOUT_FIELD\": \"Timeout (ms)\",\n\t\"SECRET_FIELD_TXT\": \"Secret (text)\",\n\t\"SECRET_FIELD_HEX\": \"Secret (hex)\",\n\t\"REGENERATE\": \"Regenerate\",\n\t\"START_TIME_FIELD\": \"Start time\",\n\t\"END_TIME_FIELD\": \"End time\",\n\t\"PBKDF2_OPTION\": \"PBKDF2 (Password)\",\n\t\"INFORMATIVE_MESSAGE_OPTION\": \"Informative message\",\n\t\"INFORMATIVE_MESSAGE_DENY_OPTION\": \"Informative message (deny)\",\n\t\"TIMEOUT_OPTION\": \"Timeout\",\n\t\"TIMEOUT_DENY_OPTION\": \"Timeout (deny)\",\n\t\"SERVER_REPORT_OPTION\": \"Server reporting\",\n\t\"PCTOTP_OPTION\": \"PC's TOTP interpretation\",\n\t\"RFCTOTP_OPTION\": \"RFC TOTP\",\n\t\"WORKING_HOURS_OPTION\": \"Working hours\",\n\t\"PERSONAL_SECURITY_TITLE\": \"Personal Security\",\n\t\"PERSONAL_SECURITY_DENY\": \"Not enough privileges were granted for Personal Security.\",\n\t\"ADD_BTN\": \"Add\",\n\t\"OS_LOCALE\": \"en\",\n\t\"SYSTEM_SECURITY_TITLE\": \"System Security\",\n\t\"SYSTEM_SECURITY_DENY\": \"Not enough privileges were granted for System Security.\",\n\t\"EDIT\": \"Edit\",\n\t\"USER_GROUPS\": \"Groups\",\n\t\"USER_HOMEDIR\": \"Home directory\",\n\t\"REMOVE_USER_WITH_HD\": \"Remove user with home directory\",\n\t\"CREATE_HD\": \"Create home directory\",\n\t\"CREATING_HD_OK\": \"The home directory was created successfully.\",\n\t\"CREATING_HD_FAIL\": \"Failed to create the home directory.\",\n\t\"SIGNATURE_VERIFICATION_FAILED\": \"This program claims it is trusted by %s, but the system failed to verify that claim.\",\n\t\"UNKNOWN_PLACEHOLDER\": \"<Unknown>\",\n\t\"NO_APP_ALLOWLIST\": \"The system administrator requires programs to have an allowlist of permissions, but this program didn't have that list.\",\n\t\"DISCARD_BUTTON\": \"Discard lost files\",\n\t\"MOUNTPOINT\": \"Mountpoint\",\n\t\"GENERATE_PROMPT\": \"Generate?\",\n\t\"MOUNT_BUTTON\": \"Mount\",\n\t\"NEW_DIR_NAME\": \"New directory name\",\n\t\"MKDIR_BUTTON\": \"Create directory\",\n\t\"CHOWN_BUTTON\": \"Change owner\",\n\t\"CHGRP_BUTTON\": \"Change group\",\n\t\"CHMOD_BUTTON\": \"Change permissions\",\n\t\"CLIPBOARD_COPY\": \"Copy\",\n\t\"CLIPBOARD_CUT\": \"Cut\",\n\t\"CLIPBOARD_PASTE\": \"Paste\",\n\t\"CLIPBOARD_SOURCE_GONE\": \"The source no longer exists or is no longer a file.\",\n\t\"CLIPBOARD_CONFLICT\": \"The destination directory already has a file or directory with the same name.\",\n\t\"SAFE_MODE_MSG\": \"Safe mode\",\n\t\"APP_OR_KEY_SIGNATURE_VERIFICATION_FAILED\": \"Trust verification for the program failed.\",\n\t\"NO_SUCH_DEVICE\": \"No such device\",\n\t\"READ_ONLY_BMGR\": \"Writes restricted by boot manager.\",\n\t\"READ_ONLY_DEV\": \"Device is read-only\",\n\t\"NO_DIRECTORY_SUPPORT\": \"Device does not support directories\",\n\t\"IS_A_DIR\": \"Is a directory\",\n\t\"NO_SUCH_FILE\": \"No such file\",\n\t\"NO_SUCH_DIR\": \"No such directory\",\n\t\"NO_SUCH_FILE_DIR\": \"No such file or directory\",\n\t\"NON_EMPTY_DIR\": \"Non-empty directory\",\n\t\"IS_A_FILE\": \"Is a file\",\n\t\"DIR_EXISTS\": \"Directory already exists\",\n\t\"FS_ACTION_FAILED\": \"Failed to perform this file system action.\",\n\t\"UNAUTHORIZED_ACTION\": \"The program does not have permissions to perform this action.\",\n\t\"CREATION_CHECK_FAILED\": \"Failed to check if this object is being created.\",\n\t\"PERMISSION_CHANGE_FAILED\": \"Failed to change permissions for this object.\",\n\t\"UPDATE_BUTTON\": \"Update OS\",\n\t\"TOGGLE_HIDDEN_FILES\": \"Hide/unhide files\",\n\t\"AUTORUN_NECESSITIES_FAILED\": \"Failed to run one of your autorun files. The system will not log you in.\",\n\t\"CRYPTO_TOOLS_TITLE\": \"Cryptographic Tools\",\n\t\"CRYPTO_TOOLS_NOPERM\": \"Not enough privileges were given to use Cryptographic Tools.\",\n\t\"CRYPTO_RNG\": \"Random generation\",\n\t\"CRYPTO_HASH\": \"Hashing\",\n\t\"CRYPTO_KEYGEN\": \"Key generation\",\n\t\"CRYPTO_ENCRYPT\": \"Encryption\",\n\t\"CRYPTO_DECRYPT\": \"Decryption\",\n\t\"CRYPTO_SIGN\": \"Signing\",\n\t\"CRYPTO_VERIFY\": \"Verification\",\n\t\"CRYPTO_DERIVEBITS\": \"Bit derivation\",\n\t\"GENERATE\": \"Generate\",\n\t\"RAW_HEX_DATA\": \"Raw data (hex)\",\n\t\"CRYPTO_HASH_FIELD\": \"Hash algorithm: \",\n\t\"CRYPTO_PLAINTEXT_FIELD\": \"Plaintext: \",\n\t\"ALGORITHM_FIELD\": \"Algorithm: \",\n\t\"LENGTH_FIELD\": \"Length: \",\n\t\"CRYPTO_NC_FIELD\": \"Named curve: \",\n\t\"IMPORT_AS_FIELD\": \"Import as: \",\n\t\"CRYPTO_KEY_FIELD\": \"Key: \",\n\t\"CRYPTO_CIPHERTEXT_FIELD\": \"Ciphertext (hex): \",\n\t\"CRYPTO_SIGNATURE_FIELD\": \"Signature (hex): \",\n\t\"CRYPTO_KEYGEN_MSG\": \"Generating key(s)...\",\n\t\"CRYPTO_KEYGEN_SYMM\": \"Is a symmetric key type\",\n\t\"CRYPTO_KEYGEN_EXPFAIL\": \"Export failed, check export settings\",\n\t\"CRYPTO_RNGOUT_FIELD\": \"Random numbers (hex): \",\n\t\"CRYPTO_KEYGEN_ACTION\": \"Generate key(s)\",\n\t\"CRYPTO_HASH_ACTION\": \"Hash\",\n\t\"CRYPTO_ENCRYPT_ACTION\": \"Encrypt\",\n\t\"CRYPTO_DECRYPT_ACTION\": \"Decrypt\",\n\t\"CRYPTO_SIGN_ACTION\": \"Sign\",\n\t\"CRYPTO_VERIFY_ACTION\": \"Verify\",\n\t\"CRYPTO_DERIVEBITS_ACTION\": \"Derive bits\",\n\t\"CRYPTO_PUBKEY_FIELD\": \"Public key: \",\n\t\"CRYPTO_PRIVKEY_FIELD\": \"Private key: \",\n\t\"CRYPTO_BASEKEY_FIELD\": \"Base key: \",\n\t\"CRYPTO_HASHOUT_FIELD\": \"Hash value (hex): \",\n\t\"CRYPTO_MODLEN_FIELD\": \"Modulus length: \",\n\t\"CRYPTO_PUBEXP_FIELD\": \"Public exponent (hex): \",\n\t\"EXPORT_AS_FIELD\": \"Export as: \",\n\t\"CRYPTO_KEYUSE_FIELD\": \"Key usages:\",\n\t\"CRYPTO_PLAINTEXTAS_FIELD\": \"Process plaintext as: \",\n\t\"CRYPTO_IV_FIELD\": \"IV (hex): \",\n\t\"CRYPTO_CTR_FIELD\": \"Counter (hex): \",\n\t\"CRYPTO_VERIFIED_CHECKBOX\": \"Verified successfully\",\n\t\"CRYPTO_SALT_FIELD\": \"Salt (hex): \",\n\t\"CRYPTO_DERIVEOUT_FIELD\": \"Derived bits (hex): \",\n\t\"CRYPTO_ITERATIONS_FIELD\": \"Iterations: \",\n\t\"PATH_INCLUDES_EMPTY\": \"The specified path includes an object with an empty name.\",\n\t\"BASIC_CURL_USAGE\": \"Usage: basiccurl [source] [output]\",\n\t\"BASIC_CURL_DESCRIPTION\": \"Downloads the specified source and saves it to the specified output.\",\n\t\"NO_ARGUMENTS\": \"No arguments specified\",\n\t\"CAT_USAGE\": \"Usage: cat [file1] <file2> <file3> ... <fileN>\",\n\t\"CAT_DESCRIPTION\": \"Concatenates the specified files and outputs to CLI output\",\n\t\"CHGRP_USAGE\": \"Usage: chgrp [group] [file]\",\n\t\"CHGRP_DESCRIPTION\": \"Changes the owning group of the specified file\",\n\t\"CHMOD_USAGE\": \"Usage: chmod [mode] [file]\",\n\t\"CHMOD_DESCRIPTION\": \"Changes what everyone may do with the specified file\",\n\t\"CHMOD_MODE_DESCRIPTION\": \"[mode] may consist of characters r (Read), w (Write) and x (eXecute).\",\n\t\"CHMOD_MODE_CONVERT\": \"[mode] number to string table: 0 - \\\"\\\", 1 - \\\"x\\\", 2 - \\\"w\\\", 3 - \\\"wx\\\", 4 - \\\"r\\\", 5 - \\\"rx\\\", 6 - \\\"rw\\\", 7 - \\\"rwx\\\"\",\n\t\"CHOWN_USAGE\": \"Usage: chown [user] [file]\",\n\t\"CHOWN_DESCRIPTION\": \"Changes the owning user of the specified file\",\n\t\"CP_USAGE\": \"Usage: cp <options> [source] [destination]\",\n\t\"CP_DESCRIPTION\": \"Copies files or directories from the source to the destination.\",\n\t\"OPT_RECURSIVE_DESCRIPTION\": \"--recursive: run on directories\",\n\t\"OPT_FORCE_DESCRIPTION\": \"--force: do not fail immediately in case of an error\",\n\t\"ARGUMENT_COUNT_MISMATCH\": \"Too much or not enough arguments\",\n\t\"DF_HEADER\": \"Medium\\tSize\\tUsed\\tAvail\\tUse%\",\n\t\"LS_USAGE\": \"Usage: ls [directory]\",\n\t\"LS_DESCRIPTION\": \"Lists the contents of the specified directory.\",\n\t\"LS_MOUNTPOINT_LIST\": \"You have the following mountpoints: \",\n\t\"MOUNTPOINT_SYSTEM\": \"system\",\n\t\"PASSWD_NEW_PROMPT\": \"Setting a new password for your user account.\",\n\t\"PASSWD_2FACTOR_LOSS_WARN\": \"Any previously set up additional factors will be removed.\",\n\t\"PASSWD_PROMPT\": \"New password: \",\n\t\"PASSWD_CONFIRM_PROMPT\": \"Re-enter password: \",\n\t\"PASSWD_FEEDBACK\": \"New password set\",\n\t\"PASSWD_MISMATCH\": \"Sorry, passwords do not match.\",\n\t\"PING_USAGE\": \"Usage: ping <--internet> [networkAddress]\",\n\t\"PING_DESCRIPTION\": \"Sends a request to the specified address to verify its availability.\",\n\t\"PING_INTERNET_OPTION\": \"--internet: send a ping to the Internet instead of PCOS Network\",\n\t\"PIVOT_ROOT_USAGE\": \"Usage: pivot_root [mountpoint]\",\n\t\"PIVOT_ROOT_DESCRIPTION\": \"Makes the specified mountpoint the new default system mountpoint for every program.\",\n\t\"REAL_TERMINAL_NAME\": \"Terminal\",\n\t\"REAL_TERMINAL_BUILTIN_LIST\": \"Built-in commands:\",\n\t\"REAL_TERMINAL_HELP_USEDESC\": \"help - Display the list, description and usage of all available built-in commands.\",\n\t\"REAL_TERMINAL_CLEAR_USEDESC\": \"clear - Clear everything displayed on the terminal right now.\",\n\t\"REAL_TERMINAL_SUGRAPH_USEDESC\": \"sugraph <desiredUsername> - Switch the terminal user using a graphical utility.\",\n\t\"REAL_TERMINAL_SU_USEDESC\": \"su <desiredUsername> - Switch the terminal user.\",\n\t\"REAL_TERMINAL_GRAPHIC_USEDESC\": \"graphic <boolean> - Enable or disable running new programs outside of background.\",\n\t\"REAL_TERMINAL_EXIT_USEDESC\": \"exit - Exit the terminal.\",\n\t\"REAL_TERMINAL_LOGON_REQUIRED\": \"(internal): You must run sugraph %s before running this program.\",\n\t\"RM_USAGE\": \"Usage: rm <options> [file]\",\n\t\"RM_DESCRIPTION\": \"Removes the specified file or directory.\",\n\t\"RKL_USAGE\": \"Usage: runKlvlCode [codeFile]\",\n\t\"RKL_DESCRIPTION\": \"Runs the specified code file in the kernel level.\",\n\t\"WRITE_USAGE\": \"Usage: write [file] [data]\",\n\t\"WRITE_DESCRIPTION\": \"Writes data to the specified file.\",\n\t\"CP_PERMISSIONS_OPTION\": \"--permissions: сopy the permissions of the original files\",\n\t\"REAL_TERMINAL_DEFAULT_PATH_FIELD\": \"Default path: %s\",\n\t\"REAL_TERMINAL_PUSHPATH_USEDESC\": \"pushpath [path] - Add a new path to explore to find commands.\",\n\t\"REAL_TERMINAL_RESETPATH_USEDESC\": \"resetpath - Reset the list of paths to explore to the default path.\",\n\t\"REAL_TERMINAL_LSPATH_USEDESC\": \"lspath - See the current list of paths to explore and the default path.\",\n\t\"MKDIR_USAGE\": \"Usage: mkdir [directory]\",\n\t\"MKDIR_DESCRIPTION\": \"Creates a new directory in the specified path.\",\n\t\"NEXT\": \"Next\",\n\t\"DESCRIBE_TEMPLATE\": \"Program: %s (%s)\\nIntent: %s\",\n\t\"EXTRA_DESCRIBE_TEMPLATE\": \"Program: %s (%s)\\nArguments: %s\\nIntent: %s\",\n\t\"DECLINE\": \"Decline\",\n\t\"ACCESS_REQUEST_TITLE\": \"Access request\",\n\t\"REAL_TERMINAL_INTENT\": \"Launch commands with your permissions\",\n\t\"PERSONAL_SECURITY_INTENT\": \"Manage your security settings\",\n\t\"FILE_EXPLORER_INTENT\": \"Launch programs and open files\",\n\t\"FILE_EXPLORER_FULL_INTENT\": \"Browse files, launch programs, and open files\",\n\t\"CRYPTO_TOOLS_INTENT\": \"Perform cryptographic operations\",\n\t\"SYSTEM_SECURITY_INTENT\": \"Management of the system-wide user account setup\",\n\t\"FORMAT_USAGE\": \"Usage: format [filesystem_type] [partition] <overwrite>\",\n\t\"FORMAT_DESCRIPTION\": \"Prepares the selected partition for use.\",\n\t\"FORMAT_FSTYPE\": \"Filesystem types: pcfs (corresponds to mountpoint PCFSiDBMount), pcfs_crypt (PCFSiDBAESCryptMount), pcfs_crypt_monokey (PCFSiDBAESCryptMount), pcfs_crypt_filetable_monokey (PCFSiDBAESCryptMount), pcbm:<data_partition> (like code in boot partition), null (DELETE the partition)\",\n\t\"FORMAT_OVERWRITE_WARN\": \"The partition already contains data. Set the overwrite parameter to 'overwrite' to remove data anyway. In that case, ALL DATA ON THE PARTITION MAY BE REMOVED.\",\n\t\"FORMAT_UNKNOWN_FSTYPE\": \"Unknown target formatting\",\n\t\"LLDA_USAGE\": \"Usage: llda_tool [action] [parameters]\",\n\t\"LLDA_ACTION_EXPORT\": \"action export: [input partition] [output file]\",\n\t\"LLDA_ACTION_IMPORT\": \"action import: [input file] [output partition]\",\n\t\"LLDA_ACTION_IMPORTSTRING\": \"action importstring: [input file] [output partition]\",\n\t\"LLDA_ACTION_COPY\": \"action copy: [input partition] [output partition]\",\n\t\"LLDA_ACTION_REMOVE\": \"action remove: [partition]\",\n\t\"LLDA_ACTION_LIST\": \"action list\",\n\t\"LLDA_DISCLAIMER\": \"When using this tool you may encounter LOSS OF DATA!\",\n\t\"LLDA_UNKNOWN_ACTION\": \"Unknown action\",\n\t\"INITDISK_OVERWRITE_WARN\": \"The system disk already contains partitioning data. Set the overwrite parameter to 'overwrite' to remove data anyway. In that case, ALL DATA ON THE DISK MAY BE REMOVED.\",\n\t\"INITDISK_USAGE\": \"Usage: initdisk [whatever] <overwrite>\",\n\t\"INITDISK_DESCRIPTION\": \"Prepares the system disk for use.\",\n\t\"MOUNT_USAGE\": \"Usage: mount [options] [fs_type] [mountpoint]\",\n\t\"MOUNT_DESCRIPTION\": \"Mounts a filesystem.\",\n\t\"MOUNT_KNOWN_FS\": \"Known filesystems: %s\",\n\t\"MOUNT_KNOWN_PPART\": \"--partition=[dataPartition] - Specify the data partition\",\n\t\"MOUNT_KNOWN_PINPA\": \"--interactivePassword - Ask for the password interactively\",\n\t\"MOUNT_KNOWN_PPASS\": \"--password=[password] - Specify the password\",\n\t\"MOUNT_KNOWN_PKEY\": \"--key=[hexKey] - Specify the encryption key\",\n\t\"MOUNT_KNOWN_PTYPE\": \"--type=[type] - For ramMount, specify type=run to create /run\",\n\t\"MOUNT_KNOWN_PURL\": \"--url=[URL] - Specify the URL\",\n\t\"MOUNT_KNOWN_PINPI\": \"--inputPipeId=[pipeId] - Specify the input pipe\",\n\t\"MOUNT_KNOWN_POUPI\": \"--outputPipeId=[pipeId] - Specify the output pipe\",\n\t\"MOUNTINFO_USAGE\": \"Usage: mountinfo [mountpoint]\",\n\t\"MOUNTINFO_DESCRIPTION\": \"Get information about a mountpoint.\",\n\t\"UMOUNT_USAGE\": \"Usage: umount <options> [mountpoint]\",\n\t\"UMOUNT_DESCRIPTION\": \"Unmounts a filesystem.\",\n\t\"UMOUNT_OPT_SYNCONLY\": \"--sync-only - Only sync the filesystem, not unmount (overrides --force)\",\n\t\"UMOUNT_OPT_FORCE\": \"--force - Force unmount the filesystem, do not sync\",\n\t\"CALC_TITLE\": \"Calculator\",\n\t\"CALC_BASIC_MODE\": \"Calculator: Basic mode\",\n\t\"CALC_ADVANCED_MODE\": \"Calculator: Advanced mode\",\n\t\"CALC_ADD\": \"Add\",\n\t\"CALC_SUBTRACT\": \"Subtract\",\n\t\"CALC_MULTIPLY\": \"Multiply\",\n\t\"CALC_DIVIDE\": \"Divide\",\n\t\"CALC_ADVMODE_BTN\": \"Advanced mode\",\n\t\"CALC_BASICMODE_BTN\": \"Basic mode\",\n\t\"CALC_OPERAND\": \"Operand %s\",\n\t\"CALC_TOMIXED_BTN\": \"Convert to mixed fraction\",\n\t\"CALC_TOIMPR_BTN\": \"Convert to improper fraction\",\n\t\"CALC_GCD\": \"GCD\",\n\t\"CALC_FACTORIAL\": \"Factorial\",\n\t\"CALC_GCD_PAGE\": \"Greatest common divisor\",\n\t\"ZKPP_OPTION\": \"ZKPP (Password)\",\n\t\"WARNING_PRIVILEGES\": \"Be careful with this feature! You may compromise system security.\",\n\t\"USER_EXT_PRIVILEGES\": \"Extended privilege set\",\n\t\"LULL_SYSTEM\": \"Sleep mode\",\n\t\"SYSTEM_IMAGING\": \"System imaging\",\n\t\"CREATE_IMAGE\": \"Create system image\",\n\t\"RESTORE_IMAGE\": \"Restore system image\",\n\t\"SELECT_FILE_PROMPT\": \"Select file: \",\n\t\"REBOOT_ON_RESTORE\": \"Reboot after restoring\",\n\t\"MERGE_STATES\": \"Merge image states\",\n\t\"LISTING_PARTITIONS_FAILED\": \"Failed to list partitions.\",\n\t\"READING_PARTITION_FAILED\": \"Failed to read partition %s\",\n\t\"LISTING_DATA_FAILED\": \"Failed to list data.\",\n\t\"READING_DATA_FAILED\": \"Failed to read data.\",\n\t\"WRITING_IMAGE_FAILED\": \"Failed to write image.\",\n\t\"SUCCESSFUL_OP\": \"The process was successfully completed.\",\n\t\"FAILED_OP\": \"The process has failed.\",\n\t\"READING_IMAGE_FAILED\": \"Failed to read image.\",\n\t\"WRITING_PARTITION_FAILED\": \"Failed to write partition %s\",\n\t\"WRITING_DATA_FAILED\": \"Failed to write data.\",\n\t\"DELETING_PARTITION_FAILED\": \"Failed to delete partition %s\",\n\t\"DELETING_DATA_FAILED\": \"Failed to delete data.\",\n\t\"SHUTTING_DOWN_FAILED\": \"Failed to shut the system down.\",\n\t\"NETWORK_STATUS_ONLINE\": \"You are connected to a local area network.\",\n\t\"NETWORK_STATUS_OFFLINE\": \"You aren't connected to any sort of network.\",\n\t\"PCOS_NETWORK_STATUS_ONLINE\": \"You are connected to PCOS Network. (hostname: %s, address: %s)\",\n\t\"PCOS_NETWORK_STATUS_OFFLINE\": \"You are disconnected from PCOS Network.\",\n\t\"PCOS_NETWORK_STATUS_STOPPED\": \"The PCOS Network service was stopped.\",\n\t\"START_MENU_FAILED\": \"The start menu has failed to launch. You can log out instead.\",\n\t\"SYSTEM_BUILT_AT\": \"System built at %s\",\n\t\"REAL_TERMINAL_VER_USEDESC\": \"ver - Show the build version and time\",\n\t\"BLANK_PRIVILEGE_FLAG\": \"Blank user privileges\",\n\t\"INSTALLING_SYSTEM_APPHARDEN\": \"Installing program security rules\",\n\t\"INSTALLING_NET_CONF\": \"Installing PCOS Network configuration\",\n\t\"NETWORK_ADDRESS_FIELD\": \"Network address: %s\",\n\t\"NETWORK_AUTOHOST_FIELD\": \"Automatic hostname: %s\",\n\t\"NETCONFIG_HOSTNAME\": \"Hostname: \",\n\t\"DIFF_USAGE\": \"Usage: diff [original] [new] [difference]\",\n\t\"DIFF_DESCRIPTION\": \"Calculates the difference between two files.\",\n\t\"PATCH_USAGE\": \"Usage: patch [original] [difference] [new]\",\n\t\"PATCH_DESCRIPTION\": \"Calculates the 'sum' of the original and the difference.\",\n\t\"SYSTEM_UP_TO_DATE\": \"The system is up to date\",\n\t\"POWER_USAGE\": \"Usage: power <options> <r|reboot|restart|k|kexec>\",\n\t\"POWER_DESCRIPTION\": \"Powers down or restarts the system. Supplying nothing to power makes a shutdown.\",\n\t\"POWER_FORCE\": \"--force: don't wait for processes, reboot or power down immediately\",\n\t\"POWER_KEXEC\": \"--kexec: reboot without reloading the page or firmware (automatically toggles reboot)\",\n\t\"UPDATEFW_BUTTON\": \"Update firmware\",\n\t\"UPDATEFW_DOWNLOADING\": \"Downloading local init.js...\",\n\t\"UPDATEFW_DOWNLOAD_FAILED\": \"Failed to download local init.js.\",\n\t\"UPDATEFW_DECODING\": \"Parsing init.js as text\",\n\t\"UPDATEFW_SETTING\": \"Setting init.js as firmware\",\n\t\"ADDUSER_USAGE\": \"Usage: adduser <options> [username]\",\n\t\"ADDUSER_DESCRIPTION\": \"Creates a new user account.\",\n\t\"ADDUSER_SKIP_PASSWD\": \"--skip-passwd: don't prompt for a password\",\n\t\"ADDUSER_SKIP_HOME\": \"--skip-home: don't create a home directory\",\n\t\"ADDUSER_GROUPS\": \"--groups: group to add (specify multiple times for multiple groups)\",\n\t\"ADDUSER_HOME\": \"--home: custom home directory\",\n\t\"NEW_USER_CREATION\": \"Creating new user \\\"%s\\\"\",\n\t\"BLOCKUSER_USAGE\": \"Usage: blockuser <username>\",\n\t\"BLOCKUSER_DESCRIPTION\": \"Blocks a user account.\",\n\t\"DELUSER_USAGE\": \"Usage: deluser <options> [username]\",\n\t\"DELUSER_DESCRIPTION\": \"Deletes a user account.\",\n\t\"DELUSER_HOMEDIR\": \"--homedir: delete the home directory\",\n\t\"OLD_USER_DELETION\": \"Deleting old user \\\"%s\\\"\",\n\t\"BATTERY_STATUS_UNAVAILABLE\": \"The battery status is unavailable.\",\n\t\"BATTERY_STATUS_CHARGING\": \"The battery is charging (%s%, %suntil full)\",\n\t\"BATTERY_STATUS_DISCHARGING\": \"The battery is discharging (%s%, %sof play)\",\n\t\"SERVER_SIGNATURE_VERIFICATION_FAILED\": \"This server cannot be trusted.\",\n\t\"NETWORK_UNREACHABLE\": \"Network is unreachable.\",\n\t\"ADDRESS_UNREACHABLE\": \"Address is unreachable.\",\n\t\"NETWORK_CLOSED\": \"The network has closed.\",\n\t\"CONNECTION_DROPPED\": \"The connection has been dropped.\",\n\t\"BLOG_BROWSER_NAME\": \"Blog Browser\",\n\t\"BLOG_BROWSER_LOADING\": \"Hold on, loading this page...\",\n\t\"BLOG_BROWSER_PROTO\": \"There's no such protocol. This version only supports the bdp:// protocol.\",\n\t\"BLOG_BROWSER_GATESET\": \"To set a connful gate, use the username part of the URL: bdp://gate@myblog.pc\",\n\t\"HOSTNAME_RESOLUTION_FAILED\": \"Failed to resolve hostname.\",\n\t\"BLOG_BROWSER_POSTCLOSE\": \"This interactive post has been closed.\",\n\t\"BLOG_BROWSER_FILEPOST\": \"This is a file post. You can save it to this system.\",\n\t\"BLOG_BROWSER_DLFILEPOST\": \"You have downloaded this file post.\",\n\t\"BLOG_BROWSER_LOADING_PROGRESS\": \"Loading this post (%s of %s chunks received)\",\n\t\"BLOG_BROWSER_NOVERIFY\": \"You have enabled an option to disable the verification of the server. This is not recommended as the network proxy can execute a man-in-the-middle attack and see your information. Would you let that happen?\",\n\t\"BLOG_BROWSER_NOSANDBOX\": \"You have enabled an option to pass through all APIs of your operating system. This is not recommended as the blog post can do anything as if it were the blog browser program. Would you let that happen?\",\n\t\"NETWORKFS_USAGE\": \"Usage: networkfs <options> [url] [mountpoint]\",\n\t\"NETWORKFS_DESCRIPTION\": \"Mounts a filesystem available over PCOS Network.\",\n\t\"NETWORKFS_NOVERIFY\": \"--no-verification: Don't verify the server's key\",\n\t\"NETWORKFS_KEY\": \"--key=[path]: Path to key for mutual verification\",\n\t\"NETWORKFS_PROTO\": \"This version only supports the netfs:// protocol.\",\n\t\"NETCONFIG_UPDATES\": \"Updates from: \",\n\t\"NETWORK_UPDATES_FIELD\": \"Updates from: %s\",\n\t\"LOCALE_NAME\": \"English\",\n\t\"SETTING_LOCALE_PREFERENCE\": \"Setting locale preference\",\n\t\"LANGUAGE_SELECT\": \"Your language: \",\n\t\"CHANGE_LOCALE\": \"Change language\",\n\t\"MOUNT_EXISTS\": \"Mount already exists\",\n\t\"INSECURE_MODE_MSG\": \"Reduced security!\",\n\t\"MODULE_REQUIRED\": \"The module \\\"%s\\\" is required for this function. Contact the system administrator.\",\n\t\"CREATING_DIRECTORY_STRUCTURE\": \"Creating directory structure\",\n\t\"GENERATING_KERNEL\": \"Generating system kernel\",\n\t\"REGENERATE_KERNEL\": \"Regenerate system kernel\",\n\t\"REGENERATING_KERNEL_FAILED\": \"Failed to regenerate system kernel\",\n\t\"TECHNICAL_LIMITATIONS\": \"This file can't be created due to technical limitations.\",\n\t\"REVIEWING_MIGRATION\": \"Reviewing migration paths\",\n\t\"MIGRATING_USER_PROFILES\": \"Migrating user profiles\",\n\t\"UPDATING_MODCFG\": \"Getting module configuration\",\n\t\"UPDATING_MODULES\": \"Updating modules\",\n\t\"FAILED_TO_UPDATE\": \"Failed to update modules\",\n\t\"UPDATE_COUNTING\": \"Counting updatable modules\",\n\t\"UPDATE_COUNT\": \"%s modules can be updated\",\n\t\"UPDATE_MODCFG\": \"Update module configuration\",\n\t\"INSTALL_ONLINE_MODULE\": \"Install online modules\",\n\t\"REMOVE_MODULES\": \"Remove modules\",\n\t\"MODMGR_PRIVFAIL\": \"Not enough permissions were granted for module management.\",\n\t\"MODMGR_TITLE\": \"Module Manager\",\n\t\"MODMGR_INTENT\": \"Manage and maintain modules on this system\",\n\t\"MANAGING_MODULE\": \"Managing module: %s (%s of %s, %s%)\",\n\t\"MODNAME_CELL\": \"Module name\",\n\t\"MODVER_CELL\": \"Module version\",\n\t\"MODTGT_CELL\": \"Targeted build\",\n\t\"APPLY_CHANGES\": \"Apply changes\",\n\t\"DISCARD_CHANGES\": \"Discard changes\",\n\t\"RELOADING_MODULES\": \"Reloading system modules\",\n\t\"SUCCESSFUL_OP_REBOOT\": \"The process was successfully completed, but you might need to restart to apply some changes.\",\n\t\"REPAIR_OS\": \"Repair OS\",\n\t\"REPAIRING_SYSTEM\": \"Repairing the system...\",\n\t\"REPAIR_FAILED\": \"System repair failed!\",\n\t\"REPAIRING_MODULE\": \"Repairing module: %s (%s of %s, %s%)\",\n\t\"MOUNT_OFFLINE_OS\": \"Mount offline OS\",\n\t\"UMOUNT_OFFLINE_OS\": \"Unmount offline OS\",\n\t\"SWAP_OFFLINE_OS\": \"Swap to offline OS\",\n\t\"SWAPPING_SYSTEMS\": \"Swapping to the system...\",\n\t\"INSTALL_OFFLINE_MODULE\": \"Install offline module\",\n\t\"RESTRICT_PROMPT\": \"Access levels:\\r\\nfull - Full access\\r\\nuser - Regular access (default)\\r\\nro - Read-only access\\r\\nInput access level\",\n\t\"RESTRICT_OPTION\": \"Restricted access\",\n\t\"BREAKOUT_MODULE_NAME\": \"The Breakout game example (from MDN)\",\n\t\"BOOTABLE_MODULE_NAME\": \"Main kernel files\",\n\t\"CORE_MODULE_NAME\": \"Core system files\",\n\t\"DIFF_MODULE_NAME\": \"Difference computing library (by Logan R. Kearsley)\",\n\t\"INSTFILES_MODULE_NAME\": \"Installer environment files\",\n\t\"KEYS_MODULE_NAME\": \"PCsoft cryptographic keys\",\n\t\"MULTIMEDIA_MODULE_NAME\": \"Multimedia support\",\n\t\"ICONS_MODULE_NAME\": \"Default PCOS 3 icons\",\n\t\"SOUNDS_MODULE_NAME\": \"Default PCOS 3 sound effects\",\n\t\"WP_MODULE_NAME\": \"Default PCOS 3 wallpapers\",\n\t\"TERMDISK_MODULE_NAME\": \"Disk management CLI tools\",\n\t\"TERMNET_MODULE_NAME\": \"Networking CLI tools\",\n\t\"TERMUSER_MODULE_NAME\": \"User management CLI tools\",\n\t\"TWNACL_MODULE_NAME\": \"TweetNaCl.js cryptographic library\",\n\t\"XTERM_MODULE_NAME\": \"xterm.js terminal support library (by The xterm.js authors)\",\n\t\"REINVENTORIZE_MODULES\": \"Reinventorize modules\",\n\t\"REINVENTORIZING_MODULES\": \"Reinventorizing modules...\",\n\t\"MODTRUST_CELL\": \"Trusted by\",\n\t\"UNSIGNED_CELL\": \"NOBODY\",\n\t\"ROOT_KEY_CELL\": \"PCsoft root trust authority\",\n\t\"USER_PREFERENCES\": \"My preferences\",\n\t\"USER_PREFS_ERROR\": \"You can't change your preferences.\",\n\t\"WALLPAPER_PATH\": \"Wallpaper path: \",\n\t\"UPDATE_PREFERENCES\": \"Update preferences\",\n\t\"USER_PREFS_UPDATED\": \"Preferences were updated. Some programs might not update right away.\",\n\t\"USER_PREFS_UPDATED_PARTIAL\": \"Not all preferences could be updated right away. Log in again to see the changes.\",\n\t\"PREF_UPDATE_FAILED\": \"Not all preferences could be updated.\"\n};\n"},"buildInfo":{"for":"1580","version":1580,"when":1766238578400,"signer":"moduleSigner","critical":false,"bootOrder":"50","commonName":"locale-en","friendlyName":"English language support","signature":"c2d5bea3ce871b218572aa7f5edd4c7ef7fe6fadb6efc2bff0522720679418d5624e3f43c7e7447fefc4c6ea0d3804786f9ed9b88254fcd3f21eacf4b8fbbb04"}},"50-locale-ru.fs":{"backend":{"files":{"boot":{"06-localesappend-ru.js":"71dd735564c84d03fadafa5a518028b8a948ccb21eec7c2741afa660eb06407ed7488946a9e4e65cbaae846c9529cef7f43e16b9a7d13fbc4fa8ea129a4c1a77"}},"permissions":{"boot/06-localesappend-ru.js":{"world":"rx"},"boot/":{"world":"rx"},"":{"world":"rx"}}},"files":{"71dd735564c84d03fadafa5a518028b8a948ccb21eec7c2741afa660eb06407ed7488946a9e4e65cbaae846c9529cef7f43e16b9a7d13fbc4fa8ea129a4c1a77":"modules.locales.ru = {\n\t\"UNTITLED_APP\": \"Безымянная программа\",\n\t\"PERMISSION_DENIED\": \"Отказано в доступе\",\n\t\"MORE_PERMISSION_DENIED\": \"Недостаточно прав для запуска этой программы.\",\n\t\"COMPATIBILITY_ISSUE_TITLE\": \"Проблема с совместимостью\",\n\t\"COMPATIBILITY_ISSUE\": \"Эта программа не может запускаться на этом компьютере как задача. Проверьте, есть ли у программы режим \\\"isolatable\\\".\",\n\t\"APP_STARTUP_CRASH_TITLE\": \"Что-то пошло не так\",\n\t\"APP_STARTUP_CRASH\": \"Системе не удалось запустить эту программу.\",\n\t\"JS_TERMINAL\": \"Терминал JavaScript\",\n\t\"TERMINAL_INVITATION\": \"PCOS 3, сборка %s\",\n\t\"PCOS_RESTARTING\": \"PCOS перезагружается. %s\",\n\t\"PLEASE_WAIT\": \"Пожалуйста, подождите.\",\n\t\"POLITE_CLOSE_SIGNAL\": \"Отправка сигнала закрытия.\",\n\t\"ABRUPT_CLOSE_SIGNAL\": \"Отправка аварийного закрытия.\",\n\t\"UNMOUNTING_MOUNTS\": \"Размонтирование точек монтирования.\",\n\t\"SAFE_TO_CLOSE\": \"Теперь эту вкладку можно закрыть.\",\n\t\"RESTART_BUTTON\": \"Перезапустить\",\n\t\"RESTARTING\": \"Выполняется перезагрузка.\",\n\t\"INSTALL_PCOS\": \"Установить PCOS\",\n\t\"INSTALLER_TITLE\": \"Установщик PCOS 3\",\n\t\"CLOSE_INSTALLER_CONFIRMATION\": \"Вы уверены, что хотите остановить установку? Этот компьютер перезапустится.\",\n\t\"YES\": \"Да\",\n\t\"NO\": \"Нет\",\n\t\"INSTALLER_INVITATION\": \"Вы устанавливаете PCOS 3 сборки %s на этом компьютере.\",\n\t\"INSTALL_BUTTON\": \"Установить\",\n\t\"LIVE_BUTTON\": \"Попробовать\",\n\t\"INSTALLER_PARTITIONING\": \"Выберите разделы загрузки и данных, которые вы хотите использовать.\",\n\t\"PARTITIONING_USE\": \"Использовать разделы\",\n\t\"PARTITION_DATA\": \"Раздел данных\",\n\t\"PARTITION_BOOT\": \"Раздел загрузки\",\n\t\"FORMAT_DATA\": \"Форматировать в PCFS\",\n\t\"DATA_INPUT_ALERT\": \"Введите имя раздела данных.\",\n\t\"PROMPT_PARTITION_TABLE\": \"Этот диск, кажется, не содержит таблицу разделов. Вы хотите вставить таблицу разделов?\",\n\t\"CONFIRM_PARTITION_ERASE\": \"Все данные на этом разделе будут удалены. Продолжить?\",\n\t\"BOOT_INPUT_ALERT\": \"Введите имя раздела загрузки.\",\n\t\"CANNOT_FIND_PARTITION\": \"Не удаётся найти раздел диска. Попробуйте форматировать раздел данных в PCFS.\",\n\t\"PCFS_DETECTION_ERROR\": \"Раздел данных, кажется, не содержит PCFS. Вы хотите использовать его?\",\n\t\"INSTALLING_PCOS\": \"Установка PCOS: %s\",\n\t\"CREATING_BOOT_PARTITION\": \"Создание раздела загрузки\",\n\t\"MOUNTING_DATA_PARTITION\": \"Монтирование раздела данных как 'target'\",\n\t\"CHANGING_ROOT_PERMISSIONS\": \"Изменение разрешений /\",\n\t\"COPYING_FOLDERS\": \"Копирование каталогов\",\n\t\"PATCHING_FS\": \"Изменение для монтирования раздела данных\",\n\t\"INSTALLATION_SUCCESSFUL\": \"Установка успешна. Закройте окно для перезагрузки.\",\n\t\"INSTALLATION_FAILED\": \"Установка не удалась. Попробуйте ещё раз. Закройте окно для перезагрузки.\",\n\t\"SHORT_DAYS\": \"%sдн\",\n\t\"SHORT_HOURS\": \"%sч\",\n\t\"SHORT_MINUTES\": \"%sмин\",\n\t\"SHORT_SECONDS\": \"%sс\",\n\t\"SHORT_MILLISECONDS\": \"%sмс\",\n\t\"SHORT_TERABYTES\": \"%sТБ\",\n\t\"SHORT_GIGABYTES\": \"%sГБ\",\n\t\"SHORT_MEGABYTES\": \"%sМБ\",\n\t\"SHORT_KILOBYTES\": \"%sКБ\",\n\t\"SHORT_BYTES\": \"%sБ\",\n\t\"AUTH_FAILED_NEW\": \"Аутентификация не удалась, пожалуйста, используйте новую сессию!\",\n\t\"AUTH_SUCCESS\": \"Аутентификация успешна!\",\n\t\"AUTH_FAILED\": \"Аутентификация не удалась.\",\n\t\"PLEASE_WAIT_TIME\": \"Пожалуйста, подождите %s\",\n\t\"REPORTING_LOGON\": \"Сообщаю о входе в систему серверу...\",\n\t\"TOTP_PC_PROMPT\": \"Введите код TOTP-PC\",\n\t\"TOTP_PROMPT\": \"Введите код TOTP\",\n\t\"ACCESS_NOT_SETUP\": \"Доступ к данному пользователю не настроен\",\n\t\"PASSWORD_PROMPT\": \"Введите пароль\",\n\t\"ENTER_BUTTON\": \"Ввод\",\n\t\"USERNAME_PROMPT\": \"Введите имя пользователя\",\n\t\"USERNAME\": \"Имя пользователя\",\n\t\"ACCESS_FN_FAIL\": \"Нет такого пользователя.\",\n\t\"RESPONSE_PLACEHOLDER\": \"Ответ...\",\n\t\"START_MENU_BTN\": \"Пуск\",\n\t\"START_MENU\": \"Меню \\\"Пуск\\\"\",\n\t\"LOG_IN_INVITATION\": \"Войти в систему\",\n\t\"LOG_OUT_BUTTON\": \"Выйти (%s)\",\n\t\"LOCK_BUTTON\": \"Заблокировать\",\n\t\"TURN_OFF_BUTTON\": \"Выключить\",\n\t\"PASSWORD\": \"Пароль\",\n\t\"LET_CREATE_ACCOUNT\": \"Давайте создадим вашу учётную запись.\",\n\t\"CREATE\": \"Создать\",\n\t\"PASSWORD_INPUT_ALERT\": \"Введите пароль.\",\n\t\"CREATING_USER_STRUCTURE\": \"Создание структуры пользователей\",\n\t\"CREATING_USER\": \"Создание пользователя\",\n\t\"INSTALLING_WP2U\": \"Установка фона на пользователя\",\n\t\"CONFIRM\": \"Подтвердить\",\n\t\"RIGHT_REVIEW\": \"Давайте рассмотрим ваши права.\",\n\t\"RIGHT_REVIEW_BTN\": \"Принять лицензию\",\n\t\"DARK_MODE\": \"Тёмная тема\",\n\t\"INSTALLING_DARKMODE\": \"Установка предпочтения тёмной темы\",\n\t\"CREATING_USER_HOME\": \"Создание домашнего каталога пользователя\",\n\t\"PROVISIONED_PREFERENCE\": \"Эта настройка управляется системным администратором.\",\n\t\"USERNAME_EXISTS\": \"Этот пользователь уже существует в системе.\",\n\t\"VIDEO_PLAYER\": \"Видеопроигрыватель\",\n\t\"INACCESSIBLE_FILE\": \"%s недоступен. Убедитесь, что у вас есть разрешения на доступ к нему, и что объект существует.\",\n\t\"FILE_NOT_SPECIFIED\": \"Файл не указан.\",\n\t\"PICTURE_VIEWER\": \"Просмотр изображений\",\n\t\"API_TEST_TERM\": \"Терминал API-разработчика\",\n\t\"HELP_TERMINAL_APITEST\": \"help - Показать справочное меню\\r\\nclear - Очистить терминал\\r\\njs_ree - Запустить код JavaScript\\r\\n--- ЭКСПОРТИРОВАННЫЕ ИПП СОВ ---\\r\\n\",\n\t\"TERM_COMMAND_NOT_FOUND\": \"%s: команда не найдена\",\n\t\"FILE_EXPLORER\": \"Проводник\",\n\t\"GRANT_FEXP_PERM\": \"Пожалуйста, предоставьте разрешения на чтение файловых структур и просмотр списка разделов.\",\n\t\"GRANT_PERM\": \"Предоставить разрешения\",\n\t\"GRANT_FEXP_PERM_ADM\": \"Свяжитесь с администратором, чтобы предоставить разрешения на чтение файловых структур и просмотр списка разделов. (FS_READ, FS_LIST_PARTITIONS)\",\n\t\"GRANT_FEXP_PERM_USR\": \"Пожалуйста, предоставьте разрешения на чтение файловых структур и просмотр списка разделов используя иную учётную запись.\",\n\t\"BROWSE_FEXP\": \"Просмотр\",\n\t\"SPACE_SHOWER\": \"Хранение в \\\"%s\\\": использовано %s из %s (%s%)\",\n\t\"FILE_STRUCT_BROWSE_FAIL\": \"Невозможно просмотреть структуру:\\n%s\",\n\t\"UNKNOWN_FS_STRUCT\": \"Неизвестная файловая структура \\\"%s\\\"\",\n\t\"UNKNOWN_FILE_TYPE\": \"Это неизвестный тип файла.\",\n\t\"TMGR_PERMISSION\": \"Диспетчеру задач не разрешено запускаться при этих условиях. Свяжитесь с системным администратором\\nТребуемые разрешения: %s\",\n\t\"TASK_MANAGER\": \"Диспетчер задач\",\n\t\"BASENAME_TASK\": \"Имя\",\n\t\"USER_TASK\": \"Пользователь\",\n\t\"TERMINATE_TASK\": \"Завершить\",\n\t\"FULL_PATH_TASK\": \"Полный путь\",\n\t\"ARGUMENTS_TASK\": \"Параметры\",\n\t\"LOGGING_OUT\": \"Выход из системы...\",\n\t\"PANIC_LINE1\": \"При использовании операционной системы была обнаружена критическая ошибка. Стабильность системы под угрозой.\",\n\t\"PANIC_LINE2\": \"Код ошибки: %s\",\n\t\"PANIC_UNSPECIFIED_ERROR\": \"НЕУКАЗАННАЯ_ОШИБКА\",\n\t\"PROBLEMATIC_COMPONENT\": \"Проблемный компонент: %s\",\n\t\"PROBLEMATIC_PARAMS\": \"Проблемные параметры: %s\",\n\t\"PROBLEMATIC_JS\": \"Проблемный JavaScript: %s: %s\",\n\t\"PANIC_LINE3\": \"Если вы видите эту ошибку в первый раз, попробуйте перезагрузить систему.\",\n\t\"PANIC_LINE4\": \"Если вы видите эту ошибку ещё раз, это значит, что что-то не так с системой.\",\n\t\"PANIC_LINE5\": \"Вы можете попытаться восстановить систему используя установщик для восстановления или переустановки PCOS 3.\",\n\t\"PANIC_LINE6\": \"Далее выполняется процедура завершения работы:\",\n\t\"PANIC_TASK_KILLED\": \"задача:%s: убита\",\n\t\"PANIC_MOUNT_UNMOUNTED\": \"точка:%s: размонтирована\",\n\t\"PANIC_MOUNT_FAILED\": \"точка:%s: %s: %s\",\n\t\"SHORT_YEARS\": \"%sг\",\n\t\"SHORT_MONTHS\": \"%sмес\",\n\t\"SYSADMIN_TOOLS_TITLE\": \"Утилиты для сисадминов\",\n\t\"SYSADMIN_TOOLS_PRIVFAIL\": \"Вы не являетесь системным администратором.\",\n\t\"FSCK_BUTTON\": \"Восстановить потерянные файлы\",\n\t\"SWIPE_BUTTON\": \"Безопасно удалить систему\",\n\t\"SETTING_FSCK_FLAG\": \"Создание файла .fsck...\",\n\t\"SETTING_FSCK_FLAG_FAILED\": \"Не удалось создать файл .fsck.\",\n\t\"WIPING_SYSTEM\": \"Безопасное удаление системы...\",\n\t\"WIPING_SYSTEM_FAILED\": \"Не удалось безопасно удалить систему.\",\n\t\"WORKING_HOURS_UNMET\": \"Вы попытались войти в систему вне рабочего времени. Повторите попытку позже.\",\n\t\"NETCONFIG_TITLE\": \"Конфигурация PCOS Network\",\n\t\"NETCONFIG_DENY\": \"Недостаточно разрешений для конфигурации PCOS Network.\",\n\t\"NETCONFIG_URLF\": \"URL прокси: \",\n\t\"NETCONFIG_UC\": \"Изменяемое: \",\n\t\"NETCONFIG_SAVE\": \"Сохранить конфиг.\",\n\t\"NETCONFIG_PREDICT\": \"Предсказать адрес\",\n\t\"EMPTY_STATUSBAR\": \"Статус\",\n\t\"NETCONFIG_SAVE_OK\": \"Конфигурация успешно сохранена\",\n\t\"NETCONFIG_SAVE_FAIL\": \"Конфигурация НЕ сохранена!\",\n\t\"PCOS_STARTING\": \"PCOS приступает к работе...\",\n\t\"FILE_PICKER\": \"Выбор файла\",\n\t\"TEXT_EDITOR\": \"Текстовый редактор\",\n\t\"LOAD_BTN\": \"Загрузить\",\n\t\"SAVE_BTN\": \"Сохранить\",\n\t\"NETCONFIG_SYSIDM\": \"System ID недоступен\",\n\t\"NO_SAVE_IN_MTN\": \"Нельзя выполнять сохранение в папке монтирований.\",\n\t\"INSTALLING_WP2L\": \"Установка фона на экран блокировки\",\n\t\"EXIT\": \"Выйти\",\n\t\"REMOVE_BTN\": \"Удалить\",\n\t\"UNMOUNT_BTN\": \"Размонтировать\",\n\t\"INSTALLING_DARKMODE2L\": \"Установка предпочтения тёмной темы на экран блокировки\",\n\t\"MESSAGE_ENTER\": \"Введите сообщение для отображения\",\n\t\"TIMEOUT_FIELD\": \"Ожидание (мс)\",\n\t\"SECRET_FIELD_TXT\": \"Секретное значение (текст)\",\n\t\"SECRET_FIELD_HEX\": \"Секретное значение (шестнадцатиричное)\",\n\t\"REGENERATE\": \"Регенерировать\",\n\t\"START_TIME_FIELD\": \"Время начала\",\n\t\"END_TIME_FIELD\": \"Время конца\",\n\t\"PBKDF2_OPTION\": \"PBKDF2 (Пароль)\",\n\t\"INFORMATIVE_MESSAGE_OPTION\": \"Информативное сообщение\",\n\t\"INFORMATIVE_MESSAGE_DENY_OPTION\": \"Информативное сообщение (отказ)\",\n\t\"TIMEOUT_OPTION\": \"Ожидание\",\n\t\"TIMEOUT_DENY_OPTION\": \"Ожидание (отказ)\",\n\t\"SERVER_REPORT_OPTION\": \"Сообщение серверу\",\n\t\"PCTOTP_OPTION\": \"Интерпретация TOTP от PC\",\n\t\"RFCTOTP_OPTION\": \"TOTP по RFC\",\n\t\"WORKING_HOURS_OPTION\": \"График работы\",\n\t\"PERSONAL_SECURITY_TITLE\": \"Личная безопасность\",\n\t\"PERSONAL_SECURITY_DENY\": \"Было предоставлено недостаточно привилегий для запуска Личной безопасности.\",\n\t\"ADD_BTN\": \"Добавить\",\n\t\"OS_LOCALE\": \"ru\",\n\t\"SYSTEM_SECURITY_TITLE\": \"Безопасность системы\",\n\t\"SYSTEM_SECURITY_DENY\": \"Было предоставлено недостаточно привилегий для запуска Безопасности системы.\",\n\t\"EDIT\": \"Редактировать\",\n\t\"USER_GROUPS\": \"Группы\",\n\t\"USER_HOMEDIR\": \"Домашний каталог\",\n\t\"REMOVE_USER_WITH_HD\": \"Удалить с домашним каталогом\",\n\t\"CREATE_HD\": \"Создать домашний каталог\",\n\t\"CREATING_HD_OK\": \"Домашний каталог успешно создан.\",\n\t\"CREATING_HD_FAIL\": \"Не удалось создать домашний каталог.\",\n\t\"SIGNATURE_VERIFICATION_FAILED\": \"Эта программа утверждает, что ей доверяет %s, но системе не удалось проверить это утверждение.\",\n\t\"UNKNOWN_PLACEHOLDER\": \"<Неизвестно>\",\n\t\"NO_APP_ALLOWLIST\": \"Системный администратор требует, чтобы у программ был белый список разрешений, но у этого программы нет этого списка.\",\n\t\"DISCARD_BUTTON\": \"Удалить потерянные файлы\",\n\t\"MOUNTPOINT\": \"Точка монтирования\",\n\t\"GENERATE_PROMPT\": \"Сгенерировать?\",\n\t\"MOUNT_BUTTON\": \"Монтировать\",\n\t\"NEW_DIR_NAME\": \"Имя нового каталога\",\n\t\"MKDIR_BUTTON\": \"Создать каталог\",\n\t\"CHOWN_BUTTON\": \"Сменить владельца\",\n\t\"CHGRP_BUTTON\": \"Сменить группу\",\n\t\"CHMOD_BUTTON\": \"Сменить разрешения\",\n\t\"CLIPBOARD_COPY\": \"Копировать\",\n\t\"CLIPBOARD_CUT\": \"Вырезать\",\n\t\"CLIPBOARD_PASTE\": \"Вставить\",\n\t\"CLIPBOARD_SOURCE_GONE\": \"Источник больше не существует или не файл.\",\n\t\"CLIPBOARD_CONFLICT\": \"В папке назначения уже есть файл или каталог с таким именем.\",\n\t\"SAFE_MODE_MSG\": \"Безопасный режим\",\n\t\"APP_OR_KEY_SIGNATURE_VERIFICATION_FAILED\": \"Проверка доверия для программы не удалась.\",\n\t\"NO_SUCH_DEVICE\": \"Нет такого устройства\",\n\t\"READ_ONLY_BMGR\": \"Записи ограничены загрузчиком ОС.\",\n\t\"READ_ONLY_DEV\": \"Устройство только для чтения\",\n\t\"NO_DIRECTORY_SUPPORT\": \"Устройство не поддерживает каталоги\",\n\t\"IS_A_DIR\": \"Является каталогом\",\n\t\"NO_SUCH_FILE\": \"Нет такого файла\",\n\t\"NO_SUCH_DIR\": \"Нет такого каталога\",\n\t\"NO_SUCH_FILE_DIR\": \"Нет такого файла или каталога\",\n\t\"NON_EMPTY_DIR\": \"Непустой каталог\",\n\t\"IS_A_FILE\": \"Является файлом\",\n\t\"DIR_EXISTS\": \"Каталог уже существует\",\n\t\"FS_ACTION_FAILED\": \"Не удалось выполнить это действие с файловой системой.\",\n\t\"UNAUTHORIZED_ACTION\": \"У программы нет прав на это действие.\",\n\t\"CREATION_CHECK_FAILED\": \"Не удалось проверить, создаётся ли этот объект.\",\n\t\"PERMISSION_CHANGE_FAILED\": \"Не удалось изменить разрешения для этого объекта.\",\n\t\"UPDATE_BUTTON\": \"Обновить ОС\",\n\t\"TOGGLE_HIDDEN_FILES\": \"Скрыть/показать файлы\",\n\t\"AUTORUN_NECESSITIES_FAILED\": \"Не удалось запустить один из ваших файлов автозапуска. Система не позволит выполнить вход.\",\n\t\"CRYPTO_TOOLS_TITLE\": \"Утилиты для криптографии\",\n\t\"CRYPTO_TOOLS_NOPERM\": \"Недостаточно прав для использования утилит для криптографии.\",\n\t\"CRYPTO_RNG\": \"Случайная генерация\",\n\t\"CRYPTO_HASH\": \"Хэширование\",\n\t\"CRYPTO_KEYGEN\": \"Генерация ключей\",\n\t\"CRYPTO_ENCRYPT\": \"Шифрование\",\n\t\"CRYPTO_DECRYPT\": \"Расшифровка\",\n\t\"CRYPTO_SIGN\": \"Подписывание\",\n\t\"CRYPTO_VERIFY\": \"Проверка подписи\",\n\t\"CRYPTO_DERIVEBITS\": \"Преобразование\",\n\t\"GENERATE\": \"Генерировать\",\n\t\"RAW_HEX_DATA\": \"Прямые данные (шестнадцатиричные)\",\n\t\"CRYPTO_HASH_FIELD\": \"Алгоритм хэширования: \",\n\t\"CRYPTO_PLAINTEXT_FIELD\": \"Простой текст: \",\n\t\"ALGORITHM_FIELD\": \"Алгоритм: \",\n\t\"LENGTH_FIELD\": \"Длина: \",\n\t\"CRYPTO_NC_FIELD\": \"Имя кривой: \",\n\t\"IMPORT_AS_FIELD\": \"Импортировать как: \",\n\t\"CRYPTO_KEY_FIELD\": \"Ключ: \",\n\t\"CRYPTO_CIPHERTEXT_FIELD\": \"Шифр (шестнадцатиричный): \",\n\t\"CRYPTO_SIGNATURE_FIELD\": \"Подпись (шестнадцатиричная): \",\n\t\"CRYPTO_KEYGEN_MSG\": \"Генерация ключа (ключей)...\",\n\t\"CRYPTO_KEYGEN_SYMM\": \"Является симметричным типом ключа\",\n\t\"CRYPTO_KEYGEN_EXPFAIL\": \"Не удалось экспортировать, проверьте настройки экспорта\",\n\t\"CRYPTO_RNGOUT_FIELD\": \"Случайные числа (шестнадцатиричные): \",\n\t\"CRYPTO_KEYGEN_ACTION\": \"Сгенерировать ключ(и)\",\n\t\"CRYPTO_HASH_ACTION\": \"Хэшировать\",\n\t\"CRYPTO_ENCRYPT_ACTION\": \"Зашифровать\",\n\t\"CRYPTO_DECRYPT_ACTION\": \"Расшифровать\",\n\t\"CRYPTO_SIGN_ACTION\": \"Подписать\",\n\t\"CRYPTO_VERIFY_ACTION\": \"Проверить подпись\",\n\t\"CRYPTO_DERIVEBITS_ACTION\": \"Преобразовать\",\n\t\"CRYPTO_PUBKEY_FIELD\": \"Открытый ключ: \",\n\t\"CRYPTO_PRIVKEY_FIELD\": \"Закрытый ключ: \",\n\t\"CRYPTO_BASEKEY_FIELD\": \"Базовый ключ: \",\n\t\"CRYPTO_HASHOUT_FIELD\": \"Значение хэша (шестнадцатиричное): \",\n\t\"CRYPTO_MODLEN_FIELD\": \"Длина модуля: \",\n\t\"CRYPTO_PUBEXP_FIELD\": \"Открытая экспонента (шестнадцатиричная): \",\n\t\"EXPORT_AS_FIELD\": \"Экспортировать как: \",\n\t\"CRYPTO_KEYUSE_FIELD\": \"Использования ключа:\",\n\t\"CRYPTO_PLAINTEXTAS_FIELD\": \"Обработать простой текст как: \",\n\t\"CRYPTO_IV_FIELD\": \"Вектор инициализации (шестнадцатиричный): \",\n\t\"CRYPTO_CTR_FIELD\": \"Счётчик (шестнадцатиричный): \",\n\t\"CRYPTO_VERIFIED_CHECKBOX\": \"Проверено успешно\",\n\t\"CRYPTO_SALT_FIELD\": \"Соль (шестнадцатиричная): \",\n\t\"CRYPTO_DERIVEOUT_FIELD\": \"Преобразование (шестнадцатиричное): \",\n\t\"CRYPTO_ITERATIONS_FIELD\": \"Итераций: \",\n\t\"PATH_INCLUDES_EMPTY\": \"В указанном пути есть объект с пустым именем.\",\n\t\"BASIC_CURL_USAGE\": \"Использование: basiccurl [источник] [выход]\",\n\t\"BASIC_CURL_DESCRIPTION\": \"Скачивает указаный источник и записывает его в указанный выход.\",\n\t\"NO_ARGUMENTS\": \"Параметры не указаны\",\n\t\"CAT_USAGE\": \"Использование: cat [файл1] <файл2> <файл3> ... <файлN>\",\n\t\"CAT_DESCRIPTION\": \"Складывает эти файлы и выводит их в выход консоли\",\n\t\"CHGRP_USAGE\": \"Использование: chgrp [группа] [файл]\",\n\t\"CHGRP_DESCRIPTION\": \"Изменяет владеющую группу файлы\",\n\t\"CHMOD_USAGE\": \"Использование: chmod [режим] [файл]\",\n\t\"CHMOD_DESCRIPTION\": \"Задаёт, что могут делать все с файлом.\",\n\t\"CHMOD_MODE_DESCRIPTION\": \"[режим] может состоять из символов r (Read, чтение), w (Write, запись) и x (eXecute, исполнение).\",\n\t\"CHMOD_MODE_CONVERT\": \"Конвертация чисел [режима] в строку: 0 - \\\"\\\", 1 - \\\"x\\\", 2 - \\\"w\\\", 3 - \\\"wx\\\", 4 - \\\"r\\\", 5 - \\\"rx\\\", 6 - \\\"rw\\\", 7 - \\\"rwx\\\"\",\n\t\"CHOWN_USAGE\": \"Использование: chown [пользователь] [файл]\",\n\t\"CHOWN_DESCRIPTION\": \"Изменяет владеющего пользователя файлы\",\n\t\"CP_USAGE\": \"Использование: cp <параметры> [источник] [назначение]\",\n\t\"CP_DESCRIPTION\": \"Копирует файлы или каталоги в указанное назначение.\",\n\t\"OPT_RECURSIVE_DESCRIPTION\": \"--recursive: запускать на каталогах\",\n\t\"OPT_FORCE_DESCRIPTION\": \"--force: не выходить сразу при ошибке\",\n\t\"ARGUMENT_COUNT_MISMATCH\": \"Слишком много или слишком мало аргументов\",\n\t\"DF_HEADER\": \"Хранилище\\tРазмер\\tИспользовано\\tДост\\tИспользовано%\",\n\t\"LS_USAGE\": \"Использование: ls [каталог]\",\n\t\"LS_DESCRIPTION\": \"Отображает содержимое указанного каталога.\",\n\t\"LS_MOUNTPOINT_LIST\": \"У вас следующие точки монтирования: \",\n\t\"MOUNTPOINT_SYSTEM\": \"системная\",\n\t\"PASSWD_NEW_PROMPT\": \"Установка нового пароля для вашей учётной записи.\",\n\t\"PASSWD_2FACTOR_LOSS_WARN\": \"Раннее установленные дополнительные факторы будут удалены.\",\n\t\"PASSWD_PROMPT\": \"Новый пароль: \",\n\t\"PASSWD_CONFIRM_PROMPT\": \"Повторите пароль: \",\n\t\"PASSWD_FEEDBACK\": \"Задан новый пароль\",\n\t\"PASSWD_MISMATCH\": \"Пароли не совпадают.\",\n\t\"PING_USAGE\": \"Использование: ping <--internet> [адресСети]\",\n\t\"PING_DESCRIPTION\": \"Отправляет запрос на указанный адрес для проверки его доступности.\",\n\t\"PING_INTERNET_OPTION\": \"--internet: отправить ping в Интернет, а не в PCOS Network\",\n\t\"PIVOT_ROOT_USAGE\": \"Использование: pivot_root [точкаМонтирования]\",\n\t\"PIVOT_ROOT_DESCRIPTION\": \"Устанавливает указанную точку монтирования как системную для всех программ.\",\n\t\"REAL_TERMINAL_NAME\": \"Терминал\",\n\t\"REAL_TERMINAL_BUILTIN_LIST\": \"Встроенные команды:\",\n\t\"REAL_TERMINAL_HELP_USEDESC\": \"help - Показать список, использование и описание встроенных команд.\",\n\t\"REAL_TERMINAL_CLEAR_USEDESC\": \"clear - Стереть всё, что сейчас в терминале.\",\n\t\"REAL_TERMINAL_SUGRAPH_USEDESC\": \"sugraph <нужноеИмя> - Переключить пользователя терминала с помощью графического интерфейса.\",\n\t\"REAL_TERMINAL_SU_USEDESC\": \"su <нужноеИмя> - Переключить пользователя терминала.\",\n\t\"REAL_TERMINAL_GRAPHIC_USEDESC\": \"graphic <булево> - Включить или выключить запуск новых программ вне фонового режима.\",\n\t\"REAL_TERMINAL_EXIT_USEDESC\": \"exit - Выйти из терминала.\",\n\t\"REAL_TERMINAL_LOGON_REQUIRED\": \"(внутреннее): Перед запуском программы необходимо запустить sugraph %s.\",\n\t\"RM_USAGE\": \"Использование: rm <параметры> [файл]\",\n\t\"RM_DESCRIPTION\": \"Удаляет указанный файл или каталог.\",\n\t\"RKL_USAGE\": \"Использование: runKlvlCode [файлСКодом]\",\n\t\"RKL_DESCRIPTION\": \"Запускает указанный файл с кодом на уровне ядра.\",\n\t\"WRITE_USAGE\": \"Использование: write [файл] [данные]\",\n\t\"WRITE_DESCRIPTION\": \"Записывает данные в указанный файл.\",\n\t\"CP_PERMISSIONS_OPTION\": \"--permissions: скопировать разрешения файлов\",\n\t\"REAL_TERMINAL_DEFAULT_PATH_FIELD\": \"Путь по умолчанию: %s\",\n\t\"REAL_TERMINAL_PUSHPATH_USEDESC\": \"pushpath [путь] - Добавить новый путь для просмотра команд.\",\n\t\"REAL_TERMINAL_RESETPATH_USEDESC\": \"resetpath - Сбросить список путей для просмотра команд к значению пути по умолчанию.\",\n\t\"REAL_TERMINAL_LSPATH_USEDESC\": \"lspath - Просмотреть текущие пути для просмотра команд и путь по умолчанию.\",\n\t\"MKDIR_USAGE\": \"Использование: mkdir [каталог]\",\n\t\"MKDIR_DESCRIPTION\": \"Создаёт новый каталог в указанном пути.\",\n\t\"NEXT\": \"Далее\",\n\t\"DESCRIBE_TEMPLATE\": \"Программа: %s (%s)\\nНамерение: %s\",\n\t\"EXTRA_DESCRIBE_TEMPLATE\": \"Программа: %s (%s)\\nПараметры: %s\\nНамерение: %s\",\n\t\"DECLINE\": \"Отклонить\",\n\t\"ACCESS_REQUEST_TITLE\": \"Запрос доступа\",\n\t\"REAL_TERMINAL_INTENT\": \"Запуск команд с вашими разрешениями\",\n\t\"PERSONAL_SECURITY_INTENT\": \"Управлять вашими настройками безопасности\",\n\t\"FILE_EXPLORER_INTENT\": \"Запускать программы и открывать файлы\",\n\t\"FILE_EXPLORER_FULL_INTENT\": \"Просматривать файлы, запускать программы и открывать файлы\",\n\t\"CRYPTO_TOOLS_INTENT\": \"Выполнять криптографические операции\",\n\t\"SYSTEM_SECURITY_INTENT\": \"Управление настройками учётных записей по всей системе\",\n\t\"FORMAT_USAGE\": \"Использование: format [тип_фс] [раздел] <перезапись>\",\n\t\"FORMAT_DESCRIPTION\": \"Готовит указанный раздел к использованию.\",\n\t\"FORMAT_FSTYPE\": \"Типы файловых систем: pcfs (соответствует точке монтирования PCFSiDBMount), pcfs_crypt (PCFSiDBAESCryptMount), pcfs_crypt_monokey (PCFSiDBAESCryptMount), pcfs_crypt_filetable_monokey (PCFSiDBAESCryptMount), pcbm:<раздел_данных> (как код загрузочного раздела), null (УДАЛИТЬ раздел)\",\n\t\"FORMAT_OVERWRITE_WARN\": \"Раздел уже содержит данные. Установите параметр перезаписи равным 'overwrite' для продолжения в любом случае. В таком случае ВСЕ ДАННЫЕ НА РАЗДЕЛЕ МОГУТ БЫТЬ УДАЛЕНЫ.\",\n\t\"FORMAT_UNKNOWN_FSTYPE\": \"Неизвестное целевое форматирование\",\n\t\"LLDA_USAGE\": \"Использование: llda_tool [действие] [параметры]\",\n\t\"LLDA_ACTION_EXPORT\": \"действие export: [раздел ввода] [файл вывода]\",\n\t\"LLDA_ACTION_IMPORT\": \"действие import: [файл ввода] [раздел вывода]\",\n\t\"LLDA_ACTION_IMPORTSTRING\": \"действие importstring: [файл ввода] [раздел вывода]\",\n\t\"LLDA_ACTION_COPY\": \"действие copy: [раздел ввода] [раздел вывода]\",\n\t\"LLDA_ACTION_REMOVE\": \"действие remove: [раздел]\",\n\t\"LLDA_ACTION_LIST\": \"действие list\",\n\t\"LLDA_DISCLAIMER\": \"При использовании утилиты можно столкнуться с ПОТЕРЕЙ ДАННЫХ!\",\n\t\"LLDA_UNKNOWN_ACTION\": \"Неизвестное действие\",\n\t\"INITDISK_OVERWRITE_WARN\": \"Системный диск уже сожержит таблицу разделов. Установите параметр перезаписи равным 'overwrite' для продолжения в любом случае. В таком случае ВСЕ ДАННЫЕ НА ДИСКЕ МОГУТ БЫТЬ УДАЛЕНЫ.\",\n\t\"INITDISK_USAGE\": \"Использование: initdisk [что угодно] <перезапись>\",\n\t\"INITDISK_DESCRIPTION\": \"Готовит системный диск к использованию.\",\n\t\"MOUNT_USAGE\": \"Использование: mount [параметры] [тип_фс] [точка_монтирования]\",\n\t\"MOUNT_DESCRIPTION\": \"Монтирует файловую систему.\",\n\t\"MOUNT_KNOWN_FS\": \"Известные типы файловых систем: %s\",\n\t\"MOUNT_KNOWN_PPART\": \"--partition=[разделДанных] - Указать раздел данных\",\n\t\"MOUNT_KNOWN_PINPA\": \"--interactivePassword - Интерактивно спрашивать пароль\",\n\t\"MOUNT_KNOWN_PPASS\": \"--password=[пароль] - Указать пароль\",\n\t\"MOUNT_KNOWN_PKEY\": \"--key=[прямойКлюч] - Указать ключ шифрования\",\n\t\"MOUNT_KNOWN_PTYPE\": \"--type=[тип] - Для ramMount, укажите type=run для авто-создания /run\",\n\t\"MOUNT_KNOWN_PURL\": \"--url=[URL] - Указать URL\",\n\t\"MOUNT_KNOWN_PINPI\": \"--inputPipeId=[идКанала] - Указать канал ввода\",\n\t\"MOUNT_KNOWN_POUPI\": \"--outputPipeId=[идКанала] - Указать канал вывода\",\n\t\"MOUNTINFO_USAGE\": \"Использование: mountinfo [точка_монтирования]\",\n\t\"MOUNTINFO_DESCRIPTION\": \"Получить информацию о точке монтирования.\",\n\t\"UMOUNT_USAGE\": \"Использование: umount <параметры> [точка_монтирования]\",\n\t\"UMOUNT_DESCRIPTION\": \"Размонтирует файловую систему.\",\n\t\"UMOUNT_OPT_SYNCONLY\": \"--sync-only - Только синхронизация, а не размонтирование (перезаписывает --force)\",\n\t\"UMOUNT_OPT_FORCE\": \"--force - Принудительно размонтировать, не синхронизовать\",\n\t\"CALC_TITLE\": \"Калькулятор\",\n\t\"CALC_BASIC_MODE\": \"Калькулятор: Основные операции\",\n\t\"CALC_ADVANCED_MODE\": \"Калькулятор: Расширенный режим\",\n\t\"CALC_ADD\": \"Сумма\",\n\t\"CALC_SUBTRACT\": \"Разность\",\n\t\"CALC_MULTIPLY\": \"Произведение\",\n\t\"CALC_DIVIDE\": \"Частное\",\n\t\"CALC_ADVMODE_BTN\": \"Расширенный режим\",\n\t\"CALC_BASICMODE_BTN\": \"Основные операции\",\n\t\"CALC_OPERAND\": \"Операнд %s\",\n\t\"CALC_TOMIXED_BTN\": \"Перевести в смешанную дробь\",\n\t\"CALC_TOIMPR_BTN\": \"Перевести в неправильную дробь\",\n\t\"CALC_GCD\": \"НОД\",\n\t\"CALC_FACTORIAL\": \"Факториал\",\n\t\"CALC_GCD_PAGE\": \"Наибольший общий делитель\",\n\t\"ZKPP_OPTION\": \"ZKPP (Пароль)\",\n\t\"WARNING_PRIVILEGES\": \"Будьте осторожны с этой функцией! Вы можете понизить уровень безопасности системы.\",\n\t\"USER_EXT_PRIVILEGES\": \"Расширенный набор разрешений\",\n\t\"LULL_SYSTEM\": \"Режим сна\",\n\t\"SYSTEM_IMAGING\": \"Образы системы\",\n\t\"CREATE_IMAGE\": \"Создать образ системы\",\n\t\"RESTORE_IMAGE\": \"Восстановить образ системы\",\n\t\"SELECT_FILE_PROMPT\": \"Выберите файл: \",\n\t\"REBOOT_ON_RESTORE\": \"Перезагрузить после восстановления\",\n\t\"MERGE_STATES\": \"Слиять состояния образов\",\n\t\"LISTING_PARTITIONS_FAILED\": \"Не удалось получить список разделов.\",\n\t\"READING_PARTITION_FAILED\": \"Не удалось прочитать раздел %s\",\n\t\"LISTING_DATA_FAILED\": \"Не удалось получить список данных.\",\n\t\"READING_DATA_FAILED\": \"Не удалось прочитать данные.\",\n\t\"WRITING_IMAGE_FAILED\": \"Не удалось записать образ.\",\n\t\"SUCCESSFUL_OP\": \"Процесс был успешно завершён.\",\n\t\"FAILED_OP\": \"Процесс завершён безуспешно.\",\n\t\"READING_IMAGE_FAILED\": \"Не удалось прочитать образ.\",\n\t\"WRITING_PARTITION_FAILED\": \"Не удалось записать раздел %s\",\n\t\"WRITING_DATA_FAILED\": \"Не удалось записать данные.\",\n\t\"DELETING_PARTITION_FAILED\": \"Не удалось удалить раздел %s\",\n\t\"DELETING_DATA_FAILED\": \"Не удалось удалить данные.\",\n\t\"SHUTTING_DOWN_FAILED\": \"Не удалось завершить работу системы.\",\n\t\"NETWORK_STATUS_ONLINE\": \"Вы подключены к локальной вычислительной сети.\",\n\t\"NETWORK_STATUS_OFFLINE\": \"Вы не подключены ни к какой сети.\",\n\t\"PCOS_NETWORK_STATUS_ONLINE\": \"Вы подключены к PCOS Network. (имя: %s, адрес: %s)\",\n\t\"PCOS_NETWORK_STATUS_OFFLINE\": \"Вы отключены от PCOS Network.\",\n\t\"PCOS_NETWORK_STATUS_STOPPED\": \"Служба PCOS Network была остановлена.\",\n\t\"START_MENU_FAILED\": \"Не удалось запустить меню \\\"Пуск\\\". Вместо этого можно выполнить выход из системы.\",\n\t\"SYSTEM_BUILT_AT\": \"Система скомпилирована %s\",\n\t\"REAL_TERMINAL_VER_USEDESC\": \"ver - Показать номер и время компиляции системы\",\n\t\"BLANK_PRIVILEGE_FLAG\": \"Нулевые привилегии\",\n\t\"INSTALLING_SYSTEM_APPHARDEN\": \"Установка правил безопасности программ\",\n\t\"INSTALLING_NET_CONF\": \"Установка конфигурации PCOS Network\",\n\t\"NETWORK_ADDRESS_FIELD\": \"Сетевой адрес: %s\",\n\t\"NETWORK_AUTOHOST_FIELD\": \"Автоматическое имя: %s\",\n\t\"NETCONFIG_HOSTNAME\": \"Имя в сети: \",\n\t\"DIFF_USAGE\": \"Использование: diff [оригинал] [новый] [разность]\",\n\t\"DIFF_DESCRIPTION\": \"Вычисляет разность между двумя файлами.\",\n\t\"PATCH_USAGE\": \"Использование: patch [оригинал] [разность] [новый]\",\n\t\"PATCH_DESCRIPTION\": \"Вычисляет 'сумму' оригинального файла и разности.\",\n\t\"SYSTEM_UP_TO_DATE\": \"Обновления отсутствуют\",\n\t\"POWER_USAGE\": \"Использование: power <параметры> <r|reboot|restart|k|kexec>\",\n\t\"POWER_DESCRIPTION\": \"Выключает или перезагружает систему. Указывание ничего приводит к завершению работы.\",\n\t\"POWER_FORCE\": \"--force: не ждать процессов, перезагрузиться или выключиться немедленно\",\n\t\"POWER_KEXEC\": \"--kexec: перезагрузить систему, не перезагружая страницу или прошивку (автоматически выбирает reboot)\",\n\t\"UPDATEFW_BUTTON\": \"Обновить прошивку\",\n\t\"UPDATEFW_DOWNLOADING\": \"Скачивание местного init.js...\",\n\t\"UPDATEFW_DOWNLOAD_FAILED\": \"Не удалось скачать местный init.js.\",\n\t\"UPDATEFW_DECODING\": \"Обработка init.js как текст\",\n\t\"UPDATEFW_SETTING\": \"Задание init.js как прошивки\",\n\t\"ADDUSER_USAGE\": \"Использование: adduser <параметры> [пользователь]\",\n\t\"ADDUSER_DESCRIPTION\": \"Создать новую учётную запись пользователя.\",\n\t\"ADDUSER_SKIP_PASSWD\": \"--skip-passwd: не спрашивать пароль\",\n\t\"ADDUSER_SKIP_HOME\": \"--skip-home: не создавать домашнюю директорию\",\n\t\"ADDUSER_GROUPS\": \"--groups: добавить в группы (указать несколько раз, чтобы добавить в несколько групп)\",\n\t\"ADDUSER_HOME\": \"--home: своя домашняя директория\",\n\t\"NEW_USER_CREATION\": \"Создание нового пользователя \\\"%s\\\"\",\n\t\"BLOCKUSER_USAGE\": \"Использование: blockuser <пользователь>\",\n\t\"BLOCKUSER_DESCRIPTION\": \"Блокирует учётную запись пользователя.\",\n\t\"DELUSER_USAGE\": \"Использование: deluser <параметры> [пользователь]\",\n\t\"DELUSER_DESCRIPTION\": \"Удаляет учётную запись пользователя.\",\n\t\"DELUSER_HOMEDIR\": \"--homedir: удалять домашнюю директорию\",\n\t\"OLD_USER_DELETION\": \"Удаление старого пользователя \\\"%s\\\"\",\n\t\"BATTERY_STATUS_UNAVAILABLE\": \"Статус батареи недоступен.\",\n\t\"BATTERY_STATUS_CHARGING\": \"Батарея заряжается (%s%, %sдо полной)\",\n\t\"BATTERY_STATUS_DISCHARGING\": \"Батарея разряжается (%s%, %sигры)\",\n\t\"SERVER_SIGNATURE_VERIFICATION_FAILED\": \"К компьютеру нет доверия.\",\n\t\"NETWORK_UNREACHABLE\": \"Сеть недоступна.\",\n\t\"ADDRESS_UNREACHABLE\": \"Адрес недоступен.\",\n\t\"NETWORK_CLOSED\": \"Сеть была закрыта.\",\n\t\"CONNECTION_DROPPED\": \"Соединение была закрыта.\",\n\t\"BLOG_BROWSER_NAME\": \"Обозреватель блогов\",\n\t\"BLOG_BROWSER_LOADING\": \"Подождите, страница загружается...\",\n\t\"BLOG_BROWSER_PROTO\": \"Нет такого протокола. Эта версия поддерживает только протокол bdp://.\",\n\t\"BLOG_BROWSER_GATESET\": \"Для того, чтобы задать ворота, используйте часть имени пользователя: bdp://gate@myblog.pc\",\n\t\"HOSTNAME_RESOLUTION_FAILED\": \"Не удалось преобразовать имя компьютера.\",\n\t\"BLOG_BROWSER_POSTCLOSE\": \"Этот интерактивный пост был закрыт.\",\n\t\"BLOG_BROWSER_FILEPOST\": \"Это пост-файл. Вы можете скачать его на этот компьютер.\",\n\t\"BLOG_BROWSER_DLFILEPOST\": \"Вы скачали этот пост-файл.\",\n\t\"BLOG_BROWSER_LOADING_PROGRESS\": \"Загрузка поста (получено %s из %s частей)\",\n\t\"BLOG_BROWSER_NOVERIFY\": \"Вы включили параметр, пропускающий проверку сервера. Это не рекомендуется, так как сетевой прокси-сервер сможет выполнить атаку \\\"человек посередине\\\" и тем самым, получить доступ к вашим данным. Вы бы позволили этому случиться?\",\n\t\"BLOG_BROWSER_NOSANDBOX\": \"Вы включили параметр пробрасывания всех ИПП вашей операционной системы. Это не рекомендуется, так как пост может выполнять любое действие, как будто он является этой программой. Вы бы позволили этому случиться?\",\n\t\"NETWORKFS_USAGE\": \"Использование: networkfs <параметры> [url] [точка_монтирования]\",\n\t\"NETWORKFS_DESCRIPTION\": \"Монтирует файловую систему, доступную через PCOS Network.\",\n\t\"NETWORKFS_NOVERIFY\": \"--no-verification: Не проверять ключ сервера\",\n\t\"NETWORKFS_KEY\": \"--key=[путь]: Путь до ключа для взаимной проверки\",\n\t\"NETWORKFS_PROTO\": \"Данная версия поддерживает только протокол netfs://.\",\n\t\"NETCONFIG_UPDATES\": \"Обновления: \",\n\t\"NETWORK_UPDATES_FIELD\": \"Обновления с: %s\",\n\t\"LOCALE_NAME\": \"Русский (Russian)\",\n\t\"SETTING_LOCALE_PREFERENCE\": \"Установка предпочитаемого языка\",\n\t\"LANGUAGE_SELECT\": \"Ваш язык: \",\n\t\"CHANGE_LOCALE\": \"Изменить язык\",\n\t\"MOUNT_EXISTS\": \"Монтирование уже существует\",\n\t\"INSECURE_MODE_MSG\": \"Безопасность снижена!\",\n\t\"MODULE_REQUIRED\": \"Для этой функции требуется модуль \\\"%s\\\". Обратитесь к системному администратору.\",\n\t\"CREATING_DIRECTORY_STRUCTURE\": \"Создание структуры каталогов\",\n\t\"GENERATING_KERNEL\": \"Создание ядра системы\",\n\t\"REGENERATE_KERNEL\": \"Повторно создать ядро системы\",\n\t\"TECHNICAL_LIMITATIONS\": \"Этот файл нельзя создать из-за технических ограничений.\",\n\t\"REVIEWING_MIGRATION\": \"Обзор путей миграции\",\n\t\"MIGRATING_USER_PROFILES\": \"Мигрируем профили пользователей\",\n\t\"UPDATING_MODCFG\": \"Получение конфигурации модулей\",\n\t\"UPDATING_MODULES\": \"Обновление модулей\",\n\t\"FAILED_TO_UPDATE\": \"Не удалось обновить модули\",\n\t\"UPDATE_COUNTING\": \"Вычисление обновляемых модулей\",\n\t\"UPDATE_COUNT\": \"Можно обновить %s модулей\",\n\t\"UPDATE_MODCFG\": \"Обновить конфигурацию модулей\",\n\t\"INSTALL_ONLINE_MODULE\": \"Установить модули по сети\",\n\t\"REMOVE_MODULES\": \"Удалить модули\",\n\t\"MODMGR_PRIVFAIL\": \"Было предоставлено недостаточно разрешений для управления модулями.\",\n\t\"MODMGR_TITLE\": \"Управление модулями\",\n\t\"MODMGR_INTENT\": \"Управлять и поддерживать модули на этой системе\",\n\t\"MANAGING_MODULE\": \"Управление модулем: %s (%s из %s, %s%)\",\n\t\"MODNAME_CELL\": \"Имя модуля\",\n\t\"MODVER_CELL\": \"Версия модуля\",\n\t\"MODTGT_CELL\": \"Целевая сборка\",\n\t\"APPLY_CHANGES\": \"Применить изменения\",\n\t\"DISCARD_CHANGES\": \"Отменить изменения\",\n\t\"RELOADING_MODULES\": \"Перезагрузка модулей системы\",\n\t\"SUCCESSFUL_OP_REBOOT\": \"Процесс был успешно завершён, но для применения некоторых изменений может потребоваться перезагрузка.\",\n\t\"REPAIR_OS\": \"Починить ОС\",\n\t\"REPAIRING_SYSTEM\": \"Исправление неисправностей...\",\n\t\"REPAIR_FAILED\": \"Восстановление системы не удалось!\",\n\t\"REPAIRING_MODULE\": \"Восстановление модуля: %s (%s из %s, %s%)\",\n\t\"MOUNT_OFFLINE_OS\": \"Монтровать автономную ОС\",\n\t\"UMOUNT_OFFLINE_OS\": \"Размонтировать автономную ОС\",\n\t\"SWAP_OFFLINE_OS\": \"Переключиться на автономную ОС\",\n\t\"SWAPPING_SYSTEMS\": \"Переключение на систему...\",\n\t\"INSTALL_OFFLINE_MODULE\": \"Установить модуль офлайн\",\n\t\"RESTRICT_PROMPT\": \"Уровни доступа:\\r\\nfull - Полный доступ\\r\\nuser - Обычный доступ (умолчание)\\r\\nro - Доступ только для чтения\\r\\nВведите уровень доступа\",\n\t\"RESTRICT_OPTION\": \"Ограниченный доступ\",\n\t\"BREAKOUT_MODULE_NAME\": \"Игра-пример Breakout (из MDN)\",\n\t\"BOOTABLE_MODULE_NAME\": \"Основные файлы ядра\",\n\t\"CORE_MODULE_NAME\": \"Важные файлы системы\",\n\t\"DIFF_MODULE_NAME\": \"Библиотека вычисления разности (сделана Logan R. Kearsley)\",\n\t\"INSTFILES_MODULE_NAME\": \"Файлы установочного окружения\",\n\t\"KEYS_MODULE_NAME\": \"Криптографические ключи PCsoft\",\n\t\"MULTIMEDIA_MODULE_NAME\": \"Поддержка мультимедиа\",\n\t\"ICONS_MODULE_NAME\": \"Иконки PCOS 3 по умолчанию\",\n\t\"SOUNDS_MODULE_NAME\": \"Звуковые эффекты PCOS 3 по умолчанию\",\n\t\"WP_MODULE_NAME\": \"Обои PCOS 3 по умолчанию\",\n\t\"TERMDISK_MODULE_NAME\": \"Управление диском в терминале\",\n\t\"TERMNET_MODULE_NAME\": \"Сетевые соединения в терминале\",\n\t\"TERMUSER_MODULE_NAME\": \"Управление пользователями в терминале\",\n\t\"TWNACL_MODULE_NAME\": \"Криптографическая библиотека TweetNaCl.js\",\n\t\"XTERM_MODULE_NAME\": \"Библиотека поддержки терминала xterm.js (сделана The xterm.js authors)\",\n\t\"REINVENTORIZE_MODULES\": \"Переинвенторизовать модули\",\n\t\"REINVENTORIZING_MODULES\": \"Повторная инвенторизация модулей...\",\n\t\"MODTRUST_CELL\": \"Кем доверено\",\n\t\"UNSIGNED_CELL\": \"НИКЕМ\",\n\t\"ROOT_KEY_CELL\": \"Корневой центр доверия PCsoft\",\n\t\"USER_PREFERENCES\": \"Мои предпочтения\",\n\t\"USER_PREFS_ERROR\": \"Вам нельзя изменять предпочтения.\",\n\t\"WALLPAPER_PATH\": \"Путь к обоям: \",\n\t\"UPDATE_PREFERENCES\": \"Обновить предпочтения\",\n\t\"USER_PREFS_UPDATED\": \"Обновления применены. Некоторые программы могут не обновиться сразу.\",\n\t\"USER_PREFS_UPDATED_PARTIAL\": \"Не все обновления были применены сразу же. Войдите ещё раз, чтобы их увидеть.\",\n\t\"PREF_UPDATE_FAILED\": \"Не все обновления были применены.\"\n};"},"buildInfo":{"for":"1580","version":1580,"when":1766238578403,"signer":"moduleSigner","critical":false,"bootOrder":"50","commonName":"locale-ru","friendlyName":"Поддержка Русского языка (Russian language support)","signature":"2e0ae9419d0757806ee81e9ca846721c0ec2860dce360e14b144d9845855b41bbdb8a01d5a0577f5bdb7449e53ccf72c06704ba3e90524bdc5166c227dedd80e"}},"50-pcos-wallpapers.fs":{"backend":{"files":{"etc":{"wallpapers":{"pcos-beta.pic":"b165b8db760089fa15a2f0950ea57bee8605d56f735e35da356be68f83e49c217a0c0983a16f2c8e7bb17c62d714ec7441ef2c5441e395d3d478ed65114e75d6","pcos-dark-beta.pic":"5f14ecbd90023a26c6c737a67da0d70ab0e7b525d2fd90cffc3489a40c726d57a8feea05e1034f32c046b6a9529f2de2623ba1430990008794e246030dbcdc69","pcos-dark-ny.pic":"68ff3654a665ceaf4a7f7362d090b7cf9f7380b84795487171fe036beb534c7bbff8f7d35027ed4a96a53c73f959bac88a0d1b70b96fcf4b9621795403b20906","pcos-lock-beta.pic":"96fc59061486c1e7cc5efef9b33a035dc3365660d6bbca423892246466ceb94970e3fdac2529fc06ded71a73ecb85072f3fe81a1a73e9fe6aa23d3bba5586c67","pcos-ny.pic":"c75e16d85d0c5a9a1617564ec94afc2d41bb6c099b060e2a0f986b07603f18ee87376e7e065e37f15fbc4a0ceb604ee768957771b4ed70808fae4619c6f0048e"}}},"permissions":{"etc/wallpapers/pcos-beta.pic":{"world":"rx"},"etc/wallpapers/pcos-dark-beta.pic":{"world":"rx"},"etc/wallpapers/pcos-dark-ny.pic":{"world":"rx"},"etc/wallpapers/pcos-lock-beta.pic":{"world":"rx"},"etc/wallpapers/pcos-ny.pic":{"world":"rx"},"etc/wallpapers/":{"world":"rx"},"etc/":{"world":"rx"},"":{"world":"rx"}}},"files":{"b165b8db760089fa15a2f0950ea57bee8605d56f735e35da356be68f83e49c217a0c0983a16f2c8e7bb17c62d714ec7441ef2c5441e395d3d478ed65114e75d6":"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTkyMCIgaGVpZ2h0PSIxMDgwIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+Cgk8ZGVmcz4KCQk8bGluZWFyR3JhZGllbnQgaWQ9IkJnR3JhZGllbnQiIHgxPSIwIiB4Mj0iMCIgeTE9IjAiIHkyPSIxIj4KCQkJPHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iIzAwYmZmZiIgLz4KCQkJPHN0b3Agb2Zmc2V0PSIxMDAlIiBzdG9wLWNvbG9yPSIjYTcwMGZmIiAvPgoJCTwvbGluZWFyR3JhZGllbnQ+Cgk8L2RlZnM+Cgk8Zz4KCQk8cmVjdCB4PSIwIiB5PSIwIiB3aWR0aD0iMTkyMCIgaGVpZ2h0PSIxMDgwIiBmaWxsPSJ1cmwoI0JnR3JhZGllbnQpIiAvPgoJCTx0ZXh0IHg9IjM1IiB5PSIxNTAiIGNsYXNzPSJzZWdvZWZvbnQiIGZpbGw9IiNmZmZmZmYiPlBDT1MgMzwvdGV4dD4KCQk8dGV4dCB4PSIxNTU1IiB5PSIxMDMwIiBjbGFzcz0ic2Vnb2Vmb250IiBmaWxsPSIjMzAzMDMwIj50ZXN0IGJ1aWxkPC90ZXh0PgoJPC9nPgoJPHN0eWxlPgoJCS5zZWdvZWZvbnQgewoJCQlmb250LWZhbWlseTogJ1NlZ29lIFVJJywgVGFob21hLCBHZW5ldmEsIFZlcmRhbmEsIHNhbnMtc2VyaWY7CgkJCWZvbnQtc2l6ZTogNjRweDsKCQkJZm9udC13ZWlnaHQ6IGJvbGQ7CgkJfQoJPC9zdHlsZT4KPC9zdmc+Cg==","5f14ecbd90023a26c6c737a67da0d70ab0e7b525d2fd90cffc3489a40c726d57a8feea05e1034f32c046b6a9529f2de2623ba1430990008794e246030dbcdc69":"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTkyMCIgaGVpZ2h0PSIxMDgwIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+Cgk8ZGVmcz4KCQk8bGluZWFyR3JhZGllbnQgaWQ9IkJnR3JhZGllbnQiIHgxPSIwIiB4Mj0iMCIgeTE9IjAiIHkyPSIxIj4KCQkJPHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iIzAwMDAwMCIgLz4KCQkJPHN0b3Agb2Zmc2V0PSIxMDAlIiBzdG9wLWNvbG9yPSIjYTcwMGZmIiAvPgoJCTwvbGluZWFyR3JhZGllbnQ+Cgk8L2RlZnM+Cgk8Zz4KCQk8cmVjdCB4PSIwIiB5PSIwIiB3aWR0aD0iMTkyMCIgaGVpZ2h0PSIxMDgwIiBmaWxsPSJ1cmwoI0JnR3JhZGllbnQpIiAvPgoJCTx0ZXh0IHg9IjM1IiB5PSIxNTAiIGNsYXNzPSJzZWdvZWZvbnQiIGZpbGw9IiNhNzAwZmYiPlBDT1MgMzwvdGV4dD4KCQk8dGV4dCB4PSIxNTU1IiB5PSIxMDMwIiBjbGFzcz0ic2Vnb2Vmb250IiBmaWxsPSIjMzAzMDMwIj50ZXN0IGJ1aWxkPC90ZXh0PgoJPC9nPgoJPHN0eWxlPgoJCS5zZWdvZWZvbnQgewoJCQlmb250LWZhbWlseTogJ1NlZ29lIFVJJywgVGFob21hLCBHZW5ldmEsIFZlcmRhbmEsIHNhbnMtc2VyaWY7CgkJCWZvbnQtc2l6ZTogNjRweDsKCQkJZm9udC13ZWlnaHQ6IGJvbGQ7CgkJfQoJPC9zdHlsZT4KPC9zdmc+Cg==","68ff3654a665ceaf4a7f7362d090b7cf9f7380b84795487171fe036beb534c7bbff8f7d35027ed4a96a53c73f959bac88a0d1b70b96fcf4b9621795403b20906":"data:image/svg+xml;base64,PCEtLSBNYWRlIHdpdGggSW5rc2NhcGUgLS0+Cjxzdmcgd2lkdGg9IjE5MjAiIGhlaWdodD0iMTA4MCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgoJPGRlZnM+CgkJPGxpbmVhckdyYWRpZW50IGlkPSJCZ0dyYWRpZW50IiB4MT0iMCIgeDI9IjAiIHkxPSIwIiB5Mj0iMSI+CgkJCTxzdG9wIG9mZnNldD0iMCUiIHN0b3AtY29sb3I9IiMwMDAwMDAiIC8+CgkJCTxzdG9wIG9mZnNldD0iMTAwJSIgc3RvcC1jb2xvcj0iI2E3MDBmZiIgLz4KCQk8L2xpbmVhckdyYWRpZW50PgoJPC9kZWZzPgoJPGc+CgkJPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjE5MjAiIGhlaWdodD0iMTA4MCIgZmlsbD0idXJsKCNCZ0dyYWRpZW50KSIgc3R5bGU9ImRpc3BsYXk6aW5saW5lIiAvPgoJCTx0ZXh0IHg9IjM1IiB5PSIxNTAiIGNsYXNzPSJzZWdvZWZvbnQiIGZpbGw9IiNhNzAwZmYiPlBDT1MgMzwvdGV4dD4KCQk8dGV4dCB4PSIxMzU1IiB5PSIxMDMwIiBjbGFzcz0ic2Vnb2Vmb250IiBmaWxsPSIjMzAzMDMwIj5IYXBweSBOZXcgWWVhciE8L3RleHQ+Cgk8L2c+Cgk8c3R5bGU+CgkJLnNlZ29lZm9udCB7CgkJCWZvbnQtZmFtaWx5OiAnU2Vnb2UgVUknLCBUYWhvbWEsIEdlbmV2YSwgVmVyZGFuYSwgc2Fucy1zZXJpZjsKCQkJZm9udC1zaXplOiA2NHB4OwoJCQlmb250LXdlaWdodDogYm9sZDsKCQl9Cgk8L3N0eWxlPgoJPGcgdHJhbnNmb3JtPSJtYXRyaXgoMi4zMSwgMCwgMCwgMi4zMSwgLTE3MDQuMzEsIC0yMzAuMjUpIj4KCQk8cmVjdCBzdHlsZT0iZmlsbDogIzgwMzMwMDsgZmlsbC1vcGFjaXR5OiAxOyBzdHJva2Utd2lkdGg6IDE7IiB3aWR0aD0iMzIiIGhlaWdodD0iODAiIHg9IjEyOTYiIHk9IjQyNSIgLz4KCQk8cGF0aCBzdHlsZT0iZmlsbDogIzAwOTkwMDsgZmlsbC1vcGFjaXR5OiAxOyBzdHJva2Utd2lkdGg6IDE7IiBkPSJtIDExNjYsNDczIDE0OSwtMTY4IDE0OCwxNjggLTUxLC0zOCAtMjgsMjkgLTMxLC0yOCAtMjcsMzAgLTI4LC0yOCAtMjcsMjggLTIyLC0zMCAtMjMsMjcgLTE4LC0zMCB6IiAvPgoJCTxwYXRoIHN0eWxlPSJmaWxsOiAjMDBhMzAwOyBmaWxsLW9wYWNpdHk6IDE7IHN0cm9rZS13aWR0aDogMTsiIGQ9Im0gMTE3Niw0MTIgMTM2LC0xNDkgMTM2LDE1MCAtNDcsLTM0IC0yNSwyNiAtMjgsLTI1IC0yNCwyNyAtMjYsLTI1IC0yNSwyNSAtMjAsLTI3IC0yMSwyNCAtMTcsLTI3IHoiIC8+CgkJPHBhdGggc3R5bGU9ImZpbGw6ICMwMGFkMDA7IGZpbGwtb3BhY2l0eTogMTsgc3Ryb2tlLXdpZHRoOiAxOyIgZD0ibSAxMTk4LDM0NyAxMTQsLTEyMyAxMTMsMTI0IC0zOSwtMjggLTIxLDIyIC0yMywtMjAgLTIwLDIyIC0yMSwtMjEgLTIxLDIxIC0xNywtMjIgLTE4LDIwIC0xNCwtMjIgeiIgLz4KCQk8cGF0aCBzdHlsZT0iZmlsbDogIzAwYzIwMDsgZmlsbC1vcGFjaXR5OiAxOyBzdHJva2Utd2lkdGg6IDE7IiBkPSJtIDEyMTksMjkyIDkyLC05NiA5MSw5NyAtMzEsLTIyIC0xNywxNyAtMTksLTE2IC0xNiwxNyAtMTcsLTE2IC0xNywxNiAtMTMsLTE4IC0xNCwxNiAtMTEsLTE3IHoiIC8+CgkJPHBhdGggc3R5bGU9ImZpbGw6ICNjNzFiMDA7IGZpbGwtb3BhY2l0eTogMSIgZD0ibSAxMDY0LDI3NCA2MywtMTY3IDUzLDE2MSAtMTYwLC0xMDIgMjA4LC02IHoiIHRyYW5zZm9ybT0ibWF0cml4KDAuNDMsIDAsIDAsIDAuNDMsIDgyNS4yOCwgMTExLjM3KSIgLz4KCQk8cGF0aCBzdHlsZT0iZmlsbDogI2VhY2YwMDsgZmlsbC1vcGFjaXR5OiAxOyBzdHJva2Utd2lkdGg6IDE7IiBkPSJtIDEzMDMsNTQyIC0xMzYsLTMxIC0xNDYsNzcgLTEwMywtOSAtMTgsNjQgNzAsLTUwIDExLDYwIDU4LC01MyAxMCw0MiA0MCwtNzMgMjksMzcgMjcsLTcwIDE3LDQ3IDM0LC02MSAyMiw2NyAzMSwtNTIgMzQsNzAgeiIgdHJhbnNmb3JtPSJtYXRyaXgoMC40MywgMCwgMCwgMC40MywgODI1LjI4LCAxMTEuMzcpIiAvPgoJCTxwYXRoIHN0eWxlPSJmaWxsOiAjZWFjZjAwOyBmaWxsLW9wYWNpdHk6IDE7IHN0cm9rZS13aWR0aDogMTsiIGQ9Im0gOTk3LDMyMCA5MCwtMzggNzYsMzUgNjUsLTE5IC0xLDQyIC0zMywtMjYgLTE5LDQzIC0yNSwtMjkgLTE0LDMwIC0xMCwtNDYgLTI1LDI5IC0zLC00NSAtMjAsMzUgLTksLTM4IC02LDQ1IC0zMCwtMjggLTEsNTAgeiIgdHJhbnNmb3JtPSJtYXRyaXgoMC40MywgMCwgMCwgMC40MywgODI1LjI4LCAxMTEuMzcpIiAvPgoJCTxnIHRyYW5zZm9ybT0ibWF0cml4KDAuNDEsIDAsIDAsIDAuNDEsIDExMDMuNTEsIDk0LjEpIj4KCQkJPHBhdGggc3R5bGU9ImZpbGw6ICMwZDAxMDA7IGZpbGwtb3BhY2l0eTogMTsiIGQ9Im0gMjg0LDU2NyBjIDcsLTIgMTUsLTMgMjIsLTMgOCwwIDE1LDAgMjIsMiA1LDEgMTAsMyAxNSw0IDcsMSAxNSwxIDIyLDEgOCwxIDE3LDEgMjUsMiA1LDAgMTAsMSAxNCwxIDUsMSAxMCwxIDE1LDEgNiwwIDEzLDAgMTksMCA3LDAgMTMsMCAyMCwwIDQsMCA4LDAgMTIsMCAyLDAgNCwwIDYsLTEgMiwtMSA0LC0zIDUsLTQgMiwtMiAzLC0zIDUsLTUgMiwtMiAzLC01IDQsLTggMywtNCA1LC04IDksLTExIDQsLTQgOCwtNyAxMywtMTAgOCwtNCAxNiwtNiAyNSwtOCA3LC0xIDEzLC0xIDIwLC0yIDksLTIgMTksLTQgMjgsLTYgNywtMSAxMywtMiAyMCwtMiA5LC0xIDE4LC0xIDI4LC0yIDgsMCAxNiwtMSAyNCwtMyA2LC0xIDEyLC0zIDE4LC01IDMsLTEgNiwtMiA5LC0yIDIsMCAzLDAgNSwwIDAsMCAtMywtMiAtMywtMiB2IDAgYyAtMiwwIC0zLDAgLTUsMCAtMywwIC02LDEgLTksMiAtNiwyIC0xMiw0IC0xOCw1IC04LDIgLTE2LDMgLTI0LDMgLTksMCAtMTgsMCAtMjgsMiAtNywxIC0xMywxIC0yMCwzIC05LDIgLTE5LDQgLTI4LDYgLTcsMSAtMTMsMSAtMjAsMiAtOSwxIC0xNyw0IC0yNSw4IC01LDMgLTksNiAtMTMsMTAgLTMsNCAtNiw3IC05LDEyIC0yLDIgLTMsNSAtNCw3IC0yLDIgLTMsMyAtNSw1IC0xLDIgLTMsMyAtNSw0IC0yLDEgLTQsMSAtNiwxIC00LDAgLTgsMCAtMTIsMCAtNywwIC0xMywwIC0yMCwwIC02LDAgLTEzLDAgLTE5LDAgLTUsMCAtMTAsMCAtMTUsLTEgLTUsLTEgLTEwLC0xIC0xNCwtMSAtOCwwIC0xNywtMSAtMjUsLTEgLTcsMCAtMTUsLTEgLTIyLC0xIC01LC0xIC0xMCwtMyAtMTUsLTQgLTcsLTIgLTE1LC0zIC0yMiwtMiAtOCwwIC0xNSwxIC0yMiwzIDAsMCAzLDIgMywyIHoiIC8+CgkJCTxwYXRoIHN0eWxlPSJmaWxsOiAjMDA1NWViOyBmaWxsLW9wYWNpdHk6IDE7IiBkPSJtIDQ0Myw1OTUgLTIxLC01IC0xNiwxNCAtMSwtMjEgLTE4LC0xMSAyMCwtOCA1LC0yMSAxMywxNiAyMSwtMiAtMTEsMTggeiIgLz4KCQkJPGNpcmNsZSBzdHlsZT0iZmlsbDogI2MwMGYwMDsgZmlsbC1vcGFjaXR5OiAxOyIgY3g9IjUyNiIgY3k9IjU0MCIgcj0iMjUiIC8+CgkJCTxwYXRoIHN0eWxlPSJmaWxsOiAjMDA1NWViOyBmaWxsLW9wYWNpdHk6IDE7IiBkPSJtIDY1MSw1MzEgLTI1LC00IC0xNywxOCAtNCwtMjUgLTIzLC0xMSAyMiwtMTIgMywtMjUgMTgsMTggMjUsLTUgLTExLDIyIHoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEwLCAxMSkiIC8+CgkJCTxjaXJjbGUgc3R5bGU9ImZpbGw6ICNjMDBmMDA7IGZpbGwtb3BhY2l0eTogMTsiIGN4PSIzMjIiIGN5PSI1NzIiIHI9IjI1IiAvPgoJCTwvZz4KCQk8ZyB0cmFuc2Zvcm09Im1hdHJpeCgtMC40OSwgMCwgMCwgMC40MywgMTQ5Ni43MywgMTMzLjkzKSI+CgkJCTxwYXRoIHN0eWxlPSJmaWxsOiAjMDAwMDAwOyBmaWxsLW9wYWNpdHk6IDEiIGQ9Im0gMTc3LDcxMiBjIC0xLC04IDEsLTE1IDMsLTIzIDIsLTUgMywtMTEgNiwtMTUgNywtNyAxNSwtMTMgMjIsLTIwIDYsLTQgMTMsLTkgMjAsLTEyIDQsLTEgNiwtMiAxMCwtMyA3LC0xIDE1LC0yIDIyLC0yIDYsMCAxMSwwIDE3LDAgNywwIDE0LDAgMjEsMSA1LDEgOSwxIDE0LDMgMiwxIDQsMiA2LDIgNSwyIDEwLDUgMTUsNyA5LDMgMTgsNiAyNyw5IDYsMiAxMiwzIDE4LDQgNCwxIDgsMSAxMSwxIDcsMSAxNSwyIDIzLDMgNywxIDE0LDEgMjEsMiA1LDAgMTEsMSAxNiwxIDMsMCA3LDAgMTAsMCA2LDAgMTEsMCAxNywwIDYsMCAxMiwtMSAxNywtMSA0LDAgNywtMSAxMSwtMiA1LC0yIDEwLC02IDE1LC05IDQsLTMgOSwtNSAxMywtOCAzLC0xIDUsLTMgOCwtNSA1LC00IDEwLC04IDE2LC0xMiAwLDAgLTMsLTIgLTMsLTIgdiAwIGMgLTUsNCAtMTAsOCAtMTYsMTIgLTIsMiAtNSw0IC04LDUgLTQsMyAtOSw1IC0xMyw4IC01LDMgLTEwLDcgLTE1LDkgLTMsMSAtNywyIC0xMSwyIC02LDEgLTExLDEgLTE3LDEgLTYsMCAtMTEsMCAtMTcsMCAtMywwIC03LDAgLTEwLDAgLTUsMCAtMTEsLTEgLTE2LC0xIC03LDAgLTE0LC0xIC0yMSwtMiAtOCwtMSAtMTUsLTIgLTIzLC0zIC00LC0xIC04LDAgLTExLC0xIC02LC0xIC0xMiwtMiAtMTgsLTQgLTksLTMgLTE4LC01IC0yNywtOSAtNSwtMiAtMTAsLTUgLTE1LC03IC0yLC0xIC00LC0yIC02LC0yIC00LC0xIC05LC0yIC0xNCwtMyAtNywtMSAtMTQsLTEgLTIxLC0xIC02LDAgLTExLDAgLTE3LDAgLTcsMCAtMTUsMCAtMjIsMiAtNCwxIC02LDEgLTEwLDMgLTcsMyAtMTQsOCAtMjAsMTIgLTgsNiAtMTYsMTMgLTIzLDIwIC0zLDQgLTQsMTAgLTYsMTUgLTIsNyAtNCwxNSAtNCwyMyAwLDAgMywyIDMsMiB6IiAvPgoJCQk8cGF0aCBzdHlsZT0iZmlsbDogI2E3MDBmZjsgZmlsbC1vcGFjaXR5OiAxIiBkPSJtIDI3Niw3OTAgLTQ5LC04IC0zNCwzNiAtOCwtNDkgLTQ1LC0yMSA0NCwtMjMgNiwtNDkgMzUsMzUgNDksLTkgLTIyLDQ0IHoiIHRyYW5zZm9ybT0ibWF0cml4KDAuNDgsIDAsIDAsIDAuNDYsIDEwNy4xOSwgMzMzLjIpIiAvPgoJCQk8Y2lyY2xlIHN0eWxlPSJmaWxsOiAjZmZiNjBkOyBmaWxsLW9wYWNpdHk6IDE7IHN0cm9rZS13aWR0aDogMTsiIGN4PSIyOTgiIGN5PSI2NTYiIHI9IjI1IiAvPgoJCQk8cGF0aCBzdHlsZT0iZmlsbDogI2ZmMWFhMDsgZmlsbC1vcGFjaXR5OiAxOyIgZD0ibSA0MjMsNjk2IC0yMywtMTAgLTIxLDEzIDIsLTI1IC0xOSwtMTYgMjQsLTYgOSwtMjMgMTMsMjEgMjUsMSAtMTYsMTkgeiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTAsIC0xMSkiIC8+CgkJCTxjaXJjbGUgc3R5bGU9ImZpbGw6ICMwMGNhZGM7IGZpbGwtb3BhY2l0eTogMTsiIGN4PSI1MTAiIGN5PSI2NjQiIHI9IjI2IiAvPgoJCTwvZz4KCTwvZz4KPC9zdmc+Cg==","96fc59061486c1e7cc5efef9b33a035dc3365660d6bbca423892246466ceb94970e3fdac2529fc06ded71a73ecb85072f3fe81a1a73e9fe6aa23d3bba5586c67":"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTkyMCIgaGVpZ2h0PSIxMDgwIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+Cgk8ZGVmcz4KCQk8bGluZWFyR3JhZGllbnQgaWQ9IkJnR3JhZGllbnQiIHgxPSIwIiB4Mj0iMCIgeTE9IjAiIHkyPSIxIj4KCQkJPHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iIzAwYmZmZiIgLz4KCQkJPHN0b3Agb2Zmc2V0PSI1MCUiIHN0b3AtY29sb3I9IiNhNzAwZmYiIC8+CgkJCTxzdG9wIG9mZnNldD0iMTAwJSIgc3RvcC1jb2xvcj0iIzAwMDAwMCIgLz4KCQk8L2xpbmVhckdyYWRpZW50PgoJPC9kZWZzPgoJPGc+CgkJPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjE5MjAiIGhlaWdodD0iMTA4MCIgZmlsbD0idXJsKCNCZ0dyYWRpZW50KSIgLz4KCQk8dGV4dCB4PSI4MDAiIHk9IjIwMCIgY2xhc3M9InNlZ29lZm9udCIgZmlsbD0iIzAwMDAwMCIgZm9udC1zaXplPSI3MnB4IiBmb250LXdlaWdodD0iYm9sZCI+UENPUyAzPC90ZXh0PgoJCTx0ZXh0IHg9Ijg2MCIgeT0iMjQwIiBjbGFzcz0ic2Vnb2Vmb250IiBmaWxsPSIjNDA0MDQwIiBmb250LXNpemU9IjM2cHgiPmxvY2tlZDwvdGV4dD4KCQk8dGV4dCB4PSIxNTU1IiB5PSIxMDUwIiBjbGFzcz0ic2Vnb2Vmb250IiBmaWxsPSIjNDA0MDQwIiBmb250LXNpemU9IjcycHgiIGZvbnQtd2VpZ2h0PSJib2xkIj50ZXN0IGJ1aWxkPC90ZXh0PgoJPC9nPgoJPHN0eWxlPgoJCS5zZWdvZWZvbnQgewoJCQlmb250LWZhbWlseTogJ1NlZ29lIFVJJywgVGFob21hLCBHZW5ldmEsIFZlcmRhbmEsIHNhbnMtc2VyaWY7CgkJfQoJPC9zdHlsZT4KPC9zdmc+Cg==","c75e16d85d0c5a9a1617564ec94afc2d41bb6c099b060e2a0f986b07603f18ee87376e7e065e37f15fbc4a0ceb604ee768957771b4ed70808fae4619c6f0048e":"data:image/svg+xml;base64,PCEtLSBNYWRlIHdpdGggSW5rc2NhcGUgLS0+Cjxzdmcgd2lkdGg9IjE5MjAiIGhlaWdodD0iMTA4MCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgoJPGRlZnM+CgkJPGxpbmVhckdyYWRpZW50IGlkPSJCZ0dyYWRpZW50IiB4MT0iMCIgeDI9IjAiIHkxPSIwIiB5Mj0iMSI+CgkJCTxzdG9wIG9mZnNldD0iMCUiIHN0b3AtY29sb3I9IiMwMGJmZmYiIC8+CgkJCTxzdG9wIG9mZnNldD0iMTAwJSIgc3RvcC1jb2xvcj0iI2E3MDBmZiIgLz4KCQk8L2xpbmVhckdyYWRpZW50PgoJPC9kZWZzPgoJPGc+CgkJPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjE5MjAiIGhlaWdodD0iMTA4MCIgZmlsbD0idXJsKCNCZ0dyYWRpZW50KSIgc3R5bGU9ImRpc3BsYXk6aW5saW5lIiAvPgoJCTx0ZXh0IHg9IjM1IiB5PSIxNTAiIGNsYXNzPSJzZWdvZWZvbnQiIGZpbGw9IiNmZmZmZmYiPlBDT1MgMzwvdGV4dD4KCQk8dGV4dCB4PSIxMzU1IiB5PSIxMDMwIiBjbGFzcz0ic2Vnb2Vmb250IiBmaWxsPSIjMzAzMDMwIj5IYXBweSBOZXcgWWVhciE8L3RleHQ+Cgk8L2c+Cgk8c3R5bGU+CgkJLnNlZ29lZm9udCB7CgkJCWZvbnQtZmFtaWx5OiAnU2Vnb2UgVUknLCBUYWhvbWEsIEdlbmV2YSwgVmVyZGFuYSwgc2Fucy1zZXJpZjsKCQkJZm9udC1zaXplOiA2NHB4OwoJCQlmb250LXdlaWdodDogYm9sZDsKCQl9Cgk8L3N0eWxlPgoJPGcgdHJhbnNmb3JtPSJtYXRyaXgoMi4zMSwgMCwgMCwgMi4zMSwgLTE3MDQuMzEsIC0yMzAuMjUpIj4KCQk8cmVjdCBzdHlsZT0iZmlsbDogIzgwMzMwMDsgZmlsbC1vcGFjaXR5OiAxOyBzdHJva2Utd2lkdGg6IDE7IiB3aWR0aD0iMzIiIGhlaWdodD0iODAiIHg9IjEyOTYiIHk9IjQyNSIgLz4KCQk8cGF0aCBzdHlsZT0iZmlsbDogIzAwOTkwMDsgZmlsbC1vcGFjaXR5OiAxOyBzdHJva2Utd2lkdGg6IDE7IiBkPSJtIDExNjYsNDczIDE0OSwtMTY4IDE0OCwxNjggLTUxLC0zOCAtMjgsMjkgLTMxLC0yOCAtMjcsMzAgLTI4LC0yOCAtMjcsMjggLTIyLC0zMCAtMjMsMjcgLTE4LC0zMCB6IiAvPgoJCTxwYXRoIHN0eWxlPSJmaWxsOiAjMDBhMzAwOyBmaWxsLW9wYWNpdHk6IDE7IHN0cm9rZS13aWR0aDogMTsiIGQ9Im0gMTE3Niw0MTIgMTM2LC0xNDkgMTM2LDE1MCAtNDcsLTM0IC0yNSwyNiAtMjgsLTI1IC0yNCwyNyAtMjYsLTI1IC0yNSwyNSAtMjAsLTI3IC0yMSwyNCAtMTcsLTI3IHoiIC8+CgkJPHBhdGggc3R5bGU9ImZpbGw6ICMwMGFkMDA7IGZpbGwtb3BhY2l0eTogMTsgc3Ryb2tlLXdpZHRoOiAxOyIgZD0ibSAxMTk4LDM0NyAxMTQsLTEyMyAxMTMsMTI0IC0zOSwtMjggLTIxLDIyIC0yMywtMjAgLTIwLDIyIC0yMSwtMjEgLTIxLDIxIC0xNywtMjIgLTE4LDIwIC0xNCwtMjIgeiIgLz4KCQk8cGF0aCBzdHlsZT0iZmlsbDogIzAwYzIwMDsgZmlsbC1vcGFjaXR5OiAxOyBzdHJva2Utd2lkdGg6IDE7IiBkPSJtIDEyMTksMjkyIDkyLC05NiA5MSw5NyAtMzEsLTIyIC0xNywxNyAtMTksLTE2IC0xNiwxNyAtMTcsLTE2IC0xNywxNiAtMTMsLTE4IC0xNCwxNiAtMTEsLTE3IHoiIC8+CgkJPHBhdGggc3R5bGU9ImZpbGw6ICNjNzFiMDA7IGZpbGwtb3BhY2l0eTogMSIgZD0ibSAxMDY0LDI3NCA2MywtMTY3IDUzLDE2MSAtMTYwLC0xMDIgMjA4LC02IHoiIHRyYW5zZm9ybT0ibWF0cml4KDAuNDMsIDAsIDAsIDAuNDMsIDgyNS4yOCwgMTExLjM3KSIgLz4KCQk8cGF0aCBzdHlsZT0iZmlsbDogI2VhY2YwMDsgZmlsbC1vcGFjaXR5OiAxOyBzdHJva2Utd2lkdGg6IDE7IiBkPSJtIDEzMDMsNTQyIC0xMzYsLTMxIC0xNDYsNzcgLTEwMywtOSAtMTgsNjQgNzAsLTUwIDExLDYwIDU4LC01MyAxMCw0MiA0MCwtNzMgMjksMzcgMjcsLTcwIDE3LDQ3IDM0LC02MSAyMiw2NyAzMSwtNTIgMzQsNzAgeiIgdHJhbnNmb3JtPSJtYXRyaXgoMC40MywgMCwgMCwgMC40MywgODI1LjI4LCAxMTEuMzcpIiAvPgoJCTxwYXRoIHN0eWxlPSJmaWxsOiAjZWFjZjAwOyBmaWxsLW9wYWNpdHk6IDE7IHN0cm9rZS13aWR0aDogMTsiIGQ9Im0gOTk3LDMyMCA5MCwtMzggNzYsMzUgNjUsLTE5IC0xLDQyIC0zMywtMjYgLTE5LDQzIC0yNSwtMjkgLTE0LDMwIC0xMCwtNDYgLTI1LDI5IC0zLC00NSAtMjAsMzUgLTksLTM4IC02LDQ1IC0zMCwtMjggLTEsNTAgeiIgdHJhbnNmb3JtPSJtYXRyaXgoMC40MywgMCwgMCwgMC40MywgODI1LjI4LCAxMTEuMzcpIiAvPgoJCTxnIHRyYW5zZm9ybT0ibWF0cml4KDAuNDEsIDAsIDAsIDAuNDEsIDExMDMuNTEsIDk0LjEpIj4KCQkJPHBhdGggc3R5bGU9ImZpbGw6ICMwZDAxMDA7IGZpbGwtb3BhY2l0eTogMTsiIGQ9Im0gMjg0LDU2NyBjIDcsLTIgMTUsLTMgMjIsLTMgOCwwIDE1LDAgMjIsMiA1LDEgMTAsMyAxNSw0IDcsMSAxNSwxIDIyLDEgOCwxIDE3LDEgMjUsMiA1LDAgMTAsMSAxNCwxIDUsMSAxMCwxIDE1LDEgNiwwIDEzLDAgMTksMCA3LDAgMTMsMCAyMCwwIDQsMCA4LDAgMTIsMCAyLDAgNCwwIDYsLTEgMiwtMSA0LC0zIDUsLTQgMiwtMiAzLC0zIDUsLTUgMiwtMiAzLC01IDQsLTggMywtNCA1LC04IDksLTExIDQsLTQgOCwtNyAxMywtMTAgOCwtNCAxNiwtNiAyNSwtOCA3LC0xIDEzLC0xIDIwLC0yIDksLTIgMTksLTQgMjgsLTYgNywtMSAxMywtMiAyMCwtMiA5LC0xIDE4LC0xIDI4LC0yIDgsMCAxNiwtMSAyNCwtMyA2LC0xIDEyLC0zIDE4LC01IDMsLTEgNiwtMiA5LC0yIDIsMCAzLDAgNSwwIDAsMCAtMywtMiAtMywtMiB2IDAgYyAtMiwwIC0zLDAgLTUsMCAtMywwIC02LDEgLTksMiAtNiwyIC0xMiw0IC0xOCw1IC04LDIgLTE2LDMgLTI0LDMgLTksMCAtMTgsMCAtMjgsMiAtNywxIC0xMywxIC0yMCwzIC05LDIgLTE5LDQgLTI4LDYgLTcsMSAtMTMsMSAtMjAsMiAtOSwxIC0xNyw0IC0yNSw4IC01LDMgLTksNiAtMTMsMTAgLTMsNCAtNiw3IC05LDEyIC0yLDIgLTMsNSAtNCw3IC0yLDIgLTMsMyAtNSw1IC0xLDIgLTMsMyAtNSw0IC0yLDEgLTQsMSAtNiwxIC00LDAgLTgsMCAtMTIsMCAtNywwIC0xMywwIC0yMCwwIC02LDAgLTEzLDAgLTE5LDAgLTUsMCAtMTAsMCAtMTUsLTEgLTUsLTEgLTEwLC0xIC0xNCwtMSAtOCwwIC0xNywtMSAtMjUsLTEgLTcsMCAtMTUsLTEgLTIyLC0xIC01LC0xIC0xMCwtMyAtMTUsLTQgLTcsLTIgLTE1LC0zIC0yMiwtMiAtOCwwIC0xNSwxIC0yMiwzIDAsMCAzLDIgMywyIHoiIC8+CgkJCTxwYXRoIHN0eWxlPSJmaWxsOiAjMDA1NWViOyBmaWxsLW9wYWNpdHk6IDE7IiBkPSJtIDQ0Myw1OTUgLTIxLC01IC0xNiwxNCAtMSwtMjEgLTE4LC0xMSAyMCwtOCA1LC0yMSAxMywxNiAyMSwtMiAtMTEsMTggeiIgLz4KCQkJPGNpcmNsZSBzdHlsZT0iZmlsbDogI2MwMGYwMDsgZmlsbC1vcGFjaXR5OiAxOyIgY3g9IjUyNiIgY3k9IjU0MCIgcj0iMjUiIC8+CgkJCTxwYXRoIHN0eWxlPSJmaWxsOiAjMDA1NWViOyBmaWxsLW9wYWNpdHk6IDE7IiBkPSJtIDY1MSw1MzEgLTI1LC00IC0xNywxOCAtNCwtMjUgLTIzLC0xMSAyMiwtMTIgMywtMjUgMTgsMTggMjUsLTUgLTExLDIyIHoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEwLCAxMSkiIC8+CgkJCTxjaXJjbGUgc3R5bGU9ImZpbGw6ICNjMDBmMDA7IGZpbGwtb3BhY2l0eTogMTsiIGN4PSIzMjIiIGN5PSI1NzIiIHI9IjI1IiAvPgoJCTwvZz4KCQk8ZyB0cmFuc2Zvcm09Im1hdHJpeCgtMC40OSwgMCwgMCwgMC40MywgMTQ5Ni43MywgMTMzLjkzKSI+CgkJCTxwYXRoIHN0eWxlPSJmaWxsOiAjMDAwMDAwOyBmaWxsLW9wYWNpdHk6IDEiIGQ9Im0gMTc3LDcxMiBjIC0xLC04IDEsLTE1IDMsLTIzIDIsLTUgMywtMTEgNiwtMTUgNywtNyAxNSwtMTMgMjIsLTIwIDYsLTQgMTMsLTkgMjAsLTEyIDQsLTEgNiwtMiAxMCwtMyA3LC0xIDE1LC0yIDIyLC0yIDYsMCAxMSwwIDE3LDAgNywwIDE0LDAgMjEsMSA1LDEgOSwxIDE0LDMgMiwxIDQsMiA2LDIgNSwyIDEwLDUgMTUsNyA5LDMgMTgsNiAyNyw5IDYsMiAxMiwzIDE4LDQgNCwxIDgsMSAxMSwxIDcsMSAxNSwyIDIzLDMgNywxIDE0LDEgMjEsMiA1LDAgMTEsMSAxNiwxIDMsMCA3LDAgMTAsMCA2LDAgMTEsMCAxNywwIDYsMCAxMiwtMSAxNywtMSA0LDAgNywtMSAxMSwtMiA1LC0yIDEwLC02IDE1LC05IDQsLTMgOSwtNSAxMywtOCAzLC0xIDUsLTMgOCwtNSA1LC00IDEwLC04IDE2LC0xMiAwLDAgLTMsLTIgLTMsLTIgdiAwIGMgLTUsNCAtMTAsOCAtMTYsMTIgLTIsMiAtNSw0IC04LDUgLTQsMyAtOSw1IC0xMyw4IC01LDMgLTEwLDcgLTE1LDkgLTMsMSAtNywyIC0xMSwyIC02LDEgLTExLDEgLTE3LDEgLTYsMCAtMTEsMCAtMTcsMCAtMywwIC03LDAgLTEwLDAgLTUsMCAtMTEsLTEgLTE2LC0xIC03LDAgLTE0LC0xIC0yMSwtMiAtOCwtMSAtMTUsLTIgLTIzLC0zIC00LC0xIC04LDAgLTExLC0xIC02LC0xIC0xMiwtMiAtMTgsLTQgLTksLTMgLTE4LC01IC0yNywtOSAtNSwtMiAtMTAsLTUgLTE1LC03IC0yLC0xIC00LC0yIC02LC0yIC00LC0xIC05LC0yIC0xNCwtMyAtNywtMSAtMTQsLTEgLTIxLC0xIC02LDAgLTExLDAgLTE3LDAgLTcsMCAtMTUsMCAtMjIsMiAtNCwxIC02LDEgLTEwLDMgLTcsMyAtMTQsOCAtMjAsMTIgLTgsNiAtMTYsMTMgLTIzLDIwIC0zLDQgLTQsMTAgLTYsMTUgLTIsNyAtNCwxNSAtNCwyMyAwLDAgMywyIDMsMiB6IiAvPgoJCQk8cGF0aCBzdHlsZT0iZmlsbDogI2E3MDBmZjsgZmlsbC1vcGFjaXR5OiAxIiBkPSJtIDI3Niw3OTAgLTQ5LC04IC0zNCwzNiAtOCwtNDkgLTQ1LC0yMSA0NCwtMjMgNiwtNDkgMzUsMzUgNDksLTkgLTIyLDQ0IHoiIHRyYW5zZm9ybT0ibWF0cml4KDAuNDgsIDAsIDAsIDAuNDYsIDEwNy4xOSwgMzMzLjIpIiAvPgoJCQk8Y2lyY2xlIHN0eWxlPSJmaWxsOiAjZmZiNjBkOyBmaWxsLW9wYWNpdHk6IDE7IHN0cm9rZS13aWR0aDogMTsiIGN4PSIyOTgiIGN5PSI2NTYiIHI9IjI1IiAvPgoJCQk8cGF0aCBzdHlsZT0iZmlsbDogI2ZmMWFhMDsgZmlsbC1vcGFjaXR5OiAxOyIgZD0ibSA0MjMsNjk2IC0yMywtMTAgLTIxLDEzIDIsLTI1IC0xOSwtMTYgMjQsLTYgOSwtMjMgMTMsMjEgMjUsMSAtMTYsMTkgeiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTAsIC0xMSkiIC8+CgkJCTxjaXJjbGUgc3R5bGU9ImZpbGw6ICMwMGNhZGM7IGZpbGwtb3BhY2l0eTogMTsiIGN4PSI1MTAiIGN5PSI2NjQiIHI9IjI2IiAvPgoJCTwvZz4KCTwvZz4KPC9zdmc+Cg=="},"buildInfo":{"for":"1580","version":1580,"when":1766238578420,"signer":"moduleSigner","critical":false,"bootOrder":"50","commonName":"pcos-wallpapers","friendlyNameRef":"WP_MODULE_NAME","signature":"c9c0473a37a781a17dc76b97b4b19a56129ea6377d94dac0dae6e5fb40dd22786265a4630377f14f1c7b88a64c00432c25fbdfcd9c81b99c3d3591210d4aee0b"}},"50-installer.fs":{"backend":{"files":{"apps":{"installer.js":"3bd52d3276b37c471b0de50f9d512953477a7fdc92a5a82ada4c64921320cd57310283bc046e05c14f08e8de6ffa41ee8bbbf23a2fcda61e90281298871bb354"},"etc":{"unattended.json.example":"e5e142af96dff5280de50365cdcf51b53485336223c1a08107b599399b8fe894591a4935f4c5b34a0ea482ec0841ce837a96226b3f34392708420ae45bbb2759"}},"permissions":{"apps/installer.js":{"world":"rx"},"apps/":{"world":"rx"},"etc/unattended.json.example":{"world":"rx"},"etc/":{"world":"rx"},"":{"world":"rx"}}},"files":{"3bd52d3276b37c471b0de50f9d512953477a7fdc92a5a82ada4c64921320cd57310283bc046e05c14f08e8de6ffa41ee8bbbf23a2fcda61e90281298871bb354":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: GET_LOCALE, GET_THEME, GET_BUILD, RUN_KLVL_CODE, LLDISK_WRITE, LLDISK_READ, FS_READ, FS_WRITE, FS_BYPASS_PERMISSIONS, FS_REMOVE, FS_LIST_PARTITIONS, SYSTEM_SHUTDOWN, FS_CHANGE_PERMISSION, LLDISK_LIST_PARTITIONS, FS_MOUNT, CSP_OPERATIONS, LLDISK_INIT_PARTITIONS, IPC_SEND_PIPE, GET_SERVER_URL, SET_USER_INFO, SET_DEFAULT_SYSTEM, RESOLVE_NAME, CONNFUL_CONNECT, CONNFUL_DISCONNECT, CONNFUL_WRITE, CONNFUL_READ, CONNFUL_ADDRESS_GET, CONNFUL_IDENTITY_GET, RELOAD_NETWORK_CONFIG, FETCH_SEND, GRAB_ATTENTION\n// signature: 6c15e3d81fb61f01b890282447d5051da74528fc9c5b260a45ab7da5bb222247c01487ef59d120e9a4f4dba753d932609dae72408a41d619590b6df94e5f9800\n// =====END MANIFEST=====\nlet onClose = () => availableAPIs.terminate();\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.closeability(false);\n\tlet networkDefaultURL = new URL(await availableAPIs.runningServer());\n\tnetworkDefaultURL.protocol = \"ws\" + (networkDefaultURL.protocol == \"https:\" ? \"s\" : \"\") + \":\";\n\tnetworkDefaultURL.pathname = \"\";\n\tconst networkSymbols = \"abcdefghijklmnopqrstuvwxyz0123456789_-\";\n\tlet automatic_configuration = {\n\t\t/* startInstall: true,\n\t\tacceptEULA: true,\n\t\tpartitioning: {\n\t\t\tdata: \"data\",\n\t\t\tboot: \"boot\",\n\t\t\tformat: true,\n\t\t\tautoInitNewInstalls: true\n\t\t},\n\t\tautoRestart: \"kexec\",\n\t\tdefaultLocale: \"en\",\n\t\textraModules: [ \"50-arcadeBreakout.fs\" ], */\n\t\tsecondstage: {\n\t\t\tnoReconfiguring: true,\n\t\t\tcreateAccount: {\n\t\t\t\t/*password: \"password\",\n\t\t\t\tdarkMode: true,\n\t\t\t\tcreate: true,*/\n\t\t\t\tusername: \"root\",\n\t\t\t\tlockUsername: true,\n\t\t\t\tonlyOnNewInstall: true\n\t\t\t},\n\t\t\tappHarden: {\n\t\t\t\trequireSignature: true,\n\t\t\t\trequireAllowlist: true\n\t\t\t},\n\t\t\tnetwork: {\n\t\t\t\turl: networkDefaultURL.toString(),\n\t\t\t\tucBits: 1,\n\t\t\t\thostname: new Array(16).fill(0).map(a => networkSymbols[Math.floor(Math.random() * networkSymbols.length)]).join(\"\"),\n\t\t\t\tupdates: \"pcosserver.pc\"\n\t\t\t},\n\t\t\treconnectToNetwork: false\n\t\t}\n\t};\n\ttry {\n\t\tautomatic_configuration = JSON.parse(await availableAPIs.fs_read({ path: (await availableAPIs.getSystemMount()) + \"/etc/unattended.json\" }));\n\t} catch {}\n\tdocument.body.style.fontFamily = \"'Segoe UI', Tahoma, Geneva, Verdana, sans-serif\";\n\tif (await availableAPIs.isDarkThemed()) document.body.style.color = \"white\";\n\tawait availableAPIs.windowTitleSet(await availableAPIs.lookupLocale(\"INSTALL_PCOS\"));\n\tlet privileges = await availableAPIs.getPrivileges();\n\tlet checklist = [ \"GET_BUILD\", \"RUN_KLVL_CODE\", \"LLDISK_WRITE\", \"LLDISK_READ\", \"FS_READ\", \"FS_WRITE\", \"FS_BYPASS_PERMISSIONS\", \"FS_REMOVE\", \"FS_LIST_PARTITIONS\", \"SYSTEM_SHUTDOWN\", \"FS_CHANGE_PERMISSION\", \"LLDISK_LIST_PARTITIONS\", \"FS_MOUNT\", \"CSP_OPERATIONS\", \"LLDISK_INIT_PARTITIONS\", \"GET_SERVER_URL\", \"RELOAD_NETWORK_CONFIG\", \"FETCH_SEND\" ];\n\tif (!checklist.every(p => privileges.includes(p))) return availableAPIs.terminate();\n\ttry {\n\t\tautomatic_configuration = JSON.parse(new TextDecoder().decode((await availableAPIs.fetchSend({\n\t\t\turl: \"https://pcos-autoconf.internal/installer\",\n\t\t\tinit: {}\n\t\t})).arrayBuffer));\n\t} catch {\n\t\ttry {\n\t\t\tautomatic_configuration = JSON.parse(new TextDecoder().decode((await availableAPIs.fetchSend({\n\t\t\t\turl: \"http://pcos-autoconf.internal/installer\",\n\t\t\t\tinit: {}\n\t\t\t})).arrayBuffer));\n\t\t} catch {}\n\t}\n\ttry {\n\t\tif (automatic_configuration.secondstage.network && automatic_configuration.secondstage.reconnectToNetwork) {\n\t\t\tawait availableAPIs.fs_write({\n\t\t\t\tpath: (await availableAPIs.getSystemMount()) + \"/etc/network.json\",\n\t\t\t\tdata: JSON.stringify(automatic_configuration.secondstage.network)\n\t\t\t});\n\t\t\tawait availableAPIs.reloadNetworkConfig();\n\t\t}\n\t} catch {}\n\tlet installed_modules = [\n\t\t\"50-bootable.fs\", \"50-core.fs\", \"00-keys.fs\", \"50-pcos-icons.fs\", \"50-pcos-sounds.fs\", \"50-pcos-wallpapers.fs\", \"50-sysadmin.fs\",\n\t\t\"50-terminal-disks.fs\", \"50-terminal-network.fs\", \"50-terminal-users.fs\", \"50-terminal.fs\", \"50-tweetnacl.fs\", \"50-xterm.fs\", \"50-blogBrowser.fs\",\n\t\t\"50-calculator.fs\", \"50-crypto-tools.fs\", \"50-multimedia.fs\"\n\t];\n\tif (automatic_configuration.extraModules) installed_modules.push(...automatic_configuration.extraModules);\n\tlet downloadFromBdpOnMissing = new URL(\"bdp://localhost\");\n\tdownloadFromBdpOnMissing.hostname = automatic_configuration.secondstage.network.updates;\n\tawait new Promise(async function(resolve) {\n\t\tlet locales = await availableAPIs.installedLocales();\n\t\tlet localeSelect = document.createElement(\"select\");\n\t\tlet localeZero = document.createElement(\"option\");\n\t\tlocaleZero.value = \"\";\n\t\tlocaleZero.innerText = \" 🌐 Language 🌐 \";\n\t\tlocaleZero.selected = true;\n\t\tlocaleZero.disabled = true;\n\t\tlocaleZero.hidden = true;\n\t\tlocaleSelect.appendChild(localeZero);\n\t\tfor (let locale of locales) {\n\t\t\tlet option = document.createElement(\"option\");\n\t\t\toption.value = locale;\n\t\t\toption.innerText = await availableAPIs.lookupOtherLocale({ key: \"LOCALE_NAME\", locale });\n\t\t\tlocaleSelect.appendChild(option);\n\t\t}\n\t\tlocaleSelect.addEventListener(\"change\", async function() {\n\t\t\tawait availableAPIs.runKlvlCode(\"modules.locales.defaultLocale = \" + JSON.stringify(localeSelect.value) + \";\");\n\t\t\tawait availableAPIs.setWinLocale(localeSelect.value);\n\t\t\tawait availableAPIs.setUILocale(localeSelect.value);\n\t\t\tinstalled_modules.push(\"50-locale-\" + localeSelect.value + \".fs\");\n\t\t\tawait availableAPIs.windowTitleSet(await availableAPIs.lookupLocale(\"INSTALL_PCOS\"));\n\t\t\tlocaleSelect.remove();\n\t\t\tawait availableAPIs.closeability(true);\n\t\t\tresolve();\n\t\t});\n\t\tif (automatic_configuration.defaultLocale) {\n\t\t\tlocaleSelect.value = automatic_configuration.defaultLocale;\n\t\t\tlocaleSelect.dispatchEvent(new Event(\"change\"));\n\t\t}\n\t\tdocument.body.appendChild(localeSelect);\n\t});\n\tif (exec_args[0]) onClose = async function() {\n\t\tmainInstallerContent.hidden = true;\n\t\tcloseContent.hidden = false;\n\t\tawait availableAPIs.closeability(false);\n\t}\n\tconst licenseText = `Copyright (c) 2024 PCsoft\nOriginal Source Code Repository: https://github.com/PC-trollbox/pcos3\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n---\nUsed libraries:\n\txterm.js:\n\t\tCopyright (c) 2017-2022, The xterm.js authors (https://github.com/xtermjs/xterm.js/graphs/contributors) (MIT License)\n\t\tCopyright (c) 2014-2017, SourceLair, Private Company (www.sourcelair.com) (MIT License)\n\t\tCopyright (c) 2012-2013, Christopher Jeffrey (MIT License)\n\ttweetnacl.js:\n\t\tPublic domain, https://github.com/dchest/tweetnacl-js\n\tfast-myers-diff (minified and modified):\n\t\tCopyright 2021 Logan R. Kearsley (https://github.com/gliese1337/fast-myers-diff)`;\n\tlet mainInstallerContent = document.createElement(\"div\");\n\tlet closeContent = document.createElement(\"div\");\n\tlet header = document.createElement(\"b\");\n\tlet postHeader = document.createElement(\"br\");\n\tlet description = document.createElement(\"span\");\n\tlet content = document.createElement(\"div\");\n\tlet button = document.createElement(\"button\");\n\tlet liveButton = document.createElement(\"button\");\n\tlet confirmDescription = document.createElement(\"p\");\n\tlet buttonYes = document.createElement(\"button\");\n\tlet buttonNo = document.createElement(\"button\");\n\n\tcloseContent.hidden = true;\n\n\tmainInstallerContent.style = \"position: absolute; top: 0; left: 0; width: 100%; height: 100%; padding: 8px; box-sizing: border-box;\";\n\tcloseContent.style = \"position: absolute; top: 0; left: 0; width: 100%; height: 100%; padding: 8px; box-sizing: border-box;\";\n\n\tconfirmDescription.innerText = await availableAPIs.lookupLocale(\"CLOSE_INSTALLER_CONFIRMATION\");\n\tbuttonYes.innerText = await availableAPIs.lookupLocale(\"YES\");\n\tbuttonNo.innerText = await availableAPIs.lookupLocale(\"NO\");\n\theader.innerText = await availableAPIs.lookupLocale(\"INSTALLER_TITLE\");\n\tdescription.innerText = (await availableAPIs.lookupLocale(\"INSTALLER_INVITATION\")).replace(\"%s\", await availableAPIs.getVersion());\n\tbutton.innerText = await availableAPIs.lookupLocale(\"INSTALL_BUTTON\");\n\tliveButton.innerText = await availableAPIs.lookupLocale(\"LIVE_BUTTON\");\n\n\tmainInstallerContent.appendChild(header);\n\tmainInstallerContent.appendChild(postHeader);\n\tmainInstallerContent.appendChild(description);\n\tmainInstallerContent.appendChild(content);\n\tmainInstallerContent.appendChild(button);\n\tmainInstallerContent.appendChild(document.createElement(\"br\"));\n\tif (exec_args[0]) mainInstallerContent.appendChild(liveButton);\n\n\tcloseContent.appendChild(confirmDescription);\n\tcloseContent.appendChild(buttonYes);\n\tcloseContent.insertAdjacentText(\"beforeend\", \" \");\n\tcloseContent.appendChild(buttonNo);\n\n\tdocument.body.appendChild(mainInstallerContent);\n\tdocument.body.appendChild(closeContent);\n\n\tbuttonNo.onclick = async function() {\n\t\tmainInstallerContent.hidden = false;\n\t\tcloseContent.hidden = true;\n\t\tawait availableAPIs.closeability(true);\n\t}\n\tbuttonYes.onclick = function() {\n\t\tonClose = () => availableAPIs.terminate();\n\t\tavailableAPIs.shutdown({\n\t\t\tisReboot: true\n\t\t});\n\t}\n\n\tbutton.onclick = async function() {\n\t\theader.remove();\n\t\tpostHeader.remove();\n\t\tliveButton.remove();\n\t\tcontent.innerHTML = \"\";\n\t\tdescription.innerText = await availableAPIs.lookupLocale(\"RIGHT_REVIEW\");\n\t\tlet textareaLicense = document.createElement(\"textarea\");\n\t\ttextareaLicense.readOnly = true;\n\t\ttextareaLicense.style.width = \"100%\";\n\t\ttextareaLicense.style.height = \"100%\";\n\t\tcontent.style.height = \"100%\";\n\t\ttextareaLicense.value = licenseText;\n\t\tcontent.appendChild(textareaLicense);\n\t\tbutton.innerText = await availableAPIs.lookupLocale(\"RIGHT_REVIEW_BTN\");\n\t\tbutton.onclick = async function() {\n\t\t\tcontent.innerHTML = \"\";\n\t\t\tcontent.style.height = \"\";\n\t\t\tdescription.innerText = await availableAPIs.lookupLocale(\"INSTALLER_PARTITIONING\");\n\t\t\tbutton.innerText = await availableAPIs.lookupLocale(\"PARTITIONING_USE\");\n\t\t\tlet partitionDataInput = document.createElement(\"input\");\n\t\t\tlet partitionDataFormat = document.createElement(\"button\");\n\t\t\tlet partitionBootInput = document.createElement(\"input\");\n\t\t\tpartitionDataInput.placeholder = await availableAPIs.lookupLocale(\"PARTITION_DATA\");\n\t\t\tpartitionDataFormat.innerText = await availableAPIs.lookupLocale(\"FORMAT_DATA\");\n\t\t\tpartitionBootInput.placeholder = await availableAPIs.lookupLocale(\"PARTITION_BOOT\");\n\t\t\tpartitionDataInput.value = \"data\";\n\t\t\tpartitionBootInput.value = \"boot\";\n\t\t\tcontent.appendChild(partitionDataInput);\n\t\t\tcontent.insertAdjacentText(\"beforeend\", \" \");\n\t\t\tcontent.appendChild(partitionDataFormat);\n\t\t\tcontent.appendChild(document.createElement(\"br\"));\n\t\t\tcontent.appendChild(partitionBootInput);\n\t\t\tlet initSyncEnd;\n\t\t\tlet initSync = new Promise(_ => initSyncEnd = _);\n\t\t\tpartitionDataFormat.onclick = async function() {\n\t\t\t\tif (!partitionDataInput.value) return await htmlAlert(await availableAPIs.lookupLocale(\"DATA_INPUT_ALERT\"));\n\t\t\t\tlet newInstall = false;\n\t\t\t\ttry {\n\t\t\t\t\tawait availableAPIs.lldaList();\n\t\t\t\t} catch {\n\t\t\t\t\tnewInstall = true;\n\t\t\t\t\tif (!automatic_configuration?.partitioning?.autoInitNewInstalls) \n\t\t\t\t\t\tif (!(await htmlConfirm(await availableAPIs.lookupLocale(\"PROMPT_PARTITION_TABLE\")))) return;\n\t\t\t\t\tawait availableAPIs.lldaInitPartitions();\n\t\t\t\t}\n\t\t\t\tlet confirmErasePart = true;\n\t\t\t\tif (!automatic_configuration?.partitioning?.format && !(automatic_configuration?.partitioning?.autoInitNewInstalls && newInstall))\n\t\t\t\t\tconfirmErasePart = await htmlConfirm(await availableAPIs.lookupLocale(\"CONFIRM_PARTITION_ERASE\"));\n\t\t\t\tif (confirmErasePart) {\n\t\t\t\t\tlet partData = await availableAPIs.lldaRead({ partition: partitionDataInput.value });\n\t\t\t\t\tlet partId;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpartId = partData.id;\n\t\t\t\t\t} catch {}\n\t\t\t\t\tif (!partId) partId = (await availableAPIs.cspOperation({\n\t\t\t\t\t\tcspProvider: \"basic\",\n\t\t\t\t\t\toperation: \"random\",\n\t\t\t\t\t\tcspArgument: new Uint8Array(64)\n\t\t\t\t\t})).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\")\n\t\t\t\t\tawait availableAPIs.lldaWrite({\n\t\t\t\t\t\tpartition: partitionDataInput.value,\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\tfiles: {},\n\t\t\t\t\t\t\tpermissions: {},\n\t\t\t\t\t\t\tid: partId\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tinitSyncEnd();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbutton.onclick = async function() {\n\t\t\t\tlet diskDataPartition = partitionDataInput.value;\n\t\t\t\tlet diskBootPartition = partitionBootInput.value;\n\t\t\t\tif (!diskDataPartition) return await htmlAlert(await availableAPIs.lookupLocale(\"DATA_INPUT_ALERT\"));\n\t\t\t\tif (!diskBootPartition) return await htmlAlert(await availableAPIs.lookupLocale(\"BOOT_INPUT_ALERT\"));\n\t\t\t\ttry {\n\t\t\t\t\tif (!(await availableAPIs.lldaList()).includes(diskDataPartition)) throw new Error();\n\t\t\t\t} catch {\n\t\t\t\t\treturn await htmlAlert(await availableAPIs.lookupLocale(\"CANNOT_FIND_PARTITION\"));\n\t\t\t\t}\n\n\t\t\t\tlet tempCopy = Object.keys((await availableAPIs.lldaRead({ partition: diskDataPartition })) || {});\n\t\t\t\tif (!tempCopy.includes(\"files\") || !tempCopy.includes(\"permissions\"))\n\t\t\t\t\tif (!(await htmlConfirm(await availableAPIs.lookupLocale(\"PCFS_DETECTION_ERROR\")))) return;\n\n\t\t\t\ttempCopy = null;\n\t\t\t\tcontent.innerHTML = \"\";\n\t\t\t\tbutton.hidden = true;\n\t\t\t\tlet isMigrated = false;\n\t\t\t\ttry {\n\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"MOUNTING_DATA_PARTITION\"));\n\t\t\t\t\tawait availableAPIs.fs_mount({\n\t\t\t\t\t\tmountpoint: \"target\",\n\t\t\t\t\t\tfilesystem: \"PCFSiDBMount\",\n\t\t\t\t\t\tfilesystemOptions: {\n\t\t\t\t\t\t\tpartition: diskDataPartition\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"REVIEWING_MIGRATION\"));\n\t\t\t\t\tlet targetListing = await availableAPIs.fs_ls({ path: \"target\" });\n\t\t\t\t\tif (targetListing.includes(\"apps\")) {\n\t\t\t\t\t\tlet targetListing = await availableAPIs.fs_ls({ path: \"target/apps\" });\n\t\t\t\t\t\tif (targetListing.includes(\"authui.js\")) {\n\t\t\t\t\t\t\tawait recursiveRemove(\"target/apps\");\n\t\t\t\t\t\t\tawait recursiveRemove(\"target/boot\");\n\t\t\t\t\t\t\tawait recursiveRemove(\"target/etc/wallpapers\");\n\t\t\t\t\t\t\tawait recursiveRemove(\"target/etc/icons\");\n\t\t\t\t\t\t\tawait recursiveRemove(\"target/etc/sounds\");\n\t\t\t\t\t\t\tawait recursiveRemove(\"target/etc/keys\");\n\t\t\t\t\t\t\tawait availableAPIs.fs_write({ path: \"target/.migration\", data: \"This file is for migration purposes\" });\n\t\t\t\t\t\t\tisMigrated = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(e);\n\t\t\t\t\tdescription.innerHTML = await availableAPIs.lookupLocale(\"INSTALLATION_FAILED\");\n\t\t\t\t\tawait availableAPIs.closeability(true);\n\t\t\t\t\tonClose = function() {\n\t\t\t\t\t\tonClose = () => availableAPIs.terminate();\n\t\t\t\t\t\tavailableAPIs.shutdown({\n\t\t\t\t\t\t\tisReboot: true\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t\tbutton.hidden = false;\n\t\t\t\tlet newInstall = true;\n\t\t\t\ttry {\n\t\t\t\t\tawait availableAPIs.fs_read({ path: \"target/etc/security/users\" });\n\t\t\t\t\tnewInstall = false;\n\t\t\t\t} catch {}\n\t\t\t\ttry {\n\t\t\t\t\tawait availableAPIs.fs_read({ path: \"target/.migration\" });\n\t\t\t\t\tisMigrated = true;\n\t\t\t\t} catch {}\n\t\t\t\tlet canSkip = (!newInstall) && automatic_configuration.secondstage.createAccount.onlyOnNewInstall;\n\t\t\t\tcontent.innerHTML = \"\";\n\t\t\t\tdescription.innerText = await availableAPIs.lookupLocale(\"LET_CREATE_ACCOUNT\");\n\t\t\t\tbutton.innerText = await availableAPIs.lookupLocale(\"CREATE\");\n\t\t\t\tlet useraccountname = document.createElement(\"input\");\n\t\t\t\tlet useraccountpassword = document.createElement(\"input\");\n\t\t\t\tlet darkmode = document.createElement(\"input\");\n\t\t\t\tlet darkmode_lb = document.createElement(\"label\");\n\t\t\t\tuseraccountname.placeholder = await availableAPIs.lookupLocale(\"USERNAME\");\n\t\t\t\tuseraccountpassword.placeholder = await availableAPIs.lookupLocale(\"PASSWORD\");\n\t\t\t\tuseraccountpassword.type = \"password\";\n\t\t\t\tdarkmode.type = \"checkbox\";\n\t\t\t\tdarkmode.id = \"darkmode\";\n\t\t\t\tdarkmode_lb.innerText = await availableAPIs.lookupLocale(\"DARK_MODE\");\n\t\t\t\tdarkmode_lb.htmlFor = \"darkmode\";\n\t\t\t\tcontent.appendChild(useraccountname);\n\t\t\t\tcontent.appendChild(document.createElement(\"br\"));\n\t\t\t\tcontent.appendChild(useraccountpassword);\n\t\t\t\tcontent.appendChild(document.createElement(\"br\"));\n\t\t\t\tcontent.appendChild(darkmode);\n\t\t\t\tcontent.appendChild(darkmode_lb);\n\t\t\t\tbutton.onclick = async function() {\n\t\t\t\t\tlet username = useraccountname.value;\n\t\t\t\t\tlet password = useraccountpassword.value;\n\t\t\t\t\tif (!username && !canSkip) return;\n\t\t\t\t\tif (username.includes(\"/\")) return;\n\t\t\t\t\tif (!password && !canSkip) return htmlAlert(await availableAPIs.lookupLocale(\"PASSWORD_INPUT_ALERT\"));\n\t\t\t\t\tlet homedir = username == \"root\" ? (\"target/root\") : (\"target/home/\" + username);\n\t\t\t\t\tlet darkModeChecked = darkmode.checked;\n\t\t\t\t\tcontent.innerHTML = \"\";\n\t\t\t\t\tbutton.hidden = true;\n\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"PLEASE_WAIT\"));\n\t\t\t\t\tawait availableAPIs.closeability(false);\n\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"CREATING_BOOT_PARTITION\"));\n\t\t\t\t\tawait availableAPIs.lldaWrite({\n\t\t\t\t\t\tpartition: diskBootPartition,\n\t\t\t\t\t\tdata: `\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst AsyncFunction = (async () => {}).constructor;\n\t\t\t\t\t\tlet pre_boot_part = coreExports.disk.partition(${JSON.stringify(diskDataPartition)}).getData();\n\t\t\t\t\t\tlet pre_boot_modules = pre_boot_part?.files;\n\t\t\t\t\t\tif (!pre_boot_modules) {\n\t\t\t\t\t\t\tcoreExports.tty_bios_api.println(\"No files were found in the storage partition\");\n\t\t\t\t\t\t\tthrow new Error(\"No files were found in the storage partition\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpre_boot_modules = pre_boot_modules[coreExports.bootSection || \"boot\"];\n\t\t\t\t\t\tif (!pre_boot_modules) {\n\t\t\t\t\t\t\tcoreExports.tty_bios_api.println(\"No boot modules were found\");\n\t\t\t\t\t\t\tthrow new Error(\"No boot modules were found\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet pre_boot_module_list = Object.keys(pre_boot_modules);\n\t\t\t\t\t\tpre_boot_module_list = pre_boot_module_list.sort((a, b) => a.localeCompare(b));\n\t\t\t\t\t\tlet pre_boot_module_script = \"\";\n\t\t\t\t\t\tfor (let module of pre_boot_module_list) {\n\t\t\t\t\t\t\tif (coreExports.bootMode == \"logboot\") pre_boot_module_script += \"coreExports.tty_bios_api.println(\" + JSON.stringify(module) + \");\\\\n\";\n\t\t\t\t\t\t\tpre_boot_module_script += await coreExports.idb.readPart(pre_boot_part.id + \"-\" + pre_boot_modules[module]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tawait new AsyncFunction(pre_boot_module_script)();\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tcoreExports.tty_bios_api.println(\"Boot failed\");\n\t\t\t\t\t\tcoreExports.tty_bios_api.println(\"Press Enter to continue and log this error locally\");\n\t\t\t\t\t\tawait coreExports.tty_bios_api.inputLine();\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t\t`});\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"CHANGING_ROOT_PERMISSIONS\"));\n\t\t\t\t\t\tawait availableAPIs.fs_chmod({ path: \"target\", newPermissions: \"rx\" });\n\t\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"COPYING_FOLDERS\"));\n\t\t\t\t\t\tlet moduleStatus = document.createElement(\"progress\");\n\t\t\t\t\t\tdescription.appendChild(document.createElement(\"br\"));\n\t\t\t\t\t\tdescription.appendChild(moduleStatus);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\trecursiveRemove(\"target/boot\");\n\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\trecursiveRemove(\"target/modules\");\n\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait availableAPIs.fs_mkdir({ path: \"target/modules\" });\n\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\tlet modules = await availableAPIs.fs_ls({ path: (await availableAPIs.getSystemMount()) + \"/modules\" });\n\t\t\t\t\t\tmoduleStatus.max = installed_modules.length;\n\t\t\t\t\t\tfor (let moduleIndex in installed_modules) {\n\t\t\t\t\t\t\tlet module = installed_modules[moduleIndex];\n\t\t\t\t\t\t\tif (!modules.includes(module)) {\n\t\t\t\t\t\t\t\tif (downloadFromBdpOnMissing) try {\n\t\t\t\t\t\t\t\t\tlet fetchModule = await bdpGet(new URL(\"/module_repository/\" + module, downloadFromBdpOnMissing));\n\t\t\t\t\t\t\t\t\tif (fetchModule.error) throw new Error(fetchModule.error);\n\t\t\t\t\t\t\t\t\tawait availableAPIs.fs_write({ path: \"target/modules/\" + module, data: fetchModule.content });\n\t\t\t\t\t\t\t\t\tmodules.push(module);\n\t\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\t\tconsole.error(\"Failed to fetch module\", module, \":\", e);\n\t\t\t\t\t\t\t\t\tthrow new Error(\"Module required (\" + module + \")\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse throw new Error(\"Module required (\" + module + \")\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tawait availableAPIs.fs_write({\n\t\t\t\t\t\t\t\t\tpath: \"target/modules/\" + module,\n\t\t\t\t\t\t\t\t\tdata: await availableAPIs.fs_read({\n\t\t\t\t\t\t\t\t\t\tpath: (await availableAPIs.getSystemMount()) + \"/modules/\" + module\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tmoduleStatus.value++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"CREATING_DIRECTORY_STRUCTURE\"));\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait availableAPIs.fs_mkdir({ path: \"target/apps\" });\n\t\t\t\t\t\t\tawait availableAPIs.fs_mkdir({ path: \"target/apps/associations\" });\n\t\t\t\t\t\t\tawait availableAPIs.fs_mkdir({ path: \"target/apps/links\" });\n\t\t\t\t\t\t\tawait availableAPIs.fs_mkdir({ path: \"target/boot\" });\n\t\t\t\t\t\t\tawait availableAPIs.fs_mkdir({ path: \"target/etc\" });\n\t\t\t\t\t\t\tawait availableAPIs.fs_mkdir({ path: \"target/etc/wallpapers\" });\n\t\t\t\t\t\t\tawait availableAPIs.fs_mkdir({ path: \"target/etc/icons\" });\n\t\t\t\t\t\t\tawait availableAPIs.fs_mkdir({ path: \"target/etc/sounds\" });\n\t\t\t\t\t\t\tawait availableAPIs.fs_mkdir({ path: \"target/etc/keys\" });\n\t\t\t\t\t\t\tawait availableAPIs.fs_mkdir({ path: \"target/etc/keys/khrl\" });\n\t\t\t\t\t\t\tawait availableAPIs.fs_mkdir({ path: \"target/etc/security\" });\n\t\t\t\t\t\t\tawait availableAPIs.fs_chmod({\n\t\t\t\t\t\t\t\tpath: \"target/etc/security\",\n\t\t\t\t\t\t\t\tnewPermissions: \"\"\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tawait availableAPIs.fs_mkdir({ path: \"target/root\" });\n\t\t\t\t\t\t\tawait availableAPIs.fs_mkdir({ path: \"target/home\" });\n\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"PATCHING_FS\"));\n\t\t\t\t\t\tlet systemCode = \"let localSystemMount = \\\".storage\\\";\\nlet mountOptions = {\\n\\tpartition: \" + JSON.stringify(diskDataPartition) + \"\\n};\\ntry {\\n\\tmodules.fs.mounts[localSystemMount] = await modules.mounts.PCFSiDBMount(mountOptions);\\n\\tmodules.defaultSystem = localSystemMount;\\n} catch (e) {\\n\\tawait panic(\\\"SYSTEM_PARTITION_MOUNTING_FAILED\\\", { underlyingJS: e, name: \\\"fs.mounts\\\", params: [localSystemMount, mountOptions]});\\n}\\n\";\n\t\t\t\t\t\tawait availableAPIs.fs_write({ path: \"target/boot/01-fsboot.js\", data: systemCode });\n\t\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"SETTING_LOCALE_PREFERENCE\"));\n\t\t\t\t\t\tawait availableAPIs.fs_write({ path: \"target/boot/06-localeset.js\", data: \"modules.locales.defaultLocale = \" + JSON.stringify(await availableAPIs.osLocale()) + \";\\n\" });\n\t\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"GENERATING_KERNEL\"));\n\t\t\t\t\t\tlet entireBoot = [];\n\t\t\t\t\t\tlet entireBootFiles = [];\n\t\t\t\t\t\tlet moduleConfig = { local: {} };\n\t\t\t\t\t\tlet bootFiles = await availableAPIs.fs_ls({ path: \"target/boot\" });\n\t\t\t\t\t\tif (bootFiles.includes(\"00-compiled.js\")) bootFiles.splice(bootFiles.indexOf(\"00-compiled.js\"), 1);\n\t\t\t\t\t\tif (bootFiles.includes(\"99-zzpatchfinisher.js\")) bootFiles.splice(bootFiles.indexOf(\"99-zzpatchfinisher.js\"), 1);\n\t\t\t\t\t\tfor (let bootFile of bootFiles) {\n\t\t\t\t\t\t\tentireBootFiles.push(bootFile);\n\t\t\t\t\t\t\tentireBoot.push([ bootFile, await availableAPIs.fs_read({\n\t\t\t\t\t\t\t\tpath: \"target/boot/\" + bootFile\n\t\t\t\t\t\t\t}) ]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmodules = (await availableAPIs.fs_ls({ path: \"target/modules\" })).sort((a, b) => a.localeCompare(b));\n\t\t\t\t\t\tfor (let module of modules) {\n\t\t\t\t\t\t\tlet moduleFile = JSON.parse(await availableAPIs.fs_read({ path: \"target/modules/\" + module }));\n\t\t\t\t\t\t\tmoduleConfig.local[module.split(\"-\").slice(1).join(\"-\").split(\".\").slice(0, -1).join(\".\")] = moduleFile.buildInfo;\n\t\t\t\t\t\t\tfor (let bootFile in (moduleFile.backend.files.boot || [])) {\n\t\t\t\t\t\t\t\tif (entireBootFiles.includes(bootFile)) continue;\n\t\t\t\t\t\t\t\tentireBoot.push([ bootFile, moduleFile.files[moduleFile.backend.files.boot[bootFile]] ]);\n\t\t\t\t\t\t\t\tentireBootFiles.push(bootFile);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tentireBoot = entireBoot.sort((a, b) => a[0].localeCompare(b[0]))\n\t\t\t\t\t\t\t.map(a => \"// modules/.../boot/\" + a[0] + \"\\n\" + a[1]).join(\"\\n\");\n\t\t\t\t\t\tawait availableAPIs.fs_write({ path: \"target/boot/00-compiled.js\", data: entireBoot + \"\\nreturn;/*\" });\n\t\t\t\t\t\tawait availableAPIs.fs_write({ path: \"target/boot/99-zzpatchfinisher.js\", data: \"*/\" });\n\t\t\t\t\t\tawait availableAPIs.fs_write({\n\t\t\t\t\t\t\tpath: \"target/etc/moduleConfig.json\",\n\t\t\t\t\t\t\tdata: JSON.stringify(moduleConfig)\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (!automatic_configuration.secondstage.noReconfiguring || newInstall) {\n\t\t\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"INSTALLING_SYSTEM_APPHARDEN\"));\n\t\t\t\t\t\t\tif (automatic_configuration.secondstage.appHarden) await availableAPIs.fs_write({\n\t\t\t\t\t\t\t\tpath: \"target/etc/appHarden\",\n\t\t\t\t\t\t\t\tdata: JSON.stringify(automatic_configuration.secondstage.appHarden)\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"INSTALLING_NET_CONF\"));\n\t\t\t\t\t\t\tif (automatic_configuration.secondstage.network) await availableAPIs.fs_write({\n\t\t\t\t\t\t\t\tpath: \"target/etc/network.json\",\n\t\t\t\t\t\t\t\tdata: JSON.stringify(automatic_configuration.secondstage.network)\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!canSkip) {\n\t\t\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"CREATING_USER_STRUCTURE\"));\n\t\t\t\t\t\t\tawait availableAPIs.fs_write({\n\t\t\t\t\t\t\t\tpath: \"target/etc/security/users\",\n\t\t\t\t\t\t\t\tdata: JSON.stringify({authui: {\n\t\t\t\t\t\t\t\t\tsecurityChecks: [],\n\t\t\t\t\t\t\t\t\tgroups: [\"authui\"],\n\t\t\t\t\t\t\t\t\thomeDirectory: \"system\",\n\t\t\t\t\t\t\t\t\tblankPrivileges: true,\n\t\t\t\t\t\t\t\t\tadditionalPrivilegeSet: [ \"IPC_SEND_PIPE\", \"GET_LOCALE\", \"GET_THEME\", \"ELEVATE_PRIVILEGES\", \"FS_READ\", \"FS_LIST_PARTITIONS\", \"CSP_OPERATIONS\" ]\n\t\t\t\t\t\t\t\t}})\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tawait availableAPIs.fs_chmod({ path: \"target/etc/security/users\", newPermissions: \"\" });\n\t\t\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"CREATING_USER\"));\n\t\t\t\t\t\t\tlet salt = await availableAPIs.cspOperation({\n\t\t\t\t\t\t\t\tcspProvider: \"basic\",\n\t\t\t\t\t\t\t\toperation: \"random\",\n\t\t\t\t\t\t\t\tcspArgument: new Uint8Array(64)\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tlet u8aToHex = (u8a) => Array.from(u8a).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\t\t\tlet key = await availableAPIs.cspOperation({\n\t\t\t\t\t\t\t\tcspProvider: \"basic\",\n\t\t\t\t\t\t\t\toperation: \"importKey\",\n\t\t\t\t\t\t\t\tcspArgument: {\n\t\t\t\t\t\t\t\t\tformat: \"raw\",\n\t\t\t\t\t\t\t\t\tkeyData: new TextEncoder().encode(password),\n\t\t\t\t\t\t\t\t\talgorithm: { name: \"PBKDF2\" },\n\t\t\t\t\t\t\t\t\textractable: false,\n\t\t\t\t\t\t\t\t\tkeyUsages: [\"deriveBits\", \"deriveKey\"]\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tlet derived = new Uint8Array(await availableAPIs.cspOperation({\n\t\t\t\t\t\t\t\tcspProvider: \"basic\",\n\t\t\t\t\t\t\t\toperation: \"deriveBits\",\n\t\t\t\t\t\t\t\tcspArgument: {\n\t\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\t\tname: \"PBKDF2\",\n\t\t\t\t\t\t\t\t\t\tsalt: salt,\n\t\t\t\t\t\t\t\t\t\titerations: 100000,\n\t\t\t\t\t\t\t\t\t\thash: \"SHA-256\"\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tbaseKey: key,\n\t\t\t\t\t\t\t\t\tlength: 256\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\tawait availableAPIs.cspOperation({ cspProvider: \"basic\", operation: \"unloadKey\", cspArgument: key });\n\t\t\t\t\t\t\tlet currentMount = await availableAPIs.getSystemMount();\n\t\t\t\t\t\t\tawait availableAPIs.setSystemMount(\"target\");\n\t\t\t\t\t\t\tawait availableAPIs.setUserInfo({\n\t\t\t\t\t\t\t\tdesiredUser: username,\n\t\t\t\t\t\t\t\tinfo: {\n\t\t\t\t\t\t\t\t\tsecurityChecks: [\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\ttype: \"pbkdf2\",\n\t\t\t\t\t\t\t\t\t\t\thash: u8aToHex(derived),\n\t\t\t\t\t\t\t\t\t\t\tsalt: u8aToHex(salt)\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t{ type: \"privrestrict\" }\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\tgroups: [ username, \"users\" ],\n\t\t\t\t\t\t\t\t\thomeDirectory: \"system\" + homedir.slice(6),\n\t\t\t\t\t\t\t\t\tblankPrivileges: false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tawait availableAPIs.setSystemMount(currentMount);\n\t\t\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"CREATING_USER_HOME\"));\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tawait availableAPIs.fs_mkdir({ path: homedir });\n\t\t\t\t\t\t\t\tawait availableAPIs.fs_chown({ path: homedir, newUser: username });\n\t\t\t\t\t\t\t\tawait availableAPIs.fs_chgrp({ path: homedir, newGrp: username });\n\t\t\t\t\t\t\t\tawait availableAPIs.fs_chmod({ path: homedir, newPermissions: \"rx\" });\n\t\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tawait availableAPIs.fs_mkdir({ path: homedir + \"/desktop\" });\n\t\t\t\t\t\t\t\tawait availableAPIs.fs_chown({ path: homedir + \"/desktop\", newUser: username });\n\t\t\t\t\t\t\t\tawait availableAPIs.fs_chgrp({ path: homedir + \"/desktop\", newGrp: username });\n\t\t\t\t\t\t\t\tawait availableAPIs.fs_chmod({ path: homedir + \"/desktop\", newPermissions: \"rx\" });\n\t\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (isMigrated) {\n\t\t\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"MIGRATING_USER_PROFILES\"));\n\t\t\t\t\t\t\tlet users = JSON.parse(await availableAPIs.fs_read({ path: \"target/etc/security/users\" }));\n\t\t\t\t\t\t\tfor (let user in users) \n\t\t\t\t\t\t\t\tif (users[user].homeDirectory.startsWith(\"storage\"))\n\t\t\t\t\t\t\t\t\tusers[user].homeDirectory = \"system\" + users[user].homeDirectory.slice(7);\n\t\t\t\t\t\t\tawait availableAPIs.fs_write({\n\t\t\t\t\t\t\t\tpath: \"target/etc/security/users\",\n\t\t\t\t\t\t\t\tdata: JSON.stringify(users)\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tawait availableAPIs.fs_rm({ path: \"target/.migration\" });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"INSTALLING_WP2U\"));\n\t\t\t\t\t\tlet wallpaperModule;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\twallpaperModule = JSON.parse(await availableAPIs.fs_read({ path: \"target/modules/50-pcos-wallpapers.fs\" }));\n\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\tif (wallpaperModule) {\n\t\t\t\t\t\t\tif (!canSkip) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tawait availableAPIs.fs_write({\n\t\t\t\t\t\t\t\t\t\tpath: homedir + \"/.wallpaper\",\n\t\t\t\t\t\t\t\t\t\tdata: wallpaperModule.files[wallpaperModule.backend.files.etc.wallpapers[\"pcos\" + (darkModeChecked ? \"-dark\" : \"\") + \"-beta.pic\"]]\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\tawait availableAPIs.fs_chown({ path: homedir + \"/.wallpaper\", newUser: username });\n\t\t\t\t\t\t\t\t\tawait availableAPIs.fs_chgrp({ path: homedir + \"/.wallpaper\", newGrp: username });\n\t\t\t\t\t\t\t\t\tawait availableAPIs.fs_chmod({ path: homedir + \"/.wallpaper\", newPermissions: \"rx\" });\n\t\t\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!automatic_configuration.secondstage.noReconfiguring || newInstall) {\n\t\t\t\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"INSTALLING_DARKMODE2L\"));\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tawait availableAPIs.fs_write({\n\t\t\t\t\t\t\t\t\t\tpath: \"target/etc/darkLockScreen\",\n\t\t\t\t\t\t\t\t\t\tdata: \"false\"\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"INSTALLING_WP2L\"));\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tawait availableAPIs.fs_write({\n\t\t\t\t\t\t\t\t\t\tpath: \"target/etc/wallpapers/lockscreen.pic\",\n\t\t\t\t\t\t\t\t\t\tdata: wallpaperModule.files[wallpaperModule.backend.files.etc.wallpapers[\"pcos-lock-beta.pic\"]]\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!canSkip) {\n\t\t\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"INSTALLING_DARKMODE\"));\n\t\t\t\t\t\t\tawait availableAPIs.fs_write({\n\t\t\t\t\t\t\t\tpath: homedir + \"/.darkmode\",\n\t\t\t\t\t\t\t\tdata: darkModeChecked.toString()\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tawait availableAPIs.fs_chown({ path: homedir + \"/.darkmode\", newUser: username });\n\t\t\t\t\t\t\tawait availableAPIs.fs_chgrp({ path: homedir + \"/.darkmode\", newGrp: username });\n\t\t\t\t\t\t\tawait availableAPIs.fs_chmod({ path: homedir + \"/.darkmode\", newPermissions: \"rx\" });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdescription.innerHTML = await availableAPIs.lookupLocale(\"INSTALLATION_SUCCESSFUL\");\n\t\t\t\t\t\tif (!automatic_configuration.autoRestart) await availableAPIs.closeability(true);\n\t\t\t\t\t\tonClose = function() {\n\t\t\t\t\t\t\tonClose = () => availableAPIs.terminate();\n\t\t\t\t\t\t\tavailableAPIs.shutdown({\n\t\t\t\t\t\t\t\tisReboot: true,\n\t\t\t\t\t\t\t\tisKexec: automatic_configuration.autoRestart == \"kexec\"\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (automatic_configuration.autoRestart) onClose();\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tconsole.error(e);\n\t\t\t\t\t\tdescription.innerHTML = await availableAPIs.lookupLocale(\"INSTALLATION_FAILED\");\n\t\t\t\t\t\tawait availableAPIs.closeability(true);\n\t\t\t\t\t\tonClose = function() {\n\t\t\t\t\t\t\tonClose = () => availableAPIs.terminate();\n\t\t\t\t\t\t\tavailableAPIs.shutdown({\n\t\t\t\t\t\t\t\tisReboot: true\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tuseraccountname.value = automatic_configuration.secondstage.createAccount.username || useraccountname.value;\n\t\t\t\tuseraccountpassword.value = automatic_configuration.secondstage.createAccount.password || \"\";\n\t\t\t\tdarkmode.checked = automatic_configuration.secondstage.createAccount.darkMode || darkmode.checked;\n\t\t\t\tuseraccountname.disabled = automatic_configuration.secondstage.createAccount.lockUsername;\n\t\t\t\tif (automatic_configuration.secondstage.createAccount.lockUsername) useraccountname.title = await availableAPIs.lookupLocale(\"PROVISIONED_PREFERENCE\");\n\t\t\t\tif (automatic_configuration.secondstage.createAccount.create || canSkip) button.click();\n\t\t\t}\n\t\t\tif (automatic_configuration.partitioning) {\n\t\t\t\tpartitionDataInput.value = automatic_configuration.partitioning.data || \"data\";\n\t\t\t\tpartitionBootInput.value = automatic_configuration.partitioning.boot || \"boot\";\n\t\t\t\tlet newInstall = false;\n\t\t\t\ttry { await availableAPIs.lldaList(); } catch { newInstall = true; }\n\t\t\t\tif (automatic_configuration.partitioning.format || (newInstall && automatic_configuration.partitioning.autoInitNewInstalls)) {\n\t\t\t\t\tpartitionDataFormat.click();\n\t\t\t\t\tawait initSync;\n\t\t\t\t}\n\t\t\t\tbutton.click();\n\t\t\t}\n\t\t}\n\t\tif (automatic_configuration.acceptEULA) button.click();\n\t}\n\tliveButton.onclick = async function() {\n\t\theader.remove();\n\t\tpostHeader.remove();\n\t\tliveButton.remove();\n\t\tcontent.innerHTML = \"\";\n\t\tdescription.innerText = await availableAPIs.lookupLocale(\"RIGHT_REVIEW\");\n\t\tlet textareaLicense = document.createElement(\"textarea\");\n\t\ttextareaLicense.readOnly = true;\n\t\ttextareaLicense.style.width = \"100%\";\n\t\ttextareaLicense.style.height = \"100%\";\n\t\tcontent.style.height = \"100%\";\n\t\ttextareaLicense.value = licenseText;\n\t\tcontent.appendChild(textareaLicense);\n\t\tbutton.innerText = await availableAPIs.lookupLocale(\"RIGHT_REVIEW_BTN\");\n\t\tbutton.onclick = async function() {\n\t\t\tcontent.innerHTML = \"\";\n\t\t\tcontent.style.height = \"\";\n\t\t\tawait availableAPIs.sendToPipe({\n\t\t\t\tpipe: exec_args[0],\n\t\t\t\tdata: true\n\t\t\t});\n\t\t\tawait availableAPIs.terminate();\n\t\t}\n\t}\n\tif (automatic_configuration.startInstall) button.click()\n})();\n\nasync function htmlAlert(msg) {\n\tlet overlay = document.createElement(\"div\");\n\tlet overlayingMessage = document.createElement(\"div\");\n\tlet description = document.createElement(\"span\");\n\tlet buttonAccept = document.createElement(\"button\");\n\toverlay.style = \"position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: black; opacity: 85%;\";\n\toverlayingMessage.style = \"position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; padding: 8px; box-sizing: border-box; color: white;\";\n\tdescription.innerText = msg;\n\tbuttonAccept.innerText = \"Ok\";\n\toverlayingMessage.appendChild(description);\n\toverlayingMessage.appendChild(document.createElement(\"hr\"));\n\toverlayingMessage.appendChild(buttonAccept);\n\tdocument.body.appendChild(overlay);\n\tdocument.body.appendChild(overlayingMessage);\n\treturn new Promise(function(resolve) {\n\t\tbuttonAccept.onclick = function() {\n\t\t\toverlay.remove();\n\t\t\toverlayingMessage.remove();\n\t\t\tresolve();\n\t\t}\n\t});\n}\n\nasync function htmlConfirm(msg) {\n\tlet overlay = document.createElement(\"div\");\n\tlet overlayingMessage = document.createElement(\"div\");\n\tlet description = document.createElement(\"span\");\n\tlet buttonAccept = document.createElement(\"button\");\n\tlet buttonDecline = document.createElement(\"button\");\n\toverlay.style = \"position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: black; opacity: 85%;\";\n\toverlayingMessage.style = \"position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; padding: 8px; box-sizing: border-box; color: white;\";\n\tdescription.innerText = msg;\n\tbuttonAccept.innerText = await availableAPIs.lookupLocale(\"YES\");\n\tbuttonDecline.innerText = await availableAPIs.lookupLocale(\"NO\");\n\toverlayingMessage.appendChild(description);\n\toverlayingMessage.appendChild(document.createElement(\"hr\"));\n\toverlayingMessage.appendChild(buttonAccept);\n\toverlayingMessage.appendChild(buttonDecline);\n\tdocument.body.appendChild(overlay);\n\tdocument.body.appendChild(overlayingMessage);\n\treturn new Promise(function(resolve) {\n\t\tbuttonAccept.onclick = function() {\n\t\t\toverlay.remove();\n\t\t\toverlayingMessage.remove();\n\t\t\tresolve(true);\n\t\t}\n\t\tbuttonDecline.onclick = function() {\n\t\t\toverlay.remove();\n\t\t\toverlayingMessage.remove();\n\t\t\tresolve(false);\n\t\t}\n\t});\n}\n\nasync function recursiveCopy(source, destination, permissions) {\n\tfor (let sourceFile of await availableAPIs.fs_ls({ path: source })) {\n\t\tlet destinationFile = destination + \"/\" + sourceFile;\n\t\tif (await availableAPIs.fs_isDirectory({ path: source + \"/\" + sourceFile })) {\n\t\t\ttry {\n\t\t\t\tawait availableAPIs.fs_mkdir({ path: destinationFile });\n\t\t\t} catch {}\n\t\t\tawait recursiveCopy(source + \"/\" + sourceFile, destinationFile, permissions);\n\t\t} else {\n\t\t\tawait availableAPIs.fs_write({\n\t\t\t\tpath: destinationFile,\n\t\t\t\tdata: await availableAPIs.fs_read({ path: source + \"/\" + sourceFile })\n\t\t\t});\n\t\t}\n\t\tif (permissions) {\n\t\t\tlet originalPermissions = await availableAPIs.fs_permissions({ path: source + \"/\" + sourceFile });\n\t\t\tawait availableAPIs.fs_chmod({ path: destinationFile, newPermissions: originalPermissions.world });\n\t\t\tawait availableAPIs.fs_chgrp({ path: destinationFile, newGrp: originalPermissions.group });\n\t\t\tawait availableAPIs.fs_chown({ path: destinationFile, newUser: originalPermissions.owner });\n\t\t}\n\t}\n}\n\nasync function recursiveRemove(target) {\n\tfor (let targetFile of await availableAPIs.fs_ls({ path: target })) {\n\t\ttargetFile = target + \"/\" + targetFile;\n\t\tif (await availableAPIs.fs_isDirectory({ path: targetFile })) await recursiveRemove(targetFile);\n\t\tawait availableAPIs.fs_rm({ path: targetFile });\n\t}\n}\n\nasync function bdpGet(path) {\n\tlet url = new URL(path);\n\tif (url.protocol != \"bdp:\") throw new Error(await availableAPIs.lookupLocale(\"BLOG_BROWSER_PROTO\"));\n\tif (url.port) throw new Error(await availableAPIs.lookupLocale(\"BLOG_BROWSER_GATESET\"));\n\tlet hostname = url.hostname, address;\n\tif (url.hostname.includes(\"[\")) {\n\t\thostname = IPv6Decompressor(url.hostname.slice(1, -1)).replaceAll(\":\", \"\");\n\t\taddress = hostname;\n\t} else address = await availableAPIs.resolve(hostname);\n\tif (!address) throw new Error(await availableAPIs.lookupLocale(\"HOSTNAME_RESOLUTION_FAILED\"));\n\tlet connection = await availableAPIs.connfulConnect({\n\t\tgate: url.username || \"blog\",\n\t\taddress,\n\t\tverifyByDomain: hostname\n\t});\n\tawait availableAPIs.connfulConnectionSettled(connection);\n\tawait availableAPIs.connfulWrite({\n\t\tconnectionID: connection,\n\t\tdata: new TextEncoder().encode(url.pathname + url.search),\n\t\thost: hostname\n\t});\n\tlet data = new TextDecoder().decode(await availableAPIs.connfulRead(connection));\n\tdata = JSON.parse(data);\n\tlet chunks = [];\n\twhile (chunks.length != data.length) {\n\t\tlet newData = new TextDecoder().decode(await availableAPIs.connfulRead(connection));\n\t\tnewData = JSON.parse(newData);\n\t\tchunks[newData.ctr] = newData.chunk;\n\t}\n\ttry {\n\t\tawait availableAPIs.connfulDisconnect(connection);\n\t} catch {}\n\treturn { ...data, content: chunks.join(\"\") };\n}\n\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) onClose();\n}); ","e5e142af96dff5280de50365cdcf51b53485336223c1a08107b599399b8fe894591a4935f4c5b34a0ea482ec0841ce837a96226b3f34392708420ae45bbb2759":"{\n\t\"startInstall\": true,\n\t\"acceptEULA\": true,\n\t\"partitioning\": {\n\t\t\"data\": \"data\",\n\t\t\"boot\": \"boot\",\n\t\t\"format\": true,\n\t\t\"autoInitNewInstalls\": true\n\t},\n\t\"autoRestart\": \"kexec\",\n\t\"defaultLocale\": \"en\",\n\t\"extraModules\": [ \"50-arcadeBreakout.fs\" ],\n\t\"secondstage\": {\n\t\t\"noReconfiguring\": true,\n\t\t\"createAccount\": {\n\t\t\t\"password\": \"password\",\n\t\t\t\"darkMode\": true,\n\t\t\t\"create\": true,\n\t\t\t\"username\": \"root\",\n\t\t\t\"lockUsername\": true,\n\t\t\t\"onlyOnNewInstall\": true\n\t\t},\n\t\t\"appHarden\": {\n\t\t\t\"requireSignature\": true,\n\t\t\t\"requireAllowlist\": true\n\t\t},\n\t\t\"network\": {\n\t\t\t\"url\": \"wss://pcos3.pcprojects.tk\",\n\t\t\t\"ucBits\": 1,\n\t\t\t\"hostname\": \"installedsys\",\n\t\t\t\"updates\": \"pcosserver.pc\"\n\t\t}\n\t}\n}"},"buildInfo":{"for":"1580","version":1580,"when":1766238578394,"signer":"moduleSigner","critical":false,"bootOrder":"50","commonName":"installer","friendlyNameRef":"INSTALLER_TITLE","signature":"82457298edbd374e46daf2e4d723ff8170d25c52424858099ae4459ef175dc8b4c9f98a3fff0dae3a40deb665211f80b084bc03fc42285b81dc4b9b5738b2407"}},"50-installer-modules.fs":{"backend":{"files":{"etc":{"appHarden":"318fd6a1f09a3ade6f15e576326c01e7f573cc45a995adbc0d470dd3f2e365c0531ec5fa64c9c347bcd7efe905c1733bf6881bea8e35fd2e6774fb38ef304e62","security":{"automaticLogon":"302dc7b73178a35b3ebcb8551dcc74e5e4b5e51d7bf0f8e22f5ac15e7e397060efc2c4e771bf95f97cba6271b77a768b3679c57fcf96dc14fa3d834b2fae7ac4","users":"1ca13f6b70b67aa390a93cda059767e41fcadc9cdec7f304f0d2a04309614d87b4b7bae4b393dbea594cded78228b5da407820a09554376ec6b7b5a0b5fcf254"},"wallpapers":{"lockscreen.pic":"f797fd93c7546a815e94946e3147f8244b06a304abf9cb134b647af792f6c5abc6142119c8a23a2b532031022166f91cee6b806578bf4daa7443271f32c860e3"}},"root":{".autorunNecessity":{"installer.lnk":"7c45c176c6f0ed707451024a5d2753c08b2200a9dbb984c78f53b127adbaa52f31004441c264bd7a2edfc5e52fa566f28e311cce09a04624ed4237a99a425bdf"},".darkmode":"d8b0220059fc3b5da4f33bb08e945fc73c7a943aeb388c0d701e4f34b9afdf49dcdd700a3855911bcd5487f607c66360e7fb57d2eed0937b91ef546e4f653739",".wallpaper":"2a772f323c91ae46c3692bf95d17537c3b20e222449141473e8c7184da640bddfb9874d8bda4fa6b5f91c8f1220afea1a8686d4c166cf5474e20ddd40b956af6","desktop":{"installer.lnk":"88437484df806d145af3017205ac9b3008df1255d27f0f3c133d6f6222e3a0d6bdb60f4c1b6c03c88b343bfbe8792046f657fb43bf5a1cb4b1c6aca989abe976"}}},"permissions":{"etc/appHarden":{"world":"rx"},"etc/security/automaticLogon":{"world":"rx"},"etc/security/users":{"world":"rx"},"etc/security/":{"world":"rx"},"etc/wallpapers/lockscreen.pic":{"world":"rx"},"etc/wallpapers/":{"world":"rx"},"etc/":{"world":"rx"},"root/.autorunNecessity/installer.lnk":{"world":"rx"},"root/.autorunNecessity/":{"world":"rx"},"root/.darkmode":{"world":"rx"},"root/.wallpaper":{"world":"rx"},"root/desktop/installer.lnk":{"world":"rx"},"root/desktop/":{"world":"rx"},"root/":{"world":"rx"},"":{"world":"rx"}}},"files":{"318fd6a1f09a3ade6f15e576326c01e7f573cc45a995adbc0d470dd3f2e365c0531ec5fa64c9c347bcd7efe905c1733bf6881bea8e35fd2e6774fb38ef304e62":"{\"requireSignature\":true,\"requireAllowlist\":true}","302dc7b73178a35b3ebcb8551dcc74e5e4b5e51d7bf0f8e22f5ac15e7e397060efc2c4e771bf95f97cba6271b77a768b3679c57fcf96dc14fa3d834b2fae7ac4":"root","1ca13f6b70b67aa390a93cda059767e41fcadc9cdec7f304f0d2a04309614d87b4b7bae4b393dbea594cded78228b5da407820a09554376ec6b7b5a0b5fcf254":"{\n\t\"root\": {\n\t\t\"securityChecks\": [ { \"type\": \"timeout\", \"timeout\": 0 } ],\n\t\t\"groups\": [\"root\"],\n\t\t\"homeDirectory\": \"system/root\"\n\t},\n\t\"authui\": {\n\t\t\"securityChecks\": [],\n\t\t\"groups\": [\"authui\"],\n\t\t\"homeDirectory\": \"system\",\n\t\t\"blankPrivileges\": true,\n\t\t\"additionalPrivilegeSet\": [ \"IPC_SEND_PIPE\", \"GET_LOCALE\", \"GET_THEME\", \"ELEVATE_PRIVILEGES\", \"FS_READ\", \"FS_LIST_PARTITIONS\", \"CSP_OPERATIONS\" ]\n\t}\n}","f797fd93c7546a815e94946e3147f8244b06a304abf9cb134b647af792f6c5abc6142119c8a23a2b532031022166f91cee6b806578bf4daa7443271f32c860e3":"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTkyMCIgaGVpZ2h0PSIxMDgwIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+Cgk8ZGVmcz4KCQk8bGluZWFyR3JhZGllbnQgaWQ9IkJnR3JhZGllbnQiIHgxPSIwIiB4Mj0iMCIgeTE9IjAiIHkyPSIxIj4KCQkJPHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iIzAwYmZmZiIgLz4KCQkJPHN0b3Agb2Zmc2V0PSI1MCUiIHN0b3AtY29sb3I9IiNhNzAwZmYiIC8+CgkJCTxzdG9wIG9mZnNldD0iMTAwJSIgc3RvcC1jb2xvcj0iIzAwMDAwMCIgLz4KCQk8L2xpbmVhckdyYWRpZW50PgoJPC9kZWZzPgoJPGc+CgkJPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjE5MjAiIGhlaWdodD0iMTA4MCIgZmlsbD0idXJsKCNCZ0dyYWRpZW50KSIgLz4KCQk8dGV4dCB4PSI4MDAiIHk9IjIwMCIgY2xhc3M9InNlZ29lZm9udCIgZmlsbD0iIzAwMDAwMCIgZm9udC1zaXplPSI3MnB4IiBmb250LXdlaWdodD0iYm9sZCI+UENPUyAzPC90ZXh0PgoJCTx0ZXh0IHg9Ijg2MCIgeT0iMjQwIiBjbGFzcz0ic2Vnb2Vmb250IiBmaWxsPSIjNDA0MDQwIiBmb250LXNpemU9IjM2cHgiPmxvY2tlZDwvdGV4dD4KCQk8dGV4dCB4PSIxNTU1IiB5PSIxMDUwIiBjbGFzcz0ic2Vnb2Vmb250IiBmaWxsPSIjNDA0MDQwIiBmb250LXNpemU9IjcycHgiIGZvbnQtd2VpZ2h0PSJib2xkIj50ZXN0IGJ1aWxkPC90ZXh0PgoJPC9nPgoJPHN0eWxlPgoJCS5zZWdvZWZvbnQgewoJCQlmb250LWZhbWlseTogJ1NlZ29lIFVJJywgVGFob21hLCBHZW5ldmEsIFZlcmRhbmEsIHNhbnMtc2VyaWY7CgkJfQoJPC9zdHlsZT4KPC9zdmc+Cg==","7c45c176c6f0ed707451024a5d2753c08b2200a9dbb984c78f53b127adbaa52f31004441c264bd7a2edfc5e52fa566f28e311cce09a04624ed4237a99a425bdf":"{\"localeReferenceName\":\"INSTALLER_TITLE\",\"path\":\"system/apps/installer.js\"}","d8b0220059fc3b5da4f33bb08e945fc73c7a943aeb388c0d701e4f34b9afdf49dcdd700a3855911bcd5487f607c66360e7fb57d2eed0937b91ef546e4f653739":"false","2a772f323c91ae46c3692bf95d17537c3b20e222449141473e8c7184da640bddfb9874d8bda4fa6b5f91c8f1220afea1a8686d4c166cf5474e20ddd40b956af6":"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTkyMCIgaGVpZ2h0PSIxMDgwIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+Cgk8ZGVmcz4KCQk8bGluZWFyR3JhZGllbnQgaWQ9IkJnR3JhZGllbnQiIHgxPSIwIiB4Mj0iMCIgeTE9IjAiIHkyPSIxIj4KCQkJPHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iIzAwYmZmZiIgLz4KCQkJPHN0b3Agb2Zmc2V0PSIxMDAlIiBzdG9wLWNvbG9yPSIjYTcwMGZmIiAvPgoJCTwvbGluZWFyR3JhZGllbnQ+Cgk8L2RlZnM+Cgk8Zz4KCQk8cmVjdCB4PSIwIiB5PSIwIiB3aWR0aD0iMTkyMCIgaGVpZ2h0PSIxMDgwIiBmaWxsPSJ1cmwoI0JnR3JhZGllbnQpIiAvPgoJCTx0ZXh0IHg9IjM1IiB5PSIxNTAiIGNsYXNzPSJzZWdvZWZvbnQiIGZpbGw9IiNmZmZmZmYiPlBDT1MgMzwvdGV4dD4KCQk8dGV4dCB4PSIxNTU1IiB5PSIxMDMwIiBjbGFzcz0ic2Vnb2Vmb250IiBmaWxsPSIjMzAzMDMwIj50ZXN0IGJ1aWxkPC90ZXh0PgoJPC9nPgoJPHN0eWxlPgoJCS5zZWdvZWZvbnQgewoJCQlmb250LWZhbWlseTogJ1NlZ29lIFVJJywgVGFob21hLCBHZW5ldmEsIFZlcmRhbmEsIHNhbnMtc2VyaWY7CgkJCWZvbnQtc2l6ZTogNjRweDsKCQkJZm9udC13ZWlnaHQ6IGJvbGQ7CgkJfQoJPC9zdHlsZT4KPC9zdmc+Cg==","88437484df806d145af3017205ac9b3008df1255d27f0f3c133d6f6222e3a0d6bdb60f4c1b6c03c88b343bfbe8792046f657fb43bf5a1cb4b1c6aca989abe976":"{\"localeReferenceName\":\"INSTALLER_TITLE\",\"path\":\"system/apps/installer.js\"}"},"buildInfo":{"for":"1580","version":1580,"when":1766238578391,"signer":"moduleSigner","critical":false,"bootOrder":"50","commonName":"installer-modules","friendlyNameRef":"INSTFILES_MODULE_NAME","signature":"abf26e3f336f35bba818d5e3e5fabeefacd16a05f303a34c509dabdd1e1f0285da416a04570108bd07cb3d0a1f4bb26a748b24f734cf26e99287d749551a3209"}}};
coreExports.tty_bios_api.println("Booting from module bundle");
let entireBoot = [];
const AsyncFunction = (async () => {}).constructor;
for (let installerModule in installerModuleBundle) {
	let reviewingModule = installerModuleBundle[installerModule];
	if (reviewingModule.backend.files.boot) {
		for (let bootFile in reviewingModule.backend.files.boot) {
			entireBoot.push([ bootFile, reviewingModule.files[reviewingModule.backend.files.boot[bootFile]] ]);
		}
	}
}
entireBoot.push(["01-fsmodule-pre.js", 'modules.fs.mounts[".installer"]=modules.mounts.ramMount({});modules.defaultSystem=".installer";modules.fs.mkdir(".installer/modules");modules.fs.mkdir(".installer/etc");let networkDefaultURL=new URL(location.origin);networkDefaultURL.protocol="ws"+(networkDefaultURL.protocol=="https:"?"s":"")+":";networkDefaultURL.pathname="";modules.fs.write(".installer/etc/network.json",JSON.stringify({url:networkDefaultURL.toString(),ucBits:1,updates:"pcosserver.pc"}));']);
entireBoot.push(["01-fsmodule-start.js", 'let installerModuleBundle = ' + JSON.stringify(installerModuleBundle) + '; for (let installerModule in installerModuleBundle) { await modules.fs.write(".installer/modules/" + installerModule, JSON.stringify(installerModuleBundle[installerModule])); }; modules.fs.write(".installer/etc/moduleConfig.json", JSON.stringify({ local: Object.fromEntries(Object.entries(installerModuleBundle).map(a => [a[0].split("-").slice(1).join("-").split(".").slice(0, -1).join("."), a[1].buildInfo])) }));']);
entireBoot = entireBoot.sort((a, b) => a[0].localeCompare(b[0])).map(a => a[1]).join("\n");
return new AsyncFunction(entireBoot)();