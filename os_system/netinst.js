// This is a generated file after netinst transform. Please modify the corresponding files, not this file directly.
// (c) Copyright 2025 PCsoft. MIT license: https://spdx.org/licenses/MIT.html
let installerModuleBundle = {"00-keys.fs":{"backend":{"files":{"etc":{"keys":{"automaticSigner":"2e8c13acfb342520ff2ef04a35b97936e88c4e1fe55f59a459918f50ac2dc432bcb0148b4f7af684fadc1a4bcd1b2f1f296af70d0b4c99b3efb3786aecc2c69a","khrl":{"list.khrl":"c90bf8bedd4d23fdfad8f8cefe7266d673d45765bee283a66f7f111a35403a1f4ab4b589886ed9d61245b68ae7037e8e3d1b22081507428cdf17a51c86df05fc"},"moduleSigner":"e00ce12890bc89a3c833b996a9c791390b927c099302ed45f533e09e89a02891214dcfe584eeab50a165a55003277fc2670044d63afe9a6ffd3246338c23ac14","pcosIntermediate":"a6d605e929be2eb718c4d117dc4b767de0d8a5f288f2cdc9699ff39c88246da40879d85eeb126066b4cfd0bbdd294bf8265fa874e1b456b6390d48cdf072c1a9"}}},"permissions":{"etc/keys/automaticSigner":{"world":"rx"},"etc/keys/khrl/list.khrl":{"world":"rx"},"etc/keys/khrl/":{"world":"rx"},"etc/keys/moduleSigner":{"world":"rx"},"etc/keys/pcosIntermediate":{"world":"rx"},"etc/keys/":{"world":"rx"},"etc/":{"world":"rx"},"":{"world":"rx"}}},"files":{"2e8c13acfb342520ff2ef04a35b97936e88c4e1fe55f59a459918f50ac2dc432bcb0148b4f7af684fadc1a4bcd1b2f1f296af70d0b4c99b3efb3786aecc2c69a":"{\"signature\":\"5c5c6fd48cdd24b27202f2a0a790583db2100a98f5cca5116ce83ab17ba4bddd995789e5d070d48f163d3ae48a9b9db1e4111d63df4ded2fc03122e64dd1af0c\",\"keyInfo\":{\"key\":{\"crv\":\"Ed25519\",\"x\":\"_HNsnL890zN3JRAnsCsuY7ylCMDc5_TRv3ka8R1v0Xc\",\"kty\":\"OKP\"},\"usages\":[\"appTrust\"],\"signedBy\":\"pcosIntermediate\"}}","c90bf8bedd4d23fdfad8f8cefe7266d673d45765bee283a66f7f111a35403a1f4ab4b589886ed9d61245b68ae7037e8e3d1b22081507428cdf17a51c86df05fc":"{\"list\":[],\"signature\":\"db1cf22f8dd93d745fb81b49f84349ac6ff7cec7b3d2b223ece67c5c125a69084435eddacbb0c8aa3c1b3ce7d5215d55264b08b5a1f6fe5d36581da855508a09\"}","e00ce12890bc89a3c833b996a9c791390b927c099302ed45f533e09e89a02891214dcfe584eeab50a165a55003277fc2670044d63afe9a6ffd3246338c23ac14":"{\"signature\":\"f77ae544e4a2b06df0ff29daf91529f9dc171381533f83f00718ecfd58fec64357f41f05b381106af14aca42555e8b5d04409d6d39b8b2a06c6451691fe8e709\",\"keyInfo\":{\"key\":{\"crv\":\"Ed25519\",\"x\":\"B37OlkJK3rhgF90Vb8k1ZHH9mPFJvBiiw1d65kOMGtw\",\"kty\":\"OKP\"},\"usages\":[\"moduleTrust\"],\"signedBy\":\"pcosIntermediate\"}}","a6d605e929be2eb718c4d117dc4b767de0d8a5f288f2cdc9699ff39c88246da40879d85eeb126066b4cfd0bbdd294bf8265fa874e1b456b6390d48cdf072c1a9":"{\"signature\":\"495297498a49528b3c7d1cc43173825eac2b3bd4ede5744864e1ba542b8cedd742141b50dd8acbdcaea8b65b564fc70dc801a44891cfa4ee5e5e92a120f4ee01\",\"keyInfo\":{\"key\":{\"crv\":\"Ed25519\",\"x\":\"qKoTLfZH16PqwOKEnll19B7lDp3tEjeyCXBzGIhGwNY\",\"kty\":\"OKP\"},\"usages\":[\"keyTrust\"]}}"},"buildInfo":{"for":"1332","version":"1332","when":1751657439206,"critical":true,"bootOrder":"00","signature":"812cc42c421e19364a37482757357ba437cab660f4fb90ba7d580c75cde0c6253464a21ab9e46b9eaf43a6203ab83155c477428a9bd5e6948bd171833a17d30b"}},"50-bootable.fs":{"backend":{"files":{"boot":{"00-pcos.js":"88c58106c1483f375397f9e0316d852ff216f8ff2938468f538717ee66fa5b264d8ec25f801479c9af4467f2360cd98c8a7618138cd9e21daa6cb35b2f228264","00-pcosksk.js":"329d6bee9e622d8d87ad4027522221ec0bed85a46275fea165bc40e1d929398619ae5d0783d30d19bb93e1354a9b9e33194925c81f61e0276e45effa7ed71457","01-fs.js":"f7304cf6c7bcd481025e22d53557c00a34d5d110adddf36d0bde4d99c9931edfb6ae7559aec41025dc01b37abe8cd0e35bd2ade0a0efbc43d9b5997604c3a678","01-fsck.js":"0bb34dc17a7c39dbab94bedacc9988560c8cbe199836d0ab9fa023e4cf5238a38f79884f343a023eecbba159631772215b7c045cacf632b03552ae9fafb468c6","01-fsmodules.js":"a9d74077f325347dd475e0b3c0c23562473952a043ee922a1e9a0effa7f355c38b8604cac073eb27489c7768877702dac124112a6d5523d76adecb36d3450aaf","02-ui.js":"af2268b91223e49ab4a25f15b525b70df5b3ed78035c36c9391daee06f2b4b531159b0f5347070bf94e50ba361a4707eab795308bb4e026dc0baf757c3cb8d9d","04-ipc.js":"853f5b3e40526a7b3d87eeee411205a4d47f9a5b71020f85542c15856b212453e0f71c78766516b7412e3ca91518449d4ac9dcd08367b2b2f38846b1bd849620","04-websockets.js":"348c0e602bce147be27b1a7e08bc5356f50123e4a225d4eab8495acf287dd9e98a946793991fdb69589a46a7e073ae60314682821ad85ca10cd15929c65d2798","05-lull.js":"c6bc8117f8dc7bc508f22bf59fc56e73ca4cd9c6b5255b408339b3ea5ea1a39329f33c8b497322f45ea48ee790c5afe572a0f883ae39d275da6e2a15859c8e40","05-network.js":"31269ce496a9b4cb2d671d97813258780914cd120a395243f37b80c2388c46c7924284e3e2fb73c1f15d1168554bd625e3ec9b027238cd8cc6d293f3581e7284","05-reeapis.js":"149411fdbbac9a38b24b20526f9fe633ab0fa5274297e162cb8315f70b8ee755c306ffab8f43fde05ffbfcc9a6e0e65c160b64c0968d9deff115b8f1a3e6123b","06-csp.js":"e7a389e08616d0e6a6b99bf803e6b9f8ad8e20dc95e09f921dbf6136845d9153b19a84e77759fb8635c95a1ec2a412ac312141301598af4dbe9a655340c818d4","06-locales.js":"7427d399bccacdf82c101735500f98e5cbdc6c05df4c535abea8b16a4cfe721d367bef0cae609b056568065a54a24cf43b1b8e7b718f5025e6a5a8b0e182dfc9","07-tasks.js":"8caaf50a5c53eb57b9ca3e54ae103c0160133d4b4c0c0ae61f2754aad98673b95e6dc20e3d5f478b6790e84e26ce49709178f39cf27c1ce845892cf3e8d5889e","09-logout.js":"3687af4f98d3697306200ccb6339612eca471bad8105037bd031bbca4067bb7a494b70c736d68f20ed2da82013e867fbb78c8177670df624f99eccb892630dee","09-restart.js":"63ce8c68a2d7f793d8660a0b00f287c282748b813bda65868988b2d8946ad98efde2ece89280cd75f9876efbcaf611a3d9bfb19989f20fd1ec2d047071ed475f","11-userfriendliness.js":"6c919eb06729eec84223f302f589b165ba0e0ec862baa62954c19c7730fe5834a613da1b5620aa7d787e23d1c37cdb5d23901c576a4398d36f662f1958738a99","12-tokens.js":"a402ccdaeaa70e5cdbbb636e4f8bd9a486737a21970d05ed6e3d4310abf3a6eb7b1d01d2da23c7d79a4e0d92d2996099c2081e4d9aba09cb0e70871bb29aaec3","12-users.js":"2fe8d4742ded1950267d63529c0dd8f030083bccdb85bfecb161cb7a43886d696750c859c8ae16b8885fcf6fcb6bdffb7e269841e9f714b5e85c3000524b61b0","13-authui.js":"ca73ba57220615f4190eb5042942a2c48af87903f63f1e76b4d82bac729cdd99b6bb91da7628c7e1cf79f1ab4eddbbf2f9705ed49d37c357e465b6c8812685f4","13-consentui.js":"f80e1107bb5a8bc7ff136747ec3240225b104d3c46cdf4fd421df81c65bbc9fa5b94b526520d9eec7af35cb44cb71cfd053749250989083467d69aad4eb2198e","14-logon-requirement.js":"7656fa27f024558063e003ee097bc3a25148bbffec37eda16c08a9f04975d0ba07ed2322edba8792c52d6cc24bda6c65d450a5a31a369bcf5ec23d9152180819","18-logon-requirement-enforce.js":"f4f6747c19b0d63d3c9f90e14b400a9cd0d997488041d4db3abd8644fef55e72b50ea4109937adf762c32514707c3cce3a4708126b23594c0fece963e1e83ab2","99-finished.js":"3514285bcae42583c3a28d9ba1638a14ad7fb9318951e9b86f02072397b62f01d161a8094c38f38f3d2c7ce42fe83cbbdbd839bacfc657945c13625eb7abd5ba"}},"permissions":{"boot/00-pcos.js":{"world":"rx"},"boot/00-pcosksk.js":{"world":"rx"},"boot/01-fs.js":{"world":"rx"},"boot/01-fsck.js":{"world":"rx"},"boot/01-fsmodules.js":{"world":"rx"},"boot/02-ui.js":{"world":"rx"},"boot/04-ipc.js":{"world":"rx"},"boot/04-websockets.js":{"world":"rx"},"boot/05-lull.js":{"world":"rx"},"boot/05-network.js":{"world":"rx"},"boot/05-reeapis.js":{"world":"rx"},"boot/06-csp.js":{"world":"rx"},"boot/06-locales.js":{"world":"rx"},"boot/07-tasks.js":{"world":"rx"},"boot/09-logout.js":{"world":"rx"},"boot/09-restart.js":{"world":"rx"},"boot/11-userfriendliness.js":{"world":"rx"},"boot/12-tokens.js":{"world":"rx"},"boot/12-users.js":{"world":"rx"},"boot/13-authui.js":{"world":"rx"},"boot/13-consentui.js":{"world":"rx"},"boot/14-logon-requirement.js":{"world":"rx"},"boot/18-logon-requirement-enforce.js":{"world":"rx"},"boot/99-finished.js":{"world":"rx"},"boot/":{"world":"rx"},"":{"world":"rx"}}},"files":{"88c58106c1483f375397f9e0316d852ff216f8ff2938468f538717ee66fa5b264d8ec25f801479c9af4467f2360cd98c8a7618138cd9e21daa6cb35b2f228264":"// @pcos-app-mode native\nconst pcos_version = \"1332\";\nconst build_time = 1751657439172;\n \nlet modules = {\n\tcore: coreExports,\n\tpcos_version,\n\tbuild_time\n};\nglobalThis.modules = modules;\n\nasync function panic(code, component) {\n\tmodules.shuttingDown = true;\n\tif (modules.session) modules.session.muteAllSessions();\n\tlet baseLocales = {\n\t\t\"PANIC_LINE1\": \"A critical problem has been detected while using the operating system. Its stability is at risk now.\",\n\t\t\"PANIC_LINE2\": \"Problem code: %s\",\n\t\t\"PANIC_UNSPECIFIED_ERROR\": \"UNSPECIFIED_ERROR\",\n\t\t\"PROBLEMATIC_COMPONENT\": \"Problematic component: %s\",\n\t\t\"PROBLEMATIC_PARAMS\": \"Problematic parameters: %s\",\n\t\t\"PROBLEMATIC_JS\": \"Problematic JavaScript: %s: %s\",\n\t\t\"PANIC_LINE3\": \"If you have seen this error message the first time, attempt rebooting.\",\n\t\t\"PANIC_LINE4\": \"If you see this error message once more, there is something wrong with the system.\",\n\t\t\"PANIC_LINE5\": \"You can try repairing the filesystem by placing a .fsck file on the system root mountpoint, with the value \\\"recover\\\" in it.\",\n\t\t\"PANIC_LINE6\": \"Proper shutdown procedure follows now:\",\n\t\t\"PANIC_TASK_KILLED\": \"task:%s: killed\",\n\t\t\"PANIC_MOUNT_UNMOUNTED\": \"mount:%s: unmounted\",\n\t\t\"PANIC_MOUNT_FAILED\": \"mount:%s: %s: %s\"\n\t}\n\tlet currentLocales = modules.locales;\n\tif (currentLocales) currentLocales = currentLocales[navigator.language.slice(0, 2).toLowerCase()];\n\tif (!currentLocales) currentLocales = baseLocales;\n\tif (!Object.keys(baseLocales).every(key => currentLocales.hasOwnProperty(key))) currentLocales = baseLocales;\n\n\tmodules.core.tty_bios_api.println(currentLocales.PANIC_LINE1);\n\tmodules.core.tty_bios_api.println(currentLocales.PANIC_LINE2.replace(\"%s\", (code || currentLocales.PANIC_UNSPECIFIED_ERROR)));\n\tif (component) {\n\t\tif (component.name) modules.core.tty_bios_api.println(currentLocales.PROBLEMATIC_COMPONENT.replace(\"%s\", component.name));\n\t\tif (component.params) modules.core.tty_bios_api.println(currentLocales.PROBLEMATIC_PARAMS.replace(\"%s\", JSON.stringify(component.params, null, \"\\t\")));\n\t\tif (component.underlyingJS) {\n\t\t\tmodules.core.tty_bios_api.println(currentLocales.PROBLEMATIC_JS.replace(\"%s\", component.underlyingJS.name).replace(\"%s\", component.underlyingJS.message));\n\t\t\tif (component.underlyingJS.stack) modules.core.tty_bios_api.println(component.underlyingJS.stack);\n\t\t}\n\t}\n\tmodules.core.tty_bios_api.println(currentLocales.PANIC_LINE3);\n\tmodules.core.tty_bios_api.println(currentLocales.PANIC_LINE4);\n\tmodules.core.tty_bios_api.println(currentLocales.PANIC_LINE5);\n\tmodules.core.tty_bios_api.println(currentLocales.PANIC_LINE6);\n\ttry {\n\t\tmodules.websocket._handles[modules.network.ws].ws.onclose = null;\n\t\tmodules.websocket._handles[modules.network.ws].ws.close();\n\t\tdelete modules.websocket._handles[modules.network.ws];\n\t} catch {}\n\tif (modules.tasks) for (let task in modules.tasks.tracker) {\n\t\tmodules.core.tty_bios_api.println(currentLocales.PANIC_TASK_KILLED.replace(\"%s\", modules.tasks.tracker[task].file));\n\t\tmodules.tasks.tracker[task].ree.closeDown();\n\t}\n\tif (modules.fs) for (let mount in modules.fs.mounts) {\n\t\ttry {\n\t\t\tawait modules.fs.unmount(mount);\n\t\t\tmodules.core.tty_bios_api.println(currentLocales.PANIC_MOUNT_UNMOUNTED.replace(\"%s\", mount));\n\t\t} catch (e) {\n\t\t\tmodules.core.tty_bios_api.println(currentLocales.PANIC_MOUNT_FAILED.replace(\"%s\", mount).replace(\"%s\", e.name).replace(\"%s\", e.message));\n\t\t}\n\t}\n\tif (modules.session) modules.session.destroy();\n\tthrow (component ? component.underlyingJS : null) || code || \"UNSPECIFIED_ERROR\";\n}\n\nfunction startupMemo() {\n\tmodules.core.tty_bios_api.println(\"PCsoft PCOS 3, build \" + pcos_version);\n\tmodules.core.tty_bios_api.println(\"Logical processors: \" + navigator.hardwareConcurrency);\n\tmodules.core.tty_bios_api.println(\"Memory available: \" + ((navigator.deviceMemory * 1024) || \"<unavailable>\") + \" MB\");\n}\nstartupMemo();","329d6bee9e622d8d87ad4027522221ec0bed85a46275fea165bc40e1d929398619ae5d0783d30d19bb93e1354a9b9e33194925c81f61e0276e45effa7ed71457":"async function ksk() {\n\t// @pcos-app-mode native\n\t// Key signing key\n\tlet ksk = {\"crv\":\"Ed25519\",\"x\":\"mjUAHanuB4DVdOViC_DRkE2QHqv9rAo2INDQHU3YgfY\",\"kty\":\"OKP\"};\n\tif (ksk.stub == \"present\") {\n\t\tlet e = new Error(\"The key signing key was not built into this build.\");\n\t\tpanic(\"KEY_SIGNING_KEY_NOT_BUILT\", {\n\t\t\tname: \"ksk\",\n\t\t\tparams: [ \"stub\" ],\n\t\t\tunderlyingJS: e\n\t\t});\n\t\tthrow e;\n\t}\n\tif (ksk.stub != \"present\") modules.ksk = ksk;\n\tif (modules.ksk) {\n\t\ttry {\n\t\t\tmodules.ksk_imported = await crypto.subtle.importKey(\"jwk\", modules.ksk, { name: \"Ed25519\" }, false, [\"verify\"]);\n\t\t} catch (e) {\n\t\t\tpanic(\"KEY_SIGNING_KEY_IMPORT_FAILED\", {\n\t\t\t\tname: \"ksk\",\n\t\t\t\tunderlyingJS: e\n\t\t\t});\n\t\t\tthrow e;\n\t\t}\n\t}\n}\nawait ksk();","f7304cf6c7bcd481025e22d53557c00a34d5d110adddf36d0bde4d99c9931edfb6ae7559aec41025dc01b37abe8cd0e35bd2ade0a0efbc43d9b5997604c3a678":"function loadFs() {\n\t// @pcos-app-mode native\n\tlet fs = {\n\t\tread: async function(file, sessionToken) {\n\t\t\tlet mount = file.split(\"/\")[0];\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\treturn await this.mounts[mount].read(file.split(\"/\").slice(1).join(\"/\"), sessionToken);\n\t\t},\n\t\twrite: async function(file, data, sessionToken) {\n\t\t\tlet filePath = file.split(\"/\").slice(1);\n\t\t\tif (filePath.includes(\"\")) throw new Error(\"PATH_INCLUDES_EMPTY\");\n\t\t\tlet mount = file.split(\"/\")[0];\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\tif (modules.core.bootMode == \"readonly\") throw new Error(\"READ_ONLY_BMGR\");\n\t\t\tif (this.mounts[mount].read_only) throw new Error(\"READ_ONLY_DEV\");\n\t\t\treturn await this.mounts[mount].write(file.split(\"/\").slice(1).join(\"/\"), data, sessionToken);\n\t\t},\n\t\trm: async function(file, sessionToken) {\n\t\t\tlet mount = file.split(\"/\")[0];\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\tif (modules.core.bootMode == \"readonly\") throw new Error(\"READ_ONLY_BMGR\");\n\t\t\tif (this.mounts[mount].read_only) throw new Error(\"READ_ONLY_DEV\");\n\t\t\treturn await this.mounts[mount].rm(file.split(\"/\").slice(1).join(\"/\"), sessionToken);\n\t\t},\n\t\tmkdir: async function(folder, sessionToken) {\n\t\t\tlet filePath = folder.split(\"/\").slice(1);\n\t\t\tif (filePath.includes(\"\")) throw new Error(\"PATH_INCLUDES_EMPTY\");\n\t\t\tlet mount = folder.split(\"/\")[0];\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\tif (modules.core.bootMode == \"readonly\") throw new Error(\"READ_ONLY_BMGR\");\n\t\t\tif (this.mounts[mount].read_only) throw new Error(\"READ_ONLY_DEV\");\n\t\t\tif (!this.mounts[mount].directory_supported) throw new Error(\"NO_DIRECTORY_SUPPORT\");\n\t\t\treturn await this.mounts[mount].mkdir(folder.split(\"/\").slice(1).join(\"/\"), sessionToken);\n\t\t},\n\t\tpermissions: async function(folder, sessionToken) {\n\t\t\tlet mount = folder.split(\"/\")[0];\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\tif (!this.mounts[mount].permissions_supported) return { owner: randomNames, group: randomNames, world: \"rwx\" };\n\t\t\treturn await this.mounts[mount].permissions(folder.split(\"/\").slice(1).join(\"/\"), sessionToken);\n\t\t},\n\t\tlsmounts: function() {\n\t\t\treturn Object.keys(this.mounts);\n\t\t},\n\t\tunmount: async function(mount, sessionToken, force) {\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\tif (!this.mounts[mount].read_only && modules.core.bootMode != \"readonly\" && !force) await this.sync(mount, sessionToken);\n\t\t\tif (!force) await this.mounts[mount].unmount(sessionToken);\n\t\t\tdelete this.mounts[mount];\n\t\t},\n\t\tchown: async function(file, owner, sessionToken) {\n\t\t\tlet filePath = file.split(\"/\").slice(1);\n\t\t\tif (filePath.includes(\"\")) throw new Error(\"PATH_INCLUDES_EMPTY\");\n\t\t\tlet mount = file.split(\"/\")[0];\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\tif (modules.core.bootMode == \"readonly\") throw new Error(\"READ_ONLY_BMGR\");\n\t\t\tif (this.mounts[mount].read_only) throw new Error(\"READ_ONLY_DEV\");\n\t\t\tif (!this.mounts[mount].permissions_supported) throw new Error(\"NO_PERMIS_SUPPORT\");\n\t\t\treturn await this.mounts[mount].chown(file.split(\"/\").slice(1).join(\"/\"), owner, sessionToken);\n\t\t},\n\t\tchgrp: async function(file, group, sessionToken) {\n\t\t\tlet filePath = file.split(\"/\").slice(1);\n\t\t\tif (filePath.includes(\"\")) throw new Error(\"PATH_INCLUDES_EMPTY\");\n\t\t\tlet mount = file.split(\"/\")[0];\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\tif (modules.core.bootMode == \"readonly\") throw new Error(\"READ_ONLY_BMGR\");\n\t\t\tif (this.mounts[mount].read_only) throw new Error(\"READ_ONLY_DEV\");\n\t\t\tif (!this.mounts[mount].permissions_supported) throw new Error(\"NO_PERMIS_SUPPORT\");\n\t\t\treturn await this.mounts[mount].chgrp(file.split(\"/\").slice(1).join(\"/\"), group, sessionToken);\n\t\t},\n\t\tchmod: async function(file, permissions, sessionToken) {\n\t\t\tlet filePath = file.split(\"/\").slice(1);\n\t\t\tif (filePath.includes(\"\")) throw new Error(\"PATH_INCLUDES_EMPTY\");\n\t\t\tlet mount = file.split(\"/\")[0];\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\tif (modules.core.bootMode == \"readonly\") throw new Error(\"READ_ONLY_BMGR\");\n\t\t\tif (this.mounts[mount].read_only) throw new Error(\"READ_ONLY_DEV\");\n\t\t\tif (!this.mounts[mount].permissions_supported) throw new Error(\"NO_PERMIS_SUPPORT\");\n\t\t\treturn await this.mounts[mount].chmod(file.split(\"/\").slice(1).join(\"/\"), permissions, sessionToken);\n\t\t},\n\t\tls: async function(folder, sessionToken) {\n\t\t\tlet mount = folder.split(\"/\")[0];\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\treturn await this.mounts[mount].ls(folder.split(\"/\").slice(1).join(\"/\"), sessionToken);\n\t\t},\n\t\tisDirectory: async function(path, sessionToken) {\n\t\t\tlet mount = path.split(\"/\")[0];\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\tif (!path.split(\"/\").slice(1).join(\"/\")) return true;\n\t\t\tif (!this.mounts[mount].directory_supported) return false;\n\t\t\treturn await this.mounts[mount].isDirectory(path.split(\"/\").slice(1).join(\"/\"), sessionToken);\n\t\t},\n\t\tmountInfo: async function(mount) {\n\t\t\treturn {\n\t\t\t\tread_only: this.mounts[mount].read_only || false,\n\t\t\t\tpermissions_supported: this.mounts[mount].permissions_supported || false,\n\t\t\t\tdirectory_supported: this.mounts[mount].directory_supported || false,\n\t\t\t\tfilesystem: this.mounts[mount].filesystem || \"unknown\"\n\t\t\t}\n\t\t},\n\t\tsync: async function(mount, sessionToken) {\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\tif (!this.mounts[mount].read_only && modules.core.bootMode != \"readonly\") return await this.mounts[mount].sync(sessionToken);\n\t\t},\n\t\tmounts: {}\n\t}\n\t\n\tasync function PCFSiDBMount(options) {\n\t\tlet partition;\n\t\ttry {\n\t\t\tpartition = modules.core.disk.partition(options.partition);\n\t\t\tpartition = partition.getData();\n\t\t} catch (e) {\n\t\t\tthrow new Error(\"PARTITION_FAILED: \" + e.toString() + \"\\n---begin stack---\\n\" + e.stack + \"\\n---end stack---\");\n\t\t}\n\t\tif (!Object.keys(partition).includes(\"files\") || !Object.keys(partition).includes(\"permissions\") || !Object.keys(partition).includes(\"id\")) throw new Error(\"PARTITION_NOT_PCFS\");\n\t\tlet partitionId = partition.id;\n\t\tpartition = null;\n\t\treturn {\n\t\t\tread: async function(key) {\n\t\t\t\tlet pathParts = key.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_FILE\");\n\t\t\t\t}\n\t\t\t\tif (typeof files === \"object\") throw new Error(\"IS_A_DIR\");\n\t\t\t\treturn String(await modules.core.idb.readPart(partitionId + \"-\" + files));\n\t\t\t},\n\t\t\twrite: async function(key, value) {\n\t\t\t\tkey = String(key);\n\t\t\t\tvalue = String(value);\n\t\t\t\tlet existenceChecks = key.split(\"/\").slice(0, -1);\n\t\t\t\tif (existenceChecks[0] == \"\") existenceChecks = existenceChecks.slice(1);\n\t\t\t\tif (existenceChecks[existenceChecks.length - 1] == \"\") existenceChecks = existenceChecks.slice(0, -1);\n\t\t\t\tlet basename = key.split(\"/\").slice(-1)[0];\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of existenceChecks) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files[basename] === \"object\") throw new Error(\"IS_A_DIR\");\n\t\t\t\tlet id = files[basename] || crypto.getRandomValues(new Uint8Array(64)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tawait modules.core.idb.writePart(partitionId + \"-\" + id, value);\n\t\t\t\tif (!files[basename]) this.backend = this._recursive_op(this.backend, \"files/\" + key, { type: \"write\", value: id });\n\t\t\t},\n\t\t\trm: async function(key) {\n\t\t\t\tkey = String(key);\n\t\t\t\tlet pathParts = key.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_FILE_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files === \"object\" && Object.keys(files).length > 0) throw new Error(\"NON_EMPTY_DIR\");\n\t\t\t\tif (typeof files === \"string\") await modules.core.idb.removePart(partitionId + \"-\" + files);\n\t\t\t\tthis.backend = this._recursive_op(this.backend, \"files/\" + key, { type: \"delete\" });\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tdelete backend.permissions[key];\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tls: async function(directory) {\n\t\t\t\tdirectory = String(directory);\n\t\t\t\tlet pathParts = directory.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files !== \"object\") throw new Error(\"IS_A_FILE\");\n\t\t\t\treturn Object.keys(files);\n\t\t\t},\n\t\t\tmkdir: async function(directory) {\n\t\t\t\tdirectory = String(directory);\n\t\t\t\tlet existenceChecks = directory.split(\"/\").slice(0, -1);\n\t\t\t\tif (existenceChecks[0] == \"\") existenceChecks = existenceChecks.slice(1);\n\t\t\t\tif (existenceChecks[existenceChecks.length - 1] == \"\") existenceChecks = existenceChecks.slice(0, -1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of existenceChecks) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (files[directory.split(\"/\").slice(-1)[0]]) throw new Error(\"DIR_EXISTS\");\n\t\t\t\tthis.backend = this._recursive_op(this.backend, \"files/\" + directory, { type: \"write\", value: {} });\n\t\t\t},\n\t\t\tpermissions: async function(file) {\n\t\t\t\tfile = String(file);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet permissions = this.backend.permissions[properFile] || {};\n\t\t\t\treturn {\n\t\t\t\t\towner: permissions.owner || randomNames,\n\t\t\t\t\tgroup: permissions.group || randomNames,\n\t\t\t\t\tworld: permissions.world || \"\",\n\t\t\t\t\trandom: !(permissions.owner || permissions.group || permissions.world) ? true : undefined\n\t\t\t\t};\n\t\t\t},\n\t\t\tchown: async function(file, owner) {\n\t\t\t\tfile = String(file);\n\t\t\t\towner = String(owner);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tif (Object.prototype.hasOwnProperty(properFile)) throw new Error(\"TECHNICAL_LIMITATIONS\");\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.owner = owner;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tchgrp: async function(file, group) {\n\t\t\t\tfile = String(file);\n\t\t\t\tgroup = String(group);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tif (Object.prototype.hasOwnProperty(properFile)) throw new Error(\"TECHNICAL_LIMITATIONS\");\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.group = group;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tchmod: async function(file, permissions) {\n\t\t\t\tfile = String(file);\n\t\t\t\tpermissions = String(permissions);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tif (Object.prototype.hasOwnProperty(properFile)) throw new Error(\"TECHNICAL_LIMITATIONS\");\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.world = permissions;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tsync: async function() {\n\t\t\t\tawait modules.core.disk.sync();\n\t\t\t},\n\t\t\tisDirectory: function(key) {\n\t\t\t\tkey = String(key);\n\t\t\t\tlet pathParts = key.split(\"/\").slice(0, -1);\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet basename = key.split(\"/\").slice(-1)[0];\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (!files.hasOwnProperty(basename)) throw new Error(\"NO_SUCH_FILE_DIR\");\n\t\t\t\tif (typeof files[basename] === \"object\") return true;\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tunmount: () => true,\n\t\t\t_recursive_op: function(obj, path, action, stage = 0) {\n\t\t\t\tif (path.split(\"/\").length == (stage + 1)) {\n\t\t\t\t\tif (action.type == \"delete\") delete obj[path.split(\"/\").slice(-1)[0]];\n\t\t\t\t\tif (action.type == \"write\") obj[path.split(\"/\").slice(-1)[0]] = action.value;\n\t\t\t\t} else obj[path.split(\"/\")[stage]] = this._recursive_op(obj[path.split(\"/\")[stage]], path, action, stage + 1);\n\t\t\t\treturn obj;\n\t\t\t},\n\t\t\tdirectory_supported: true,\n\t\t\tread_only: !!options.read_only,\n\t\t\tfilesystem: \"PCFS\",\n\t\t\tpermissions_supported: true,\n\t\t\tpartition: null,\n\t\t\tget backend() {\n\t\t\t\tif (!this.partition) this.partition = modules.core.disk.partition(options.partition);\n\t\t\t\treturn this.partition.getData();\n\t\t\t},\n\t\t\tset backend(data) {\n\t\t\t\tif (!this.partition) this.partition = modules.core.disk.partition(options.partition);\n\t\t\t\tthis.partition.setData(data);\n\t\t\t}\n\t\t};\n\t};\n\n\tasync function PCFSiDBAESCryptMount(options) {\n\t\tlet partition;\n\t\ttry {\n\t\t\tpartition = modules.core.disk.partition(options.partition);\n\t\t\tpartition = partition.getData();\n\t\t} catch (e) {\n\t\t\tthrow new Error(\"PARTITION_FAILED: \" + e.toString() + \"\\n---begin stack---\\n\" + e.stack + \"\\n---end stack---\");\n\t\t}\n\t\tif (!Object.keys(partition).includes(\"files\") || !Object.keys(partition).includes(\"permissions\") || !Object.keys(partition).includes(\"cryptodata\") || !Object.keys(partition).includes(\"id\")) throw new Error(\"PARTITION_NOT_PCFS_ENCRYPTED\");\n\t\tif (options.interactivePassword) {\n\t\t\tlet passwordInput = \"\";\n\t\t\tlet tbi = modules.core.tty_bios_api;\n\t\t\tfunction outputPasswordAsking() {\n\t\t\t\ttbi.clear();\n\t\t\t\ttbi.println(\"|--------------------------------------------|\")\n\t\t\t\ttbi.println(\"| Mounting encrypted partition               |\");\n\t\t\t\ttbi.println(\"|--------------------------------------------|\");\n\t\t\t\ttbi.println(\"| Enter your password. Typed \" + passwordInput.length + \" characters. \" + \" \".repeat(Math.max((3 - (passwordInput.length).toString().length), 0)) + \"|\");\n\t\t\t\ttbi.println(\"| Press Enter to mount.                      |\");\n\t\t\t\ttbi.println(\"|--------------------------------------------|\");\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\toutputPasswordAsking();\n\t\t\t\tlet key = await tbi.inputKey();\n\t\t\t\tif (key.key == \"Enter\") break;\n\t\t\t\tif (key.key.length == 1) passwordInput += key.key;\n\t\t\t\tif (key.key == \"Backspace\") passwordInput = passwordInput.slice(0, -1);\n\t\t\t}\n\t\t\toptions.password = passwordInput;\n\t\t}\n\t\tif (options.password) options.key = await modules.core.pbkdf2(options.password, partition.cryptodata.salt);\n\t\tif (!options.key) throw new Error(\"GETTING_KEY_FAILED\");\n\t\tlet importedKey = await crypto.subtle.importKey(\"raw\", Uint8Array.from(options.key.match(/.{1,2}/g).map(a => parseInt(a, 16))), { name: \"AES-GCM\" }, false, [ \"encrypt\", \"decrypt\" ]);\n\t\toptions.key = options.key.length + \"L\";\n\t\toptions.password = options.password.length + \"L\";\n\t\tif (partition.cryptodata.passwordLockingInitial) {\n\t\t\tlet baseData = crypto.getRandomValues(new Uint8Array(32));\n\t\t\tlet iv = crypto.getRandomValues(new Uint8Array(16));\n\t\t\tlet ct = new Uint8Array(await crypto.subtle.encrypt({ name: \"AES-GCM\", iv }, importedKey, baseData));\n\t\t\tlet passwordLocking = new Uint8Array(iv.length + ct.length);\n\t\t\tpasswordLocking.set(iv);\n\t\t\tpasswordLocking.set(ct, iv.length);\n\t\t\tpartition.cryptodata.passwordLocking = passwordLocking.reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\tif (partition.encryptedFileTable) {\n\t\t\t\tlet fileIV = crypto.getRandomValues(new Uint8Array(16));\n\t\t\t\tlet fileCT = new Uint8Array(await crypto.subtle.encrypt({ name: \"AES-GCM\", iv: fileIV }, importedKey, new TextEncoder().encode(JSON.stringify({\n\t\t\t\t\tfiles: partition.files,\n\t\t\t\t\tpermissions: partition.permissions\n\t\t\t\t}))));\n\t\t\t\tpartition.files = {};\n\t\t\t\tpartition.permissions = {};\n\t\t\t\tlet ept = new Uint8Array(fileIV.length + fileCT.length);\n\t\t\t\tept.set(fileIV);\n\t\t\t\tept.set(fileCT, fileIV.length);\n\t\t\t\tpartition.encryptedFileTable = ept.reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t}\n\t\t\tdelete partition.cryptodata.passwordLockingInitial;\n\t\t\tmodules.core.disk.partition(options.partition).setData(partition);\n\t\t}\n\t\tif (partition.cryptodata.passwordLocking) {\n\t\t\tlet iv = new Uint8Array(partition.cryptodata.passwordLocking.slice(0, 32).match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\tlet ct = new Uint8Array(partition.cryptodata.passwordLocking.slice(32).match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\tawait crypto.subtle.decrypt({ name: \"AES-GCM\", iv }, importedKey, ct);\n\t\t}\n\t\tlet partitionId = partition.id;\n\t\tpartition = null;\n\t\treturn {\n\t\t\tread: async function(key) {\n\t\t\t\tkey = String(key);          \n\t\t\t\tlet pathParts = key.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tlet files = (await this.getBackend()).files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_FILE\");\n\t\t\t\t}\n\t\t\t\tif (typeof files === \"object\") throw new Error(\"IS_A_DIR\");\n\t\t\t\tlet part = await modules.core.idb.readPart(partitionId + \"-\" + files);\n\t\t\t\tlet iv = new Uint8Array(part.slice(0, 32).match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\t\tlet ct = new Uint8Array(part.slice(32).match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\t\treturn new TextDecoder().decode(new Uint8Array(await crypto.subtle.decrypt({ name: \"AES-GCM\", iv }, this.key, ct)));\n\t\t\t},\n\t\t\twrite: async function(key, value) {\n\t\t\t\tkey = String(key);\n\t\t\t\tvalue = String(value);\n\t\t\t\tlet existenceChecks = key.split(\"/\").slice(0, -1);\n\t\t\t\tif (existenceChecks[0] == \"\") existenceChecks = existenceChecks.slice(1);\n\t\t\t\tif (existenceChecks[existenceChecks.length - 1] == \"\") existenceChecks = existenceChecks.slice(0, -1);\n\t\t\t\tlet basename = key.split(\"/\").slice(-1)[0];\n\t\t\t\tlet files = (await this.getBackend()).files;\n\t\t\t\tfor (let part of existenceChecks) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files[basename] === \"object\") throw new Error(\"IS_A_DIR\");\n\t\t\t\tlet id = files[basename] || crypto.getRandomValues(new Uint8Array(64)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet newIV = crypto.getRandomValues(new Uint8Array(16));\n\t\t\t\tlet newCT = new Uint8Array(await crypto.subtle.encrypt({ name: \"AES-GCM\", iv: newIV }, this.key, new TextEncoder().encode(value)));\n\t\t\t\tlet newPart = new Uint8Array(newIV.length + newCT.length);\n\t\t\t\tnewPart.set(newIV);\n\t\t\t\tnewPart.set(newCT, newIV.length);\n\t\t\t\tnewPart = newPart.reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tawait modules.core.idb.writePart(partitionId + \"-\" + id, newPart);\n\t\t\t\tif (!files[basename]) await this.setBackend(this._recursive_op(await this.getBackend(), \"files/\" + key, { type: \"write\", value: id }));\n\t\t\t},\n\t\t\trm: async function(key) {\n\t\t\t\tkey = String(key);\n\t\t\t\tlet pathParts = key.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet files = (await this.getBackend()).files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_FILE_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files === \"object\" && Object.keys(files).length > 0) throw new Error(\"NON_EMPTY_DIR\");\n\t\t\t\tif (typeof files === \"string\") await modules.core.idb.removePart(partitionId + \"-\" + files);\n\t\t\t\tawait this.setBackend(this._recursive_op(await this.getBackend(), \"files/\" + key, { type: \"delete\" }));\n\t\t\t\tlet backend = await this.getBackend();\n\t\t\t\tdelete backend.permissions[key];\n\t\t\t\tawait this.setBackend(backend);\n\t\t\t},\n\t\t\tls: async function(directory) {\n\t\t\t\tdirectory = String(directory);\n\t\t\t\tlet pathParts = directory.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet files = (await this.getBackend()).files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files !== \"object\") throw new Error(\"IS_A_FILE\");\n\t\t\t\treturn Object.keys(files);\n\t\t\t},\n\t\t\tmkdir: async function(directory) {\n\t\t\t\tdirectory = String(directory);\n\t\t\t\tlet existenceChecks = directory.split(\"/\").slice(0, -1);\n\t\t\t\tif (existenceChecks[0] == \"\") existenceChecks = existenceChecks.slice(1);\n\t\t\t\tif (existenceChecks[existenceChecks.length - 1] == \"\") existenceChecks = existenceChecks.slice(0, -1);\n\t\t\t\tlet files = (await this.getBackend()).files;\n\t\t\t\tfor (let part of existenceChecks) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (files[directory.split(\"/\").slice(-1)[0]]) throw new Error(\"DIR_EXISTS\");\n\t\t\t\tawait this.setBackend(this._recursive_op(await this.getBackend(), \"files/\" + directory, { type: \"write\", value: {} }));\n\t\t\t},\n\t\t\tpermissions: async function(file) {\n\t\t\t\tfile = String(file);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet permissions = (await this.getBackend()).permissions[properFile] || {};\n\t\t\t\treturn {\n\t\t\t\t\towner: permissions.owner || randomNames,\n\t\t\t\t\tgroup: permissions.group || randomNames,\n\t\t\t\t\tworld: permissions.world || \"\",\n\t\t\t\t\trandom: !(permissions.owner || permissions.group || permissions.world) ? true : undefined\n\t\t\t\t};\n\t\t\t},\n\t\t\tchown: async function(file, owner) {\n\t\t\t\tfile = String(file);\n\t\t\t\towner = String(owner);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tif (Object.prototype.hasOwnProperty(properFile)) throw new Error(\"TECHNICAL_LIMITATIONS\");\n\t\t\t\tlet backend = await this.getBackend();\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.owner = owner;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tawait this.setBackend(backend);\n\t\t\t},\n\t\t\tchgrp: async function(file, group) {\n\t\t\t\tfile = String(file);\n\t\t\t\tgroup = String(group);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tif (Object.prototype.hasOwnProperty(properFile)) throw new Error(\"TECHNICAL_LIMITATIONS\");\n\t\t\t\tlet backend = await this.getBackend();\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.group = group;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tawait this.setBackend(backend);\n\t\t\t},\n\t\t\tchmod: async function(file, permissions) {\n\t\t\t\tfile = String(file);\n\t\t\t\tpermissions = String(permissions);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tif (Object.prototype.hasOwnProperty(properFile)) throw new Error(\"TECHNICAL_LIMITATIONS\");\n\t\t\t\tlet backend = await this.getBackend();\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.world = permissions;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tawait this.setBackend(backend);\n\t\t\t},\n\t\t\tisDirectory: async function(key) {\n\t\t\t\tkey = String(key);\n\t\t\t\tlet pathParts = key.split(\"/\").slice(0, -1);\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet basename = key.split(\"/\").slice(-1)[0];\n\t\t\t\tlet files = (await this.getBackend()).files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (!files.hasOwnProperty(basename)) throw new Error(\"NO_SUCH_FILE_DIR\");\n\t\t\t\tif (typeof files[basename] === \"object\") return true;\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tsync: async function() {\n\t\t\t\tawait modules.core.disk.sync();\n\t\t\t},\n\t\t\tunmount: () => true,\n\t\t\t_recursive_op: function(obj, path, action, stage = 0) {\n\t\t\t\tif (path.split(\"/\").length == (stage + 1)) {\n\t\t\t\t\tif (action.type == \"delete\") delete obj[path.split(\"/\").slice(-1)[0]];\n\t\t\t\t\tif (action.type == \"write\") obj[path.split(\"/\").slice(-1)[0]] = action.value;\n\t\t\t\t} else obj[path.split(\"/\")[stage]] = this._recursive_op(obj[path.split(\"/\")[stage]], path, action, stage + 1);\n\t\t\t\treturn obj;\n\t\t\t},\n\t\t\tdirectory_supported: true,\n\t\t\tfilesystem: \"PCFS-AES\",\n\t\t\tread_only: !!options.read_only,\n\t\t\tpermissions_supported: true,\n\t\t\tpartition: null,\n\t\t\tgetBackend: async function() {\n\t\t\t\tif (!this.partition) this.partition = modules.core.disk.partition(options.partition);\n\t\t\t\tlet returnedData = this.partition.getData();\n\t\t\t\tif (returnedData.encryptedFileTable) {\n\t\t\t\t\tlet iv = new Uint8Array(returnedData.encryptedFileTable.slice(0, 32).match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\t\t\tlet ct = new Uint8Array(returnedData.encryptedFileTable.slice(32).match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\t\t\treturn JSON.parse(new TextDecoder().decode(new Uint8Array(await crypto.subtle.decrypt({ name: \"AES-GCM\", iv }, this.key, ct))));   \n\t\t\t\t}\n\t\t\t\treturn returnedData;\n\t\t\t},\n\t\t\tsetBackend: async function(data) {\n\t\t\t\tif (!this.partition) this.partition = modules.core.disk.partition(options.partition);\n\t\t\t\tlet returnedData = this.partition.getData();\n\t\t\t\tif (returnedData.encryptedFileTable) {\n\t\t\t\t\tlet newIV = crypto.getRandomValues(new Uint8Array(16));\n\t\t\t\t\tlet newCT = new Uint8Array(await crypto.subtle.encrypt({ name: \"AES-GCM\", iv: newIV }, this.key, new TextEncoder().encode(JSON.stringify(data))));\n\t\t\t\t\tlet newPart = new Uint8Array(newIV.length + newCT.length);\n\t\t\t\t\tnewPart.set(newIV);\n\t\t\t\t\tnewPart.set(newCT, newIV.length);\n\t\t\t\t\tnewPart = newPart.reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\t\treturn this.partition.setData({ ...returnedData, encryptedFileTable: newPart });\n\t\t\t\t}\n\t\t\t\tthis.partition.setData(data);\n\t\t\t},\n\t\t\tkey: importedKey\n\t\t};\n\t};\n\t\n\tfunction ramMount(options) {\n\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\treturn {\n\t\t\tread: async function(key) {\n\t\t\t\tkey = String(key);\n\t\t\t\tlet pathParts = key.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_FILE\");\n\t\t\t\t}\n\t\t\t\tif (typeof files === \"object\") throw new Error(\"IS_A_DIR\");\n\t\t\t\treturn String(this.ramFiles.get(files));\n\t\t\t},\n\t\t\twrite: async function(key, value) {\n\t\t\t\tkey = String(key);\n\t\t\t\tvalue = String(value);\n\t\t\t\tlet existenceChecks = key.split(\"/\").slice(0, -1);\n\t\t\t\tif (existenceChecks[0] == \"\") existenceChecks = existenceChecks.slice(1);\n\t\t\t\tif (existenceChecks[existenceChecks.length - 1] == \"\") existenceChecks = existenceChecks.slice(0, -1);\n\t\t\t\tlet basename = key.split(\"/\").slice(-1)[0];\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of existenceChecks) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files[basename] === \"object\") throw new Error(\"IS_A_DIR\");\n\t\t\t\tlet id = files[basename] || crypto.getRandomValues(new Uint8Array(64)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tthis.ramFiles.set(id, value);\n\t\t\t\tif (!files[basename]) this.backend = this._recursive_op(this.backend, \"files/\" + key, { type: \"write\", value: id });\n\t\t\t},\n\t\t\trm: async function(key) {\n\t\t\t\tkey = String(key);\n\t\t\t\tlet pathParts = key.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_FILE_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files === \"object\" && Object.keys(files).length > 0) throw new Error(\"NON_EMPTY_DIR\");\n\t\t\t\tif (typeof files === \"string\") this.ramFiles.delete(files);\n\t\t\t\tthis.backend = this._recursive_op(this.backend, \"files/\" + key, { type: \"delete\" });\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tdelete backend.permissions[key];\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tls: async function(directory) {\n\t\t\t\tdirectory = String(directory);\n\t\t\t\tlet pathParts = directory.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files !== \"object\") throw new Error(\"IS_A_FILE\");\n\t\t\t\treturn Object.keys(files);\n\t\t\t},\n\t\t\tmkdir: async function(directory) {\n\t\t\t\tdirectory = String(directory);\n\t\t\t\tlet existenceChecks = directory.split(\"/\").slice(0, -1);\n\t\t\t\tif (existenceChecks[0] == \"\") existenceChecks = existenceChecks.slice(1);\n\t\t\t\tif (existenceChecks[existenceChecks.length - 1] == \"\") existenceChecks = existenceChecks.slice(0, -1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of existenceChecks) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (files[directory.split(\"/\").slice(-1)[0]]) throw new Error(\"DIR_EXISTS\");\n\t\t\t\tthis.backend = this._recursive_op(this.backend, \"files/\" + directory, { type: \"write\", value: {} });\n\t\t\t},\n\t\t\tpermissions: async function(file) {\n\t\t\t\tfile = String(file);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet permissions = this.backend.permissions[properFile] || {};\n\t\t\t\treturn {\n\t\t\t\t\towner: permissions.owner || randomNames,\n\t\t\t\t\tgroup: permissions.group || randomNames,\n\t\t\t\t\tworld: permissions.world || \"\",\n\t\t\t\t\trandom: !(permissions.owner || permissions.group || permissions.world) ? true : undefined\n\t\t\t\t};\n\t\t\t},\n\t\t\tchown: async function(file, owner) {\n\t\t\t\tfile = String(file);\n\t\t\t\towner = String(owner);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tif (Object.prototype.hasOwnProperty(properFile)) throw new Error(\"TECHNICAL_LIMITATIONS\");\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.owner = owner;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tchgrp: async function(file, group) {\n\t\t\t\tfile = String(file);\n\t\t\t\tgroup = String(group);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tif (Object.prototype.hasOwnProperty(properFile)) throw new Error(\"TECHNICAL_LIMITATIONS\");\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.group = group;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tchmod: async function(file, permissions) {\n\t\t\t\tfile = String(file);\n\t\t\t\tpermissions = String(permissions);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tif (Object.prototype.hasOwnProperty(properFile)) throw new Error(\"TECHNICAL_LIMITATIONS\");\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.world = permissions;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tisDirectory: function(key) {\n\t\t\t\tkey = String(key);\n\t\t\t\tlet pathParts = key.split(\"/\").slice(0, -1);\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet basename = key.split(\"/\").slice(-1)[0];\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (!files.hasOwnProperty(basename)) throw new Error(\"NO_SUCH_FILE_DIR\");\n\t\t\t\tif (typeof files[basename] === \"object\") return true;\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\t_recursive_op: function(obj, path, action, stage = 0) {\n\t\t\t\tif (path.split(\"/\").length == (stage + 1)) {\n\t\t\t\t\tif (action.type == \"delete\") delete obj[path.split(\"/\").slice(-1)[0]];\n\t\t\t\t\tif (action.type == \"write\") obj[path.split(\"/\").slice(-1)[0]] = action.value;\n\t\t\t\t} else obj[path.split(\"/\")[stage]] = this._recursive_op(obj[path.split(\"/\")[stage]], path, action, stage + 1);\n\t\t\t\treturn obj;\n\t\t\t},\n\t\t\tsync: () => true,\n\t\t\tunmount: () => true,\n\t\t\tdirectory_supported: true,\n\t\t\tread_only: !!options.read_only,\n\t\t\tfilesystem: \"extramfs\",\n\t\t\tpermissions_supported: true,\n\t\t\tbackend: options.type == \"run\" ? { files: { run: {} }, permissions: {\n\t\t\t\t\"\": {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"rx\"\n\t\t\t\t},\n\t\t\t\trun: {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"rwx\"\n\t\t\t\t}\n\t\t\t}} : { files: {}, permissions: {\n\t\t\t\t\"\": {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"rx\"\n\t\t\t\t}\n\t\t\t} },\n\t\t\tramFiles: new Map()\n\t\t};\n\t}\n\t\n\tfunction preferenceMount(options) {\n\t\treturn {\n\t\t\tread: a => JSON.stringify(modules.core.prefs.read(a), null, \"\\t\"),\n\t\t\twrite: (a, b) => modules.core.prefs.write(a, JSON.parse(b)),\n\t\t\trm: a => modules.core.prefs.rm(a),\n\t\t\tls: a => modules.core.prefs.ls(a),\n\t\t\tpermissions: function() {\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\treturn {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t},\n\t\t\tchown: _ => !1,\n\t\t\tchgrp: _ => !1,\n\t\t\tchmod: _ => !1,\n\t\t\tsync: () => true,\n\t\t\tunmount: () => true,\n\t\t\tdirectory_supported: false,\n\t\t\tread_only: !!options.read_only,\n\t\t\tfilesystem: \"preffs\",\n\t\t\tpermissions_supported: true\n\t\t};\n\t}\n\n\tasync function SFSPMount(options) {\n\t\tlet session, serverData;\n\t\ttry {\n\t\t\tsession = await fetch(options.url + \"/session\");\n\t\t\tsession = await session.json();\n\t\t\tserverData = await fetch(options.url + \"/properties\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\theaders: {\n\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t},\n\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t...options,\n\t\t\t\t\tsessionToken: session\n\t\t\t\t})\n\t\t\t});\n\t\t\tserverData = await serverData.json();\n\t\t} catch (e) {\n\t\t\tthrow new Error(\"Could not connect to server\");\n\t\t}\n\t\treturn {\n\t\t\tread: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"read\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\twrite: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"write\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\trm: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"rm\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\tls: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"ls\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\tmkdir: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"mkdir\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\tpermissions: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"permissions\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\tchown: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"chown\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\tchgrp: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"chgrp\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\tchmod: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"chmod\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\tsync: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"sync\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\tisDirectory: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"isDirectory\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\tunmount: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"unmount\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\t...serverData\n\t\t};\n\t};\n\n\tasync function IPCMount(options) { // ChatGPT code below\n\t\tif (!options.inputPipeId || !options.outputPipeId) throw new Error(\"PIPE_IDS_REQUIRED\");\n\t\n\t\tconst inputPipeId = options.inputPipeId;\n\t\tconst outputPipeId = options.outputPipeId;\n\t\tlet lock = false;\n\t\n\t\tasync function acquireLock() {\n\t\t\treturn new Promise((resolve) => {\n\t\t\t\tconst tryLock = () => {\n\t\t\t\t\tif (!lock) {\n\t\t\t\t\t\tlock = true;\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsetTimeout(tryLock, 10); // retry after 10ms\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tsetTimeout(tryLock, 10);\n\t\t\t});\n\t\t}\n\t\n\t\tasync function releaseLock() {\n\t\t\tlock = false;\n\t\t}\n\t\n\t\t// Function to send request and receive response\n\t\tasync function ipcRequest(action, payload = {}) {\n\t\t\tawait acquireLock();\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tmodules.ipc.listenFor(outputPipeId).then((response) => {\n\t\t\t\t\treleaseLock();\n\t\t\t\t\tif (response.error) return reject(new Error(response.error));\n\t\t\t\t\treturn resolve(response.data);\n\t\t\t\t});\n\t\t\t\tmodules.ipc.send(inputPipeId, { action, ...payload });\n\t\t\t});\n\t\t}\n\t\n\t\t// Initial request to get filesystem properties\n\t\tconst filesystemData = await ipcRequest(\"properties\", { data: options });\n\t\n\t\treturn {\n\t\t\tread: async function(key) {\n\t\t\t\treturn ipcRequest(\"read\", { key: String(key) });\n\t\t\t},\n\t\t\twrite: async function(key, value) {\n\t\t\t\treturn ipcRequest(\"write\", { key: String(key), value: String(value) });\n\t\t\t},\n\t\t\trm: async function(key) {\n\t\t\t\treturn ipcRequest(\"rm\", { key: String(key) });\n\t\t\t},\n\t\t\tls: async function(directory) {\n\t\t\t\treturn ipcRequest(\"ls\", { directory: String(directory) });\n\t\t\t},\n\t\t\tmkdir: async function(directory) {\n\t\t\t\treturn ipcRequest(\"mkdir\", { directory: String(directory) });\n\t\t\t},\n\t\t\tpermissions: async function(file) {\n\t\t\t\treturn ipcRequest(\"permissions\", { file: String(file) });\n\t\t\t},\n\t\t\tchown: async function(file, owner) {\n\t\t\t\treturn ipcRequest(\"chown\", { file: String(file), owner: String(owner) });\n\t\t\t},\n\t\t\tchgrp: async function(file, group) {\n\t\t\t\treturn ipcRequest(\"chgrp\", { file: String(file), group: String(group) });\n\t\t\t},\n\t\t\tchmod: async function(file, permissions) {\n\t\t\t\treturn ipcRequest(\"chmod\", { file: String(file), permissions: String(permissions) });\n\t\t\t},\n\t\t\tisDirectory: async function(key) {\n\t\t\t\treturn ipcRequest(\"isDirectory\", { key: String(key) });\n\t\t\t},\n\t\t\tsync: async function() {\n\t\t\t\treturn ipcRequest(\"sync\");\n\t\t\t},\n\t\t\tunmount: async function() {\n\t\t\t\treturn ipcRequest(\"unmount\");\n\t\t\t},\n\t\t\t...filesystemData\n\t\t};\n\t} // ChatGPT code ends here\n\n\tasync function fileMount(options) {\n\t\tlet file = JSON.parse(await modules.fs.read(options.srcFile));\n\t\tlet backend = file.backend;\n\t\tdelete file.backend;\n\t\tlet files = file.files;\n\t\tdelete file.files;\n\t\treturn {\n\t\t\tread: async function(key) {\n\t\t\t\tkey = String(key);\n\t\t\t\tlet pathParts = key.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_FILE\");\n\t\t\t\t}\t\n\t\t\t\tif (typeof files === \"object\") throw new Error(\"IS_A_DIR\");\n\t\t\t\treturn String(this.files[files]);\n\t\t\t},\n\t\t\twrite: async function(key, value) {\n\t\t\t\tkey = String(key);\n\t\t\t\tvalue = String(value);\n\t\t\t\tlet existenceChecks = key.split(\"/\").slice(0, -1);\n\t\t\t\tif (existenceChecks[0] == \"\") existenceChecks = existenceChecks.slice(1);\n\t\t\t\tif (existenceChecks[existenceChecks.length - 1] == \"\") existenceChecks = existenceChecks.slice(0, -1);\n\t\t\t\tlet basename = key.split(\"/\").slice(-1)[0];\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of existenceChecks) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files[basename] === \"object\") throw new Error(\"IS_A_DIR\");\n\t\t\t\tlet id = files[basename] || crypto.getRandomValues(new Uint8Array(64)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tthis.files[id] = value;\n\t\t\t\tif (!files[basename]) this.backend = this._recursive_op(this.backend, \"files/\" + key, { type: \"write\", value: id });\n\t\t\t},\n\t\t\trm: async function(key) {\n\t\t\t\tkey = String(key);\n\t\t\t\tlet pathParts = key.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_FILE_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files === \"object\" && Object.keys(files).length > 0) throw new Error(\"NON_EMPTY_DIR\");\n\t\t\t\tif (typeof files === \"string\") delete this.files[files];\n\t\t\t\tthis.backend = this._recursive_op(this.backend, \"files/\" + key, { type: \"delete\" });\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tdelete backend.permissions[key];\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tls: async function(directory) {\n\t\t\t\tdirectory = String(directory);\n\t\t\t\tlet pathParts = directory.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files !== \"object\") throw new Error(\"IS_A_FILE\");\n\t\t\t\treturn Object.keys(files);\n\t\t\t},\n\t\t\tmkdir: async function(directory) {\n\t\t\t\tdirectory = String(directory);\n\t\t\t\tlet existenceChecks = directory.split(\"/\").slice(0, -1);\n\t\t\t\tif (existenceChecks[0] == \"\") existenceChecks = existenceChecks.slice(1);\n\t\t\t\tif (existenceChecks[existenceChecks.length - 1] == \"\") existenceChecks = existenceChecks.slice(0, -1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of existenceChecks) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (files[directory.split(\"/\").slice(-1)[0]]) throw new Error(\"DIR_EXISTS\");\n\t\t\t\tthis.backend = this._recursive_op(this.backend, \"files/\" + directory, { type: \"write\", value: {} });\n\t\t\t},\n\t\t\tpermissions: async function(file) {\n\t\t\t\tfile = String(file);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet permissions = this.backend.permissions[properFile] || {};\n\t\t\t\treturn {\n\t\t\t\t\towner: permissions.owner || randomNames,\n\t\t\t\t\tgroup: permissions.group || randomNames,\n\t\t\t\t\tworld: permissions.world || \"\",\n\t\t\t\t\trandom: !(permissions.owner || permissions.group || permissions.world) ? true : undefined\n\t\t\t\t};\n\t\t\t},\n\t\t\tchown: async function(file, owner) {\n\t\t\t\tfile = String(file);\n\t\t\t\towner = String(owner);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tif (Object.prototype.hasOwnProperty(properFile)) throw new Error(\"TECHNICAL_LIMITATIONS\");\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.owner = owner;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tchgrp: async function(file, group) {\n\t\t\t\tfile = String(file);\n\t\t\t\tgroup = String(group);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tif (Object.prototype.hasOwnProperty(properFile)) throw new Error(\"TECHNICAL_LIMITATIONS\");\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.group = group;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tchmod: async function(file, permissions) {\n\t\t\t\tfile = String(file);\n\t\t\t\tpermissions = String(permissions);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tif (Object.prototype.hasOwnProperty(properFile)) throw new Error(\"TECHNICAL_LIMITATIONS\");\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.world = permissions;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tisDirectory: function(key) {\n\t\t\t\tkey = String(key);\n\t\t\t\tlet pathParts = key.split(\"/\").slice(0, -1);\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet basename = key.split(\"/\").slice(-1)[0];\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (!files.hasOwnProperty(basename)) throw new Error(\"NO_SUCH_FILE_DIR\");\n\t\t\t\tif (typeof files[basename] === \"object\") return true;\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\t_recursive_op: function(obj, path, action, stage = 0) {\n\t\t\t\tif (path.split(\"/\").length == (stage + 1)) {\n\t\t\t\t\tif (action.type == \"delete\") delete obj[path.split(\"/\").slice(-1)[0]];\n\t\t\t\t\tif (action.type == \"write\") obj[path.split(\"/\").slice(-1)[0]] = action.value;\n\t\t\t\t} else obj[path.split(\"/\")[stage]] = this._recursive_op(obj[path.split(\"/\")[stage]], path, action, stage + 1);\n\t\t\t\treturn obj;\n\t\t\t},\n\t\t\tsync: async function() {\n\t\t\t\treturn await modules.fs.write(options.srcFile, JSON.stringify({ ...file, backend: this.backend, files: this.files }));\n\t\t\t},\n\t\t\tunmount: () => true,\n\t\t\tdirectory_supported: true,\n\t\t\tread_only: !!options.read_only,\n\t\t\tfilesystem: \"filefs\",\n\t\t\tpermissions_supported: true,\n\t\t\tbackend: backend,\n\t\t\tfiles: files\n\t\t};\n\t}\n\n\tasync function overlayMount(options) {\n\t\treturn {\n\t\t\tread: function(key, token) {\n\t\t\t\treturn this._basic_first_op(\"read\", key, token);\n\t\t\t},\n\t\t\twrite: function(key, value, token) {\n\t\t\t\treturn this._basic_first_op(\"write\", key, value, token);\n\t\t\t},\n\t\t\trm: function(key, token) {\n\t\t\t\treturn this._basic_first_op(\"rm\", key, token);\n\t\t\t},\n\t\t\tls: async function(directory, token) {\n\t\t\t\tlet listing = [], commonErrorMessages = {}, errors = 0;\n\t\t\t\tfor (let mount of options.mounts) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlisting.push(...(await modules.fs.ls(mount + \"/\" + directory, token)));\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\terrors++;\n\t\t\t\t\t\tcommonErrorMessages[e.message] = (commonErrorMessages[e.message] || 0) + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (errors == options.mounts.length) throw new Error(Object.entries(commonErrorMessages).sort((a, b) => b[1] - a[1])[0][0]);\n\t\t\t\treturn Array.from(new Set(listing));\n\t\t\t},\n\t\t\tmkdir: function(directory, token) {\n\t\t\t\treturn this._basic_first_op(\"mkdir\", directory, token);\n\t\t\t},\n\t\t\tpermissions: async function(file, token) {\n\t\t\t\tlet commonErrorMessages = {}, checkedHowMany = 0;\n\t\t\t\tfor (let mount of options.mounts) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcheckedHowMany++;\n\t\t\t\t\t\tlet permissions = await modules.fs.permissions(mount + \"/\" + file, token);\n\t\t\t\t\t\tif (permissions.random && checkedHowMany != options.mounts.length)\n\t\t\t\t\t\t\tthrow new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\t\treturn permissions;\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tcommonErrorMessages[e.message] = (commonErrorMessages[e.message] || 0) + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow new Error(Object.entries(commonErrorMessages).sort((a, b) => b[1] - a[1])[0][0]);\n\t\t\t},\n\t\t\tchown: function(file, owner, token) {\n\t\t\t\treturn this._basic_first_op(\"chown\", file, owner, token);\n\t\t\t},\n\t\t\tchgrp: function(file, group, token) {\n\t\t\t\treturn this._basic_first_op(\"chgrp\", file, group, token);\n\t\t\t},\n\t\t\tchmod: function(file, permissions, token) {\n\t\t\t\treturn this._basic_first_op(\"chmod\", file, permissions, token);\n\t\t\t},\n\t\t\tisDirectory: function(key, token) {\n\t\t\t\treturn this._basic_first_op(\"isDirectory\", key, token);\n\t\t\t},\n\t\t\tsync: function(token) {\n\t\t\t\treturn this._every_op(\"sync\", token);\n\t\t\t},\n\t\t\tunmount: function(token) {\n\t\t\t\tif (options.autoManage) return this._every_op(\"unmount\", token);\n\t\t\t},\n\t\t\t_basic_first_op: async function(op, key, ...args) {\n\t\t\t\tlet pathParts = key.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tkey = pathParts.join(\"/\");\n\t\t\t\tlet previousKey = key.split(\"/\").slice(0, -1).join(\"/\");\n\t\t\t\tlet basename = key.split(\"/\").slice(-1).join(\"/\");\n\t\t\t\tlet lookedForMount;\n\t\t\t\tfor (let mount of options.mounts) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet listing = await modules.fs.ls(mount + \"/\" + previousKey, args[args.length - 1]);\n\t\t\t\t\t\tif (listing.includes(basename)) {\n\t\t\t\t\t\t\tlookedForMount = mount;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch {}\n\t\t\t\t}\n\t\t\t\tif (lookedForMount) return modules.fs[op](lookedForMount + \"/\" + key, ...args);\n\t\t\t\tlet commonErrorMessages = {};\n\t\t\t\tfor (let mount of options.mounts) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn await modules.fs[op](mount + \"/\" + key, ...args);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tcommonErrorMessages[e.message] = (commonErrorMessages[e.message] || 0) + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow new Error(Object.entries(commonErrorMessages).sort((a, b) => b[1] - a[1])[0][0]);\n\t\t\t},\n\t\t\t_every_op: async function(op) {\n\t\t\t\tlet commonErrorMessages = {}, gotError;\n\t\t\t\tfor (let mount of options.mounts) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait modules.fs[op](mount);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tgotError = true;\n\t\t\t\t\t\tcommonErrorMessages[e.message] = (commonErrorMessages[e.message] || 0) + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (gotError) throw new Error(Object.entries(commonErrorMessages).sort((a, b) => b[1] - a[1])[0][0]);\n\t\t\t},\n\t\t\tdirectory_supported: true,\n\t\t\tread_only: !!options.read_only,\n\t\t\tfilesystem: \"overlayfs\",\n\t\t\tpermissions_supported: true\n\t\t};\n\t}\n\t\n\tfs.mounts[\"ram\"] = ramMount({\n\t\ttype: \"run\"\n\t});\n\tmodules.mounts = {\n\t\tPCFSiDBMount,\n\t\tPCFSiDBAESCryptMount,\n\t\tramMount,\n\t\tpreferenceMount,\n\t\tSFSPMount,\n\t\tIPCMount,\n\t\tfileMount,\n\t\toverlayMount\n\t};\n\tmodules.fs = fs;\n\tmodules.defaultSystem = \"ram\";\n}\n\nloadFs();","0bb34dc17a7c39dbab94bedacc9988560c8cbe199836d0ab9fa023e4cf5238a38f79884f343a023eecbba159631772215b7c045cacf632b03552ae9fafb468c6":"async function fsck() {\n\t// @pcos-app-mode native\n\tfunction println(str) {\n\t\tmodules.core.tty_bios_api.println(str);\n\t\treturn new Promise(function(resolve) {\n\t\t\trequestAnimationFrame(resolve);\n\t\t})\n\t}\n\tlet fsckMode;\n\ttry {\n\t\tfsckMode = await modules.fs.read(modules.defaultSystem + \"/.fsck\");\n\t\tawait modules.fs.rm(modules.defaultSystem + \"/.fsck\");\n\t} catch {\n\t\tawait println(\"Skipping file system checking.\");\n\t\treturn;\n\t}\n\tasync function scanLLDA() {\n\t\tlet fs = modules.fs;\n\t\tif (fs.mounts[modules.defaultSystem].read_only) {\n\t\t\tawait println(\"File system is read-only.\");\n\t\t\treturn { lldaPoints: \"abort\", lldaId: \"abort\" };\n\t\t}\n\t\tif (fs.mounts[modules.defaultSystem].partition.getData) {\n\t\t\tlet llda = fs.mounts[modules.defaultSystem].partition.getData().files;\n\t\t\tlet lldaId = fs.mounts[modules.defaultSystem].partition.getData().id;\n\t\t\tllda = Object.values(llda);\n\t\t\twhile (llda.some(a => typeof a === \"object\")) llda = llda.map(a => typeof a === \"object\" ? Object.values(a) : a).flat(); \n\t\t\treturn { lldaPoints: llda, lldaId: lldaId };\n\t\t} else {\n\t\t\tawait println(\"Low-level disk access is impossible.\");\n\t\t\treturn { lldaPoints: \"abort\", lldaId: \"abort\" };\n\t\t}\n\t}\n\tawait println(\"A file system check has been requested.\");\n\tawait println(\"Scanning for file points.\");\n\tlet { lldaPoints, lldaId } = await scanLLDA();\n\tif (lldaPoints === \"abort\") {\n\t\tawait println(\"Skipping file system checking.\");\n\t\treturn;\n\t}\n\tawait println(\"File points found: \" + lldaPoints.length);\n\tawait println(\"Reading indexedDB keys.\");\n\tlet idb_keys = modules.core.idb._db.transaction(\"disk\").objectStore(\"disk\").getAllKeys();\n\tidb_keys = await new Promise(function(resolve) {\n\t\tidb_keys.onsuccess = () => resolve(idb_keys.result);\n\t});\n\tidb_keys.splice(idb_keys.indexOf(\"disk\"), 1);\n\tawait println(\"IndexedDB keys found: \" + idb_keys.length);\n\tawait println(\"Filtering IndexedDB keys...\");\n\tif (fsckMode != \"discard-all\") idb_keys = idb_keys.filter(a => a.startsWith(lldaId + \"-\")).map(a => a.slice(lldaId.length + 1));\n\tawait println(\"Filtered keys: \" + idb_keys.length);\n\tlet missingFiles = idb_keys.filter(a => !lldaPoints.includes(a.slice(fsckMode == \"discard-all\" ? (lldaId + \"-\").length : 0)));\n\tawait println(\"Missing files: \" + missingFiles.length);\n\tlet llda = modules.fs.mounts[modules.defaultSystem].partition.getData();\n\tif (fsckMode == \"recover\") {\n\t\ttry {\n\t\t\tawait modules.fs.mkdir(modules.defaultSystem + \"/lost+found\");\n\t\t\tawait println(\"Created lost+found directory.\");\n\t\t} catch {\n\t\t\tawait println(\"Lost+found directory already exists.\");\n\t\t}\n\t\tfor (let file of missingFiles) {\n\t\t\tawait println(\"Moving \" + file + \" to lost+found.\");\n\t\t\tllda.files[\"lost+found\"][file] = file;\n\t\t}\n\t} else if (fsckMode == \"discard\" || fsckMode == \"discard-all\") {\n\t\tfor (let file of missingFiles) {\n\t\t\tawait println(\"Deleting \" + file + \".\");\n\t\t\tawait modules.core.idb.removePart((fsckMode == \"discard\" ? (lldaId + \"-\") : \"\") + file);\n\t\t}\n\t} else {\n\t\tawait println(\"Unsure what to do, not doing anything.\");\n\t}\n\tawait println(\"Saving modified file table.\");\n\tmodules.fs.mounts[modules.defaultSystem].partition.setData(llda);\n\tawait modules.core.idb.sync();\n\tawait println(\"File system check complete.\");\n}\nawait fsck();","a9d74077f325347dd475e0b3c0c23562473952a043ee922a1e9a0effa7f355c38b8604cac073eb27489c7768877702dac124112a6d5523d76adecb36d3450aaf":"async function loadModules() {\n\tlet hexToU8A = (hex) => Uint8Array.from(hex.match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\tlet khrlSignatures = [];\n\tasync function loadKHRL() {\n\t\tlet khrlFiles = await modules.fs.ls(\".00-keys.fs/etc/keys/khrl\");\n\t\tfor (let khrlFile of khrlFiles) {\n\t\t\tlet khrl = JSON.parse(await modules.fs.read(\".00-keys.fs/etc/keys/khrl/\" + khrlFile));\n\t\t\tlet khrlSignature = khrl.signature;\n\t\t\tdelete khrl.signature;\n\t\t\tif (await crypto.subtle.verify({ name: \"Ed25519\" }, modules.ksk_imported, hexToU8A(khrlSignature), new TextEncoder().encode(JSON.stringify(khrl.list)))) {\n\t\t\t\tkhrlSignatures.push(...khrl.list);\n\t\t\t}\n\t\t}\n\t}\n\tasync function recursiveKeyVerify(key, khrl) {\n\t\tif (!key) throw new Error(\"NO_KEY\");\n\t\tif (key.keyInfo.dates?.since > Date.now()) throw new Error(\"KEY_NOT_IN_TIME\");\n\t\tif (Date.now() > key.keyInfo.dates?.until) throw new Error(\"KEY_NOT_IN_TIME\");\n\t\tlet u8aToHex = (u8a) => Array.from(u8a).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\tlet hash = u8aToHex(new Uint8Array(await crypto.subtle.digest(\"SHA-256\", new TextEncoder().encode((key.keyInfo.key).x))));\n\t\tlet hexToU8A = (hex) => Uint8Array.from(hex.match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\tif (khrl.includes(hash)) throw new Error(\"KEY_REVOKED\");\n\t\tlet signedByKey = modules.ksk_imported;\n\t\tif (key.keyInfo.signedBy) {\n\t\t\tsignedByKey = JSON.parse(await modules.fs.read(\".00-keys.fs/etc/keys/\" + key.keyInfo.signedBy));\n\t\t\tif (!signedByKey.keyInfo.usages.includes(\"keyTrust\")) throw new Error(\"NOT_KEY_AUTHORITY\");\n\t\t\tawait recursiveKeyVerify(signedByKey, khrl);\n\t\t\tsignedByKey = await crypto.subtle.importKey(\"jwk\", signedByKey.keyInfo.key, { name: \"Ed25519\" }, false, [\"verify\"]);\n\t\t}\n\t\tif (!await crypto.subtle.verify({ name: \"Ed25519\" }, signedByKey, hexToU8A(key.signature), new TextEncoder().encode(JSON.stringify(key.keyInfo)))) throw new Error(\"KEY_SIGNATURE_VERIFICATION_FAILED\");\n\t\treturn true;\n\t}\n\ttry {\n\t\tlet moduleList = (await modules.fs.ls(modules.defaultSystem + \"/modules\")).sort((a, b) => a.localeCompare(b));\n\t\tfor (let moduleName of moduleList) {\n\t\t\tlet fullModuleFile = JSON.parse(await modules.fs.read(modules.defaultSystem + \"/modules/\" + moduleName));\n\t\t\tlet fullModuleSignature = fullModuleFile.buildInfo.signature;\n\t\t\tdelete fullModuleFile.buildInfo.signature;\n\t\t\tif (moduleName == \"00-keys.fs\") {\n\t\t\t\ttry {\n\t\t\t\t\tfullModuleFile = JSON.stringify(fullModuleFile);\n\t\t\t\t\tif (!(await crypto.subtle.verify({\n\t\t\t\t\t\tname: \"Ed25519\"\n\t\t\t\t\t}, modules.ksk_imported, hexToU8A(fullModuleSignature), new TextEncoder().encode(fullModuleFile)))) throw new Error(\"MODULE_SIGNATURE_VERIFICATION_FAILED\");\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (modules.core.bootMode != \"disable-harden\") await panic(\"KEYS_MODULE_VERIFICATION_FAILED\", {\n\t\t\t\t\t\tname: \"/modules/00-keys.fs\",\n\t\t\t\t\t\tparams: [modules.defaultSystem],\n\t\t\t\t\t\tunderlyingJS: e\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlet critical = fullModuleFile.buildInfo.critical;\n\t\t\t\ttry {\n\t\t\t\t\tlet signingKey = JSON.parse(await modules.fs.read(\".00-keys.fs/etc/keys/\" + fullModuleFile.buildInfo.signer));\n\t\t\t\t\tawait recursiveKeyVerify(signingKey, khrlSignatures);\n\t\t\t\t\tif (!signingKey.keyInfo.usages.includes(\"moduleTrust\")) throw new Error(\"NOT_MODULE_SIGNING_KEY\");\n\t\t\t\t\tlet importSigningKey = await crypto.subtle.importKey(\"jwk\", signingKey.keyInfo.key, { name: \"Ed25519\" }, false, [\"verify\"]);\n\t\t\t\t\tfullModuleFile = JSON.stringify(fullModuleFile);\n\t\t\t\t\tif (!await crypto.subtle.verify({\n\t\t\t\t\t\tname: \"Ed25519\"\n\t\t\t\t\t}, importSigningKey, hexToU8A(fullModuleSignature), new TextEncoder().encode(fullModuleFile))) throw new Error(\"MODULE_SIGNATURE_VERIFICATION_FAILED\");\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(\"Failed to verify module:\", e);\n\t\t\t\t\tif (critical && modules.core.bootMode != \"disable-harden\") await panic(\"CRITICAL_MODULE_VERIFICATION_FAILED\", {\n\t\t\t\t\t\tname: \"/modules/\" + moduleName,\n\t\t\t\t\t\tparams: [modules.defaultSystem],\n\t\t\t\t\t\tunderlyingJS: e\n\t\t\t\t\t});\n\t\t\t\t\tif (modules.core.bootMode != \"disable-harden\") {\n\t\t\t\t\t\tmoduleList.splice(moduleList.indexOf(moduleName), 1);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmodules.fs.mounts[\".\" + moduleName] = await modules.mounts.fileMount({\n\t\t\t\tsrcFile: modules.defaultSystem + \"/modules/\" + moduleName,\n\t\t\t\tread_only: true\n\t\t\t});\n\t\t\tif (moduleName == \"00-keys.fs\") await loadKHRL();\n\t\t\tif (modules.core.bootMode == \"logboot\") modules.core.tty_bios_api.println(\"\\t../modules/\" + moduleName);\n\t\t}\n\t\tlet newSystemMount = \"system\";\n\t\tif (modules.defaultSystem == \"system\") newSystemMount = \"system-\" + crypto.getRandomValues(new Uint8Array(4)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\tmodules.fs.mounts[newSystemMount] = await modules.mounts.overlayMount({\n\t\t\tmounts: [ modules.defaultSystem, ...moduleList.map(a => \".\" + a) ]\n\t\t});\n\t\tmodules.defaultSystem = newSystemMount;\n\t} catch (e) {\n\t\tconsole.error(\"Module system failed:\", e);\n\t}\n}\nawait loadModules();","af2268b91223e49ab4a25f15b525b70df5b3ed78035c36c9391daee06f2b4b531159b0f5347070bf94e50ba361a4707eab795308bb4e026dc0baf757c3cb8d9d":"function loadUi() {\n\t// @pcos-app-mode native\n\tlet uiStyle = document.createElement(\"style\");\n\tuiStyle.innerHTML = `body {\n\t\toverflow: hidden;\n\t\tbackground: black;\n\t\tcursor: none;\n\t\tfont-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n\t}\n\n\t.taskbar {\n\t\twidth: 100%;\n\t\tbackground: ${modules.core.bootMode == \"safe\" ? \"rgb(128, 128, 128)\" : \"rgba(128, 128, 128, 0.85)\"};\n\t\tleft: 0;\n\t\tbottom: 0;\n\t\tposition: absolute;\n\t\tpadding: 4px;\n\t\tbox-sizing: border-box;\n\t\tborder-radius: 4px;\n\t\tdisplay: flex;\n\t}\n\n\t.taskbar .clock {\n\t\tmargin-right: 4px;\n\t}\n\n\t.taskbar .icon {\n\t\twidth: 27px;\n\t\theight: 27px;\n\t\tbackground-size: contain;\n\t\tmargin: 0 4px;\n\t}\n\n\t.filler {\n\t\tflex: 1;\n\t}\n\n\t.window {\n\t\tposition: absolute;\n\t\ttop: 50%;\n\t\tleft: 50%;\n\t\ttransform: translate(-50%, -50%);\n\t\tbackground-color: ${modules.core.bootMode == \"safe\" ? \"rgb(240, 240, 240)\" : \"rgba(240, 240, 240, 0.5)\"};\n\t\tborder: 1px solid #ccc;\n\t\tbox-shadow: ${modules.core.bootMode == \"safe\" ? \"none\" : \"0 0 5px rgba(0, 0, 0, 0.3)\"};\n\t\tz-index: 1;\n\t\tresize: both;\n\t\twidth: 320px;\n\t\theight: 180px;\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t\toverflow: auto;\n\t\tbackdrop-filter: ${modules.core.bootMode == \"safe\" ? \"none\" : \"blur(8px)\"};\n\t\tanimation: ${modules.core.bootMode == \"safe\" ? \"none\" : \"fade-in 0.1s ease-in forwards\"};\n\t\tborder-radius: 4px;\n\t}\n\n\n\t.window.icon {\n\t\ttop: 72px;\n\t\tleft: 72px;\n\t\tresize: none;\n\t\twidth: 128px;\n\t\theight: 128px;\n\t}\n\n\t.window.dark {\n\t\tbackground-color: ${modules.core.bootMode == \"safe\" ? \"rgb(55, 55, 55)\" : \"rgba(55, 55, 55, 0.5)\"};\n\t\tcolor: white;\n\t\tborder: 1px solid #1b1b1b;\n\t}\n\n\t.window .title-bar {\n\t\tpadding: 6px;\n\t\tbackground-color: ${modules.core.bootMode == \"safe\" ? \"rgb(204, 204, 204)\" : \"rgba(204, 204, 204, 0.5)\"};\n\t\tcursor: move;\n\t\tdisplay: flex;\n\t\tflex: 1;\n\t\tuser-select: none;\n\t}\n\n\t.window.dark .title-bar {\n\t\tbackground-color: ${modules.core.bootMode == \"safe\" ? \"rgb(27, 27, 27)\" : \"rgba(27, 27, 27, 0.5)\"};\n\t}\n\n\t.window .button {\n\t\tcursor: pointer;\n\t\tpadding: 4px;\n\t\tborder: none;\n\t\tflex: 1;\n\t\tmargin: 0 0 0 2px;\n\t\tborder-radius: 4px;\n\t}\n\n\t.window .button:hover {\n\t\topacity: 75%;\n\t}\n\n\t.window .close-button {\n\t\tbackground: red;\n\t\tcolor: white;\n\t}\n\n\t.window .title-displayer {\n\t\tflex: 100;\n\t}\n\n\t.window .close-button:disabled {\n\t\topacity: 25%;\n\t}\n\n\t.window.fullscreen .resize-handle {\n\t\tdisplay: none;\n\t}\n\n\t.window.fullscreen {\n\t\twidth: 100% !important;\n\t\theight: 100% !important;\n\t\tposition: fixed;\n\t\ttop: 0 !important;\n\t\tleft: 0 !important;\n\t\ttransform: none;\n\t\tresize: none;\n\t\tborder: none;\n\t\tbox-shadow: none;\n\t}\n\n\t.window.fullscreen .title-bar {\n\t\tcursor: default;\n\t}\n\n\t.window .content {\n\t\tflex: 100;\n\t\toverflow: auto;\n\t\tposition: relative;\n\t\tbackground-color: #f0f0f0;\n\t}\n\n\t.window.dark .content {\n\t\tbackground-color: #373737;\n\t}\n\n\t.session {\n\t\tposition: fixed;\n\t\ttop: 0;\n\t\tleft: 0;\n\t\twidth: 100%;\n\t\theight: 100%;\n\t\tbackground: black;\n\t\tcursor: default;\n\t\tanimation: ${modules.core.bootMode == \"safe\" ? \"none\" : \"fade-in 0.1s ease-in forwards\"};\n\t}\n\n\t.session.secure {\n\t\tbackground: none${modules.core.bootMode == \"safe\" ? \" !important\" : \"\"};\n\t\tbackdrop-filter: ${modules.core.bootMode == \"safe\" ? \"none\" : \"blur(8px) brightness(50%)\"};\n\t\tanimation: ${modules.core.bootMode == \"safe\" ? \"none\" : \"fade 0.1s ease-out forwards\"};\n\t}\n\n\t.hidden {\n\t\tdisplay: none;\n\t}\n\t\n\t@keyframes fade-in {\n\t\t0% {\n\t\t\topacity: 0;\n\t\t}\n\n\t\t100% {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\n\t@keyframes fade {\n\t\t0% {\n\t\t\tbackdrop-filter: blur(0px) brightness(100%);\n\t\t}\n\n\t\t100% {\n\t\t\tbackdrop-filter: blur(8px) brightness(50%);\n\t\t}\n\t}`;\n\tdocument.head.appendChild(uiStyle);\n\n\tfunction createWindow(sessionId, makeFullscreenOnAllScreens, asIconWindow, reportMovement) {\n\t\tlet fullscreen = makeFullscreenOnAllScreens || matchMedia(\"(max-width: 600px)\").matches;\n\t\tif (asIconWindow) fullscreen = false;\n\t\tlet id = crypto.getRandomValues(new Uint8Array(64)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\tlet windowDiv = document.createElement('div');\n\t\twindowDiv.className = 'window ' + (fullscreen ? \"fullscreen \" : \"\") + \" \" + (asIconWindow ? \"icon\" : \"\");\n\t\tif (session.attrib(sessionId, \"dark\")) windowDiv.classList.add(\"dark\");\n\t\twindowDiv.id = 'window-' + id;\n\t\tlet titleBar = document.createElement('div');\n\t\ttitleBar.className = 'title-bar';\n\t\tlet title = document.createElement('span');\n\t\ttitle.className = 'title-displayer';\n\t\tlet closeButton = document.createElement('button');\n\t\tcloseButton.className = 'button close-button';\n\t\tcloseButton.innerHTML = '&#10005;';\n\t\ttitleBar.appendChild(title);\n\t\tif (!fullscreen && !asIconWindow) {\n\t\t\tlet fullscreenButton = document.createElement('button');\n\t\t\tfullscreenButton.className = 'button';\n\t\t\tfullscreenButton.innerHTML = '&#x25a1;';\n\t\t\tfullscreenButton.onclick = function() {\n\t\t\t\twindowDiv.classList.toggle(\"fullscreen\");\n\t\t\t}\n\t\t\ttitleBar.appendChild(fullscreenButton);\n\t\t}\n\t\tif (!asIconWindow) titleBar.appendChild(closeButton);\n\t\twindowDiv.appendChild(titleBar);\n\t\tlet content = document.createElement('div');\n\t\tcontent.className = 'content';\n\t\twindowDiv.appendChild(content);\n\t\tsession.tracker[sessionId].html.appendChild(windowDiv);\n\t\tif (!fullscreen) makeDraggable(windowDiv, titleBar, reportMovement);\n\t\treturn {\n\t\t\twindowDiv,\n\t\t\ttitle,\n\t\t\tcloseButton,\n\t\t\tcontent,\n\t\t\tsessionId\n\t\t};\n\t}\n\n\tfunction makeDraggable(windowDiv, titleBar, reportMovement) {\n\t\tlet pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;\n\n\t\ttitleBar.onmousedown = dragMouseDown;\n\t\ttitleBar.ontouchstart = dragMouseDown;\n\n\t\tfunction dragMouseDown(e) {\n\t\t\tif (e.type != \"touchstart\") e.preventDefault();\n\t\t\tif (e.type == \"touchstart\") e = e.touches[0];\n\t\t\tpos3 = e.clientX;\n\t\t\tpos4 = e.clientY;\n\n\t\t\tdocument.onmouseup = closeDragElement;\n\t\t\tdocument.ontouchend = closeDragElement;\n\t\t\tdocument.ontouchcancel = closeDragElement;\n\t\t\tdocument.onmousemove = elementDrag;\n\t\t\tdocument.ontouchmove = elementDrag;\n\t\t}\n\n\t\tfunction elementDrag(e) {\n\t\t\te.preventDefault();\n\t\t\tif (e.type == \"touchmove\") e = e.touches[0];\n\t\t\tpos1 = pos3 - e.clientX;\n\t\t\tpos2 = pos4 - e.clientY;\n\t\t\tpos3 = e.clientX;\n\t\t\tpos4 = e.clientY;\n\n\t\t\tif (!windowDiv.classList.contains(\"fullscreen\")) {\n\t\t\t\tif (reportMovement) reportMovement(windowDiv.offsetLeft - pos1, windowDiv.offsetTop - pos2);\n\t\t\t\twindowDiv.style.top = windowDiv.offsetTop - pos2 + 'px';\n\t\t\t\twindowDiv.style.left = windowDiv.offsetLeft - pos1 + 'px';\n\t\t\t}\n\t\t}\n\n\t\tfunction closeDragElement() {\n\t\t\tdocument.onmouseup = null;\n\t\t\tdocument.ontouchend = null;\n\t\t\tdocument.ontouchcancel = null;\n\t\t\tdocument.onmousemove = null;\n\t\t\tdocument.ontouchmove = null;\n\t\t}\n\t}\n\n\tlet session = {\n\t\tmksession: function() {\n\t\t\tif (modules.shuttingDown) throw new Error(\"SYSTEM_SHUTDOWN_REQUESTED\");\n\t\t\tlet identifier = crypto.getRandomValues(new Uint8Array(64)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\tlet session = document.createElement('div');\n\t\t\tsession.className = \"session hidden\";\n\t\t\tdocument.body.appendChild(session);\n\t\t\tthis.tracker[identifier] = {\n\t\t\t\thtml: session,\n\t\t\t\tattrib: {}\n\t\t\t};\n\t\t\treturn identifier;\n\t\t},\n\t\trmsession: function(session) {\n\t\t\tthis.tracker[session].html.remove();\n\t\t\tdelete this.tracker[session];\n\t\t},\n\t\tmuteAllSessions: function() {\n\t\t\tfor (let session in this.tracker) this.tracker[session].html.classList.add(\"hidden\");\n\t\t\tthis.active = null;\n\t\t},\n\t\tactivateSession: function(session) {\n\t\t\tthis.tracker[this.active]?.html?.classList?.add(\"hidden\");\n\t\t\tthis.tracker[session].html.classList.remove(\"hidden\");\n\t\t\tthis.active = session;\n\t\t},\n\t\tattrib: function(session, key, val) {\n\t\t\tif (val !== undefined) this.tracker[session].attrib[key] = val;\n\t\t\tif (key !== undefined) return this.tracker[session].attrib[key];\n\t\t\treturn this.tracker[session].attrib;\n\t\t},\n\t\tdestroy: function() {\n\t\t\tfor (let session in this.tracker) this.rmsession(session);\n\t\t\tthis.tracker = {};\n\t\t\tdelete this.systemSession;\n\t\t\tdelete modules.liu;\n\t\t\tdelete modules.serviceSession;\n\t\t\tuiStyle.remove();\n\t\t\tdelete modules.uiStyle;\n\t\t},\n\t\ttracker: {},\n\t\tactive: null\n\t}\n\n\tmodules.window = createWindow;\n\tmodules.session = session;\n\tmodules.uiStyle = uiStyle;\n\n\tmodules.session.systemSession = session.mksession();\n\tsession.muteAllSessions();\n\tsession.activateSession(modules.session.systemSession);\n\tmodules.startupWindow = modules.window(modules.session.systemSession);\n\tmodules.startupWindowProgress = document.createElement(\"progress\");\n\tmodules.startupWindow.title.innerText = \"PCOS 3\";\n\tmodules.startupWindow.content.style.padding = \"8px\";\n\tmodules.startupWindow.closeButton.classList.toggle(\"hidden\", true);\n\tmodules.startupWindow.content.innerText = \"PCOS is starting...\";\n\tmodules.startupWindow.content.appendChild(document.createElement(\"br\"));\n\tmodules.startupWindow.content.appendChild(modules.startupWindowProgress);\n}\n\nloadUi();","853f5b3e40526a7b3d87eeee411205a4d47f9a5b71020f85542c15856b212453e0f71c78766516b7412e3ca91518449d4ac9dcd08367b2b2f38846b1bd849620":"function loadIpc() {\n\t// @pcos-app-mode native\n\tmodules.ipc = {\n\t\tcreate: function() {\n\t\t\tlet id = crypto.getRandomValues(new Uint8Array(64)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\tthis._ipc[id] = { owner: \"root\", group: \"root\", world: false, _listeners: [] };\n\t\t\treturn id;\n\t\t},\n\t\tdeclareAccess: function(id, access) {\n\t\t\tthis._ipc[id] = { ...this._ipc[id], ...access };\n\t\t},\n\t\tlistenFor: function(id) {\n\t\t\tlet thatIPC = this._ipc;\n\t\t\treturn new Promise(function(resolve) {\n\t\t\t\tlet hasResolved = false;\n\t\t\t\treturn thatIPC[id]._listeners.push(function e(d) {\n\t\t\t\t\tif (hasResolved) return;\n\t\t\t\t\thasResolved = true;\n\t\t\t\t\treturn resolve(d);\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\t\tsend: function(id, data) {\n\t\t\ttry {\n\t\t\t\tthis._ipc[id]._listeners.forEach(listener => listener(data));\n\t\t\t} catch {}\n\t\t},\n\t\tgetIPC: function(id) {\n\t\t\tlet ipc = { ...this._ipc[id] };\n\t\t\tipc._listeners = ipc._listeners.length;\n\t\t\treturn ipc;\n\t\t},\n\t\t_ipc: {}\n\t}\n}\nloadIpc();","348c0e602bce147be27b1a7e08bc5356f50123e4a225d4eab8495acf287dd9e98a946793991fdb69589a46a7e073ae60314682821ad85ca10cd15929c65d2798":"function loadWebsocketSupport() {\n\tlet websocketAPI = {\n\t\tgetHandle: function(url) {\n\t\t\tlet handle = Array.from(crypto.getRandomValues(new Uint8Array(64))).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\tlet websocket = new WebSocket(url);\n\t\t\twebsocket.binaryType = \"arraybuffer\";\n\t\t\twebsocketAPI._handles[handle] = {\n\t\t\t\tws: websocket,\n\t\t\t\tacl: {\n\t\t\t\t\towner: handle.slice(0, 16),\n\t\t\t\t\tgroup: handle.slice(0, 16),\n\t\t\t\t\tworld: true\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn handle;\n\t\t},\n\t\tsend: (arg) => websocketAPI._handles[arg.handle].ws.send(arg.data),\n\t\tclose: function(handle) {\n\t\t\tif (websocketAPI._handles.hasOwnProperty(handle)) websocketAPI._handles[handle].ws.close();\n\t\t\tdelete websocketAPI._handles[handle];\n\t\t},\n\t\tgetInfo: function(handle) {\n\t\t\treturn {\n\t\t\t\tbufferedAmount: websocketAPI._handles[handle].ws.bufferedAmount,\n\t\t\t\textensions: websocketAPI._handles[handle].ws.extensions,\n\t\t\t\tprotocol: websocketAPI._handles[handle].ws.protocol,\n\t\t\t\treadyState: websocketAPI._handles[handle].ws.readyState,\n\t\t\t\turl: websocketAPI._handles[handle].ws.url\n\t\t\t}\n\t\t},\n\t\twaitForEvent: function(arg) {\n\t\t\treturn new Promise(function(resolve) {\n\t\t\t\twebsocketAPI._handles[arg.handle].ws.addEventListener(arg.eventName, function meName(arg2) {\n\t\t\t\t\tif (arg.eventName == \"message\") resolve(arg2.data);\n\t\t\t\t\telse if (arg.eventName == \"error\") resolve({\n\t\t\t\t\t\tcode: arg2.code,\n\t\t\t\t\t\treason: arg2.reason,\n\t\t\t\t\t\twasClean: arg2.wasClean\n\t\t\t\t\t});\n\t\t\t\t\telse resolve(arg.eventName);\n\t\t\t\t\ttry {\n\t\t\t\t\t\twebsocketAPI._handles[arg.handle].ws.removeEventListener(arg.eventName, meName);\n\t\t\t\t\t} catch {}\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\t\tassertAccess: function(arg) {\n\t\t\tif (arg.newACL) websocketAPI._handles[arg.handle].acl = arg.newACL;\n\t\t\treturn websocketAPI._handles[arg.handle].acl;\n\t\t},\n\t\twebsocketState: (handle) => websocketAPI._handles[handle].ws.readyState,\n\t\t_handles: {}\n\t}\n\tmodules.websocket = websocketAPI;\n}\n\nloadWebsocketSupport();","c6bc8117f8dc7bc508f22bf59fc56e73ca4cd9c6b5255b408339b3ea5ea1a39329f33c8b497322f45ea48ee790c5afe572a0f883ae39d275da6e2a15859c8e40":"function loadLull() {\n\tlet lullSession;\n\tmodules.lull = function() {\n\t\tif (lullSession) return;\n\t\tlet style = document.createElement(\"style\");\n\t\tstyle.innerHTML = `* { cursor: none !important; };`;\n\t\tdocument.head.appendChild(style);\n\t\tlullSession = modules.session.mksession();\n\t\tmodules.session.muteAllSessions();\n\t\tmodules.session.activateSession(lullSession);\n\t\tfunction wake() {\n\t\t\tremoveEventListener(\"mousemove\", wake);\n\t\t\tremoveEventListener(\"click\", wake);\n\t\t\tremoveEventListener(\"keydown\", wake);\n\t\t\tstyle.remove();\n\t\t\tmodules.session.muteAllSessions();\n\t\t\tmodules.session.activateSession(modules.session.systemSession);\n\t\t\tmodules.session.rmsession(lullSession);\n\t\t\tlullSession = null;\n\t\t}\n\t\taddEventListener(\"mousemove\", wake);\n\t\taddEventListener(\"click\", wake);\n\t\taddEventListener(\"keydown\", wake);\n\t}\n}\nloadLull();","31269ce496a9b4cb2d671d97813258780914cd120a395243f37b80c2388c46c7924284e3e2fb73c1f15d1168554bd625e3ec9b027238cd8cc6d293f3581e7284":"async function networkd() {\n\tlet hexToU8A = (hex) => Uint8Array.from(hex.match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\tlet u8aToHex = (u8a) => Array.from(u8a).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\tmodules.network = { connected: false, address: null, ws: null, runOnClose: Promise.resolve(), _runOnClose: _ => 1 };\n\ttry {\n\t\tlet config = await modules.fs.read(modules.defaultSystem + \"/etc/network.json\");\n\t\tconfig = JSON.parse(config);\n\t\tfunction isPacketFiltered(packet) {\n\t\t\tif (!config.filters) return false;\n\t\t\tfor (let filter of config.filters) {\n\t\t\t\tif (filter.type == 0) return filter.result;\n\t\t\t\tif (filter.type == 1 && isPacketFrom(packet, filter)) return filter.result;\n\t\t\t\tif (filter.type == 2 && filter.protocol == packet.data.type) return filter.result;\n\t\t\t\tif (filter.type == 3 && isPacketFrom(packet, filter) && filter.protocol == packet.data.type) return filter.result;\n\t\t\t\tif (filter.type == 4 && isPacketFrom(packet, filter) &&\n\t\t\t\t\t(packet.data.type == \"connectionful\" || packet.data.type == \"connectionless\")) {\n\t\t\t\t\t\tif (packet.data.gate == filter.gate) return filter.result;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tfunction isPacketFrom(packet, filter) {\n\t\t\tif (filter.from == packet.from) return true;\n\t\t\tif (filter.ipHash == packet.from.slice(0, 8)) return true;\n\t\t\tif (filter.systemID == packet.from.slice(8, 24)) return true;\n\t\t\treturn false;\n\t\t}\n\t\tmodules.network.reloadConfig = async function() {\n\t\t\tconfig = JSON.parse(await modules.fs.read(modules.defaultSystem + \"/etc/network.json\"));\n\t\t\tmodules.network.updates = config.updates;\n\t\t\ttry {\n\t\t\t\tws.send(JSON.stringify({\n\t\t\t\t\tfinalProxyPacket: true\n\t\t\t\t}));\n\t\t\t\tws.close();\n\t\t\t} catch {\n\t\t\t\tonclose();\n\t\t\t}\n\t\t}\n\t\tmodules.network.updates = config.updates;\n\t\tlet stage = 0;\n\t\tlet pukey = (modules.core.prefs.read(\"system_id\") || {}).public;\n\t\tlet importedKey = await crypto.subtle.importKey(\"jwk\", (modules.core.prefs.read(\"system_id\") || {}).private, { name: \"Ed25519\" }, true, [\"sign\"]);\n\t\tlet ws = new WebSocket(config.url);\n\t\tlet handle = Array.from(crypto.getRandomValues(new Uint8Array(64))).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\tmodules.network.runOnClose = new Promise(a => modules.network._runOnClose = a);\n\t\tws.binaryType = \"arraybuffer\";\n\t\tasync function onclose() {\n\t\t\tmodules.network.connected = false;\n\t\t\tmodules.network.address = null;\n\t\t\tmodules.network.hostname = null;\n\t\t\tmodules.network._runOnClose();\n\t\t\tws = new WebSocket(config.url);\n\t\t\tstage = 0;\n\t\t\tws.onmessage = onmessage;\n\t\t\tws.onclose = onclose;\n\t\t\tmodules.network.runOnClose = new Promise(a => modules.network._runOnClose = a);\n\t\t}\n\t\tasync function onmessage(e) {\n\t\t\tlet messageData;\n\t\t\ttry {\n\t\t\t\tmessageData = JSON.parse(e.data);\n\t\t\t} catch {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (stage == 0) {\n\t\t\t\tws.send(JSON.stringify({ ...pukey, forceConnect: true, userCustomizable: config.ucBits, hostname: config.hostname }));\n\t\t\t\tstage++;\n\t\t\t} else if (stage == 1) {\n\t\t\t\tif (messageData.event != \"SignatureRequest\") {\n\t\t\t\t\tws.onclose = null;\n\t\t\t\t\tdelete modules.websocket._handles[handle];\n\t\t\t\t\treturn ws.close();\n\t\t\t\t}\n\t\t\t\tws.send(u8aToHex(new Uint8Array(await crypto.subtle.sign({ name: \"Ed25519\" }, importedKey, hexToU8A(messageData.signBytes)))));\n\t\t\t\tstage++;\n\t\t\t} else if (stage == 2) {\n\t\t\t\tif (messageData.event != \"ConnectionEstablished\") {\n\t\t\t\t\tws.onclose = null;\n\t\t\t\t\tdelete modules.websocket._handles[handle];\n\t\t\t\t\treturn ws.close();\n\t\t\t\t}\n\t\t\t\tmodules.websocket._handles[handle] = {\n\t\t\t\t\tws: ws,\n\t\t\t\t\tacl: {\n\t\t\t\t\t\towner: handle.slice(0, 16),\n\t\t\t\t\t\tgroup: handle.slice(0, 16),\n\t\t\t\t\t\tworld: true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmodules.network.connected = true;\n\t\t\t\tmodules.network.address = messageData.address;\n\t\t\t\tmodules.network.hostname = messageData.hostname;\n\t\t\t\tmodules.network.ws = handle;\n\t\t\t\tstage++;\n\t\t\t} else if (stage == 3) {\n\t\t\t\tif (messageData.event == \"DisconnectionComplete\") {\n\t\t\t\t\tmodules.network.connected = false;\n\t\t\t\t\tmodules.network.address = null;\n\t\t\t\t\tmodules.network.hostname = null;\n\t\t\t\t\tmodules.network.ws = null;\n\t\t\t\t\tmodules.network._runOnClose();\n\t\t\t\t\tws.onclose = null;\n\t\t\t\t\tdelete modules.websocket._handles[handle];\n\t\t\t\t\treturn ws.close();\n\t\t\t\t}\n\t\t\t\tif (messageData.from) {\n\t\t\t\t\tif (isPacketFiltered(messageData)) {\n\t\t\t\t\t\te.stopImmediatePropagation();\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (messageData.data.type == \"ping\") {\n\t\t\t\t\t\tif (typeof messageData.data.resend !== \"string\") return;\n\t\t\t\t\t\tif (messageData.data.resend.length > 64) return;\n\t\t\t\t\t\tws.send(JSON.stringify({ receiver: messageData.from, data: { type: \"pong\", resend: messageData.data.resend } }));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tws.onmessage = onmessage;\n\t\tws.onclose = onclose;\n\t} catch {\n\t\tmodules.network.serviceStopped = true;\n\t\tmodules.core.tty_bios_api.println(\"network: not starting network\");\n\t}\n}\nnetworkd();","149411fdbbac9a38b24b20526f9fe633ab0fa5274297e162cb8315f70b8ee755c306ffab8f43fde05ffbfcc9a6e0e65c160b64c0968d9deff115b8f1a3e6123b":"function reeAPIs() {\n\t// @pcos-app-mode native\n\n\tasync function denyUnmanifested(list, token) {\n\t\tlet privileges = (await modules.tokens.info(token)).privileges;\n\t\tlet isAllowlist = list.some(a => a.lineType == \"allow\");\n\t\tif (isAllowlist) list = list.filter(a => a.lineType == \"allow\");\n\t\tlet disallowedRegistry = [];\n\t\tfor (let privilege of privileges) {\n\t\t\tif ((!list.some(x => x.data == privilege && x.lineType == \"allow\") && isAllowlist) || list.some(x => x.data == privilege && x.lineType == \"deny\")) {\n\t\t\t\tprivileges = privileges.filter(x => x != privilege);\n\t\t\t\tdisallowedRegistry.push(privilege);\n\t\t\t}\n\t\t}\n\t\tmodules.tokens.removePrivileges(token, disallowedRegistry);\n\t\treturn privileges;\n\t}\n\n\tmodules.reeAPIInstance = async function(opts) {\n\t\tlet {ree, ses, token, taskId, limitations, privateData} = opts;\n\t\tlet processToken = token;\n\t\tlet tokenInfo = await modules.tokens.info(token);\n\t\tlet user = tokenInfo.user;\n\t\tlet groups = tokenInfo.groups || [];\n\t\tlet privileges = tokenInfo.privileges;\n\t\tlet processPipes = [];\n\t\tlet websockets = [];\n\t\tlet automatedLogonSessions = {};\n\t\tlet networkListens = {};\n\t\tlet connections = {};\n\t\tlet language = modules.session.attrib(ses, \"language\") || undefined;\n\t\tprivileges = await denyUnmanifested(limitations, token);\n\n\t\tasync function fs_action(action, privilegeCheck, path, ...xtra) {\n\t\t\tlet fsPermissions;\n\t\t\ttry {\n\t\t\t\tfsPermissions = await modules.fs.permissions(path);\n\t\t\t} catch (e) {\n\t\t\t\tif (e.name == \"Error\") throw e;\n\t\t\t\tthrow new Error(\"FS_ACTION_FAILED\");\n\t\t\t}\n\t\t\tif (!privilegeCheck(fsPermissions)) throw new Error(\"PERMISSION_DENIED\");\n\t\t\ttry {\n\t\t\t\tlet response = await modules.fs[action](path, ...xtra);\n\t\t\t\treturn response;\n\t\t\t} catch (e) {\n\t\t\t\tif (e.name == \"Error\") throw e;\n\t\t\t\tthrow new Error(\"FS_ACTION_FAILED\");\n\t\t\t}\n\t\t}\n\t\tasync function recursiveKeyVerify(key, khrl) {\n\t\t\tif (!key) throw new Error(\"NO_KEY\");\n\t\t\tif (key.keyInfo.dates?.since > Date.now()) throw new Error(\"KEY_NOT_IN_TIME\");\n\t\t\tif (Date.now() > key.keyInfo.dates?.until) throw new Error(\"KEY_NOT_IN_TIME\");\n\t\t\tlet u8aToHex = (u8a) => Array.from(u8a).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\tlet hash = u8aToHex(new Uint8Array(await crypto.subtle.digest(\"SHA-256\", new TextEncoder().encode((key.keyInfo.key).x))));\n\t\t\tlet hexToU8A = (hex) => Uint8Array.from(hex.match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\tif (khrl.includes(hash)) throw new Error(\"KEY_REVOKED\");\n\t\t\tlet signedByKey = modules.ksk_imported;\n\t\t\tif (key.keyInfo.signedBy) {\n\t\t\t\tsignedByKey = JSON.parse(await modules.fs.read(modules.defaultSystem + \"/etc/keys/\" + key.keyInfo.signedBy, token));\n\t\t\t\tif (!signedByKey.keyInfo.usages.includes(\"keyTrust\")) throw new Error(\"NOT_KEY_AUTHORITY\");\n\t\t\t\tawait recursiveKeyVerify(signedByKey, khrl);\n\t\t\t\tsignedByKey = await crypto.subtle.importKey(\"jwk\", signedByKey.keyInfo.key, { name: \"Ed25519\" }, false, [\"verify\"]);\n\t\t\t}\n\t\t\tif (!await crypto.subtle.verify({ name: \"Ed25519\" }, signedByKey, hexToU8A(key.signature), new TextEncoder().encode(JSON.stringify(key.keyInfo)))) throw new Error(\"KEY_SIGNATURE_VERIFICATION_FAILED\");\n\t\t\treturn true;\n\t\t}\n\n\t\tree.beforeCloseDown(async function() {\n\t\t\tfor (let processPipe of processPipes) delete modules.ipc._ipc[processPipe];\n\t\t\tfor (let connection in connections) try { networkListens[connections[connection].networkListenID].ws.send(JSON.stringify({\n\t\t\t\treceiver: connections[connection].from,\n\t\t\t\tdata: {\n\t\t\t\t\ttype: \"connectionful\",\n\t\t\t\t\taction: \"drop\",\n\t\t\t\t\tconnectionID: connection.slice(0, -7),\n\t\t\t\t\tgate: connections[connection].gateIfNeeded\n\t\t\t\t}\n\t\t\t})); } catch {}\n\t\t\tfor (let networkListen in networkListens) networkListens[networkListen].ws.removeEventListener(\"message\", networkListens[networkListen].fn);\n\t\t\tfor (let websocket of websockets) modules.websocket.close(websocket);\n\t\t\tawait modules.tokens.revoke(token);\n\t\t\tfor (let i in modules.csps) if (modules.csps[i].hasOwnProperty(\"removeSameGroupKeys\")) modules.csps[i].removeSameGroupKeys(null, taskId);\n\t\t});\n\t\tlet apis = {\n\t\t\tprivate: {\n\t\t\t\tsetUser: async function(newUser) {\n\t\t\t\t\tuser = newUser;\n\t\t\t\t\tgroups = (await modules.users.getUserInfo(newUser, false, token || processToken)).groups || [];\n\t\t\t\t},\n\t\t\t\taddPrivilege: (newPrivilege) => !privileges.includes(newPrivilege) && privileges.push(newPrivilege),\n\t\t\t\trmPrivilege: (newPrivilege) => privileges.includes(newPrivilege) && privileges.splice(privileges.indexOf(newPrivilege), 1),\n\t\t\t\tsetPrivileges: (newPrivileges) => privileges = newPrivileges,\n\t\t\t\treauthorize: async function() {\n\t\t\t\t\tlet tokenInfo = await modules.tokens.info(token);\n\t\t\t\t\tuser = tokenInfo.user;\n\t\t\t\t\tgroups = tokenInfo.groups || [];\n\t\t\t\t\tprivileges = tokenInfo.privileges;\n\t\t\t\t\tprivileges = await denyUnmanifested(limitations, token);\n\t\t\t\t}\n\t\t\t},\n\t\t\tpublic: {\n\t\t\t\tgetUser: () => user,\n\t\t\t\tgetPrivileges: () => privileges,\n\t\t\t\tterminate: async function() {\n\t\t\t\t\tawait ree.closeDown();\n\t\t\t\t},\n\t\t\t\trmPrivilege: async function(privilege) {\n\t\t\t\t\tif (!privileges.includes(privilege)) throw new Error(\"NO_SUCH_PRIVILEGE\");\n\t\t\t\t\tprivileges.splice(privileges.indexOf(privilege), 1);\n\t\t\t\t\tawait modules.tokens.removePrivilege(token, privilege);\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\trmPrivileges: async function(privilegesRemoved) {\n\t\t\t\t\tprivileges = privileges.filter(x => !privilegesRemoved.includes(x));\n\t\t\t\t\tawait modules.tokens.removePrivileges(token, privilegesRemoved);\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tswitchUser: async function(desiredUser) {\n\t\t\t\t\tif (!privileges.includes(\"SWITCH_USERS_AUTOMATICALLY\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tawait modules.tokens.halfInitialize(token, desiredUser);\n\t\t\t\t\tlet tokenInfo = await modules.tokens.info(token);\n\t\t\t\t\tuser = tokenInfo.user;\n\t\t\t\t\tgroups = tokenInfo.groups || [];\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tshutdown: async function(arg) {\n\t\t\t\t\tlet {isKexec, isReboot, force, token} = arg;\n\t\t\t\t\tif (!privileges.includes(\"SYSTEM_SHUTDOWN\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (force) {\n\t\t\t\t\t\ttry { modules.websocket._handles[modules.network.ws].ws.close(); } catch {}\n\t\t\t\t\t\tmodules.session.destroy();\n\t\t\t\t\t\tif (isReboot) return location.reload();\n\t\t\t\t\t\treturn modules.killSystem();\n\t\t\t\t\t}\n\t\t\t\t\tawait modules.restart(!isReboot, token || processToken, isKexec);\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tfs_read: async function(arg) {\n\t\t\t\t\tlet {path, token} = arg;\n\t\t\t\t\tif (!privileges.includes(\"FS_READ\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn await fs_action(\"read\", (fsPermissions) => fsPermissions.owner == user || fsPermissions.world.includes(\"r\") || groups.includes(fsPermissions.group) || privileges.includes(\"FS_BYPASS_PERMISSIONS\"), path, token || processToken);\n\t\t\t\t},\n\t\t\t\tfs_ls: async function(arg) {\n\t\t\t\t\tlet {path, token} = arg;\n\t\t\t\t\tif (!privileges.includes(\"FS_READ\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn await fs_action(\"ls\",\n\t\t\t\t\t(fsPermissions) =>\n\t\t\t\t\t\tfsPermissions.owner == user ||\n\t\t\t\t\t\tgroups.includes(fsPermissions.group) ||\n\t\t\t\t\t\t(fsPermissions.world.includes(\"r\") &&\n\t\t\t\t\t\tfsPermissions.world.includes(\"x\")) || privileges.includes(\"FS_BYPASS_PERMISSIONS\"), path, token || processToken);\n\t\t\t\t},\n\t\t\t\tfs_write: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"FS_WRITE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet {path, data, token} = arg;\n\t\t\t\t\tlet pathParent = path.split(\"/\").slice(0, -1).join(\"/\");\n\t\t\t\t\tlet basename = path.split(\"/\").slice(-1)[0];\n\t\t\t\t\tlet isCreating = false;\n\t\t\t\t\tlet fsParentPermissions;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!(await modules.fs.ls(pathParent, token || processToken)).includes(basename)) isCreating = true;\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tthrow new Error(\"CREATION_CHECK_FAILED\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfsParentPermissions = await modules.fs.permissions(pathParent, token || processToken);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tthrow new Error(\"PERMISSION_CHECKING_FAILED\");\n\t\t\t\t\t}\n\t\t\t\t\tif (!fsParentPermissions.world.includes(\"w\") && fsParentPermissions.owner != user && !groups.includes(fsParentPermissions.group) && !privileges.includes(\"FS_BYPASS_PERMISSIONS\")) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\t\n\t\t\t\t\tif (isCreating) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait modules.fs.chown(path, user, token || processToken);\n\t\t\t\t\t\t\tawait modules.fs.chgrp(path, groups[0], token || processToken);\n\t\t\t\t\t\t\tawait modules.fs.chmod(path, \"r\", token || processToken);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tif (e.name == \"Error\") throw e;\n\t\t\t\t\t\t\tthrow new Error(\"PERMISSION_CHANGE_FAILED\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn await fs_action(\"write\", (fsPermissions) => fsPermissions.owner == user || groups.includes(fsPermissions.group) || fsPermissions.world.includes(\"w\") || privileges.includes(\"FS_BYPASS_PERMISSIONS\"), path, data, token || processToken);\n\t\t\t\t},\n\t\t\t\tfs_rm: async function(arg) {\n\t\t\t\t\tlet {path, token} = arg;\n\t\t\t\t\tif (!privileges.includes(\"FS_REMOVE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn await fs_action(\"rm\", (fsPermissions) => fsPermissions.owner == user || privileges.includes(\"FS_BYPASS_PERMISSIONS\"), path, token);\n\t\t\t\t},\n\t\t\t\tfs_mkdir: async function(arg) {\n\t\t\t\t\tlet {path, token} = arg;\n\t\t\t\t\tif (!privileges.includes(\"FS_WRITE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet pathParent = path.split(\"/\").slice(0, -1).join(\"/\");\n\t\t\t\t\tlet fsPermissions;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfsPermissions = await modules.fs.permissions(pathParent, token || processToken);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tthrow new Error(\"PERMISSION_CHECKING_FAILED\");\n\t\t\t\t\t}\n\t\t\t\t\tif (!fsPermissions.world.includes(\"w\") && fsPermissions.owner != user && !groups.includes(fsPermissions.group) && !privileges.includes(\"FS_BYPASS_PERMISSIONS\")) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait modules.fs.chown(path, user, token || processToken);\n\t\t\t\t\t\tawait modules.fs.chgrp(path, groups[0] || user, token || processToken);\n\t\t\t\t\t\tawait modules.fs.chmod(path, \"rx\", token || processToken);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (e.name == \"Error\") throw e;\n\t\t\t\t\t\tthrow new Error(\"PERMISSION_CHANGE_FAILED\");\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn await modules.fs.mkdir(path, token || processToken);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (e.name == \"Error\") throw e;\n\t\t\t\t\t\tthrow new Error(\"FS_ACTION_FAILED\");\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfs_chown: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"FS_CHANGE_PERMISSION\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet {path, newUser, token} = arg;\n\t\t\t\t\treturn await fs_action(\"chown\", (fsPermissions) => fsPermissions.owner == user || privileges.includes(\"FS_BYPASS_PERMISSIONS\"), path, newUser, token || processToken);\n\t\t\t\t},\n\t\t\t\tfs_chgrp: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"FS_CHANGE_PERMISSION\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet {path, newGrp, token} = arg;\n\t\t\t\t\treturn await fs_action(\"chgrp\", (fsPermissions) => fsPermissions.owner == user || privileges.includes(\"FS_BYPASS_PERMISSIONS\"), path, newGrp, token || processToken);\n\t\t\t\t},\n\t\t\t\tfs_chmod: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"FS_CHANGE_PERMISSION\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet {path, newPermissions, token} = arg;\n\t\t\t\t\treturn await fs_action(\"chmod\", (fsPermissions) => fsPermissions.owner == user || privileges.includes(\"FS_BYPASS_PERMISSIONS\"), path, newPermissions, token || processToken);\n\t\t\t\t},\n\t\t\t\tfs_permissions: async function(arg) {\n\t\t\t\t\tlet {path, token} = arg;\n\t\t\t\t\tif (!privileges.includes(\"FS_READ\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet pathParent = path.split(\"/\").slice(0, -1).join(\"/\");\n\t\t\t\t\tif (pathParent != \"\") {\n\t\t\t\t\t\tlet fsPermissions;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tfsPermissions = await modules.fs.permissions(pathParent, token || processToken);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tthrow new Error(\"PERMISSION_CHECKING_FAILED\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!fsPermissions.world.includes(\"r\") && fsPermissions.owner != user && !privileges.includes(\"FS_BYPASS_PERMISSIONS\")) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\t}\n\t\t\t\t\treturn await fs_action(\"permissions\", () => true, path, token || processToken);\n\t\t\t\t},\n\t\t\t\tfs_mounts: async function() {\n\t\t\t\t\tif (!privileges.includes(\"FS_LIST_PARTITIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn await modules.fs.lsmounts();\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (e.name == \"Error\") throw e;\n\t\t\t\t\t\tthrow new Error(\"FS_ACTION_FAILED\");\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfs_sync: async function(arg) {\n\t\t\t\t\tlet {mount, token} = arg;\n\t\t\t\t\tif (!privileges.includes(\"FS_UNMOUNT\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn await modules.fs.sync(mount, token || processToken);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (e.name == \"Error\") throw e;\n\t\t\t\t\t\tthrow new Error(\"FS_ACTION_FAILED\");\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfs_unmount: async function(arg) {\n\t\t\t\t\tlet {mount, token, force} = arg;\n\t\t\t\t\tif (!privileges.includes(\"FS_UNMOUNT\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn await modules.fs.unmount(mount, token || processToken, force);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (e.name == \"Error\") throw e;\n\t\t\t\t\t\tthrow new Error(\"FS_ACTION_FAILED\");\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfs_mountInfo: async function(mount) {\n\t\t\t\t\tif (!privileges.includes(\"FS_LIST_PARTITIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn await modules.fs.mountInfo(mount);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (e.name == \"Error\") throw e;\n\t\t\t\t\t\tthrow new Error(\"FS_ACTION_FAILED\");\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tgetSystemMount: async function() {\n\t\t\t\t\tif (!privileges.includes(\"FS_LIST_PARTITIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.defaultSystem;\n\t\t\t\t},\n\t\t\t\tcreatePipe: async function() {\n\t\t\t\t\tif (!privileges.includes(\"IPC_CREATE_PIPE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet pipe = await modules.ipc.create();\n\t\t\t\t\tmodules.ipc.declareAccess(pipe, {\n\t\t\t\t\t\towner: user,\n\t\t\t\t\t\tgroup: groups[0],\n\t\t\t\t\t\tworld: false\n\t\t\t\t\t});\n\t\t\t\t\tprocessPipes.push(pipe);\n\t\t\t\t\treturn pipe;\n\t\t\t\t},\n\t\t\t\tlistenToPipe: async function(pipe) {\n\t\t\t\t\tif (!privileges.includes(\"IPC_LISTEN_PIPE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet permissions = await modules.ipc.getIPC(pipe);\n\t\t\t\t\tif (permissions.owner != user && !groups.includes(permissions.group) && !permissions.world && !privileges.includes(\"IPC_BYPASS_PERMISSIONS\") && !processPipes.includes(pipe)) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\treturn await modules.ipc.listenFor(pipe);\n\t\t\t\t},\n\t\t\t\tsendToPipe: async function(dataSend) {\n\t\t\t\t\tif (!privileges.includes(\"IPC_SEND_PIPE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet {pipe, data} = dataSend;\n\t\t\t\t\tlet permissions = await modules.ipc.getIPC(pipe);\n\t\t\t\t\tif (permissions.owner != user && !groups.includes(permissions.group) && !permissions.world && !privileges.includes(\"IPC_BYPASS_PERMISSIONS\") && !processPipes.includes(pipe)) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\treturn await modules.ipc.send(pipe, data);\n\t\t\t\t},\n\t\t\t\tclosePipe: async function(pipe) {\n\t\t\t\t\tif (!processPipes.includes(pipe)) throw new Error(\"NOT_OWN_PIPE\");\n\t\t\t\t\tprocessPipes.splice(processPipes.indexOf(pipe), 1);\n\t\t\t\t\treturn delete modules.ipc._ipc[pipe];\n\t\t\t\t},\n\t\t\t\tsetPipePermissions: async function(opts) {\n\t\t\t\t\tif (!privileges.includes(\"IPC_CHANGE_PERMISSION\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet {pipe, newPermissions} = opts;\n\t\t\t\t\tlet permissions = await modules.ipc.getIPC(pipe);\n\t\t\t\t\tif (permissions.owner != user && !groups.includes(permissions.group) && !permissions.world && !privileges.includes(\"IPC_BYPASS_PERMISSIONS\") && !processPipes.includes(pipe)) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\treturn await modules.ipc.declareAccess(pipe, newPermissions);\n\t\t\t\t},\n\t\t\t\televate: async function(newPrivileges) {\n\t\t\t\t\tnewPrivileges = newPrivileges.filter(privilege => !privileges.includes(privilege));\n\t\t\t\t\tnewPrivileges = Array.from(new Set(newPrivileges));\n\t\t\t\t\tif (!privileges.includes(\"SWITCH_USERS_AUTOMATICALLY\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tprivileges.push(...newPrivileges);\n\t\t\t\t\tawait modules.tokens.addPrivileges(token, newPrivileges);\n\t\t\t\t\tprivileges = await denyUnmanifested(limitations, token);\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tgetVersion: function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_BUILD\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.pcos_version;\n\t\t\t\t},\n\t\t\t\tlocale: function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_LOCALE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn language || navigator.languages[0].split(\"-\")[0].toLowerCase();\n\t\t\t\t},\n\t\t\t\tosLocale: function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_LOCALE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.locales.get(\"OS_LOCALE\", language);\n\t\t\t\t},\n\t\t\t\tgetUserInfo: async function(arg) {\n\t\t\t\t\tlet {desiredUser, token, sensitive} = arg;\n\t\t\t\t\tif (!privileges.includes(\"GET_USER_INFO\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (desiredUser != user && !privileges.includes(\"USER_INFO_OTHERS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (sensitive && desiredUser != user && !privileges.includes(\"SENSITIVE_USER_INFO_OTHERS\")) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\treturn await modules.users.getUserInfo(desiredUser, sensitive, token || processToken);\n\t\t\t\t},\n\t\t\t\tsetUserInfo: async function(arg) {\n\t\t\t\t\tlet {desiredUser, token, info} = arg;\n\t\t\t\t\tif (!privileges.includes(\"SET_USER_INFO\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn await modules.users.moduser(desiredUser, info, token || processToken);\n\t\t\t\t},\n\t\t\t\tsetOwnSecurityChecks: async function(arg) {\n\t\t\t\t\tlet {token, checks} = arg;\n\t\t\t\t\tif (!privileges.includes(\"SET_SECURITY_CHECKS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet allowedTypes = [ \"pbkdf2\", \"informative\", \"informative_deny\", \"timeout\", \"timeout_deny\", \"serverReport\", \"pc-totp\", \"totp\", \"workingHours\", \"zkpp\" ];\n\t\t\t\t\tlet sanitizedChecks = [];\n\t\t\t\t\tchecks.filter(a => allowedTypes.includes(a.type));\n\t\t\t\t\tfor (let checkIndex in checks) {\n\t\t\t\t\t\tlet check = checks[checkIndex];\n\t\t\t\t\t\tif (check.type == \"pbkdf2\") {\n\t\t\t\t\t\t\tif (!check.salt || !check.hash) continue;\n\t\t\t\t\t\t\tcheck = { type: \"pbkdf2\", salt: check.salt, hash: check.hash };\n\t\t\t\t\t\t} else if (check.type == \"informative\" || check.type == \"informative_deny\") {\n\t\t\t\t\t\t\tif (!check.message) continue;\n\t\t\t\t\t\t\tcheck = { type: check.type, message: check.message };\n\t\t\t\t\t\t} else if (check.type == \"timeout\" || check.type == \"timeout_deny\") {\n\t\t\t\t\t\t\tif (!check.timeout) continue;\n\t\t\t\t\t\t\tcheck = { type: check.type, timeout: check.timeout };\n\t\t\t\t\t\t} else if (check.type == \"serverReport\") {\n\t\t\t\t\t\t\tif (!check.url) continue;\n\t\t\t\t\t\t\tcheck = { type: \"serverReport\", url: check.url };\n\t\t\t\t\t\t} else if (check.type == \"pc-totp\" || check.type == \"totp\") {\n\t\t\t\t\t\t\tif (!check.secret) continue;\n\t\t\t\t\t\t\tcheck = { type: check.type, secret: check.secret };\n\t\t\t\t\t\t} else if (check.type == \"workingHours\") {\n\t\t\t\t\t\t\tif (!check.start || !check.end) continue;\n\t\t\t\t\t\t\tif (typeof check.start.hours !== \"number\" || typeof check.start.minutes !== \"number\" || typeof check.start.seconds !== \"number\") continue;\n\t\t\t\t\t\t\tif (typeof check.end.hours !== \"number\" || typeof check.end.minutes !== \"number\" || typeof check.end.seconds !== \"number\") continue;\n\t\t\t\t\t\t\tcheck = {\n\t\t\t\t\t\t\t\ttype: \"workingHours\",\n\t\t\t\t\t\t\t\tstart: {\n\t\t\t\t\t\t\t\t\thours: check.start.hours,\n\t\t\t\t\t\t\t\t\tminutes: check.start.minutes,\n\t\t\t\t\t\t\t\t\tseconds: check.start.seconds\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tend: {\n\t\t\t\t\t\t\t\t\thours: check.end.hours,\n\t\t\t\t\t\t\t\t\tminutes: check.end.minutes,\n\t\t\t\t\t\t\t\t\tseconds: check.end.seconds\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else if (check.type == \"zkpp\") {\n\t\t\t\t\t\t\tif (!check.publicKey) continue;\n\t\t\t\t\t\t\tcheck = { type: \"zkpp\", publicKey: check.publicKey };\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsanitizedChecks.push(check);\n\t\t\t\t\t}\n\t\t\t\t\tlet previousUserInfo = await modules.users.getUserInfo(user, false, token || processToken);\n\t\t\t\t\tawait modules.users.moduser(user, { ...previousUserInfo, securityChecks: sanitizedChecks }, token || processToken);\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tgetNewToken: async function(desiredUser) {\n\t\t\t\t\tif (!privileges.includes(\"ELEVATE_PRIVILEGES\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (modules.session.attrib(ses, \"secureLock\")) await modules.session.attrib(ses, \"secureLock\");\n\t\t\t\t\tif (modules.session.active != ses) throw new Error(\"TRY_AGAIN_LATER\");\n\t\t\t\t\tlet releaseLock;\n\t\t\t\t\tlet lock = new Promise((resolve) => releaseLock = resolve);\n\t\t\t\t\tmodules.session.attrib(ses, \"secureLock\", lock);\n\t\t\t\t\tlet secureSession = await modules.session.mksession();\n\t\t\t\t\tmodules.session.attrib(ses, \"secureID\", secureSession);\n\t\t\t\t\tmodules.session.attrib(secureSession, \"language\", language);\n\n\t\t\t\t\tlet dom = modules.session.tracker[secureSession].html;\n\t\t\t\t\tlet ogDom = modules.session.tracker[ses].html;\n\t\t\t\t\tlet bgfx = document.createElement(\"div\");\n\t\t\t\t\tbgfx.classList.add(\"session\", \"secure\");\n\t\t\t\t\tdom.appendChild(bgfx);\n\t\t\t\t\tmodules.session.attrib(secureSession, \"dark\", modules.session.attrib(ses, \"dark\"));\n\t\t\t\t\tdom.style.background = ogDom.style.background;\n\t\t\t\t\tdom.style.backgroundSize = \"100% 100%\";\n\n\t\t\t\t\tmodules.session.muteAllSessions();\n\t\t\t\t\tmodules.session.activateSession(secureSession);\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet logonUI = await modules.authui(secureSession, desiredUser);\n\t\t\t\t\t\treturn new Promise(function(resolve) {\n\t\t\t\t\t\t\tlogonUI.hook(async function(result) {\n\t\t\t\t\t\t\t\treleaseLock();\n\t\t\t\t\t\t\t\tmodules.session.attrib(ses, \"secureLock\", null);\n\t\t\t\t\t\t\t\tmodules.session.attrib(ses, \"secureID\", null);\n\t\t\t\t\t\t\t\tmodules.session.muteAllSessions();\n\t\t\t\t\t\t\t\tmodules.session.rmsession(secureSession);\n\t\t\t\t\t\t\t\tmodules.session.activateSession(ses);\n\t\t\t\t\t\t\t\tif (result.success == false) return resolve(false);\n\t\t\t\t\t\t\t\treturn resolve(result.token);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tconsole.error(\"authui:\", e);\n\t\t\t\t\t\treleaseLock();\n\t\t\t\t\t\tmodules.session.attrib(ses, \"secureLock\", null);\n\t\t\t\t\t\tmodules.session.attrib(ses, \"secureID\", null);\n\t\t\t\t\t\tmodules.session.muteAllSessions();\n\t\t\t\t\t\tmodules.session.rmsession(secureSession);\n\t\t\t\t\t\tmodules.session.activateSession(ses);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tgetProcessToken: () => processToken,\n\t\t\t\tsetProcessToken: async function(desiredToken) {\n\t\t\t\t\tif (!privileges.includes(\"ELEVATE_PRIVILEGES\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet validation = await modules.tokens.validate(desiredToken, {});\n\t\t\t\t\tif (!validation) throw new Error(\"INVALID_TOKEN\");\n\t\t\t\t\ttoken = processToken = desiredToken;\n\t\t\t\t\tlet tokenInfo = await modules.tokens.info(token);\n\t\t\t\t\tuser = tokenInfo.user;\n\t\t\t\t\tgroups = tokenInfo.groups || [];\n\t\t\t\t\tprivileges = tokenInfo.privileges;\n\t\t\t\t\tprivileges = await denyUnmanifested(limitations, token);\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\trevokeToken: function(dt) {\n\t\t\t\t\tif (!privileges.includes(\"MANAGE_TOKENS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.tokens.revoke(dt || processToken);\n\t\t\t\t},\n\t\t\t\tforkToken: function(dt) {\n\t\t\t\t\tif (!privileges.includes(\"MANAGE_TOKENS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.tokens.fork(dt || processToken);\n\t\t\t\t},\n\t\t\t\tremoveTokenPrivilege: async function(arg) {\n\t\t\t\t\tlet {token, privilege} = arg;\n\t\t\t\t\tif (!privileges.includes(\"MANAGE_TOKENS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tawait modules.tokens.removePrivilege(token, privilege);\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tremoveTokenPrivileges: async function(arg) {\n\t\t\t\t\tlet {token} = arg;\n\t\t\t\t\tif (!privileges.includes(\"MANAGE_TOKENS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tawait modules.tokens.removePrivileges(token, arg.privileges);\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\testimateStorage: async function() {\n\t\t\t\t\tif (!privileges.includes(\"FS_LIST_PARTITIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet estimate = await navigator.storage.estimate();\n\t\t\t\t\treturn {\n\t\t\t\t\t\tinternal: {\n\t\t\t\t\t\t\tused: estimate.usage,\n\t\t\t\t\t\t\tfree: estimate.quota - estimate.usage,\n\t\t\t\t\t\t\ttotal: estimate.quota\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\tstartTask: async function(arg) {\n\t\t\t\t\tlet {file, argPassed, token, runInBackground, silent, privateData} = arg;\n\t\t\t\t\tif (!privileges.includes(\"START_TASK\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (runInBackground && !privileges.includes(\"START_BACKGROUND_TASK\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!token) token = await modules.tokens.fork(processToken);\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn await modules.tasks.exec(file, argPassed, modules.window(runInBackground ? modules.serviceSession : ses), token, silent, privateData);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (e.name == \"Error\") throw e;\n\t\t\t\t\t\tthrow new Error(\"UNABLE_TO_START_TASK\");\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tlistTasks: async function() {\n\t\t\t\t\tif (!privileges.includes(\"LIST_TASKS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.tasks.listPublicTasks();\n\t\t\t\t},\n\t\t\t\ttaskInfo: async function(taskId) {\n\t\t\t\t\tif (!privileges.includes(\"LIST_TASKS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn await modules.tasks.taskInfo(taskId);\n\t\t\t\t},\n\t\t\t\tsignalTask: async function(arg) {\n\t\t\t\t\tlet {taskId, signal} = arg;\n\t\t\t\t\tif (!privileges.includes(\"SIGNAL_TASK\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!privileges.includes(\"TASK_BYPASS_PERMISSIONS\")) {\n\t\t\t\t\t\tlet taskInfo = await modules.tasks.taskInfo(taskId);\n\t\t\t\t\t\tif (taskInfo.runBy != user) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\t}\n\t\t\t\t\treturn await modules.tasks.sendSignal(taskId, signal);\n\t\t\t\t},\n\t\t\t\tlookupLocale: function(key) {   \n\t\t\t\t\tif (!privileges.includes(\"GET_LOCALE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.locales.get(key, language);\n\t\t\t\t},\n\t\t\t\tlookupOtherLocale: function(arg) {\n\t\t\t\t\tlet {key, locale} = arg;   \n\t\t\t\t\tif (!privileges.includes(\"GET_LOCALE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.locales.get(key, locale);\n\t\t\t\t},\n\t\t\t\tufTimeInc: function(args) {\n\t\t\t\t\tif (!privileges.includes(\"GET_LOCALE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.userfriendliness.inconsiderateTime(language, ...args);\n\t\t\t\t},\n\t\t\t\tufInfoUnits: function(args) {\n\t\t\t\t\tif (!privileges.includes(\"GET_LOCALE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.userfriendliness.informationUnits(language, ...args)\n\t\t\t\t},\n\t\t\t\tisDarkThemed: function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_THEME\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.session.attrib(ses, \"dark\")\n\t\t\t\t},\n\t\t\t\tfetchSend: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"FETCH_SEND\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet {url, init} = arg;\n\t\t\t\t\tlet fetc = await fetch(url, init);\n\t\t\t\t\tlet responseAB;\n\t\t\t\t\tif (init.mode != \"no-cors\" && !init.noArrayBuffer) responseAB = await fetc.arrayBuffer();\n\t\t\t\t\treturn {\n\t\t\t\t\t\tstatus: fetc.status,\n\t\t\t\t\t\tstatusText: fetc.statusText,\n\t\t\t\t\t\tok: fetc.ok,\n\t\t\t\t\t\tredirected: fetc.redirected,\n\t\t\t\t\t\ttype: fetc.type,\n\t\t\t\t\t\turl: fetc.url,\n\t\t\t\t\t\theaders: Object.fromEntries(Array.from(fetc.headers)),\n\t\t\t\t\t\tarrayBuffer: responseAB,\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\tswitchUserWithSetup: async function(desiredUser) {\n\t\t\t\t\tif (!privileges.includes(\"SWITCH_USERS_AUTOMATICALLY\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tawait modules.tokens.userInitialize(token, desiredUser);\n\t\t\t\t\tlet tokenInfo = await modules.tokens.info(token);\n\t\t\t\t\tuser = tokenInfo.user;\n\t\t\t\t\tgroups = tokenInfo.groups || [];\n\t\t\t\t\tprivileges = tokenInfo.privileges;\n\t\t\t\t\tprivileges = await denyUnmanifested(limitations, token);\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\trunKlvlCode: async function(code) {\n\t\t\t\t\tif (!privileges.includes(\"RUN_KLVL_CODE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn eval(code);\n\t\t\t\t},\n\t\t\t\tcspOperation: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"CSP_OPERATIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.csps[arg.cspProvider][arg.operation](arg.cspArgument, taskId);\n\t\t\t\t},\n\t\t\t\tavailableCsps: async function() {\n\t\t\t\t\tif (!privileges.includes(\"CSP_OPERATIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn Object.keys(modules.csps);\n\t\t\t\t},\n\t\t\t\tufTimeCon: function(args) {\n\t\t\t\t\tif (!privileges.includes(\"GET_LOCALE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.userfriendliness.considerateTime(language, ...args);\n\t\t\t\t},\n\t\t\t\twebsocketOpen: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"WEBSOCKETS_OPEN\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet handle = await modules.websocket.getHandle(arg);\n\t\t\t\t\twebsockets.push(handle);\n\t\t\t\t\tmodules.websocket.assertAccess({ handle, newACL: {\n\t\t\t\t\t\towner: user,\n\t\t\t\t\t\tgroup: groups[0],\n\t\t\t\t\t\tworld: false\n\t\t\t\t\t}});\n\t\t\t\t\treturn handle;\n\t\t\t\t},\n\t\t\t\tlistenToWebsocket: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"WEBSOCKETS_LISTEN\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet permissions = modules.websocket.assertAccess({ handle: arg.handle });\n\t\t\t\t\tif (permissions.owner != user && !groups.includes(permissions.group) && !permissions.world && !privileges.includes(\"WEBSOCKET_BYPASS_PERMISSIONS\") && !websockets.includes(arg.handle)) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\treturn await modules.websocket.waitForEvent(arg);\n\t\t\t\t},\n\t\t\t\tsendToWebsocket: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"WEBSOCKETS_SEND\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet permissions = modules.websocket.assertAccess({ handle: arg.handle });\n\t\t\t\t\tif (permissions.owner != user && !groups.includes(permissions.group) && !permissions.world && !privileges.includes(\"WEBSOCKET_BYPASS_PERMISSIONS\") && !websockets.includes(arg.handle)) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\treturn await modules.websocket.send(arg);\n\t\t\t\t},\n\t\t\t\tcloseWebsocket: async function(websocket) {\n\t\t\t\t\tif (!websockets.includes(websocket)) throw new Error(\"NOT_OWN_WEBSOCKET\");\n\t\t\t\t\twebsockets.splice(websockets.indexOf(websocket), 1);\n\t\t\t\t\treturn modules.websocket.close(websocket);\n\t\t\t\t},\n\t\t\t\twebsocketInfo: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"WEBSOCKET_INFO\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet permissions = modules.websocket.assertAccess({ handle: arg.handle });\n\t\t\t\t\tif (permissions.owner != user && !groups.includes(permissions.group) && !permissions.world && !privileges.includes(\"WEBSOCKET_BYPASS_PERMISSIONS\") && !websockets.includes(arg.handle)) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\treturn await modules.websocket.getInfo(arg);\n\t\t\t\t},\n\t\t\t\tsetWebsocketPermissions: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"WEBSOCKET_SET_PERMISSIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet permissions = modules.websocket.assertAccess({ handle: arg.handle });\n\t\t\t\t\tif (permissions.owner != user && !groups.includes(permissions.group) && !permissions.world && !privileges.includes(\"WEBSOCKET_BYPASS_PERMISSIONS\") && !websockets.includes(arg.handle)) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\treturn await modules.websocket.assertAccess(arg);\n\t\t\t\t},\n\t\t\t\tgetPublicSystemID: async function() {\n\t\t\t\t\tif (!privileges.includes(\"IDENTIFY_SYSTEM\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn (modules.core.prefs.read(\"system_id\") || {}).public;\n\t\t\t\t},\n\t\t\t\tgetPrivateSystemID: async function() {\n\t\t\t\t\tif (!privileges.includes(\"IDENTIFY_SYSTEM_SENSITIVE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn (modules.core.prefs.read(\"system_id\") || {}).private;\n\t\t\t\t},\n\t\t\t\ttypeIntoOtherCLI: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"CLI_MODIFICATIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!modules.tasks.tracker.hasOwnProperty(arg.taskId)) throw new Error(\"TASK_NOT_FOUND\");\n\t\t\t\t\tlet bypassWorks = modules.tasks.tracker[arg.taskId].apis.public.getProcessToken() == arg.bypass;\n\t\t\t\t\tif (!bypassWorks) {\n\t\t\t\t\t\tlet taskInfo = await modules.tasks.taskInfo(arg.taskId);\n\t\t\t\t\t\tif (taskInfo.runBy != user && !privileges.includes(\"TASK_BYPASS_PERMISSIONS\")) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\t}\n\t\t\t\t\tif (!modules.tasks.tracker[arg.taskId].cliio) throw new Error(\"NO_CLI_ATTACHED\");\n\t\t\t\t\treturn await modules.tasks.tracker[arg.taskId].cliio.xtermInstance.input(arg.text, arg.human);\n\t\t\t\t},\n\t\t\t\tgetOtherCLIData: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"CLI_MODIFICATIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!modules.tasks.tracker.hasOwnProperty(arg.taskId)) throw new Error(\"TASK_NOT_FOUND\");\n\t\t\t\t\tlet bypassWorks = modules.tasks.tracker[arg.taskId].apis.public.getProcessToken() == arg.bypass;\n\t\t\t\t\tif (!bypassWorks) {\n\t\t\t\t\t\tlet taskInfo = await modules.tasks.taskInfo(arg.taskId);\n\t\t\t\t\t\tif (taskInfo.runBy != user && !privileges.includes(\"TASK_BYPASS_PERMISSIONS\")) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\t}\n\t\t\t\t\tif (!modules.tasks.tracker[arg.taskId].cliio) throw new Error(\"NO_CLI_ATTACHED\");\n\t\t\t\t\treturn await modules.tasks.tracker[arg.taskId].cliio.signup();\n\t\t\t\t},\n\t\t\t\twaitForOtherCLI: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"CLI_MODIFICATIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!modules.tasks.tracker.hasOwnProperty(arg.taskId)) throw new Error(\"TASK_NOT_FOUND\");\n\t\t\t\t\tlet bypassWorks = modules.tasks.tracker[arg.taskId].apis.public.getProcessToken() == arg.bypass;\n\t\t\t\t\tif (!bypassWorks) {\n\t\t\t\t\t\tlet taskInfo = await modules.tasks.taskInfo(arg.taskId);\n\t\t\t\t\t\tif (taskInfo.runBy != user && !privileges.includes(\"TASK_BYPASS_PERMISSIONS\")) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\t}\n\t\t\t\t\tif (modules.tasks.tracker[arg.taskId].cliio) return true;\n\t\t\t\t\treturn await modules.tasks.tracker[arg.taskId].cliio.attachedCLISignUp();\n\t\t\t\t},\n\t\t\t\tlldaRead: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"LLDISK_READ\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.core.disk.partition(arg.partition).getData();\n\t\t\t\t},\n\t\t\t\tlldaWrite: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"LLDISK_WRITE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.core.disk.partition(arg.partition).setData(arg.data);\n\t\t\t\t},\n\t\t\t\tlldaList: async function() {\n\t\t\t\t\tif (!privileges.includes(\"LLDISK_LIST_PARTITIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.core.disk.partitions();\n\t\t\t\t},\n\t\t\t\tlldaInitPartitions: async function() {\n\t\t\t\t\tif (!privileges.includes(\"LLDISK_INIT_PARTITIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.core.disk.insertPartitionTable();\n\t\t\t\t},\n\t\t\t\tlldaRemove: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"LLDISK_REMOVE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.core.disk.partition(arg.partition).remove();\n\t\t\t\t},\n\t\t\t\tlldaIDBRead: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"LLDISK_IDB_READ\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.core.idb.readPart(arg.key);\n\t\t\t\t},\n\t\t\t\tlldaIDBWrite: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"LLDISK_IDB_WRITE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tawait modules.core.idb.writePart(arg.key, arg.value);\n\t\t\t\t},\n\t\t\t\tlldaIDBRemove: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"LLDISK_IDB_REMOVE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tawait modules.core.idb.removePart(arg.key);\n\t\t\t\t},\n\t\t\t\tlldaIDBList: async function() {\n\t\t\t\t\tif (!privileges.includes(\"LLDISK_IDB_LIST\")) throw new Error(\"UNAUTHORIZED_ACTION\"); \n\t\t\t\t\treturn modules.core.idb.listParts(); \n\t\t\t\t},\n\t\t\t\tlldaIDBSync: async function() {\n\t\t\t\t\tif (!privileges.includes(\"LLDISK_IDB_SYNC\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tawait modules.core.idb.sync();\n\t\t\t\t},\n\t\t\t\tfs_mount: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"FS_MOUNT\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (modules.fs.mounts[arg.mountpoint]) throw new Error(\"MOUNT_EXISTS\");\n\t\t\t\t\tmodules.fs.mounts[arg.mountpoint] = await modules.mounts[arg.filesystem](arg.filesystemOptions);\n\t\t\t\t},\n\t\t\t\tsupportedFilesystems: async function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_FILESYSTEMS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn Object.keys(modules.mounts);\n\t\t\t\t},\n\t\t\t\tinstalledLocales: async function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_LOCALE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn Object.keys(modules.locales).filter(a => a != \"get\" && a != \"defaultLocale\");\n\t\t\t\t},\n\t\t\t\trunningServer: async function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_SERVER_URL\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn location.origin;\n\t\t\t\t},\n\t\t\t\tfs_isDirectory: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"FS_READ\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet {path, token} = arg;\n\t\t\t\t\treturn await fs_action(\"isDirectory\", (fsPermissions) => fsPermissions.owner == user || fsPermissions.world.includes(\"r\") || groups.includes(fsPermissions.group) || privileges.includes(\"FS_BYPASS_PERMISSIONS\"), path, token || processToken);\n\t\t\t\t},\n\t\t\t\tautomatedLogonCreate: async function(arg) {\n\t\t\t\t\tlet { desiredUser, token } = arg;\n\t\t\t\t\tif (!privileges.includes(\"ELEVATE_PRIVILEGES\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet automatedLogon = Array.from(crypto.getRandomValues(new Uint8Array(64))).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet access = await modules.users.access(desiredUser, token || processToken);\n\t\t\t\t\t\taccess = await access.getNextPrompt();\n\t\t\t\t\t\tautomatedLogonSessions[automatedLogon] = access;\n\t\t\t\t\t} catch {\n\t\t\t\t\t\tthrow new Error(\"AUTOMATED_LOGON_CREATE_FAILED\")\n\t\t\t\t\t}\n\t\t\t\t\treturn automatedLogon;\n\t\t\t\t},\n\t\t\t\tautomatedLogonGet: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"ELEVATE_PRIVILEGES\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet sharedObj = { ...automatedLogonSessions[arg] };\n\t\t\t\t\t\tdelete sharedObj.input;\n\t\t\t\t\t\treturn sharedObj;\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tthrow new Error(\"AUTOMATED_LOGON_GET_FAILED\");\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tautomatedLogonInput: async function(arg) {\n\t\t\t\t\tlet { session, input } = arg;\n\t\t\t\t\tif (!privileges.includes(\"ELEVATE_PRIVILEGES\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\tautomatedLogonSessions[session] = await automatedLogonSessions[session].input(input);\n\t\t\t\t\t} catch {\n\t\t\t\t\t\tthrow new Error(\"AUTOMATED_LOGON_INPUT_FAILED\");\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tautomatedLogonDelete: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"ELEVATE_PRIVILEGES\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tdelete automatedLogonSessions[arg];\n\t\t\t\t},\n\t\t\t\tsetSystemMount: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"SET_DEFAULT_SYSTEM\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tmodules.defaultSystem = arg;\n\t\t\t\t},\n\t\t\t\tusedRAM: async function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_SYSTEM_RESOURCES\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet mem = performance.memory;\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttotal: mem.jsHeapSizeLimit,\n\t\t\t\t\t\t\tused: mem.usedJSHeapSize,\n\t\t\t\t\t\t\tfree: mem.jsHeapSizeLimit - mem.usedJSHeapSize\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch {}\n\t\t\t\t\tlet mem = await performance.measureUserAgentSpecificMemory();\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttotal: Infinity,\n\t\t\t\t\t\tused: mem.bytes,\n\t\t\t\t\t\tfree: Infinity\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tcheckBootMode: async function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_BOOT_MODE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.core.bootMode || \"normal\";\n\t\t\t\t},\n\t\t\t\tgetScreenInfo: async function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_SCREEN_INFO\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn {\n\t\t\t\t\t\twidth: document.documentElement.clientWidth,\n\t\t\t\t\t\theight: document.documentElement.clientHeight,\n\t\t\t\t\t\tcolorDepth: screen.colorDepth,\n\t\t\t\t\t\torientation: {\n\t\t\t\t\t\t\ttype: screen.orientation.type,\n\t\t\t\t\t\t\tangle: screen.orientation.angle\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfullWidth: screen.width,\n\t\t\t\t\t\tfullHeight: screen.height,\n\t\t\t\t\t\tavailWidth: screen.availWidth,\n\t\t\t\t\t\tavailHeight: screen.availHeight,\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\twaitTermination: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"LIST_TASKS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.tasks.waitTermination(arg);\n\t\t\t\t},\n\t\t\t\tconsentGetToken: async function(params) {\n\t\t\t\t\tif (!privileges.includes(\"ELEVATE_PRIVILEGES\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (modules.session.attrib(ses, \"secureLock\")) await modules.session.attrib(ses, \"secureLock\");\n\t\t\t\t\tif (modules.session.active != ses) throw new Error(\"TRY_AGAIN_LATER\");\n\t\t\t\t\tlet { desiredUser, intent } = params;\n\t\t\t\t\tif (!intent) throw new Error(\"INTENT_REQUIRED\");\n\t\t\t\t\tlet releaseLock;\n\t\t\t\t\tlet lock = new Promise((resolve) => releaseLock = resolve);\n\t\t\t\t\tmodules.session.attrib(ses, \"secureLock\", lock);\n\t\t\t\t\tlet secureSession = await modules.session.mksession();\n\t\t\t\t\tmodules.session.attrib(ses, \"secureID\", secureSession);\n\t\t\t\t\tmodules.session.attrib(secureSession, \"language\", language);\n\n\t\t\t\t\tlet dom = modules.session.tracker[secureSession].html;\n\t\t\t\t\tlet ogDom = modules.session.tracker[ses].html;\n\t\t\t\t\tlet bgfx = document.createElement(\"div\");\n\t\t\t\t\tbgfx.classList.add(\"session\", \"secure\");\n\t\t\t\t\tdom.appendChild(bgfx);\n\t\t\t\t\tmodules.session.attrib(secureSession, \"dark\", modules.session.attrib(ses, \"dark\"));\n\t\t\t\t\tdom.style.background = ogDom.style.background;\n\t\t\t\t\tdom.style.backgroundSize = \"100% 100%\";\n\n\t\t\t\t\tmodules.session.muteAllSessions();\n\t\t\t\t\tmodules.session.activateSession(secureSession);\n\t\t\t\t\tlet task = await modules.tasks.taskInfo(taskId);\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet logonUI = await modules.consentui(secureSession, {\n\t\t\t\t\t\t\tuser: desiredUser,\n\t\t\t\t\t\t\tpath: task.file,\n\t\t\t\t\t\t\targs: task.arg,\n\t\t\t\t\t\t\tintent,\n\t\t\t\t\t\t\tname: params.name\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn new Promise(function(resolve) {\n\t\t\t\t\t\t\tlogonUI.hook(async function(result) {\n\t\t\t\t\t\t\t\treleaseLock();\n\t\t\t\t\t\t\t\tmodules.session.attrib(ses, \"secureLock\", null);\n\t\t\t\t\t\t\t\tmodules.session.attrib(ses, \"secureID\", null);\n\t\t\t\t\t\t\t\tmodules.session.muteAllSessions();\n\t\t\t\t\t\t\t\tmodules.session.rmsession(secureSession);\n\t\t\t\t\t\t\t\tmodules.session.activateSession(ses);\n\t\t\t\t\t\t\t\tif (result.success == false) return resolve(false);\n\t\t\t\t\t\t\t\treturn resolve(result.token);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tconsole.error(\"consentui:\", e);\n\t\t\t\t\t\treleaseLock();\n\t\t\t\t\t\tmodules.session.attrib(ses, \"secureLock\", null);\n\t\t\t\t\t\tmodules.session.attrib(ses, \"secureID\", null);\n\t\t\t\t\t\tmodules.session.muteAllSessions();\n\t\t\t\t\t\tmodules.session.rmsession(secureSession);\n\t\t\t\t\t\tmodules.session.activateSession(ses);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tnetworkPing: async function(address) {\n\t\t\t\t\tif (!privileges.includes(\"PCOS_NETWORK_PING\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet websocketHandle = modules.network.ws;\n\t\t\t\t\tif (!websocketHandle) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\tlet websocket = modules.websocket._handles[websocketHandle].ws;\n\t\t\t\t\tif (websocket.readyState != 1) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\treturn Promise.race([ new Promise(async function(resolve, reject) {\n\t\t\t\t\t\tlet networkListenID = Array.from(crypto.getRandomValues(new Uint8Array(64))).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\t\tlet packetId = Array.from(crypto.getRandomValues(new Uint8Array(32))).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\t\tlet resend = Array.from(crypto.getRandomValues(new Uint8Array(32))).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\t\tfunction eventListener(e) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlet packet = JSON.parse(e.data);\n\t\t\t\t\t\t\t\tif (packet.packetID == packetId && packet.event == \"AddressUnreachable\") {\n\t\t\t\t\t\t\t\t\treject(new Error(\"ADDRESS_UNREACHABLE\"));\n\t\t\t\t\t\t\t\t\tdelete networkListens[networkListenID];\n\t\t\t\t\t\t\t\t\twebsocket.removeEventListener(\"message\", eventListener);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (packet.from == address && packet.data.type == \"pong\" && packet.data.resend == resend) {\n\t\t\t\t\t\t\t\t\tresolve(\"success\");\n\t\t\t\t\t\t\t\t\tdelete networkListens[networkListenID];\n\t\t\t\t\t\t\t\t\twebsocket.removeEventListener(\"message\", eventListener);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnetworkListens[networkListenID] = { ws: websocket, fn: eventListener };\n\t\t\t\t\t\twebsocket.addEventListener(\"message\", eventListener);\n\t\t\t\t\t\twebsocket.send(JSON.stringify({\n\t\t\t\t\t\t\treceiver: address,\n\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\ttype: \"ping\",\n\t\t\t\t\t\t\t\tresend: resend\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tid: packetId\n\t\t\t\t\t\t}))\n\t\t\t\t\t}), new Promise((_, reject) => modules.network.runOnClose.then(_ => reject(new Error(\"NETWORK_CLOSED\")))) ]);\n\t\t\t\t},\n\t\t\t\tlogOut: async function(desiredUser) {\n\t\t\t\t\tif (desiredUser != user && !privileges.includes(\"LOGOUT_OTHERS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (desiredUser == user && !privileges.includes(\"LOGOUT\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (modules.session.active != ses && !privileges.includes(\"LOGOUT_OTHERS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tawait modules.logOut(desiredUser);\n\t\t\t\t},\n\t\t\t\tlock: async function() {\n\t\t\t\t\tif (modules.session.active == ses && !privileges.includes(\"LOGOUT\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (modules.session.active != ses && !privileges.includes(\"LOGOUT_OTHERS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tmodules.session.muteAllSessions();\n\t\t\t\t\tmodules.session.activateSession(modules.session.systemSession);\n\t\t\t\t},\n\t\t\t\tgetPrivateData: () => privateData,\n\t\t\t\tlull: async function() {\n\t\t\t\t\tif (!privileges.includes(\"LULL_SYSTEM\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (modules.session.active != ses && !privileges.includes(\"LULL_SYSTEM_FORCE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tawait modules.lull();\n\t\t\t\t},\n\t\t\t\tconnlessListen: async function(gate) {\n\t\t\t\t\tif (!privileges.includes(\"CONNLESS_LISTEN\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!gate.startsWith(\"user_\") && !privileges.includes(\"CONNLESS_LISTEN_GLOBAL\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet websocketHandle = modules.network.ws;\n\t\t\t\t\tif (!websocketHandle) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\tlet websocket = modules.websocket._handles[websocketHandle].ws;\n\t\t\t\t\tif (websocket.readyState != 1) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\treturn Promise.race([ new Promise(async function(resolve) {\n\t\t\t\t\t\tlet networkListenID = Array.from(crypto.getRandomValues(new Uint8Array(64))).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\t\tfunction eventListener(e) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlet packet = JSON.parse(e.data);\n\t\t\t\t\t\t\t\tif (packet.data.type == \"connectionless\" && packet.data.gate == gate) {\n\t\t\t\t\t\t\t\t\twebsocket.removeEventListener(\"message\", eventListener);\n\t\t\t\t\t\t\t\t\tdelete networkListens[networkListenID];\n\t\t\t\t\t\t\t\t\tresolve(packet);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnetworkListens[networkListenID] = { ws: websocket, fn: eventListener };\n\t\t\t\t\t\twebsocket.addEventListener(\"message\", eventListener);\n\t\t\t\t\t}), new Promise((_, reject) => modules.network.runOnClose.then(_ => reject(new Error(\"NETWORK_CLOSED\")))) ]);\n\t\t\t\t},\n\t\t\t\tconnlessSend: async function(sendOpts) {\n\t\t\t\t\tif (!privileges.includes(\"CONNLESS_SEND\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet websocketHandle = modules.network.ws;\n\t\t\t\t\tif (!websocketHandle) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\tlet websocket = modules.websocket._handles[websocketHandle].ws;\n\t\t\t\t\tif (websocket.readyState != 1) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\tlet { gate, address, content } = sendOpts;\n\t\t\t\t\tlet packetId = Array.from(crypto.getRandomValues(new Uint8Array(32))).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\twebsocket.send(JSON.stringify({\n\t\t\t\t\t\treceiver: address,\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\ttype: \"connectionless\",\n\t\t\t\t\t\t\tgate: gate,\n\t\t\t\t\t\t\tcontent: content\n\t\t\t\t\t\t},\n\t\t\t\t\t\tid: packetId\n\t\t\t\t\t}));\n\t\t\t\t\treturn Promise.race([ new Promise(async function(resolve, reject) {\n\t\t\t\t\t\tlet networkListenID = Array.from(crypto.getRandomValues(new Uint8Array(64))).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\t\tfunction eventListener(e) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlet packet = JSON.parse(e.data);\n\t\t\t\t\t\t\t\tif (packet.from) return;\n\t\t\t\t\t\t\t\tif (packet.packetID == packetId) {\n\t\t\t\t\t\t\t\t\twebsocket.removeEventListener(\"message\", eventListener);\n\t\t\t\t\t\t\t\t\tdelete networkListens[networkListenID];\n\t\t\t\t\t\t\t\t\tif (packet.event == \"PacketPong\") return resolve(\"success\");\n\t\t\t\t\t\t\t\t\treject(new Error(\"ADDRESS_UNREACHABLE\"));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnetworkListens[networkListenID] = { ws: websocket, fn: eventListener };\n\t\t\t\t\t\twebsocket.addEventListener(\"message\", eventListener);\n\t\t\t\t\t}), new Promise((_, reject) => modules.network.runOnClose.then(_ => reject(new Error(\"NETWORK_CLOSED\")))) ]);\n\t\t\t\t},\n\t\t\t\tgetUsers: async function(token) {\n\t\t\t\t\tif (!privileges.includes(\"GET_USER_LIST\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn await modules.users.getUsers(token || processToken);\n\t\t\t\t},\n\t\t\t\tgetNetworkAddress: async function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_NETWORK_ADDRESS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.network.address;\n\t\t\t\t},\n\t\t\t\tconnfulListen: async function(listenOpts) {\n\t\t\t\t\tif (!privileges.includes(\"CONNFUL_LISTEN\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet {gate, key, private: privateKey, verifyClientKeyChain} = listenOpts;\n\t\t\t\t\tif (!gate.startsWith(\"user_\") && !privileges.includes(\"CONNFUL_LISTEN_GLOBAL\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet websocketHandle = modules.network.ws;\n\t\t\t\t\tif (!websocketHandle) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\tlet websocket = modules.websocket._handles[websocketHandle].ws;\n\t\t\t\t\tif (websocket.readyState != 1) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\tlet networkListenID = Array.from(crypto.getRandomValues(new Uint8Array(64))).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\tlet usableKey = await crypto.subtle.importKey(\"jwk\", privateKey, {name: \"Ed25519\"}, true, [\"sign\"]);\n\t\t\t\t\tlet hexToU8A = (hex) => Uint8Array.from(hex.match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\t\t\tlet u8aToHex = (u8a) => Array.from(u8a).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\tlet _connectionBufferPromise = null;\n\t\t\t\t\tlet _connectionBufferReject = null;\n\t\t\t\t\tlet connectionBufferPromise = new Promise((r, j) => [_connectionBufferPromise, _connectionBufferReject] = [r, j]);\n\t\t\t\t\tasync function eventListener(e) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlet packet = JSON.parse(e.data);\n\t\t\t\t\t\t\tif (!packet.from) return;\n\t\t\t\t\t\t\tif (packet.data.type == \"connectionful\" && packet.data.gate == gate && packet.data.action == \"start\") {\n\t\t\t\t\t\t\t\tif (!packet.data.connectionID) return;\n\t\t\t\t\t\t\t\tif (connections[packet.data.connectionID + \":server\"]) return;\n\t\t\t\t\t\t\t\tlet ephemeralKey = await crypto.subtle.generateKey({name: \"Ed25519\"}, true, [\"deriveBits\"]);\n\t\t\t\t\t\t\t\tlet exported = await crypto.subtle.exportKey(\"jwk\", ephemeralKey.publicKey);\n\t\t\t\t\t\t\t\texported = {signedBy: \"serverKey\", usages: [\"connfulSecureEphemeral\"], key:exported};\n\t\t\t\t\t\t\t\tlet signature = u8aToHex(new Uint8Array(await crypto.subtle.sign({\n\t\t\t\t\t\t\t\t\tname: \"Ed25519\"\n\t\t\t\t\t\t\t\t}, usableKey, new TextEncoder().encode(JSON.stringify(exported)))));\n\t\t\t\t\t\t\t\tlet theirUsableKey = await crypto.subtle.importKey(\"jwk\", packet.data.content.keyInfo.key, { name: \"X25519\" }, true, []);\n\t\t\t\t\t\t\t\tlet joinedKeys = await crypto.subtle.deriveBits({ name: \"X25519\", public: theirUsableKey }, ephemeralKey.privateKey, 256);\n\t\t\t\t\t\t\t\tlet aesUsableKey = await crypto.subtle.importKey(\"raw\", joinedKeys, {name: \"AES-GCM\"}, true, [\"encrypt\", \"decrypt\"]);\n\t\t\t\t\t\t\t\tlet _dataBufferPromise = null, _rejectDataPromise = null;\n\t\t\t\t\t\t\t\tlet dataBufferPromise = new Promise((r, j) => [_dataBufferPromise, _rejectDataPromise] = [r, j]);\n\t\t\t\t\t\t\t\tconnections[packet.data.connectionID + \":server\"] = {\n\t\t\t\t\t\t\t\t\tourKey: ephemeralKey,\n\t\t\t\t\t\t\t\t\tfrom: packet.from,\n\t\t\t\t\t\t\t\t\ttheirMainKeyReceived: false,\n\t\t\t\t\t\t\t\t\ttheirKeyRaw: packet.data.content,\n\t\t\t\t\t\t\t\t\taesUsableKey,\n\t\t\t\t\t\t\t\t\tdataBuffer: [],\n\t\t\t\t\t\t\t\t\tdataBufferPromise,\n\t\t\t\t\t\t\t\t\t_dataBufferPromise,\n\t\t\t\t\t\t\t\t\t_rejectDataPromise,\n\t\t\t\t\t\t\t\t\tnetworkListenID\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\twebsocket.send(JSON.stringify({\n\t\t\t\t\t\t\t\t\treceiver: packet.from,\n\t\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\t\ttype: \"connectionful\",\n\t\t\t\t\t\t\t\t\t\taction: \"start\",\n\t\t\t\t\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\t\t\t\tkeyInfo: exported,\n\t\t\t\t\t\t\t\t\t\t\tsignature\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tconnectionID: packet.data.connectionID\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\t} else if (packet.data.type == \"connectionful\" && packet.data.gate == gate && packet.data.action == \"xchange\") {\n\t\t\t\t\t\t\t\tif (!packet.data.connectionID) return;\n\t\t\t\t\t\t\t\tif (!connections.hasOwnProperty(packet.data.connectionID + \":server\")) return;\n\t\t\t\t\t\t\t\tif (connections[packet.data.connectionID + \":server\"].theirMainKeyReceived) return;\n\t\t\t\t\t\t\t\tif (connections[packet.data.connectionID + \":server\"].dying) return;\n\t\t\t\t\t\t\t\tlet theirMainKeyDecrypt = JSON.parse(new TextDecoder().decode(await crypto.subtle.decrypt({\n\t\t\t\t\t\t\t\t\tname: \"AES-GCM\",\n\t\t\t\t\t\t\t\t\tiv: hexToU8A(packet.data.content.iv),\n\t\t\t\t\t\t\t\t}, connections[packet.data.connectionID + \":server\"].aesUsableKey, hexToU8A(packet.data.content.ct))));\n\t\t\t\t\t\t\t\tlet usableMainKey = await crypto.subtle.importKey(\"jwk\", theirMainKeyDecrypt.keyInfo.key, { name: \"Ed25519\" }, true, [\"verify\"]);\n\t\t\t\t\t\t\t\tlet verifyKeySignature = await crypto.subtle.verify({ name: \"Ed25519\" }, usableMainKey, hexToU8A(connections[packet.data.connectionID + \":server\"].theirKeyRaw.signature), new TextEncoder().encode(JSON.stringify(connections[packet.data.connectionID + \":server\"].theirKeyRaw.keyInfo)));\n\t\t\t\t\t\t\t\tif (verifyClientKeyChain && verifyKeySignature) {\n\t\t\t\t\t\t\t\t\tverifyKeySignature = false;\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tlet khrlFiles = await modules.fs.ls(modules.defaultSystem + \"/etc/keys/khrl\", processToken);\n\t\t\t\t\t\t\t\t\t\tlet khrlSignatures = [];\n\t\t\t\t\t\t\t\t\t\tfor (let khrlFile of khrlFiles) {\n\t\t\t\t\t\t\t\t\t\t\tlet khrl = JSON.parse(await modules.fs.read(modules.defaultSystem + \"/etc/keys/khrl/\" + khrlFile, processToken));\n\t\t\t\t\t\t\t\t\t\t\tlet khrlSignature = khrl.signature;\n\t\t\t\t\t\t\t\t\t\t\tdelete khrl.signature;\n\t\t\t\t\t\t\t\t\t\t\tif (await crypto.subtle.verify({ name: \"Ed25519\" }, modules.ksk_imported, hexToU8A(khrlSignature), new TextEncoder().encode(JSON.stringify(khrl.list)))) {\n\t\t\t\t\t\t\t\t\t\t\t\tkhrlSignatures.push(...khrl.list);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tverifyKeySignature = await recursiveKeyVerify(theirMainKeyDecrypt, khrlSignatures);\n\t\t\t\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!verifyKeySignature || !theirMainKeyDecrypt.keyInfo.usages.includes(\"connfulSecureClient:\" + packet.from)) {\n\t\t\t\t\t\t\t\t\tdelete connections[packet.data.connectionID + \":server\"];\n\t\t\t\t\t\t\t\t\twebsocket.send(JSON.stringify({\n\t\t\t\t\t\t\t\t\t\treceiver: packet.from,\n\t\t\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"connectionful\",\n\t\t\t\t\t\t\t\t\t\t\taction: \"drop\",\n\t\t\t\t\t\t\t\t\t\t\tconnectionID: packet.data.connectionID\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconnections[packet.data.connectionID + \":server\"].theirMainKeyReceived = theirMainKeyDecrypt;\n\t\t\t\t\t\t\t\tlet iv = crypto.getRandomValues(new Uint8Array(16));\n\t\t\t\t\t\t\t\twebsocket.send(JSON.stringify({\n\t\t\t\t\t\t\t\t\treceiver: packet.from,\n\t\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\t\ttype: \"connectionful\",\n\t\t\t\t\t\t\t\t\t\taction: \"xchange\",\n\t\t\t\t\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\t\t\t\tiv: u8aToHex(iv),\n\t\t\t\t\t\t\t\t\t\t\tct: u8aToHex(new Uint8Array(await crypto.subtle.encrypt({\n\t\t\t\t\t\t\t\t\t\t\t\tname: \"AES-GCM\",\n\t\t\t\t\t\t\t\t\t\t\t\tiv\n\t\t\t\t\t\t\t\t\t\t\t}, connections[packet.data.connectionID + \":server\"].aesUsableKey, new TextEncoder().encode(JSON.stringify(key)))))\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tconnectionID: packet.data.connectionID\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\t} else if (packet.data.type == \"connectionful\" && packet.data.gate == gate && packet.data.action == \"drop\") {\n\t\t\t\t\t\t\t\tif (!packet.data.connectionID) return;\n\t\t\t\t\t\t\t\tif (!connections.hasOwnProperty(packet.data.connectionID + \":server\")) return;\n\t\t\t\t\t\t\t\tif (connections[packet.data.connectionID + \":server\"].dying) return;\n\t\t\t\t\t\t\t\twebsocket.send(JSON.stringify({\n\t\t\t\t\t\t\t\t\treceiver: packet.from,\n\t\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\t\ttype: \"connectionful\",\n\t\t\t\t\t\t\t\t\t\taction: \"drop\",\n\t\t\t\t\t\t\t\t\t\tconnectionID: packet.data.connectionID\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\t\tif (connections[packet.data.connectionID + \":server\"]._rejectDataPromise)\n\t\t\t\t\t\t\t\t\tconnections[packet.data.connectionID + \":server\"]._rejectDataPromise(new Error(\"CONNECTION_DROPPED\"));\n\t\t\t\t\t\t\t\tconnections[packet.data.connectionID + \":server\"].dying = true;\n\t\t\t\t\t\t\t\tif (!connections[packet.data.connectionID + \":server\"].dataBuffer.length)\n\t\t\t\t\t\t\t\t\tdelete connections[packet.data.connectionID + \":server\"];\n\t\t\t\t\t\t\t} else if (packet.data.type == \"connectionful\" && packet.data.gate == gate && packet.data.action == \"nice2meetu\") {\n\t\t\t\t\t\t\t\tif (!packet.data.connectionID) return;\n\t\t\t\t\t\t\t\tif (!connections.hasOwnProperty(packet.data.connectionID + \":server\")) return;\n\t\t\t\t\t\t\t\tif (!connections[packet.data.connectionID + \":server\"].theirMainKeyReceived) return;\n\t\t\t\t\t\t\t\tif (!connections[packet.data.connectionID + \":server\"].aesUsableKey) return;\n\t\t\t\t\t\t\t\tif (connections[packet.data.connectionID + \":server\"].dying) return;\n\t\t\t\t\t\t\t\tnetworkListens[networkListenID].connectionBuffer.push(packet.data.connectionID + \":server\");\n\t\t\t\t\t\t\t\tlet _curcbp = _connectionBufferPromise;\n\t\t\t\t\t\t\t\tconnectionBufferPromise = new Promise((r, j) => [_connectionBufferPromise, _connectionBufferReject] = [r, j]);\n\t\t\t\t\t\t\t\tnetworkListens[networkListenID].connectionBufferPromise = connectionBufferPromise;\n\t\t\t\t\t\t\t\t_curcbp();\n\t\t\t\t\t\t\t} else if (packet.data.type == \"connectionful\" && packet.data.gate == gate && packet.data.action == \"data\") {\n\t\t\t\t\t\t\t\tif (!packet.data.connectionID) return;\n\t\t\t\t\t\t\t\tif (!connections.hasOwnProperty(packet.data.connectionID + \":server\")) return;\n\t\t\t\t\t\t\t\tif (!connections[packet.data.connectionID + \":server\"].aesUsableKey) return;\n\t\t\t\t\t\t\t\tif (!connections[packet.data.connectionID + \":server\"].theirMainKeyReceived) return;\n\t\t\t\t\t\t\t\tif (connections[packet.data.connectionID + \":server\"].dying) return;\n\t\t\t\t\t\t\t\tif (connections[packet.data.connectionID + \":server\"].writingLock) await connections[packet.data.connectionID + \":server\"].writingLock;\n\t\t\t\t\t\t\t\tlet writingLockRelease;\n\t\t\t\t\t\t\t\tlet writingLock = new Promise(r => writingLockRelease = r);\n\t\t\t\t\t\t\t\tconnections[packet.data.connectionID + \":server\"].writingLock = writingLock;\n\t\t\t\t\t\t\t\tconnections[packet.data.connectionID + \":server\"].dataBuffer.push(new TextDecoder().decode(await crypto.subtle.decrypt({\n\t\t\t\t\t\t\t\t\tname: \"AES-GCM\",\n\t\t\t\t\t\t\t\t\tiv: hexToU8A(packet.data.content.iv)\n\t\t\t\t\t\t\t\t}, connections[packet.data.connectionID + \":server\"].aesUsableKey, hexToU8A(packet.data.content.ct))));\n\t\t\t\t\t\t\t\tif (!(connections[connID + \":server\"].dataBuffer.length - 1)) {\n\t\t\t\t\t\t\t\t\tlet _curdbp = connections[packet.data.connectionID + \":server\"].dataBufferPromise;\n\t\t\t\t\t\t\t\t\tlet _dataBufferPromise = null, _rejectDataPromise = null;\n\t\t\t\t\t\t\t\t\tlet dataBufferPromise = new Promise((r, e) => [_dataBufferPromise, _rejectDataPromise] = [r, e]);\n\t\t\t\t\t\t\t\t\tconnections[packet.data.connectionID + \":server\"].dataBufferPromise = dataBufferPromise;\n\t\t\t\t\t\t\t\t\tconnections[packet.data.connectionID + \":server\"]._dataBufferPromise = _dataBufferPromise;\n\t\t\t\t\t\t\t\t\tconnections[packet.data.connectionID + \":server\"]._rejectDataPromise = _rejectDataPromise;\n\t\t\t\t\t\t\t\t\t_curdbp();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twritingLockRelease();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch {}\n\t\t\t\t\t}\n\t\t\t\t\tnetworkListens[networkListenID] = { ws: websocket, gate: gate, fn: eventListener, connectionBuffer: [], connectionBufferPromise }\n\t\t\t\t\tmodules.network.runOnClose.then(function() {\n\t\t\t\t\t\tfor (let connectionID in connections) if (connections[connectionID].networkListenID == networkListenID) {\n\t\t\t\t\t\t\tconnections[connectionID].dying = true;\n\t\t\t\t\t\t\tconnections[connectionID]._rejectDataPromise(new Error(\"NETWORK_CLOSED\"));\n\t\t\t\t\t\t\tif (!connections[connectionID].dataBuffer.length) delete connections[connectionID];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdelete networkListens[networkListenID];\n\t\t\t\t\t\t_connectionBufferReject(new Error(\"NETWORK_CLOSED\"));\n\t\t\t\t\t});\n\t\t\t\t\twebsocket.addEventListener(\"message\", eventListener);\n\t\t\t\t\treturn networkListenID;\n\t\t\t\t},\n\t\t\t\tconnfulListenConnections: async function(networkListenID) {\n\t\t\t\t\tif (!privileges.includes(\"CONNFUL_LISTEN\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!networkListens.hasOwnProperty(networkListenID)) throw new Error(\"INVALID_LISTEN_ID\");\n\t\t\t\t\tif (!networkListens[networkListenID].connectionBuffer.length) await networkListens[networkListenID].connectionBufferPromise;\n\t\t\t\t\tlet connectionID = networkListens[networkListenID].connectionBuffer[0];\n\t\t\t\t\tnetworkListens[networkListenID].connectionBuffer = networkListens[networkListenID].connectionBuffer.slice(1);\n\t\t\t\t\treturn connectionID;\n\t\t\t\t},\n\t\t\t\tgetBuildTime: function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_BUILD\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.build_time;\n\t\t\t\t},\n\t\t\t\tconnfulConnect: async function(connOpts) {\n\t\t\t\t\tif (!privileges.includes(\"CONNFUL_CONNECT\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet {address, gate, key, private: privateKey, doNotVerifyServer, verifyByDomain} = connOpts;\n\t\t\t\t\tlet websocketHandle = modules.network.ws;\n\t\t\t\t\tif (!websocketHandle) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\tlet websocket = modules.websocket._handles[websocketHandle].ws;\n\t\t\t\t\tif (websocket.readyState != 1) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\tlet networkListenID = Array.from(crypto.getRandomValues(new Uint8Array(64))).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\tlet connID = crypto.getRandomValues(new Uint8Array(64)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\t\tlet hexToU8A = (hex) => Uint8Array.from(hex.match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\t\t\tlet u8aToHex = (u8a) => Array.from(u8a).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\tlet newKeyKA, exportedKA;\n\t\t\t\t\tif (!key && !privateKey) {\n\t\t\t\t\t\tnewKeyKA = await crypto.subtle.generateKey({name: \"Ed25519\", namedCurve: \"P-256\"}, true, [\"sign\", \"verify\"]);\n\t\t\t\t\t\texportedKA = await crypto.subtle.exportKey(\"jwk\", newKeyKA.publicKey);\n\t\t\t\t\t\texportedKA = { keyInfo: { usages: [\"connfulSecureClient:\" + modules.network.address], key: exportedKA }, signature: null };\n\t\t\t\t\t\tnewKeyKA = newKeyKA.privateKey;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewKeyKA = await crypto.subtle.importKey(\"jwk\", privateKey, {name: \"Ed25519\"}, true, [\"sign\"]);\n\t\t\t\t\t\texportedKA = key;\n\t\t\t\t\t}\n\t\t\t\t\tlet ephemeralKey = await crypto.subtle.generateKey({name: \"X25519\"}, true, [\"deriveBits\"]);\n\t\t\t\t\tlet exported = await crypto.subtle.exportKey(\"jwk\", ephemeralKey.publicKey);\n\t\t\t\t\texported = { signedBy: \"clientKey\", usages: [\"connfulSecureEphemeral\"], key: exported };\n\t\t\t\t\tlet signature = u8aToHex(new Uint8Array(await crypto.subtle.sign({ name: \"Ed25519\" }, newKeyKA, new TextEncoder().encode(JSON.stringify(exported)))));\n\t\t\t\t\tlet _dataBufferPromise = null;\n\t\t\t\t\tlet _rejectDataPromise = null;\n\t\t\t\t\tlet dataBufferPromise = new Promise((r, e) => [_dataBufferPromise, _rejectDataPromise] = [r, e]);\n\t\t\t\t\tlet _settlePromise = null;\n\t\t\t\t\tlet _rejectPromise = null;\n\t\t\t\t\tlet settlePromise = new Promise((r, e) => [_settlePromise, _rejectPromise] = [r, e]);\n\t\t\t\t\tlet packetID = crypto.getRandomValues(new Uint8Array(32)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\t\tconnections[connID + \":client\"] = {\n\t\t\t\t\t\tourKey: ephemeralKey,\n\t\t\t\t\t\tfrom: address,\n\t\t\t\t\t\ttheirMainKeyReceived: false,\n\t\t\t\t\t\ttheirKeyRaw: null,\n\t\t\t\t\t\taesUsableKey: null,\n\t\t\t\t\t\tnetworkListenID,\n\t\t\t\t\t\tdataBuffer: [],\n\t\t\t\t\t\tdataBufferPromise,\n\t\t\t\t\t\tsettlePromise,\n\t\t\t\t\t\tgateIfNeeded: gate\n\t\t\t\t\t}\n\t\t\t\t\tasync function eventListener(e) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlet packet = JSON.parse(e.data);\n\t\t\t\t\t\t\tif (!packet.from) {\n\t\t\t\t\t\t\t\tif (packet.event == \"AddressUnreachable\" && packet.packetID == packetID)\n\t\t\t\t\t\t\t\t\t_rejectPromise(new Error(\"ADDRESS_UNREACHABLE\"));\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (packet.data.gate) return;\n\t\t\t\t\t\t\tif (packet.data.type == \"connectionful\" && packet.data.connectionID == connID && packet.data.action == \"start\") {\n\t\t\t\t\t\t\t\tif (connections[connID + \":client\"].aesUsableKey) return;\n\t\t\t\t\t\t\t\tlet theirUsableKey = await crypto.subtle.importKey(\"jwk\", packet.data.content.keyInfo.key, { name: \"X25519\" }, true, []);\n\t\t\t\t\t\t\t\tlet joinedKeys = await crypto.subtle.deriveBits({ name: \"X25519\", public: theirUsableKey }, ephemeralKey.privateKey, 256);\n\t\t\t\t\t\t\t\tlet aesUsableKey = await crypto.subtle.importKey(\"raw\", joinedKeys, {\n\t\t\t\t\t\t\t\t\tname: \"AES-GCM\"\n\t\t\t\t\t\t\t\t}, true, [\"encrypt\", \"decrypt\"]);\n\t\t\t\t\t\t\t\tconnections[connID + \":client\"].aesUsableKey = aesUsableKey;\n\t\t\t\t\t\t\t\tconnections[connID + \":client\"].theirKeyRaw = packet.data.content;\n\t\t\t\t\t\t\t\tlet iv = crypto.getRandomValues(new Uint8Array(16));\n\t\t\t\t\t\t\t\twebsocket.send(JSON.stringify({\n\t\t\t\t\t\t\t\t\treceiver: address,\n\t\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\t\ttype: \"connectionful\",\n\t\t\t\t\t\t\t\t\t\taction: \"xchange\",\n\t\t\t\t\t\t\t\t\t\tconnectionID: connID,\n\t\t\t\t\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\t\t\t\tiv: u8aToHex(iv),\n\t\t\t\t\t\t\t\t\t\t\tct: u8aToHex(new Uint8Array(await crypto.subtle.encrypt({\n\t\t\t\t\t\t\t\t\t\t\t\tname: \"AES-GCM\",\n\t\t\t\t\t\t\t\t\t\t\t\tiv\n\t\t\t\t\t\t\t\t\t\t\t}, aesUsableKey, new TextEncoder().encode(JSON.stringify(exportedKA)))))\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tgate\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\t} else if (packet.data.type == \"connectionful\" && packet.data.connectionID == connID && packet.data.action == \"xchange\") {\n\t\t\t\t\t\t\t\tif (connections[connID + \":client\"].theirMainKeyReceived) return;\n\t\t\t\t\t\t\t\tlet theirMainKeyDecrypt = JSON.parse(new TextDecoder().decode(await crypto.subtle.decrypt({\n\t\t\t\t\t\t\t\t\tname: \"AES-GCM\",\n\t\t\t\t\t\t\t\t\tiv: hexToU8A(packet.data.content.iv)\n\t\t\t\t\t\t\t\t}, connections[connID + \":client\"].aesUsableKey, hexToU8A(packet.data.content.ct))));\n\t\t\t\t\t\t\t\tlet usableMainKey = await crypto.subtle.importKey(\"jwk\", theirMainKeyDecrypt.keyInfo.key, {name: \"Ed25519\"}, true, [\"verify\"]);\n\t\t\t\t\t\t\t\tlet verifyKeySignature = await crypto.subtle.verify({ name: \"Ed25519\" }, usableMainKey, hexToU8A(connections[connID + \":client\"].theirKeyRaw.signature), new TextEncoder().encode(JSON.stringify(connections[connID + \":client\"].theirKeyRaw.keyInfo)));\n\t\t\t\t\t\t\t\tif (!doNotVerifyServer && verifyKeySignature) {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tlet khrlFiles = await modules.fs.ls(modules.defaultSystem + \"/etc/keys/khrl\", processToken);\n\t\t\t\t\t\t\t\t\t\tlet khrlSignatures = [];\n\t\t\t\t\t\t\t\t\t\tfor (let khrlFile of khrlFiles) {\n\t\t\t\t\t\t\t\t\t\t\tlet khrl = JSON.parse(await modules.fs.read(modules.defaultSystem + \"/etc/keys/khrl/\" + khrlFile, processToken));\n\t\t\t\t\t\t\t\t\t\t\tlet khrlSignature = khrl.signature;\n\t\t\t\t\t\t\t\t\t\t\tdelete khrl.signature;\n\t\t\t\t\t\t\t\t\t\t\tif (await crypto.subtle.verify({ name: \"Ed25519\" }, modules.ksk_imported, hexToU8A(khrlSignature), new TextEncoder().encode(JSON.stringify(khrl.list)))) {\n\t\t\t\t\t\t\t\t\t\t\t\tkhrlSignatures.push(...khrl.list);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tverifyKeySignature = await recursiveKeyVerify(theirMainKeyDecrypt, khrlSignatures);\n\t\t\t\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t\t\t\tverifyKeySignature = false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!verifyKeySignature || (!theirMainKeyDecrypt.keyInfo.usages.includes(\"connfulSecureServer:\" + address) &&\n\t\t\t\t\t\t\t\t\t\t!theirMainKeyDecrypt.keyInfo.usages.includes(\"connfulSecureServer:\" + verifyByDomain))) {\n\t\t\t\t\t\t\t\t\t_rejectPromise(new Error(\"SERVER_SIGNATURE_VERIFICATION_FAILED\"));\n\t\t\t\t\t\t\t\t\twebsocket.removeEventListener(\"message\", eventListener);\n\t\t\t\t\t\t\t\t\tdelete connections[connID + \":client\"];\n\t\t\t\t\t\t\t\t\tdelete networkListens[networkListenID];\n\t\t\t\t\t\t\t\t\treturn websocket.send(JSON.stringify({\n\t\t\t\t\t\t\t\t\t\treceiver: address,\n\t\t\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"connectionful\",\n\t\t\t\t\t\t\t\t\t\t\taction: \"drop\",\n\t\t\t\t\t\t\t\t\t\t\tconnectionID: connID,\n\t\t\t\t\t\t\t\t\t\t\tgate\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconnections[connID + \":client\"].theirMainKeyReceived = theirMainKeyDecrypt;\n\t\t\t\t\t\t\t\twebsocket.send(JSON.stringify({\n\t\t\t\t\t\t\t\t\treceiver: address,\n\t\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\t\ttype: \"connectionful\",\n\t\t\t\t\t\t\t\t\t\taction: \"nice2meetu\",\n\t\t\t\t\t\t\t\t\t\tconnectionID: connID,\n\t\t\t\t\t\t\t\t\t\tgate\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\t\t_settlePromise();\n\t\t\t\t\t\t\t} else if (packet.data.type == \"connectionful\" && packet.data.connectionID == connID && packet.data.action == \"drop\") {\n\t\t\t\t\t\t\t\tif (connections[connID + \":client\"].dying) return;\n\t\t\t\t\t\t\t\t_rejectPromise(new Error(\"CONNECTION_DROPPED\"));\n\t\t\t\t\t\t\t\tif (_rejectDataPromise) _rejectDataPromise(new Error(\"CONNECTION_DROPPED\"));\n\t\t\t\t\t\t\t\twebsocket.send(JSON.stringify({\n\t\t\t\t\t\t\t\t\treceiver: address,\n\t\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\t\ttype: \"connectionful\",\n\t\t\t\t\t\t\t\t\t\taction: \"drop\",\n\t\t\t\t\t\t\t\t\t\tconnectionID: connID,\n\t\t\t\t\t\t\t\t\t\tgate\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\t\tconnections[connID + \":client\"].dying = true;\n\t\t\t\t\t\t\t\twebsocket.removeEventListener(\"message\", eventListener);\n\t\t\t\t\t\t\t\tdelete networkListens[networkListenID];\n\t\t\t\t\t\t\t\tif (!connections[connID + \":client\"].dataBuffer.length) delete connections[connID + \":client\"];\n\t\t\t\t\t\t\t} else if (packet.data.type == \"connectionful\" && packet.data.connectionID == connID && packet.data.action == \"data\") {\n\t\t\t\t\t\t\t\tif (!connections[connID + \":client\"].aesUsableKey) return;\n\t\t\t\t\t\t\t\tif (!connections[connID + \":client\"].theirMainKeyReceived) return;\n\t\t\t\t\t\t\t\tif (connections[connID + \":client\"].writingLock) await connections[connID + \":client\"].writingLock;\n\t\t\t\t\t\t\t\tlet writingLockRelease;\n\t\t\t\t\t\t\t\tlet writingLock = new Promise(r => writingLockRelease = r);\n\t\t\t\t\t\t\t\tconnections[connID + \":client\"].writingLock = writingLock;\n\t\t\t\t\t\t\t\tconnections[connID + \":client\"].dataBuffer.push(new TextDecoder().decode(await crypto.subtle.decrypt({\n\t\t\t\t\t\t\t\t\tname: \"AES-GCM\",\n\t\t\t\t\t\t\t\t\tiv: hexToU8A(packet.data.content.iv)\n\t\t\t\t\t\t\t\t}, connections[connID + \":client\"].aesUsableKey, hexToU8A(packet.data.content.ct))));\n\t\t\t\t\t\t\t\tif (!(connections[connID + \":client\"].dataBuffer.length - 1)) {\n\t\t\t\t\t\t\t\t\t_dataBufferPromise();\n\t\t\t\t\t\t\t\t\tdataBufferPromise = new Promise((r, e) => [_dataBufferPromise, _rejectDataPromise] = [r, e]);\n\t\t\t\t\t\t\t\t\tconnections[packet.data.connectionID + \":client\"].dataBufferPromise = dataBufferPromise;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twritingLockRelease();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch {}\n\t\t\t\t\t};\n\t\t\t\t\tnetworkListens[networkListenID] = { ws: websocket, gate: gate, fn: eventListener };\n\t\t\t\t\twebsocket.addEventListener(\"message\", eventListener);\n\t\t\t\t\twebsocket.send(JSON.stringify({\n\t\t\t\t\t\treceiver: address,\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\ttype: \"connectionful\",\n\t\t\t\t\t\t\taction: \"start\",\n\t\t\t\t\t\t\tgate,\n\t\t\t\t\t\t\tconnectionID: connID,\n\t\t\t\t\t\t\tcontent: { keyInfo: exported, signature }\n\t\t\t\t\t\t},\n\t\t\t\t\t\tid: packetID\n\t\t\t\t\t}));\n\t\t\t\t\tmodules.network.runOnClose.then(function() {\n\t\t\t\t\t\tif (connections.hasOwnProperty(connID + \":client\")) {\n\t\t\t\t\t\t\tconnections[connID + \":client\"].dying = true;\n\t\t\t\t\t\t\tif (!connections[connID + \":client\"].dataBuffer.length) delete connections[connID + \":client\"];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdelete networkListens[networkListenID];\n\t\t\t\t\t\t_rejectPromise(new Error(\"NETWORK_CLOSED\"));\n\t\t\t\t\t\t_rejectDataPromise(new Error(\"NETWORK_CLOSED\"));\n\t\t\t\t\t});\n\t\t\t\t\treturn connID + \":client\";\n\t\t\t\t},\n\t\t\t\tconnfulConnectionSettled: async function(connectionID) {\n\t\t\t\t\tif (!privileges.includes(\"CONNFUL_CONNECT\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!connections.hasOwnProperty(connectionID)) throw new Error(\"NO_SUCH_CONNECTION\");\n\t\t\t\t\tawait connections[connectionID].settlePromise;\n\t\t\t\t},\n\t\t\t\tconnfulDisconnect: async function(connectionID) {\n\t\t\t\t\tif (!privileges.includes(\"CONNFUL_DISCONNECT\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!connections.hasOwnProperty(connectionID)) throw new Error(\"NO_SUCH_CONNECTION\");\n\t\t\t\t\tif (connections[connectionID].dying) return;\n\t\t\t\t\tnetworkListens[connections[connectionID].networkListenID].ws.send(JSON.stringify({\n\t\t\t\t\t\treceiver: connections[connectionID].from,\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\ttype: \"connectionful\",\n\t\t\t\t\t\t\taction: \"drop\",\n\t\t\t\t\t\t\tconnectionID: connectionID.slice(0, -7),\n\t\t\t\t\t\t\tgate: connections[connectionID].gateIfNeeded\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t\t\t},\n\t\t\t\tconnfulForceDisconnect: async function(connectionID) {\n\t\t\t\t\tif (!privileges.includes(\"CONNFUL_DISCONNECT\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tdelete connections[connectionID];\n\t\t\t\t},\n\t\t\t\tconnfulWrite: async function(sendOpts) {\n\t\t\t\t\tif (!privileges.includes(\"CONNFUL_WRITE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!connections.hasOwnProperty(sendOpts.connectionID)) throw new Error(\"NO_SUCH_CONNECTION\");\n\t\t\t\t\tif (connections[sendOpts.connectionID].dying) throw new Error(\"CONNECTION_DROPPED\");\n\t\t\t\t\tlet iv = crypto.getRandomValues(new Uint8Array(16));\n\t\t\t\t\tlet u8aToHex = (u8a) => Array.from(u8a).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\tnetworkListens[connections[sendOpts.connectionID].networkListenID].ws.send(JSON.stringify({\n\t\t\t\t\t\treceiver: connections[sendOpts.connectionID].from,\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\ttype: \"connectionful\",\n\t\t\t\t\t\t\taction: \"data\",\n\t\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\tiv: u8aToHex(iv),\n\t\t\t\t\t\t\t\tct: u8aToHex(new Uint8Array(await crypto.subtle.encrypt({\n\t\t\t\t\t\t\t\t\tname: \"AES-GCM\",\n\t\t\t\t\t\t\t\t\tiv\n\t\t\t\t\t\t\t\t}, connections[sendOpts.connectionID].aesUsableKey, new TextEncoder().encode(sendOpts.data))))\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tconnectionID: sendOpts.connectionID.slice(0, -7),\n\t\t\t\t\t\t\tgate: connections[sendOpts.connectionID].gateIfNeeded\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t\t\t},\n\t\t\t\tconnfulRead: async function(connectionID) {\n\t\t\t\t\tif (!privileges.includes(\"CONNFUL_READ\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!connections.hasOwnProperty(connectionID)) throw new Error(\"NO_SUCH_CONNECTION\");\n\t\t\t\t\tif (!connections[connectionID].dataBuffer.length) await connections[connectionID].dataBufferPromise;\n\t\t\t\t\tlet data = connections[connectionID].dataBuffer.shift();\n\t\t\t\t\tif (connections[connectionID].dying && connections[connectionID].dataBuffer.length == 0) delete connections[connectionID]; \n\t\t\t\t\treturn data;\n\t\t\t\t},\n\t\t\t\tconnfulAddressGet: async function(connectionID) {\n\t\t\t\t\tif (!privileges.includes(\"CONNFUL_ADDRESS_GET\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!connections.hasOwnProperty(connectionID)) throw new Error(\"NO_SUCH_CONNECTION\");\n\t\t\t\t\treturn connections[connectionID].from;\n\t\t\t\t},\n\t\t\t\tconnfulIdentityGet: async function(connectionID) {\n\t\t\t\t\tif (!privileges.includes(\"CONNFUL_IDENTITY_GET\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!connections.hasOwnProperty(connectionID)) throw new Error(\"NO_SUCH_CONNECTION\");\n\t\t\t\t\treturn connections[connectionID].theirMainKeyReceived;\n\t\t\t\t},\n\t\t\t\tsystemUptime: async function() {\n\t\t\t\t\tif (!privileges.includes(\"SYSTEM_UPTIME\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn Math.floor(performance.now());\n\t\t\t\t},\n\t\t\t\tnetworkRawWrite: function(data) {\n\t\t\t\t\tif (!privileges.includes(\"NETWORK_RAW_WRITE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet websocketHandle = modules.network.ws;\n\t\t\t\t\tif (!websocketHandle) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\tlet websocket = modules.websocket._handles[websocketHandle].ws;\n\t\t\t\t\tif (websocket.readyState != 1) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\twebsocket.send(data);\n\t\t\t\t},\n\t\t\t\tnetworkRawRead: function() {\n\t\t\t\t\tif (!privileges.includes(\"NETWORK_RAW_READ\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet websocketHandle = modules.network.ws;\n\t\t\t\t\tif (!websocketHandle) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\tlet websocket = modules.websocket._handles[websocketHandle].ws;\n\t\t\t\t\tif (websocket.readyState != 1) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\treturn Promise.race([ new Promise(async function(resolve) {\n\t\t\t\t\t\tnetworkListens[networkListenID] = { ws: websocket, fn: _ => resolve(_.data) };\n\t\t\t\t\t\twebsocket.addEventListener(\"message\", eventListener);\n\t\t\t\t\t}), new Promise((_, reject) => modules.network.runOnClose.then(_ => reject(new Error(\"NETWORK_CLOSED\")))) ]);\n\t\t\t\t},\n\t\t\t\tgetHostname: async function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_HOSTNAME\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.network.hostname;\n\t\t\t\t},\n\t\t\t\tresolve: async function(name) {\n\t\t\t\t\tif (!privileges.includes(\"RESOLVE_NAME\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet websocketHandle = modules.network.ws;\n\t\t\t\t\tif (!websocketHandle) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\tlet websocket = modules.websocket._handles[websocketHandle].ws;\n\t\t\t\t\tif (websocket.readyState != 1) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\tlet tlds = JSON.parse(await modules.fs.read(modules.defaultSystem + \"/etc/tlds.json\"));\n\t\t\t\t\tfunction resolveRecursive(name, address) {\n\t\t\t\t\t\tif (tlds.hasOwnProperty(name)) return tlds[name];\n\t\t\t\t\t\tif (address == null) return null;\n\t\t\t\t\t\treturn new Promise(function(resolve) {\n\t\t\t\t\t\t\tlet gate = \"user_\" + Array.from(crypto.getRandomValues(new Uint8Array(16))).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\t\t\tlet networkListenID = Array.from(crypto.getRandomValues(new Uint8Array(64))).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\t\t\tfunction eventListener(e) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tlet packet = JSON.parse(e.data);\n\t\t\t\t\t\t\t\t\tif (packet.data.type == \"connectionless\" && packet.data.gate == gate && packet.from == address) {\n\t\t\t\t\t\t\t\t\t\twebsocket.removeEventListener(\"message\", eventListener);\n\t\t\t\t\t\t\t\t\t\tdelete networkListens[networkListenID];\n\t\t\t\t\t\t\t\t\t\tresolve(packet.data.content);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnetworkListens[networkListenID] = { ws: websocket, fn: eventListener };\n\t\t\t\t\t\t\twebsocket.addEventListener(\"message\", eventListener);\n\t\t\t\t\t\t\twebsocket.send(JSON.stringify({\n\t\t\t\t\t\t\t\treceiver: address,\n\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\ttype: \"connectionless\",\n\t\t\t\t\t\t\t\t\tgate: \"resolve\",\n\t\t\t\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\t\t\treply: gate,\n\t\t\t\t\t\t\t\t\t\tquery: name\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tlet nameParts = name.split(\".\").reverse();\n\t\t\t\t\tlet currentResolve;\n\t\t\t\t\tfor (let part = 0; part < nameParts.length; part++) currentResolve = await resolveRecursive(nameParts.slice(0, part + 1).reverse().join(\".\"), currentResolve);\n\t\t\t\t\treturn currentResolve;\n\t\t\t\t},\n\t\t\t\tpatchDiff: function(libraryOptions) {\n\t\t\t\t\tif (!privileges.includes(\"PATCH_DIFF\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!window.diff) throw new Error(\"MODULE_REQUIRED\");\n\t\t\t\t\tlet operations = { diff_core, diff, lcs, calcPatch, applyPatch, calcSlices };\n\t\t\t\t\treturn [ ...operations[libraryOptions.operation](...libraryOptions.args) ];\n\t\t\t\t},\n\t\t\t\tsetFirmware: async function(new_flash) {\n\t\t\t\t\tif (!privileges.includes(\"SET_FIRMWARE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (modules.core.setFW) {\n\t\t\t\t\t\tawait modules.core.setFW(new_flash);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tlocalStorage.setItem(\"runtime_flash\", new_flash);\n\t\t\t\t},\n\t\t\t\treloadNetworkConfig: async function() {\n\t\t\t\t\tif (!privileges.includes(\"RELOAD_NETWORK_CONFIG\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tawait modules.network.reloadConfig();\n\t\t\t\t},\n\t\t\t\tbatteryStatus: async function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_BATTERY_STATUS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet battery = await navigator.getBattery();\n\t\t\t\t\treturn {\n\t\t\t\t\t\tcharging: battery.charging,\n\t\t\t\t\t\tlevel: battery.level,\n\t\t\t\t\t\tchargingTime: battery.chargingTime,\n\t\t\t\t\t\tdischargingTime: battery.dischargingTime\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\tgetUpdateService: async function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_UPDATE_SERVICE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.network.updates;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlet customAPIs = modules.customAPIs;\n\t\tif (customAPIs) {\n\t\t\tfor (let api in (customAPIs.public || {})) apis.public[api] = async (...args) => customAPIs.public[api](processToken, ...args);\n\t\t\tfor (let api in (customAPIs.private || {})) apis.private[api] = async (...args) => customAPIs.private[api](processToken, ...args);\n\t\t}\n\t\treturn apis;\n\t}\n}\nreeAPIs();","e7a389e08616d0e6a6b99bf803e6b9f8ad8e20dc95e09f921dbf6136845d9153b19a84e77759fb8635c95a1ec2a412ac312141301598af4dbe9a655340c818d4":"function loadBasicCSP() {\n\tmodules.csps = {};\n\tlet cryptoKeys = {};\n\tfunction cryptoKeyIntoKeyObject(ck, groupBy) {\n\t\tif (ck.privateKey && ck.publicKey) return {\n\t\t\tprivateKey: cryptoKeyIntoKeyObject(ck.privateKey, groupBy),\n\t\t\tpublicKey: cryptoKeyIntoKeyObject(ck.publicKey, groupBy),\n\t\t};\n\t\tlet keyID = crypto.getRandomValues(new Uint8Array(64)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\tif (!cryptoKeys.hasOwnProperty(groupBy)) cryptoKeys[groupBy] = {};\n\t\tcryptoKeys[groupBy][keyID] = ck;\n\t\treturn {\n\t\t\ttype: ck.type,\n\t\t\textractable: ck.extractable,\n\t\t\talgorithm: ck.algorithm,\n\t\t\tusages: ck.usages,\n\t\t\tkeyID: keyID\n\t\t}\n\t}\n\tmodules.csps.basic = {\n\t\tcspMetadata: function() {\n\t\t\treturn {\n\t\t\t\tname: \"Basic Cryptographic Provider\",\n\t\t\t\tversion: modules.pcos_version,\n\t\t\t\tdeveloper: \"PCsoft\",\n\t\t\t\tfeatures: Object.keys(modules.csps.basic)\n\t\t\t}\n\t\t},\n\t\trandom: async function(typedArray) {\n\t\t\treturn crypto.getRandomValues(typedArray);\n\t\t},\n\t\timportKey: async function(arg, groupBy) {\n\t\t\treturn cryptoKeyIntoKeyObject(await crypto.subtle.importKey(arg.format, arg.keyData, arg.algorithm, arg.extractable, arg.keyUsages), groupBy);\n\t\t},\n\t\tgenerateKey: async function(arg, groupBy) {\n\t\t\treturn cryptoKeyIntoKeyObject(await crypto.subtle.generateKey(arg.algorithm, arg.extractable, arg.keyUsages), groupBy);\n\t\t},\n\t\tderiveBits: async function(arg, groupBy) {\n\t\t\targ.baseKey = cryptoKeys[groupBy][arg.baseKey.keyID];\n\t\t\tif (arg.algorithm.public) arg.algorithm.public = cryptoKeys[groupBy][arg.algorithm.public.keyID];\n\t\t\treturn crypto.subtle.deriveBits(arg.algorithm, arg.baseKey, arg.length);\n\t\t},\n\t\tderiveKey: async function(arg, groupBy) {\n\t\t\targ.baseKey = cryptoKeys[groupBy][arg.baseKey.keyID];\n\t\t\tif (arg.algorithm.public) arg.algorithm.public = cryptoKeys[groupBy][arg.algorithm.public.keyID];\n\t\t\treturn cryptoKeyIntoKeyObject(await crypto.subtle.deriveKey(arg.algorithm, arg.baseKey, arg.derivedKeyType, arg.extractable, arg.keyUsages), groupBy);\n\t\t},\n\t\twrapKey: async function(arg, groupBy) {\n\t\t\targ.key = cryptoKeys[groupBy][arg.key.keyID];\n\t\t\targ.wrappingKey = cryptoKeys[groupBy][arg.wrappingKey.keyID];\n\t\t\treturn crypto.subtle.wrapKey(arg.format, arg.key, arg.wrappingKey, arg.wrapAlgo);\n\t\t},\n\t\tdigest: async function(arg) {\n\t\t\treturn crypto.subtle.digest(arg.algorithm, arg.data);\n\t\t},\n\t\tencrypt: async function(arg, groupBy) {\n\t\t\targ.key = cryptoKeys[groupBy][arg.key.keyID];\n\t\t\treturn crypto.subtle.encrypt(arg.algorithm, arg.key, arg.data);\n\t\t},\n\t\tsign: async function(arg, groupBy) {\n\t\t\targ.key = cryptoKeys[groupBy][arg.key.keyID];\n\t\t\treturn crypto.subtle.sign(arg.algorithm, arg.key, arg.data);\n\t\t},\n\t\texportKey: async function(arg, groupBy) {\n\t\t\targ.key = cryptoKeys[groupBy][arg.key.keyID];\n\t\t\treturn crypto.subtle.exportKey(arg.format, arg.key);\n\t\t},\n\t\tunwrapKey: async function(arg, groupBy) {\n\t\t\targ.unwrappingKey = cryptoKeys[groupBy][arg.unwrappingKey.keyID];\n\t\t\treturn cryptoKeyIntoKeyObject(await crypto.subtle.unwrapKey(arg.format, arg.keyData, arg.unwrappingKey, arg.unwrapAlgo, arg.unwrappedKeyAlgo, arg.extractable, arg.keyUsages), groupBy);\n\t\t},\n\t\tdecrypt: async function(arg, groupBy) {\n\t\t\targ.key = cryptoKeys[groupBy][arg.key.keyID];\n\t\t\treturn crypto.subtle.decrypt(arg.algorithm, arg.key, arg.data);\n\t\t},\n\t\tverify: async function(arg, groupBy) {\n\t\t\targ.key = cryptoKeys[groupBy][arg.key.keyID];\n\t\t\treturn crypto.subtle.verify(arg.algorithm, arg.key, arg.signature, arg.data);\n\t\t},\n\t\tunloadKey: (key, groupBy) => delete cryptoKeys[groupBy][key.keyID],\n\t\tremoveSameGroupKeys: (_, groupBy) => delete cryptoKeys[groupBy]\n\t}\n\tif (window.nacl) {\n\t\tmodules.csps.tweetnacl = {\n\t\t\tcspMetadata: function() {\n\t\t\t\treturn {\n\t\t\t\t\tname: \"TweetNaCl Cryptographic Provider\",\n\t\t\t\t\tversion: \"1.0.3\",\n\t\t\t\t\tdeveloper: \"TweetNaCl.js developers (https://github.com/dchest/tweetnacl-js)\",\n\t\t\t\t\tfeatures: Object.keys(modules.csps.tweetnacl)\n\t\t\t\t}\n\t\t\t},\n\t\t\trandom: typedArray => nacl.randomBytes(typedArray.length),\n\t\t\tgenerateKey: type => nacl[type].keyPair(),\n\t\t\tderiveKey: arg => nacl[arg.type].keyPair.fromSeed(arg.seed),\n\t\t\tdigest: message => nacl.hash(message),\n\t\t\tencrypt: arg => nacl[arg.type](arg.message, arg.nonce, arg.key1, arg.key2),\n\t\t\tsign: arg => nacl.sign.detached(arg.message, arg.secretKey),\n\t\t\tdecrypt: arg => nacl[arg.type].open(arg.box, arg.nonce, arg.key1, arg.key2),\n\t\t\tverify: arg => nacl.sign.detached.verify(arg.message, arg.signature, arg.publicKey)\n\t\t};\n\t}\n}\nloadBasicCSP();","7427d399bccacdf82c101735500f98e5cbdc6c05df4c535abea8b16a4cfe721d367bef0cae609b056568065a54a24cf43b1b8e7b718f5025e6a5a8b0e182dfc9":"function localization() {\n\t// @pcos-app-mode native\n\tlet locales = {\n\t\tget: function(key, lang) {\n\t\t\tlang = lang || locales.defaultLocale || navigator.languages[0].split(\"-\")[0].toLowerCase();\n\t\t\tlet locale = locales[lang];\n\t\t\tif (!locale) locale = locales[locales.defaultLocale || \"en\"];\n\t\t\tif (!locale) locale = {};\n\t\t\tif (!locale.hasOwnProperty(key)) locale = locales[locales.defaultLocale || \"en\"] || {};\n\t\t\treturn locale.hasOwnProperty(key) ? locale[key] : key;\n\t\t}\n\t}\n\tmodules.locales = locales;\n}\nlocalization();","8caaf50a5c53eb57b9ca3e54ae103c0160133d4b4c0c0ae61f2754aad98673b95e6dc20e3d5f478b6790e84e26ce49709178f39cf27c1ce845892cf3e8d5889e":"function loadTasks() {\n\t// @pcos-app-mode native\n\tmodules.startupWindow.content.innerText = modules.locales.get(\"PCOS_STARTING\");\n\tlet tasks = {\n\t\texec: async function(file, arg, windowObject, token, silent, privateData) {\n\t\t\tlet errorAudio = new Audio();\n\t\t\ttry {\n\t\t\t\tlet errorSoundPerm = await modules.fs.permissions(modules.defaultSystem + \"/etc/sounds/error.aud\", token);\n\t\t\t\tif (!errorSoundPerm.world.includes(\"r\")) throw new Error(\"Not allowed to read error.aud\");\n\t\t\t\tlet errorSound = await modules.fs.read(modules.defaultSystem + \"/etc/sounds/error.aud\", token);\n\t\t\t\terrorAudio.src = errorSound;\n\t\t\t} catch {}\n\t\t\tif (modules.session.attrib(windowObject.sessionId, \"loggingOut\")) throw new Error(\"LOGGING_OUT\");\n\t\t\tlet language = modules.session.attrib(windowObject.sessionId, \"language\") || undefined;\n\t\t\tif (modules.shuttingDown) {\n\t\t\t\twindowObject.windowDiv.remove();\n\t\t\t\tthrow new Error(\"SYSTEM_SHUTDOWN_REQUESTED\");\n\t\t\t}\n\t\t\tlet appRedirecting = {};\n\t\t\ttry {\n\t\t\t\tappRedirecting = JSON.parse(await this.fs.read(modules.defaultSystem + \"/etc/appRedir\", token));\n\t\t\t} catch {}\n\t\t\tif (modules.core.bootMode == \"safe\") appRedirecting = {};\n\t\t\tif (appRedirecting.hasOwnProperty(file)) file = appRedirecting[file];\n\t\t\twindowObject.title.innerText = modules.locales.get(\"UNTITLED_APP\", language);\n\t\t\twindowObject.content.innerText = \"\";\n\t\t\twindowObject.content.style = \"\";\n\t\t\tlet taskId = crypto.getRandomValues(new Uint8Array(64)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\tlet executablePermissions, executable;\n\t\t\ttry {\n\t\t\t\texecutablePermissions = await this.fs.permissions(file, token);\n\t\t\t\texecutable = await this.fs.read(file, token);\n\t\t\t} catch (e) {\n\t\t\t\twindowObject.title.innerText = modules.locales.get(\"APP_STARTUP_CRASH_TITLE\", language);\n\t\t\t\twindowObject.content.innerText = modules.locales.get(\"APP_STARTUP_CRASH\", language);\n\t\t\t\twindowObject.content.style.padding = \"8px\";\n\t\t\t\twindowObject.closeButton.disabled = false;\n\t\t\t\twindowObject.closeButton.onclick = (e) => windowObject.windowDiv.remove() && e.stopPropagation();\n\t\t\t\tif (silent) windowObject.windowDiv.remove();\n\t\t\t\tif (!silent) errorAudio.play();\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\tif (!executablePermissions.world.includes(\"r\") || !executablePermissions.world.includes(\"x\")) {\n\t\t\t\twindowObject.title.innerText = modules.locales.get(\"PERMISSION_DENIED\", language);\n\t\t\t\twindowObject.content.innerText = modules.locales.get(\"MORE_PERMISSION_DENIED\", language);\n\t\t\t\twindowObject.content.style.padding = \"8px\";\n\t\t\t\twindowObject.closeButton.disabled = false;\n\t\t\t\twindowObject.closeButton.onclick = (e) => windowObject.windowDiv.remove() && e.stopPropagation();\n\t\t\t\tif (silent) windowObject.windowDiv.remove();\n\t\t\t\tif (!silent) errorAudio.play();\n\t\t\t\tthrow new Error(\"MORE_PERMISSION_DENIED\", language);\n\t\t\t}\n\t\t\tif (!executable.includes(\"// @pcos-app-mode isolat\" + \"able\")) {\n\t\t\t\twindowObject.title.innerText = modules.locales.get(\"COMPATIBILITY_ISSUE_TITLE\", language);\n\t\t\t\twindowObject.content.innerText = modules.locales.get(\"COMPATIBILITY_ISSUE\", language);\n\t\t\t\twindowObject.content.style.padding = \"8px\";\n\t\t\t\twindowObject.closeButton.disabled = false;\n\t\t\t\twindowObject.closeButton.onclick = (e) => windowObject.windowDiv.remove() && e.stopPropagation();\n\t\t\t\tif (silent) windowObject.windowDiv.remove();\n\t\t\t\tif (!silent) errorAudio.play();\n\t\t\t\tthrow new Error(\"COMPATIBILITY_ISSUE\");\n\t\t\t}\n\t\t\tlet appHardening = {overridable:true};\n\t\t\ttry {\n\t\t\t\tappHardening = JSON.parse(await this.fs.read(modules.defaultSystem + \"/etc/appHarden\", token));\n\t\t\t} catch {}\n\t\t\tlet disableHarden = appHardening.overridable && modules.core.bootMode == \"disable-harden\";\n\t\t\tif (disableHarden) appHardening = {overridable:true};\n\t\t\tlet limitations = [];\n\t\t\tlet execSignature = {};\n\t\t\tif (executable.includes(\"// =====BEGIN MANIFEST=====\")) {\n\t\t\t\tlet parsingLines = executable.split(\"\\n\");\n\t\t\t\tlet parsingBoundStart = parsingLines.indexOf(\"// =====BEGIN MANIFEST=====\");\n\t\t\t\tlet parsingBoundEnd = parsingLines.indexOf(\"// =====END MANIFEST=====\");\n\t\t\t\tlet upToParse = parsingLines.slice(parsingBoundStart, parsingBoundEnd + 1);\n\t\t\t\tlet knownLineTypes = [\"allow\", \"deny\"];\n\t\t\t\tfor (let line of upToParse) {\n\t\t\t\t\tlet lineType = line.split(\": \")[0].replace(\"// \", \"\");\n\t\t\t\t\tlet lineData = line.replace(\"// \" + lineType + \": \", \"\");\n\t\t\t\t\tif (lineType == \"signature\") {\n\t\t\t\t\t\texecSignature.signature = lineData;\n\t\t\t\t\t\texecutable = executable.replace(line + \"\\n\", \"\");\n\t\t\t\t\t}\n\t\t\t\t\tif (lineType == \"signer\") execSignature.signer = lineData;\n\t\t\t\t\tif (lineType == \"asck\") execSignature.selfContainedSigner = lineData;\n\t\t\t\t\tif (knownLineTypes.includes(lineType)) {\n\t\t\t\t\t\tlet dataParts = lineData.split(\", \");\n\t\t\t\t\t\tfor (let data of dataParts) limitations.push({ lineType, data });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (disableHarden) limitations = [];\n\t\t\tlet hexToU8A = (hex) => Uint8Array.from(hex.match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\tlet u8aToHex = (u8a) => Array.from(u8a).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\tif (!limitations.some(lim => lim.lineType == \"allow\") && appHardening.requireAllowlist && !disableHarden) {\n\t\t\t\twindowObject.title.innerText = modules.locales.get(\"PERMISSION_DENIED\", language);\n\t\t\t\twindowObject.content.innerText = modules.locales.get(\"NO_APP_ALLOWLIST\", language);\n\t\t\t\twindowObject.content.style.padding = \"8px\";\n\t\t\t\twindowObject.closeButton.disabled = false;\n\t\t\t\twindowObject.closeButton.onclick = (e) => windowObject.windowDiv.remove() && e.stopPropagation();\n\t\t\t\tif (silent) windowObject.windowDiv.remove();\n\t\t\t\tif (!silent) errorAudio.play();\n\t\t\t\tthrow new Error(\"NO_APP_ALLOWLIST\");\n\t\t\t}\n\n\t\t\tasync function recursiveKeyVerify(key, khrl) {\n\t\t\t\tif (!key) throw new Error(\"NO_KEY\");\n\t\t\t\tif (key.keyInfo.dates?.since > Date.now()) throw new Error(\"KEY_NOT_IN_TIME\");\n\t\t\t\tif (Date.now() > key.keyInfo.dates?.until) throw new Error(\"KEY_NOT_IN_TIME\");\n\t\t\t\tlet u8aToHex = (u8a) => Array.from(u8a).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\tlet hash = u8aToHex(new Uint8Array(await crypto.subtle.digest(\"SHA-256\", new TextEncoder().encode((key.keyInfo.key).x))));\n\t\t\t\tlet hexToU8A = (hex) => Uint8Array.from(hex.match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\t\tif (khrl.includes(hash)) throw new Error(\"KEY_REVOKED\");\n\t\t\t\tlet signedByKey = modules.ksk_imported;\n\t\t\t\tif (key.keyInfo.signedBy) {\n\t\t\t\t\tsignedByKey = JSON.parse(await modules.fs.read(modules.defaultSystem + \"/etc/keys/\" + key.keyInfo.signedBy, token));\n\t\t\t\t\tif (!signedByKey.keyInfo.usages.includes(\"keyTrust\")) throw new Error(\"NOT_KEY_AUTHORITY\");\n\t\t\t\t\tawait recursiveKeyVerify(signedByKey, khrl);\n\t\t\t\t\tsignedByKey = await crypto.subtle.importKey(\"jwk\", signedByKey.keyInfo.key, { name: \"Ed25519\" }, false, [\"verify\"]);\n\t\t\t\t}\n\t\t\t\tif (!await crypto.subtle.verify({ name: \"Ed25519\" }, signedByKey, hexToU8A(key.signature), new TextEncoder().encode(JSON.stringify(key.keyInfo)))) throw new Error(\"KEY_SIGNATURE_VERIFICATION_FAILED\");\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif ((execSignature.signer || appHardening.requireSignature || execSignature.selfContainedSigner) && !disableHarden) {\n\t\t\t\ttry {\n\t\t\t\t\tlet khrlFiles = await this.fs.ls(modules.defaultSystem + \"/etc/keys/khrl\", token);\n\t\t\t\t\tlet khrlSignatures = [];\n\t\t\t\t\tfor (let khrlFile of khrlFiles) {\n\t\t\t\t\t\tlet khrl = JSON.parse(await this.fs.read(modules.defaultSystem + \"/etc/keys/khrl/\" + khrlFile, token));\n\t\t\t\t\t\tlet khrlSignature = khrl.signature;\n\t\t\t\t\t\tdelete khrl.signature;\n\t\t\t\t\t\tif (await crypto.subtle.verify({ name: \"Ed25519\" }, modules.ksk_imported, hexToU8A(khrlSignature), new TextEncoder().encode(JSON.stringify(khrl.list)))) {\n\t\t\t\t\t\t\tkhrlSignatures.push(...khrl.list);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlet signingKey = JSON.parse(execSignature.selfContainedSigner || \"null\");\n\t\t\t\t\tif (!signingKey || appHardening.disableASCK) signingKey = JSON.parse(await this.fs.read(modules.defaultSystem + \"/etc/keys/\" + execSignature.signer, token));\n\t\t\t\t\tawait recursiveKeyVerify(signingKey, khrlSignatures);\n\t\t\t\t\tif (signingKey.keyInfo) if (!signingKey.keyInfo.usages.includes(\"appTrust\")) throw new Error(\"NOT_APP_SIGNING_KEY\");\n\t\t\t\t\tlet importSigningKey = await crypto.subtle.importKey(\"jwk\", signingKey.keyInfo.key, { name: \"Ed25519\" }, false, [\"verify\"]);\n\t\t\t\t\tif (!await crypto.subtle.verify({ name: \"Ed25519\" }, importSigningKey, hexToU8A(execSignature.signature), new TextEncoder().encode(executable))) throw new Error(\"APP_SIGNATURE_VERIFICATION_FAILED\");\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(\"Failed to verify app signature:\", e);\n\t\t\t\t\twindowObject.title.innerText = modules.locales.get(\"PERMISSION_DENIED\", language);\n\t\t\t\t\twindowObject.content.innerText = modules.locales.get(\"SIGNATURE_VERIFICATION_FAILED\", language).replace(\"%s\", execSignature.signer || modules.locales.get(\"UNKNOWN_PLACEHOLDER\", language));\n\t\t\t\t\twindowObject.content.style.padding = \"8px\";\n\t\t\t\t\twindowObject.closeButton.disabled = false;\n\t\t\t\t\twindowObject.closeButton.onclick = (e) => windowObject.windowDiv.remove() && e.stopPropagation();\n\t\t\t\t\tif (silent) windowObject.windowDiv.remove();\n\t\t\t\t\tif (!silent) errorAudio.play();\n\t\t\t\t\tthrow new Error(\"APP_OR_KEY_SIGNATURE_VERIFICATION_FAILED\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet ree = await this.ree(windowObject.content, token);\n\t\t\ttry {\n\t\t\t\tmodules.session.attrib(windowObject.sessionId, \"openReeWindows\", [ ...(modules.session.attrib(windowObject.sessionId, \"openReeWindows\") || []), taskId ]);\n\t\t\t\targ = arg || [];\n\t\t\t\tif (!(arg instanceof Array)) arg = [];\n\t\t\t\targ = arg.map(a => String(a));\n\t\t\t\tlet that = this;\n\t\t\t\tree.iframe.style = \"width: 100%; height: 100%; border: none; top: 0; left: 0; position: absolute;\";\n\t\t\t\tlet reeAPIInstance = await modules.reeAPIInstance({ ree, ses: windowObject.sessionId, token, taskId, limitations, privateData });\n\t\t\t\tfor (let action in reeAPIInstance.public) ree.exportAPI(action, (e) => reeAPIInstance.public[action](e.arg));\n\t\t\t\tthis.tracker[taskId] = {\n\t\t\t\t\tree,\n\t\t\t\t\tfile: file,\n\t\t\t\t\targ: arg,\n\t\t\t\t\tapis: reeAPIInstance,\n\t\t\t\t\tcritical: false,\n\t\t\t\t\tcliio: {\n\t\t\t\t\t\tattached: false,\n\t\t\t\t\t\tattachedCLISignUp: function() {\n\t\t\t\t\t\t\treturn new Promise(a => attachedCLIRegistrations.push(a));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tlet registrations = [];\n\t\t\t\tlet attachedCLIRegistrations = [];\n\t\t\t\tlet cliCache = [];\n\t\t\t\twindowObject.closeButton.addEventListener(\"click\", () => that.sendSignal(taskId, 15));\n\t\t\t\tree.exportAPI(\"attachCLI\", async function() {\n\t\t\t\t\tif (that.tracker[taskId].cliio.attached) return true;\n\t\t\t\t\tif (!window.Terminal) return false;\n\t\t\t\t\tfor (let registration of attachedCLIRegistrations) registration();\n\t\t\t\t\tattachedCLIRegistrations = [];\n\t\t\t\t\tlet signup = () => new Promise((resolve) => registrations.push(resolve));\n\t\t\t\t\tree.iframe.hidden = true;\n\t\t\t\t\tlet termDiv = document.createElement(\"div\");\n\t\t\t\t\ttermDiv.style = \"position: absolute; top: 0; left: 0; width: 100%; height: 100%;\";\n\t\t\t\t\tlet fitAddon = new FitAddon.FitAddon();\n\t\t\t\t\tlet termInstance = new Terminal();\n\t\t\t\t\ttermInstance.loadAddon(fitAddon);\n\t\t\t\t\ttermInstance.open(termDiv);\n\t\t\t\t\twindowObject.content.appendChild(termDiv);\n\t\t\t\t\tthat.tracker[taskId].cliio.attached = true;\n\t\t\t\t\tthat.tracker[taskId].cliio.xtermInstance = termInstance;\n\t\t\t\t\tlet onresizeFn = () => fitAddon.fit();\n\t\t\t\t\tonresizeFn();\n\t\t\t\t\tlet robs = new ResizeObserver(onresizeFn);\n\t\t\t\t\tthat.tracker[taskId].cliio.robsInstance = robs;\n\t\t\t\t\trobs.observe(windowObject.windowDiv);\n\t\t\t\t\tthat.tracker[taskId].cliio.signup = signup;\n\t\t\t\t\tthat.tracker[taskId].cliio.xtermInstance.onData(e => cliCache.push(e));\n\t\t\t\t\ttermInstance.clear();\n\t\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, 8));\n\t\t\t\t\treturn true;  \n\t\t\t\t});\n\t\t\t\tree.exportAPI(\"toMyCLI\", async function(apiArg) {\n\t\t\t\t\tif (that.tracker[taskId].cliio.attached) {\n\t\t\t\t\t\tthat.tracker[taskId].cliio.xtermInstance.write(apiArg.arg);\n\t\t\t\t\t\tfor (let registered in registrations) {\n\t\t\t\t\t\t\tawait registrations[registered]({ type: \"write\", data: apiArg.arg });\n\t\t\t\t\t\t\tregistrations.splice(0, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tree.exportAPI(\"fromMyCLI\", async function() {\n\t\t\t\t\tif (!that.tracker[taskId].cliio.attached) return false;\n\t\t\t\t\tlet ti = that.tracker[taskId].cliio.xtermInstance;\n\t\t\t\t\treturn new Promise(async function(resolve) {\n\t\t\t\t\t\tif (cliCache.length) {\n\t\t\t\t\t\t\tlet element = cliCache[0];\n\t\t\t\t\t\t\tcliCache = cliCache.slice(1);\n\t\t\t\t\t\t\tresolve(element);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet d = ti.onData(async function(e) {\n\t\t\t\t\t\t\tcliCache = cliCache.slice(1);\n\t\t\t\t\t\t\tresolve(e);\n\t\t\t\t\t\t\td.dispose();\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\tree.exportAPI(\"clearMyCLI\", async function() {\n\t\t\t\t\tif (that.tracker[taskId].cliio.attached) that.tracker[taskId].cliio.xtermInstance.clear();\n\t\t\t\t\tfor (let registered in registrations) {\n\t\t\t\t\t\tawait registrations[registered]({ type: \"consoleClear\" });\n\t\t\t\t\t\tregistrations.splice(registered, 1);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tree.exportAPI(\"cliSize\", function() {\n\t\t\t\t\tif (!that.tracker[taskId].cliio.attached) return [ 0, 0 ];\n\t\t\t\t\treturn [ that.tracker[taskId].cliio.xtermInstance.cols, that.tracker[taskId].cliio.xtermInstance.rows ];\n\t\t\t\t});\n\t\t\t\tree.exportAPI(\"detachCLI\", function() {\n\t\t\t\t\tif (!that.tracker[taskId].cliio.attached) return true;\n\t\t\t\t\tthat.tracker[taskId].cliio.attached = false;\n\t\t\t\t\tthat.tracker[taskId].cliio.xtermInstance.clear();\n\t\t\t\t\tthat.tracker[taskId].cliio.robsInstance.disconnect();\n\t\t\t\t\tdelete that.tracker[taskId].cliio.robsInstance;\n\t\t\t\t\tthat.tracker[taskId].cliio.xtermInstance.dispose();\n\t\t\t\t\tdelete that.tracker[taskId].cliio.xtermInstance;\n\t\t\t\t\tdelete that.tracker[taskId].cliio.signup;\n\t\t\t\t\tregistrations = [];\n\t\t\t\t\tree.iframe.hidden = false;\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t\tree.exportAPI(\"windowVisibility\", (apiArg) => windowObject.windowDiv.classList.toggle(\"hidden\", !apiArg.arg));\n\t\t\t\tree.exportAPI(\"windowTitleSet\", (apiArg) => windowObject.title.innerText = apiArg.arg);\n\t\t\t\tree.exportAPI(\"windowResize\", function(apiArg) {\n\t\t\t\t\tif (reeAPIInstance.public.getPrivileges().includes(\"GRAB_ATTENTION\")) {\n\t\t\t\t\t\twindowObject.windowDiv.style.width = apiArg.arg[0] + \"px\";\n\t\t\t\t\t\twindowObject.windowDiv.style.height = apiArg.arg[1] + \"px\";\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tree.exportAPI(\"windowSize\", function() {\n\t\t\t\t\treturn {\n\t\t\t\t\t\twidth: windowObject.windowDiv.clientWidth,\n\t\t\t\t\t\theight: windowObject.windowDiv.clientHeight\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tree.exportAPI(\"windowRelocate\", function(apiArg) {\n\t\t\t\t\tif (reeAPIInstance.public.getPrivileges().includes(\"GRAB_ATTENTION\")) {\n\t\t\t\t\t\twindowObject.windowDiv.style.top = apiArg.arg[0] + \"px\";\n\t\t\t\t\t\twindowObject.windowDiv.style.left = apiArg.arg[1] + \"px\";\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tree.exportAPI(\"windowFullscreen\", function(apiArg) {\n\t\t\t\t\tif (reeAPIInstance.public.getPrivileges().includes(\"GRAB_ATTENTION\")) {\n\t\t\t\t\t\twindowObject.windowDiv.classList.toggle(\"fullscreen\", apiArg.arg);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tree.exportAPI(\"closeability\", (apiArg) => windowObject.closeButton.classList.toggle(\"hidden\", !apiArg.arg));\n\t\t\t\tree.exportAPI(\"critical\", function(apiArg) {\n\t\t\t\t\tif (reeAPIInstance.public.getPrivileges().includes(\"SYSTEM_STABILITY\")) {\n\t\t\t\t\t\tthat.tracker[taskId].critical = !!apiArg.arg;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tawait ree.eval(\"taskId = \" + JSON.stringify(taskId) + \";\");\n\t\t\t\tawait ree.eval(\"exec_args = \" + JSON.stringify(arg) + \";\");\n\t\t\t\tree.beforeCloseDown(function() {\n\t\t\t\t\tlet orw = modules.session.attrib(windowObject.sessionId, \"openReeWindows\");\n\t\t\t\t\torw.splice(orw.indexOf(taskId), 1);\n\t\t\t\t\tmodules.session.attrib(windowObject.sessionId, \"openReeWindows\", orw);\n\t\t\t\t\tif (that.tracker[taskId].cliio.attached) {    \n\t\t\t\t\t\tthat.tracker[taskId].cliio.attached = false;\n\t\t\t\t\t\tthat.tracker[taskId].cliio.xtermInstance.clear();\n\t\t\t\t\t\tthat.tracker[taskId].cliio.robsInstance.disconnect();\n\t\t\t\t\t\tthat.tracker[taskId].cliio.robsInstance = null;\n\t\t\t\t\t\tthat.tracker[taskId].cliio.xtermInstance.dispose();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tree.beforeCloseDown(() => windowObject.windowDiv.remove());\n\t\t\t\tree.beforeCloseDown(() => delete that.tracker[taskId]);\n\t\t\t\tawait ree.eval(executable);\n\t\t\t} catch (e) {\n\t\t\t\tree.closeDown();\n\t\t\t\twindowObject.title.innerText = modules.locales.get(\"APP_STARTUP_CRASH_TITLE\", language);\n\t\t\t\twindowObject.content.innerText = modules.locales.get(\"APP_STARTUP_CRASH\", language);\n\t\t\t\twindowObject.content.style.padding = \"8px\";\n\t\t\t\twindowObject.closeButton.disabled = false;\n\t\t\t\twindowObject.windowDiv.classList.toggle(\"hidden\", false);\n\t\t\t\twindowObject.closeButton.onclick = (e) => windowObject.windowDiv.remove() && e.stopPropagation();\n\t\t\t\tif (silent) windowObject.windowDiv.remove();\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\treturn taskId;\n\t\t},\n\t\tsendSignal: async function(taskId, signal, bypassCritical) {\n\t\t\tif (signal == 9) {\n\t\t\t\tif (this.tracker[taskId].critical && !bypassCritical) {\n\t\t\t\t\tlet memory = this.tracker[taskId];\n\t\t\t\t\tawait memory.ree.closeDown();\n\t\t\t\t\tawait panic(\"CRITICAL_TASK_FAILED\", {\n\t\t\t\t\t\tname: memory.file,\n\t\t\t\t\t\tparams: memory.arg\n\t\t\t\t\t});\n\t\t\t\t\tthrow new Error(\"CRITICAL_TASK_FAILED\");\n\t\t\t\t}\n\t\t\t\treturn await this.tracker[taskId].ree.closeDown();\n\t\t\t}\n\t\t\treturn await this.tracker[taskId].ree.eval(\"dispatchEvent(new CustomEvent(\\\"signal\\\", { detail: \" + JSON.stringify(signal) + \", bubbles: true }));\");\n\t\t},\n\t\trunsProperly: async function(taskId) {\n\t\t\ttry {\n\t\t\t\treturn await this.tracker[taskId].ree.eval(\"true\");\n\t\t\t} catch (e) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tlistPublicTasks: () => Object.keys(tasks.tracker),\n\t\twaitTermination: async function(taskId) {\n\t\t\tif (!this.tracker.hasOwnProperty(taskId)) return;\n\t\t\treturn new Promise((resolve) => this.tracker[taskId].ree.beforeCloseDown(() => resolve()));\n\t\t},\n\t\ttaskInfo: async function(taskId) {\n\t\t\tif (!this.tracker.hasOwnProperty(taskId)) return null;\n\t\t\tlet info = await modules.tokens.info(this.tracker[taskId].apis.public.getProcessToken());\n\t\t\tif (!info) info = { user: taskId.slice(0, 16) };\n\t\t\treturn {\n\t\t\t\tfile: this.tracker[taskId].file,\n\t\t\t\targ: this.tracker[taskId].arg,\n\t\t\t\trunBy: info.user,\n\t\t\t\tcliio: this.tracker[taskId].cliio.attached\n\t\t\t}\n\t\t},\n\t\ttracker: {},\n\t\tfs: modules.fs,\n\t\tree: modules.core.createREE\n\t};\n\t\n\tmodules.tasks = tasks;\n}\nloadTasks();","3687af4f98d3697306200ccb6339612eca471bad8105037bd031bbca4067bb7a494b70c736d68f20ed2da82013e867fbb78c8177670df624f99eccb892630dee":"async function logOut(target) {\n\tlet liu = modules.liu;\n\tif (!liu.hasOwnProperty(target)) throw new Error(\"USER_NOT_LOGGED_IN\");\n\tlet session = liu[target].session;\n\tlet token = liu[target].logon.token;\n\tlet secureSession = modules.session.attrib(session, \"secureID\");\n\tawait modules.session.attrib(session, \"loggingOut\", true);\n\tclearInterval(liu[target].clockInterval);\n\tif (modules.session.active == session || (secureSession && modules.session.active == secureSession)) await modules.session.muteAllSessions();\n\tawait modules.session.activateSession(modules.session.systemSession);\n\tlet loggingOutWindow = modules.window(modules.session.systemSession, true);\n\tloggingOutWindow.title.innerText = modules.locales.get(\"LOGGING_OUT\");\n\tloggingOutWindow.content.style.padding = \"8px\";\n\tloggingOutWindow.closeButton.disabled = true;\n\tloggingOutWindow.content.innerText = modules.locales.get(\"LOGGING_OUT\");\n\tlet taskList = modules.session.attrib(session, \"openReeWindows\") || [];\n\tlet timeout = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n\tfunction allProcessesClosed() {\n\t\treturn new Promise(function(resolve) {\n\t\t\tlet int = setInterval(function() {\n\t\t\t\ttry {\n\t\t\t\t\ttaskList = modules.session.attrib(session, \"openReeWindows\") || [];\n\t\t\t\t\tif (Object.keys(taskList).length == 0) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t\tclearInterval(int);\n\t\t\t\t\t}\n\t\t\t\t} catch {\n\t\t\t\t\tresolve();\n\t\t\t\t\tclearInterval(int);\n\t\t\t\t}\n\t\t\t})\n\t\t});\n\t}\n\tloggingOutWindow.content.innerText = modules.locales.get(\"POLITE_CLOSE_SIGNAL\");\n\tfor (let taskId of taskList) modules.tasks.sendSignal(taskId, 15);\n\tawait Promise.race([\n\t\ttimeout(5000),\n\t\tallProcessesClosed()\n\t]);\n\tloggingOutWindow.content.innerText = modules.locales.get(\"ABRUPT_CLOSE_SIGNAL\");\n\tif (secureSession) {\n\t\ttaskList = modules.session.attrib(secureSession, \"openReeWindows\") || [];\n\t\tfor (let taskId of taskList) modules.tasks.sendSignal(taskId, 9);\n\t}\n\ttaskList = modules.session.attrib(session, \"openReeWindows\") || [];\n\tfor (let taskId of taskList) modules.tasks.sendSignal(taskId, 9);\n\tawait allProcessesClosed();\n\tloggingOutWindow.windowDiv.remove();\n\tdelete modules.liu[target];\n\tawait modules.tokens.revoke(token);\n\tif (secureSession) await modules.session.rmsession(secureSession);\n\tawait modules.session.rmsession(session);\n}\n\nmodules.logOut = logOut;","63ce8c68a2d7f793d8660a0b00f287c282748b813bda65868988b2d8946ad98efde2ece89280cd75f9876efbcaf611a3d9bfb19989f20fd1ec2d047071ed475f":"function restartLoad() {\n\t// @pcos-app-mode native\n\tfunction timeout(ms) {\n\t\treturn new Promise(resolve => setTimeout(resolve, ms));\n\t}\n\tfunction allProcessesClosed() {\n\t\treturn new Promise(function(resolve) {\n\t\t\tlet int = setInterval(function() {\n\t\t\t\tif (Object.keys(modules.tasks.tracker).length == 0) {\n\t\t\t\t\tresolve();\n\t\t\t\t\tclearInterval(int);\n\t\t\t\t}\n\t\t\t})\n\t\t});\n\t}\n\t\n\tasync function restart(noAutomaticReload = false, token, kexec) {\n\t\ttry {\n\t\t\tlet shutdownSoundPerm = await modules.fs.permissions(modules.defaultSystem + \"/etc/sounds/shutdown.aud\");\n\t\t\tif (!shutdownSoundPerm.world.includes(\"r\")) throw new Error(\"Not allowed to read shutdown.aud\");\n\t\t\tlet shutdownSound = await modules.fs.read(modules.defaultSystem + \"/etc/sounds/shutdown.aud\");\n\t\t\tlet shutdownAudio = new Audio();\n\t\t\tshutdownAudio.src = shutdownSound;\n\t\t\tshutdownAudio.play();\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to play shutdown.aud:\", e);\n\t\t}\n\t\tmodules.shuttingDown = true;\n\t\tlet window = modules.window;\n\t\tlet fs = modules.fs;\n\t\tlet tasks = modules.tasks;\n\t\tmodules.session.muteAllSessions();\n\t\tmodules.session.activateSession(modules.session.systemSession);\n\t\tlet windowDiv = window(modules.session.systemSession, true);\n\t\twindowDiv.closeButton.classList.toggle(\"hidden\", true);\n\t\twindowDiv.title.innerText = modules.locales.get(\"PCOS_RESTARTING\").replace(\"%s\", \"\");\n\t\twindowDiv.content.style.padding = \"8px\";\n\t\tlet description = document.createElement(\"p\");\n\t\tdescription.innerText = modules.locales.get(\"PCOS_RESTARTING\").replace(\"%s\", modules.locales.get(\"PLEASE_WAIT\"));\n\t\twindowDiv.content.appendChild(description);\n\t\tdescription.innerText = modules.locales.get(\"PCOS_RESTARTING\").replace(\"%s\", modules.locales.get(\"POLITE_CLOSE_SIGNAL\"));\n\t\tfor (let taskId in tasks.tracker) tasks.sendSignal(taskId, 15);\n\t\tawait Promise.race([\n\t\t\ttimeout(5000),\n\t\t\tallProcessesClosed()\n\t\t]);\n\t\ttry {\n\t\t\tmodules.websocket._handles[modules.network.ws].send(JSON.stringify({\n\t\t\t\tfinalProxyPacket: true\n\t\t\t}));\n\t\t} catch {}\n\t\tdescription.innerText = modules.locales.get(\"PCOS_RESTARTING\").replace(\"%s\", modules.locales.get(\"ABRUPT_CLOSE_SIGNAL\"));\n\t\tfor (let taskId in tasks.tracker) tasks.sendSignal(taskId, 9, true);\n\t\tawait allProcessesClosed();\n\t\ttry {\n\t\t\tmodules.websocket._handles[modules.network.ws].ws.onclose = null;\n\t\t\tmodules.websocket._handles[modules.network.ws].ws.close();\n\t\t\tdelete modules.websocket._handles[modules.network.ws];\n\t\t} catch {}\n\t\tdescription.innerText = modules.locales.get(\"PCOS_RESTARTING\").replace(\"%s\", modules.locales.get(\"UNMOUNTING_MOUNTS\"));\n\t\tfor (let mount in fs.mounts) try { await fs.sync(mount, token); } catch {}\n\t\tfor (let mount in fs.mounts) try { await fs.umount(mount, token); } catch {}\n\t\tfor (let mount in fs.mounts) try { await fs.umount(mount, token, true); } catch {}\n\t\tdescription.innerText = modules.locales.get(\"PCOS_RESTARTING\").replace(\"%s\", modules.locales.get(\"RESTARTING\"));\n\t\tif (!noAutomaticReload) {\n\t\t\tif (kexec) {\n\t\t\t\ttry {\n\t\t\t\t\tmodules.session.destroy();\n\t\t\t\t\tawait new ((async _=>0).constructor)(\n\t\t\t\t\t\tmodules.core.disk.partition(\"boot\").getData()\n\t\t\t\t\t)();\n\t\t\t\t\treturn modules.killSystem();\n\t\t\t\t} catch (e) {\n\t\t\t\t\tawait panic(\"KEXEC_FAILED\", {\n\t\t\t\t\t\tname: \"kexec\",\n\t\t\t\t\t\tunderlyingJS: e\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn location.reload();\n\t\t}\n\t\tmodules.killSystem();\n\t\tdescription.innerText = modules.locales.get(\"SAFE_TO_CLOSE\");\n\t\tlet button = document.createElement(\"button\");\n\t\tbutton.innerText = modules.locales.get(\"RESTART_BUTTON\");\n\t\tbutton.onclick = function() {\n\t\t\tdescription.innerText = modules.locales.get(\"PCOS_RESTARTING\").replace(\"%s\", modules.locales.get(\"RESTARTING\"));\n\t\t\tbutton.remove();\n\t\t\tlocation.reload();\n\t\t}\n\t\twindowDiv.content.appendChild(button);\n\t}\n\t\n\tmodules.restart = restart;\n}\n\nrestartLoad();","6c919eb06729eec84223f302f589b165ba0e0ec862baa62954c19c7730fe5834a613da1b5620aa7d787e23d1c37cdb5d23901c576a4398d36f662f1958738a99":"function loadUserFriendly() {\n\t// @pcos-app-mode native\n\tmodules.userfriendliness = {\n\t\tinconsiderateTime: function(language, ms, majorUnitsOnly, displayMs) {\n\t\t\tlet string = \"\";\n\t\t\tlet days = Math.floor(ms / 86400000);\n\t\t\tlet hours = Math.floor(ms / 3600000) % 24;\n\t\t\tlet minutes = Math.floor(ms / 60000) % 60;\n\t\t\tlet seconds = Math.floor(ms / 1000) % 60;\n\t\t\tif (days) string = string + modules.locales.get(\"SHORT_DAYS\", language).replace(\"%s\", days) + \" \";\n\t\t\tif (days && majorUnitsOnly) return string;\n\t\t\tif (hours) string = string + modules.locales.get(\"SHORT_HOURS\", language).replace(\"%s\", hours) + \" \";\n\t\t\tif (hours && majorUnitsOnly) return string;\n\t\t\tif (minutes) string = string + modules.locales.get(\"SHORT_MINUTES\", language).replace(\"%s\", minutes) + \" \";\n\t\t\tif (minutes && majorUnitsOnly) return string;\n\t\t\tif (seconds) string = string + modules.locales.get(\"SHORT_SECONDS\", language).replace(\"%s\", seconds) + \" \";\n\t\t\tif (displayMs && (ms % 1000)) {\n\t\t\t\tif (seconds && majorUnitsOnly) return string;\n\t\t\t\tstring = string + modules.locales.get(\"SHORT_MILLISECONDS\", language).replace(\"%s\", (ms % 1000)) + \" \";\n\t\t\t}\n\t\t\treturn string;\n\t\t},\n\t\tinformationUnits: function(language, bytes, majorUnitsOnly) {\n\t\t\tlet string = \"\";\n\t\t\tlet tb = Math.floor(bytes / (1024 * 1024 * 1024 * 1024));\n\t\t\tlet gb = Math.floor(bytes / (1024 * 1024 * 1024)) % 1024;\n\t\t\tlet mb = Math.floor(bytes / (1024 * 1024)) % 1024;\n\t\t\tlet kb = Math.floor(bytes / 1024) % 1024;\n\t\t\tlet b = bytes % 1024;\n\t\t\tif (tb) string = string + modules.locales.get(\"SHORT_TERABYTES\", language).replace(\"%s\", tb) + \" \";\n\t\t\tif (tb && majorUnitsOnly) return string;\n\t\t\tif (gb) string = string + modules.locales.get(\"SHORT_GIGABYTES\", language).replace(\"%s\", gb) + \" \";\n\t\t\tif (gb && majorUnitsOnly) return string;\n\t\t\tif (mb) string = string + modules.locales.get(\"SHORT_MEGABYTES\", language).replace(\"%s\", mb) + \" \";\n\t\t\tif (mb && majorUnitsOnly) return string;\n\t\t\tif (kb) string = string + modules.locales.get(\"SHORT_KILOBYTES\", language).replace(\"%s\", kb) + \" \";\n\t\t\tif (kb && majorUnitsOnly) return string;\n\t\t\tif (b) string = string + modules.locales.get(\"SHORT_BYTES\", language).replace(\"%s\", b);\n\t\t\tif (b && majorUnitsOnly) return string;\n\t\t\treturn string;\n\t\t},\n\t\tconsiderateTime: function(language, ms, majorUnitsOnly, displayMs) {\n\t\t\tlet dateObject = new Date(ms + (new Date(ms).getTimezoneOffset() * 60000));\n\t\t\tlet string = \"\";\n\t\t\tlet years = dateObject.getFullYear() - 1970;\n\t\t\tlet months = dateObject.getMonth();\n\t\t\tlet days = dateObject.getDate() - 1;\n\t\t\tlet hours = dateObject.getHours();\n\t\t\tlet minutes = dateObject.getMinutes();\n\t\t\tlet seconds = dateObject.getSeconds();\n\t\t\tlet millisec = dateObject.getMilliseconds();\n\t\t\tif (years) string = string + modules.locales.get(\"SHORT_YEARS\", language).replace(\"%s\", years) + \" \";\n\t\t\tif (years && majorUnitsOnly) return string;\n\t\t\tif (months) string = string + modules.locales.get(\"SHORT_MONTHS\", language).replace(\"%s\", months) + \" \";\n\t\t\tif (months && majorUnitsOnly) return string;\n\t\t\tif (days) string = string + modules.locales.get(\"SHORT_DAYS\", language).replace(\"%s\", days) + \" \";\n\t\t\tif (days && majorUnitsOnly) return string;\n\t\t\tif (hours) string = string + modules.locales.get(\"SHORT_HOURS\", language).replace(\"%s\", hours) + \" \";\n\t\t\tif (hours && majorUnitsOnly) return string;\n\t\t\tif (minutes) string = string + modules.locales.get(\"SHORT_MINUTES\", language).replace(\"%s\", minutes) + \" \";\n\t\t\tif (minutes && majorUnitsOnly) return string;\n\t\t\tif (seconds) string = string + modules.locales.get(\"SHORT_SECONDS\", language).replace(\"%s\", seconds) + \" \";\n\t\t\tif (displayMs && millisec) {\n\t\t\t\tif (seconds && majorUnitsOnly) return string;\n\t\t\t\tstring = string + modules.locales.get(\"SHORT_MILLISECONDS\", language).replace(\"%s\", (millisec % 1000)) + \" \";\n\t\t\t}\n\t\t\treturn string;\n\t\t}\n\t}\n}\nloadUserFriendly();","a402ccdaeaa70e5cdbbb636e4f8bd9a486737a21970d05ed6e3d4310abf3a6eb7b1d01d2da23c7d79a4e0d92d2996099c2081e4d9aba09cb0e70871bb29aaec3":"function setupTokens() {\n\t// @pcos-app-mode native\n\tmodules.tokens = {\n\t\tgenerate: async function() {\n\t\t\tlet rng = crypto.getRandomValues(new Uint8Array(64));\n\t\t\tlet token = Array.from(rng).map(x => x.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\tthis._tokens[token] = { privileges: [], user: \"nobody\", groups: [] };\n\t\t\treturn token;\n\t\t},\n\t\trevoke: async function(token) {\n\t\t\tdelete this._tokens[token];\n\t\t},\n\t\tsetPrivileges: async function(token, privileges) {\n\t\t\tthis._tokens[token].privileges = privileges;\n\t\t},\n\t\taddPrivilege: async function(token, privilege) {\n\t\t\tthis._tokens[token].privileges.push(privilege);\n\t\t},\n\t\taddPrivileges: async function(token, privileges) {\n\t\t\tthis._tokens[token].privileges.push(...privileges);\n\t\t},\n\t\tremovePrivilege: async function(token, privilege) {\n\t\t\tthis._tokens[token].privileges = this._tokens[token].privileges.filter(x => x != privilege);\n\t\t},\n\t\tremovePrivileges: async function(token, privileges) {\n\t\t\tthis._tokens[token].privileges = this._tokens[token].privileges.filter(x => !privileges.includes(x));\n\t\t},\n\t\tuserInitialize: async function(token, user) {\n\t\t\tthis._tokens[token].user = user;\n\t\t\tthis._tokens[token].groups = (await modules.users.getUserInfo(user, token)).groups || [];\n\t\t\tthis._tokens[token].privileges = [\"FS_READ\", \"FS_WRITE\", \"FS_REMOVE\", \"FS_CHANGE_PERMISSION\", \"FS_LIST_PARTITIONS\", \"IPC_CREATE_PIPE\", \"IPC_LISTEN_PIPE\", \"IPC_SEND_PIPE\", \"IPC_CHANGE_PERMISSION\", \"ELEVATE_PRIVILEGES\", \"GET_USER_INFO\", \"SET_SECURITY_CHECKS\", \"START_TASK\", \"LIST_TASKS\", \"SIGNAL_TASK\", \"FETCH_SEND\", \"CSP_OPERATIONS\", \"IDENTIFY_SYSTEM\", \"WEBSOCKETS_OPEN\", \"WEBSOCKETS_LISTEN\", \"WEBSOCKETS_SEND\", \"WEBSOCKET_SET_PERMISSIONS\", \"MANAGE_TOKENS\", \"WEBSOCKET_INFO\", \"GRAB_ATTENTION\", \"CLI_MODIFICATIONS\", \"GET_THEME\", \"GET_LOCALE\", \"GET_FILESYSTEMS\", \"GET_BUILD\", \"GET_SERVER_URL\", \"START_BACKGROUND_TASK\", \"GET_BOOT_MODE\", \"GET_SCREEN_INFO\", \"PCOS_NETWORK_PING\", \"LOGOUT\", \"LULL_SYSTEM\", \"CONNLESS_LISTEN\", \"CONNLESS_SEND\", \"GET_NETWORK_ADDRESS\", \"CONNFUL_LISTEN\", \"CONNFUL_CONNECT\", \"CONNFUL_DISCONNECT\", \"CONNFUL_WRITE\", \"CONNFUL_READ\", \"CONNFUL_ADDRESS_GET\", \"SYSTEM_UPTIME\", \"GET_HOSTNAME\", \"RESOLVE_NAME\", \"PATCH_DIFF\", \"GET_BATTERY_STATUS\", \"CONNFUL_IDENTITY_GET\", \"GET_UPDATE_SERVICE\"];\n\t\t\tif (user == \"root\") this._tokens[token].privileges.push(\"FS_UNMOUNT\", \"SYSTEM_SHUTDOWN\", \"SWITCH_USERS_AUTOMATICALLY\", \"USER_INFO_OTHERS\", \"SET_USER_INFO\", \"FS_BYPASS_PERMISSIONS\", \"IPC_BYPASS_PERMISSIONS\", \"TASK_BYPASS_PERMISSIONS\", \"SENSITIVE_USER_INFO_OTHERS\", \"SYSTEM_STABILITY\", \"RUN_KLVL_CODE\", \"IDENTIFY_SYSTEM_SENSITIVE\", \"WEBSOCKET_BYPASS_PERMISSIONS\", \"LLDISK_READ\", \"LLDISK_WRITE\", \"LLDISK_LIST_PARTITIONS\", \"LLDISK_REMOVE\", \"LLDISK_IDB_READ\", \"LLDISK_IDB_WRITE\", \"LLDISK_IDB_REMOVE\", \"LLDISK_IDB_LIST\", \"LLDISK_IDB_SYNC\", \"FS_MOUNT\", \"SET_DEFAULT_SYSTEM\", \"GET_SYSTEM_RESOURCES\", \"LLDISK_INIT_PARTITIONS\", \"LOGOUT_OTHERS\", \"LULL_SYSTEM_FORCE\", \"CONNLESS_LISTEN_GLOBAL\", \"GET_USER_LIST\", \"CONNFUL_LISTEN_GLOBAL\", \"NETWORK_RAW_WRITE\", \"NETWORK_RAW_READ\", \"SET_FIRMWARE\", \"RELOAD_NETWORK_CONFIG\");\n\t\t\tif ((await modules.users.getUserInfo(user, token)).blankPrivileges) this._tokens[token].privileges = [];\n\t\t\tthis._tokens[token].privileges.push(...((await modules.users.getUserInfo(user, token)).additionalPrivilegeSet || []));\n\t\t\tthis._tokens[token].privileges = Array.from(new Set(this._tokens[token].privileges));\n\t\t},\n\t\thalfInitialize: async function(token, user) {\n\t\t\tthis._tokens[token].user = user;\n\t\t\tthis._tokens[token].groups = (await modules.users.getUserInfo(user, token)).groups || [];\n\t\t},\n\t\tinfo: async function(token) {\n\t\t\treturn this._tokens[token];\n\t\t},\n\t\tvalidate: async function(token, criteria) {\n\t\t\tif (!this._tokens.hasOwnProperty(token)) return false;\n\t\t\tif (criteria.user && this._tokens[token].user != criteria.user) return false;\n\t\t\tif (criteria.group && !this._tokens[token].groups.includes(criteria.group)) return false;\n\t\t\tif (criteria.privilege && !this._tokens[token].privileges.includes(criteria.privilege)) return false;\n\t\t\treturn true;\n\t\t},\n\t\tfork: async function(token) {\n\t\t\tlet rng = crypto.getRandomValues(new Uint8Array(64));\n\t\t\tlet newToken = Array.from(rng).map(x => x.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\tthis._tokens[newToken] = JSON.parse(JSON.stringify(this._tokens[token]));\n\t\t\treturn newToken;  \n\t\t},\n\t\t_tokens: {}\n\t}\n}\nsetupTokens();","2fe8d4742ded1950267d63529c0dd8f030083bccdb85bfecb161cb7a43886d696750c859c8ae16b8885fcf6fcb6bdffb7e269841e9f714b5e85c3000524b61b0":"async function setupUsers() {\n\t// @pcos-app-mode native\n\tasync function handleAuthentication(user, prompts, finishFunction) {\n\t\tlet currentPromptIndex = 0;\n\t\tlet destroyed = false;\n\n\t\treturn {\n\t\t\tgetNextPrompt: async function() {\n\t\t\t\tif (destroyed) return {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: modules.locales.get(\"AUTH_FAILED_NEW\")\n\t\t\t\t};\n\t\t\t\tif (currentPromptIndex >= prompts.length) {\n\t\t\t\t\tif (finishFunction) await finishFunction(true);\n\t\t\t\t\tlet token = await modules.tokens.generate();\n\t\t\t\t\tawait modules.tokens.userInitialize(token, user);\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: true,\n\t\t\t\t\t\tmessage: modules.locales.get(\"AUTH_SUCCESS\"),\n\t\t\t\t\t\ttoken: token\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tlet that = this;\n\t\t\t\tlet currentPrompt = prompts[currentPromptIndex];\n\t\t\t\tlet used = false;\n\t\t\t\t\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: \"intermediate\",\n\t\t\t\t\ttype: currentPrompt.type,\n\t\t\t\t\tmessage: currentPrompt.message,\n\t\t\t\t\twantsUserInput: currentPrompt.userInput,\n\t\t\t\t\tchallenge: currentPrompt.challenge,\n\t\t\t\t\tinput: async function(input) {\n\t\t\t\t\t\tif (used || destroyed) return that.getNextPrompt();\n\t\t\t\t\t\tif (!used) used = true;\n\t\t\t\t\t\tlet verified;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tverified = await currentPrompt.verify(input);\n\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\tverified = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!verified) {\n\t\t\t\t\t\t\tdestroyed = true;\n\t\t\t\t\t\t\tif (finishFunction) await finishFunction(false);\n\t\t\t\t\t\t\treturn { success: false, message: modules.locales.get(\"AUTH_FAILED\") };\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcurrentPromptIndex++;\n\t\t\t\t\t\treturn that.getNextPrompt();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\t}\n\n\tlet test = \"{}\";\n\ttry {\n\t\ttest = await modules.fs.read(modules.defaultSystem + \"/etc/security/users\");\n\t} catch {\n\t\tif (!modules.settingUp) test = \"systemStatusInvalid\";\n\t}\n\ttry {\n\t\tJSON.parse(test);\n\t} catch (e) {\n\t\tif (!modules.settingUp) await panic(\"USER_SYSTEM_CORRUPTED\", {\n\t\t\tname: \"/etc/security/users\",\n\t\t\tparams: [modules.defaultSystem],\n\t\t\tunderlyingJS: e\n\t\t})\n\t}\n\n\tmodules.users = {\n\t\tinit: async function(token) {\n\t\t\tawait this.mkrecursive(modules.defaultSystem + \"/etc/security\", token);\n\t\t\tawait modules.fs.chmod(modules.defaultSystem + \"/etc\", \"rx\", token);\n\t\t\tawait this.mkrecursive(modules.defaultSystem + \"/root\", token);\n\t\t\tawait modules.fs.write(modules.defaultSystem + \"/etc/security/users\", JSON.stringify({root: {\n\t\t\t\tsecurityChecks: [],\n\t\t\t\tgroups: [\"root\"],\n\t\t\t\thomeDirectory: modules.defaultSystem + \"/root\"\n\t\t\t},\n\t\t\tauthui: {\n\t\t\t\tsecurityChecks: [],\n\t\t\t\tgroups: [\"authui\"],\n\t\t\t\thomeDirectory: modules.defaultSystem,\n\t\t\t\tblankPrivileges: true,\n\t\t\t\tadditionalPrivilegeSet:  [ \"IPC_SEND_PIPE\", \"GET_LOCALE\", \"GET_THEME\", \"ELEVATE_PRIVILEGES\", \"FS_READ\", \"FS_LIST_PARTITIONS\", \"CSP_OPERATIONS\" ]\n\t\t\t}}), token);\n\t\t},\n\t\tmkrecursive: async function(dir, token) {\n\t\t\tlet slices = dir.split(\"/\");\n\t\t\tfor (let slice in slices) {\n\t\t\t\tlet previousParts = slices.slice(0, slice).join(\"/\");\n\t\t\t\tif (!previousParts) continue;\n\t\t\t\tlet currentPart = slices[slice];\n\t\t\t\tlet check = await modules.fs.ls(previousParts, token);\n\t\t\t\tpreviousParts += \"/\";\n\t\t\t\tif (!check.includes(currentPart)) await modules.fs.mkdir(previousParts + currentPart, token);\n\t\t\t}\n\t\t},\n\t\tmoduser: async function(user, data, token) {\n\t\t\tlet userDB = JSON.parse(await modules.fs.read(modules.defaultSystem + \"/etc/security/users\"), token);\n\t\t\tuserDB[user] = data;\n\t\t\tawait modules.fs.write(modules.defaultSystem + \"/etc/security/users\", JSON.stringify(userDB), token);\n\t\t},\n\t\tgetUserInfo: async function(user, sensitive = false, token) {\n\t\t\tlet userDB = JSON.parse(await modules.fs.read(modules.defaultSystem + \"/etc/security/users\"), token);\n\t\t\tif (!userDB.hasOwnProperty(user)) return null;\n\t\t\tuserDB = userDB[user];\n\t\t\tif (!sensitive) delete userDB.securityChecks;\n\t\t\treturn userDB;\n\t\t},\n\t\tconfigured: async function(token) {\n\t\t\ttry {\n\t\t\t\tJSON.parse(await modules.fs.read(modules.defaultSystem + \"/etc/security/users\"), token);\n\t\t\t\treturn true;\n\t\t\t} catch {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\taccess: async function(user, token) {\n\t\t\tlet userDB = JSON.parse(await modules.fs.read(modules.defaultSystem + \"/etc/security/users\"), token);\n\t\t\tlet credentials = userDB[user].securityChecks;\n\t\t\tfor (let check in credentials) {\n\t\t\t\tif (credentials[check].type == \"pbkdf2\") {\n\t\t\t\t\tcredentials[check].userInput = true;\n\t\t\t\t\tcredentials[check].type = \"password\";\n\t\t\t\t\tcredentials[check].message = modules.locales.get(\"PASSWORD_PROMPT\");\n\t\t\t\t\tcredentials[check].verify = async function(input) {\n\t\t\t\t\t\treturn (await modules.core.pbkdf2(input, credentials[check].salt)) == credentials[check].hash;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (credentials[check].type == \"informative\" || credentials[check].type == \"informative_deny\") {\n\t\t\t\t\tcredentials[check].verify = () => credentials[check].type == \"informative\";\n\t\t\t\t\tcredentials[check].type = \"informative\";\n\t\t\t\t\tcredentials[check].userInput = false;\n\t\t\t\t}\n\t\t\t\tif (credentials[check].type == \"timeout\" || credentials[check].type == \"timeout_deny\") {\n\t\t\t\t\tlet isTimeout = credentials[check].type == \"timeout\";\n\t\t\t\t\tcredentials[check].message = modules.locales.get(\"PLEASE_WAIT_TIME\").replace(\"%s\", modules.userfriendliness.inconsiderateTime(credentials[check].timeout));\n\t\t\t\t\tcredentials[check].verify = () => new Promise(resolve => setTimeout(resolve, credentials[check].timeout, isTimeout));\n\t\t\t\t\tcredentials[check].type = \"promise\";\n\t\t\t\t\tcredentials[check].userInput = false;\n\t\t\t\t}\n\t\t\t\tif (credentials[check].type == \"serverReport\") {\n\t\t\t\t\tcredentials[check].message = modules.locales.get(\"REPORTING_LOGON\");\n\t\t\t\t\tcredentials[check].type = \"promise\";\n\t\t\t\t\tcredentials[check].verify = async function() {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlet response = await fetch(credentials[check].url);\n\t\t\t\t\t\t\tif (!response.ok) return false;\n\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcredentials[check].userInput = false;\n\t\t\t\t}\n\t\t\t\tif (credentials[check].type == \"pc-totp\") {\n\t\t\t\t\tcredentials[check].message = modules.locales.get(\"TOTP_PC_PROMPT\");\n\t\t\t\t\tcredentials[check].type = \"text\";\n\t\t\t\t\tcredentials[check].userInput = true;\n\t\t\t\t\tcredentials[check].verify = async function(input) {\n\t\t\t\t\t\tlet sha256 = async b => Array.from(new Uint8Array(await crypto.subtle.digest(\"SHA-256\", new TextEncoder().encode(b)))).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\t\tlet c = Math.floor((Math.floor(Date.now() / 1000)) / 30);\n\t\t\t\t\t\tlet hash = await sha256(credentials[check].secret + c);\n\t\t\t\t\t\thash = parseInt(hash, 16);\n\t\t\t\t\t\thash = hash % 60466176;\n\t\t\t\t\t\thash = hash.toString();\n\t\t\t\t\t\thash = hash.split(\"\", 6);\n\t\t\t\t\t\thash = hash.join(\"\");\n\t\t\t\t\t\treturn hash == input;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (credentials[check].type == \"totp\") {\n\t\t\t\t\tcredentials[check].message = modules.locales.get(\"TOTP_PROMPT\");\n\t\t\t\t\tcredentials[check].type = \"text\";\n\t\t\t\t\tcredentials[check].userInput = true;\n\t\t\t\t\tlet hexToU8A = (hex) => Uint8Array.from(hex.match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\t\t\tlet keyImport = await crypto.subtle.importKey(\"raw\", hexToU8A(credentials[check].secret?.padStart(20, \"0\")), {\n\t\t\t\t\t\tname: \"HMAC\",\n\t\t\t\t\t\thash: \"SHA-1\"\n\t\t\t\t\t}, true, [ \"sign\" ]);\n\t\t\t\t\t\n\t\t\t\t\tcredentials[check].verify = async function(input) {\n\t\t\t\t\t\tlet counter = hexToU8A(Math.floor(Date.now() / 30000).toString(16).padStart(16, \"0\"));\n\t\t\t\t\t\tlet hmacSign = await crypto.subtle.sign(\"HMAC\", keyImport, counter);\n\t\t\t\t\t\thmacSign = Array.from(new Uint8Array(hmacSign));\n\t\t\t\t\t\tlet offset = hmacSign[19] & 0xf; // https://datatracker.ietf.org/doc/html/rfc4226#section-5.4\n\t\t\t\t\t\tlet code = (hmacSign[offset] & 0x7f) << 24\n\t\t\t\t\t\t\t| (hmacSign[offset + 1] & 0xff) << 16\n\t\t\t\t\t\t\t| (hmacSign[offset + 2] & 0xff) << 8\n\t\t\t\t\t\t\t| (hmacSign[offset + 3] & 0xff);\n\t\t\t\t\t\tcode = code % 1000000;\n\t\t\t\t\t\treturn (code.toString() == input) || (code.toString().padStart(6, \"0\") == input);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (credentials[check].type == \"workingHours\") {\n\t\t\t\t\tlet workingHourStarts = new Date();\n\t\t\t\t\tworkingHourStarts.setHours(credentials[check].start.hours || 0, credentials[check].start.minutes || 0, credentials[check].start.seconds || 0);\n\t\t\t\t\tlet workingHourEnds = new Date();\n\t\t\t\t\tworkingHourEnds.setHours(credentials[check].end.hours || 0, credentials[check].end.minutes || 0, credentials[check].end.seconds || 0);\n\t\t\t\t\t\n\t\t\t\t\tif (new Date() > workingHourEnds || new Date() < workingHourStarts) {\n\t\t\t\t\t\tcredentials[check].message = modules.locales.get(\"WORKING_HOURS_UNMET\");\n\t\t\t\t\t\tcredentials[check].type = \"informative\";\n\t\t\t\t\t\tcredentials[check].userInput = false;\n\t\t\t\t\t\tcredentials[check].verify = () => false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcredentials[check].message = modules.locales.get(\"AUTH_SUCCESS\");\n\t\t\t\t\t\tcredentials[check].type = \"promise\";\n\t\t\t\t\t\tcredentials[check].userInput = false;\n\t\t\t\t\t\tcredentials[check].verify = () => true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (credentials[check].type == \"zkpp\") {\n\t\t\t\t\tcredentials[check].message = modules.locales.get(\"MODULE_REQUIRED\").replace(\"%s\", \"tweetnacl\");\n\t\t\t\t\tcredentials[check].type = \"informative\";\n\t\t\t\t\tcredentials[check].userInput = false;\n\t\t\t\t\tcredentials[check].verify = () => false;\n\t\t\t\t\tif (window.nacl) {\n\t\t\t\t\t\tlet hexToU8A = (hex) => Uint8Array.from(hex.match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\t\t\t\tlet randomChallenge = crypto.getRandomValues(new Uint8Array(64)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\t\t\tcredentials[check].message = modules.locales.get(\"PASSWORD_PROMPT\");\n\t\t\t\t\t\tcredentials[check].type = \"zkpp_password\";\n\t\t\t\t\t\tcredentials[check].userInput = true;\n\t\t\t\t\t\tcredentials[check].challenge = randomChallenge;\n\t\t\t\t\t\tcredentials[check].verify = input => nacl.sign.detached.verify(hexToU8A(credentials[check].challenge), hexToU8A(input), hexToU8A(credentials[check].publicKey));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (credentials.length == 0) {\n\t\t\t\tcredentials.push({\n\t\t\t\t\ttype: \"informative\",\n\t\t\t\t\tmessage: modules.locales.get(\"ACCESS_NOT_SETUP\"),\n\t\t\t\t\tuserInput: false,\n\t\t\t\t\tverify: () => false\n\t\t\t\t})\n\t\t\t}\n\t\t\treturn handleAuthentication(user, credentials);\n\t\t},\n\t\tgetUsers: async function(token) {\n\t\t\tlet userDB = JSON.parse(await modules.fs.read(modules.defaultSystem + \"/etc/security/users\"), token);\n\t\t\treturn Object.keys(userDB);\n\t\t}\n\t}\n}\nawait setupUsers();","ca73ba57220615f4190eb5042942a2c48af87903f63f1e76b4d82bac729cdd99b6bb91da7628c7e1cf79f1ab4eddbbf2f9705ed49d37c357e465b6c8812685f4":"async function authui(ses = modules.session.active, user, token, isLogonScreen) {\n\t// @pcos-app-mode native\n\tif (modules.shuttingDown) return { hook: _ => _ };\n\tlet appToken;\n\tif (token) appToken = modules.tokens.fork(token);\n\telse {\n\t\tappToken = await modules.tokens.generate();\n\t\tawait modules.tokens.userInitialize(appToken, \"authui\");\n\t}\n\tlet hook = new Function();\n\tlet ipc = await modules.ipc.create();\n\tmodules.ipc.declareAccess(ipc, { owner: \"authui\", group: \"authui\", world: false });\n\tlet windowObject = modules.window(ses);\n\tif (isLogonScreen) windowObject.closeButton.classList.toggle(\"hidden\", true);\n\tlet authTask = await modules.tasks.exec(modules.defaultSystem + \"/apps/authui.js\", [], windowObject, appToken, false, [ ipc, user || \"\" ]);\n\tasync function waitForIt() {\n\t\tlet msg = await Promise.race([\n\t\t\tmodules.ipc.listenFor(ipc),\n\t\t\tmodules.tasks.waitTermination(authTask)\n\t\t]);\n\t\tdelete modules.ipc._ipc[ipc];\n\t\ttry {\n\t\t\tawait modules.tasks.sendSignal(authTask, 9);\n\t\t\thook(msg);\n\t\t} catch {\n\t\t\thook({\n\t\t\t\tsuccess: false,\n\t\t\t\tcancelled: true\n\t\t\t});\n\t\t}\n\t}\n\twaitForIt();\n\treturn { hook: (e) => hook = e };\n}\nmodules.authui = authui;","f80e1107bb5a8bc7ff136747ec3240225b104d3c46cdf4fd421df81c65bbc9fa5b94b526520d9eec7af35cb44cb71cfd053749250989083467d69aad4eb2198e":"async function consentui(ses = modules.session.active, config, token) {\n\t// @pcos-app-mode native\n\tif (modules.shuttingDown) return { hook: _ => _ };\n\tlet appToken;\n\tif (token) appToken = modules.tokens.fork(token);\n\telse {\n\t\tappToken = await modules.tokens.generate();\n\t\tawait modules.tokens.userInitialize(appToken, \"authui\");\n\t}\n\tlet hook = new Function();\n\tlet ipc = await modules.ipc.create();\n\tmodules.ipc.declareAccess(ipc, { owner: \"authui\", group: \"authui\", world: false });\n\tlet windowObject = modules.window(ses);\n\tlet authTask = await modules.tasks.exec(modules.defaultSystem + \"/apps/consentui.js\", [], windowObject, appToken, false, [\n\t\tipc,\n\t\tconfig.user || \"\",\n\t\tJSON.stringify({\n\t\t\tpath: config.path,\n\t\t\targs: config.args,\n\t\t\tsubmittedIntent: config.intent,\n\t\t\tsubmittedName: config.name\n\t\t})\n\t]);\n\tasync function waitForIt() {\n\t\tlet msg = await Promise.race([\n\t\t\tmodules.ipc.listenFor(ipc),\n\t\t\tmodules.tasks.waitTermination(authTask)\n\t\t]);\n\t\tdelete modules.ipc._ipc[ipc];\n\t\ttry {\n\t\t\tawait modules.tasks.sendSignal(authTask, 9);\n\t\t\thook(msg);\n\t\t} catch {\n\t\t\thook({\n\t\t\t\tsuccess: false,\n\t\t\t\tcancelled: true\n\t\t\t});\n\t\t}\n\t}\n\twaitForIt();\n\treturn { hook: (e) => hook = e };\n}\nmodules.consentui = consentui;","7656fa27f024558063e003ee097bc3a25148bbffec37eda16c08a9f04975d0ba07ed2322edba8792c52d6cc24bda6c65d450a5a31a369bcf5ec23d9152180819":"async function requireLogon() {\n\t// @pcos-app-mode native\n\ttry {\n\t\tlet startupSoundPerm = await modules.fs.permissions(modules.defaultSystem + \"/etc/sounds/startup.aud\");\n\t\tif (!startupSoundPerm.world.includes(\"r\")) throw new Error(\"Not allowed to read startup.aud\");\n\t\tlet startupSound = await modules.fs.read(modules.defaultSystem + \"/etc/sounds/startup.aud\");\n\t\tlet startupAudio = new Audio();\n\t\tstartupAudio.src = startupSound;\n\t\tstartupAudio.play();\n\t} catch (e) {\n\t\tconsole.error(\"Failed to play startup sound:\", e);\n\t}\n\tlet liu = {};\n\tmodules.liu = liu;\n\tserviceLogon();\n\tlet insertedLockMessage = false;\n\tasync function handleLogin(resolvedLogon, liu) {\n\t\tmodules.session.muteAllSessions();\n\t\tlet userInfo = await modules.tokens.info(resolvedLogon.token);\n\t\tlet session;\n\t\tlet liuUser = userInfo.user;\n\t\tlet wasLiuLoaded = false;\n\t\tif (liu.hasOwnProperty(userInfo.user)) {\n\t\t\tsession = liu[userInfo.user].session;\n\t\t\tawait modules.tokens.revoke(resolvedLogon.token);\n\t\t\tresolvedLogon = liu[userInfo.user].logon;\n\t\t\tuserInfo = await modules.tokens.info(resolvedLogon.token);\n\t\t\twasLiuLoaded = true;\n\t\t} else {\n\t\t\tsession = modules.session.mksession();\n\t\t\tliu[userInfo.user] = {\n\t\t\t\tsession,\n\t\t\t\tlogon: resolvedLogon,\n\t\t\t}\n\t\t}\n\t\tif (modules.session.attrib(session, \"secureID\")) return modules.session.activateSession(modules.session.attrib(session, \"secureID\"));\n\t\tmodules.session.activateSession(session);\n\t\tlet dom = modules.session.tracker[session].html;\n\t\tlet bgPic = \"\";\n\t\tlet isDark = false;\n\t\tlet locale;\n\t\tlet basicPrivilegeChecklist = [ \"FS_READ\", \"FS_LIST_PARTITIONS\", \"IPC_SEND_PIPE\", \"IPC_LISTEN_PIPE\", \"START_TASK\", \"GET_LOCALE\", \"GET_THEME\", \"LOGOUT\" ];\n\t\tif (!basicPrivilegeChecklist.every(privilege => userInfo.privileges.includes(privilege))) {\n\t\t\tlet failureMessage = modules.window(session);\n\t\t\tfailureMessage.title.innerText = \"Permission denied\";\n\t\t\tfailureMessage.content.style.padding = \"8px\";\n\t\t\tfailureMessage.content.innerText = \"There were not enough privileges to log you in. Please contact your system administrator.\";\n\t\t\tfailureMessage.closeButton.onclick = async function() {\n\t\t\t\tfailureMessage.windowDiv.remove();\n\t\t\t\tawait modules.logOut(userInfo.user);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tlet permissions = await modules.fs.permissions((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.wallpaper\", resolvedLogon.token);\n\t\t\tif (permissions.owner != userInfo.user && !userInfo.groups.includes(permissions.group) && !(permissions.world.includes(\"r\") && permissions.world.includes(\"x\")) && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\tthrow new Error(\"Permission denied reading wallpaper\");\n\t\t\t}\n\t\t\tbgPic = await modules.fs.read((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.wallpaper\", resolvedLogon.token);\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to read wallpaper:\", e);\n\t\t}\n\t\ttry {\n\t\t\tlet permissionsdm = await modules.fs.permissions((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.darkmode\", resolvedLogon.token);\n\t\t\tif (permissionsdm.owner != userInfo.user && !userInfo.groups.includes(permissionsdm.group) && !(permissionsdm.world.includes(\"r\") && permissionsdm.world.includes(\"x\")) && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\tthrow new Error(\"Permission denied reading dark mode preference\");\n\t\t\t}\n\t\t\tisDark = (await modules.fs.read((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.darkmode\", resolvedLogon.token)) == \"true\";\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to read dark mode preference:\", e);\n\t\t}\n\t\ttry {\n\t\t\tlet permissionsloc = await modules.fs.permissions((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.locale\", resolvedLogon.token);\n\t\t\tif (permissionsloc.owner != userInfo.user && !userInfo.groups.includes(permissionsloc.group) && !(permissionsloc.world.includes(\"r\") && permissionsloc.world.includes(\"x\")) && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\tthrow new Error(\"Permission denied reading locale preference\");\n\t\t\t}\n\t\t\tlocale = await modules.fs.read((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.locale\", resolvedLogon.token);\n\t\t\tmodules.session.attrib(session, \"language\", locale);\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to read dark mode preference:\", e);\n\t\t}\n\t\tif (modules.core.bootMode == \"safe\") {\n\t\t\tisDark = true;\n\t\t\tif (!wasLiuLoaded) {\n\t\t\t\tlet message = document.createElement(\"span\");\n\t\t\t\tmessage.innerText = modules.locales.get(\"SAFE_MODE_MSG\", locale);\n\t\t\t\tmessage.style = \"position: absolute; right: 8px; bottom: 8px; color: white;\";\n\t\t\t\tdom.appendChild(message);\n\t\t\t\tlet message2 = document.createElement(\"span\");\n\t\t\t\tmessage2.innerText = modules.locales.get(\"SAFE_MODE_MSG\", locale);\n\t\t\t\tmessage2.style = \"position: absolute; top: 8px; left: 8px; color: white;\";\n\t\t\t\tdom.appendChild(message2);\n\t\t\t}\n\t\t\tbgPic = \"\";\n\t\t}\n\t\tif (modules.core.bootMode == \"disable-harden\" && !wasLiuLoaded) {\n\t\t\tlet message = document.createElement(\"span\");\n\t\t\tmessage.innerText = modules.locales.get(\"INSECURE_MODE_MSG\", locale);\n\t\t\tmessage.style = \"position: absolute; right: 8px; bottom: 8px; color: white;\";\n\t\t\tdom.appendChild(message);\n\t\t\tlet message2 = document.createElement(\"span\");\n\t\t\tmessage2.innerText = modules.locales.get(\"INSECURE_MODE_MSG\", locale);\n\t\t\tmessage2.style = \"position: absolute; top: 8px; left: 8px; color: white;\";\n\t\t\tdom.appendChild(message2);\n\t\t}\n\t\tmodules.session.attrib(session, \"dark\", isDark);\n\t\tdom.style.background = \"url(\" + JSON.stringify(bgPic) + \")\";\n\t\tif (modules.core.bootMode == \"safe\") dom.style.background = \"black\";\n\t\tdom.style.backgroundSize = \"100% 100%\";\n\t\tif (!wasLiuLoaded) {\n\t\t\tlet autoRunNecessities = [];\n\t\t\ttry {\n\t\t\t\tlet autoRunPermissions = await modules.fs.permissions((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.autorunNecessity\", resolvedLogon.token);\n\t\t\t\tif (autoRunPermissions.owner != userInfo.user && !userInfo.groups.includes(autoRunPermissions.group) && !(autoRunPermissions.world.includes(\"r\") && autoRunPermissions.world.includes(\"x\")) && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\t\tthrow new Error(\"Permission denied reading autorun necessities\");\n\t\t\t\t}\n\t\t\t\tif (modules.core.bootMode != \"safe\") autoRunNecessities = await modules.fs.ls((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.autorunNecessity\", resolvedLogon.token);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(\"Failed to read autorun necessities:\", e);\n\t\t\t}\n\t\t\tfunction breakNecessityFailure() {\n\t\t\t\tlet failureMessage = modules.window(session);\n\t\t\t\tfailureMessage.title.innerText = modules.locales.get(\"PERMISSION_DENIED\", locale);\n\t\t\t\tfailureMessage.content.style.padding = \"8px\";\n\t\t\t\tfailureMessage.content.innerText = modules.locales.get(\"AUTORUN_NECESSITIES_FAILED\", locale);\n\t\t\t\tfailureMessage.closeButton.onclick = async function() {\n\t\t\t\t\tfailureMessage.windowDiv.remove();\n\t\t\t\t\tawait modules.logOut(userInfo.user);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let autoRunNecessity of autoRunNecessities) {\n\t\t\t\tlet necessityPermissions = await modules.fs.permissions((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.autorunNecessity/\" + autoRunNecessity, resolvedLogon.token);\n\t\t\t\tif (necessityPermissions.owner != userInfo.user && !userInfo.groups.includes(necessityPermissions.group) && !(necessityPermissions.world.includes(\"r\") && necessityPermissions.world.includes(\"x\")) && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\t\treturn breakNecessityFailure();\n\t\t\t\t}\n\t\t\t\tlet link = await modules.fs.read((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.autorunNecessity/\" + autoRunNecessity, resolvedLogon.token);\n\t\t\t\ttry {\n\t\t\t\t\tlink = JSON.parse(link);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(\"Failed to parse autorun necessity:\", e);\n\t\t\t\t\treturn breakNecessityFailure();\n\t\t\t\t}\n\t\t\t\tif (link.disabled) continue;\n\t\t\t\ttry {\n\t\t\t\t\tlet ipcPipe = modules.ipc.create();\n\t\t\t\t\tmodules.ipc.declareAccess(ipcPipe, {\n\t\t\t\t\t\towner: userInfo.user,\n\t\t\t\t\t\tgroup: userInfo.groups[0],\n\t\t\t\t\t\tworld: false\n\t\t\t\t\t});\n\t\t\t\t\tlet forkedToken;\n\t\t\t\t\tif (link.automaticLogon) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlet logon = await modules.users.access(link.automaticLogon.username, resolvedLogon.token);\n\t\t\t\t\t\t\tlogon = await logon.getNextPrompt();\n\t\t\t\t\t\t\tfor (let response of link.automaticLogon.responses)\n\t\t\t\t\t\t\t\tif (logon.success == \"intermediate\") logon = await logon.input(response);\n\t\t\t\t\t\t\tif (!logon.success) throw new Error(logon.message);\n\t\t\t\t\t\t\tforkedToken = logon.token;\n\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\tif (necessityPermissions.world.includes(\"r\") && forkedToken) {\n\t\t\t\t\t\t\tlet ownUser = await modules.tokens.info(forkedToken);\n\t\t\t\t\t\t\tlet ownUserInfo = await modules.users.getUserInfo(ownUser.user, true, forkedToken);\n\t\t\t\t\t\t\townUserInfo.securityChecks = [];\n\t\t\t\t\t\t\tawait modules.users.moduser(ownUser.user, ownUserInfo, forkedToken);\n\t\t\t\t\t\t\tawait modules.tokens.revoke(forkedToken);\n\t\t\t\t\t\t\tforkedToken = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!forkedToken) forkedToken = await modules.tokens.fork(resolvedLogon.token);\n\t\t\t\t\tlet appWindow = modules.window(session);\n\t\t\t\t\tlet ipcResult = modules.ipc.listenFor(ipcPipe);\n\t\t\t\t\tlet taskId = await modules.tasks.exec(link.path, [ ...(link.args || []), ipcPipe ], appWindow, forkedToken, true);\n\t\t\t\t\tlet finishTaskPromise = new Promise(function(resolve) {\n\t\t\t\t\t\tmodules.tasks.tracker[taskId].ree.beforeCloseDown(() => resolve());\n\t\t\t\t\t})\n\t\t\t\t\tipcResult = await Promise.race([ipcResult, finishTaskPromise]);\n\t\t\t\t\tif (!ipcResult) throw new Error(\"Software rejected autorun necessity.\");\n\t\t\t\t\tif (modules.tasks.tracker.hasOwnProperty(taskId)) await modules.tasks.sendSignal(taskId, 9);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(\"Failed to execute autorun necessity:\", e);\n\t\t\t\t\treturn breakNecessityFailure();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlet autoRun = [];\n\t\t\ttry {\n\t\t\t\tlet autoRunPermissions = await modules.fs.permissions((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.autorun\", resolvedLogon.token);\n\t\t\t\tif (autoRunPermissions.owner != userInfo.user && !userInfo.groups.includes(autoRunPermissions.group) && !(autoRunPermissions.world.includes(\"r\") && autoRunPermissions.world.includes(\"x\")) && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\t\tthrow new Error(\"Permission denied reading autorun\");\n\t\t\t\t}\n\t\t\t\tif (modules.core.bootMode != \"safe\") autoRun = await modules.fs.ls((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.autorun\", resolvedLogon.token);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(\"Failed to read autorun:\", e);\n\t\t\t}\n\t\t\tfor (let autoRunFile of autoRun) {\n\t\t\t\tlet autoRunItemPermissions = await modules.fs.permissions((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.autorun/\" + autoRunFile, resolvedLogon.token);\n\t\t\t\tif (autoRunItemPermissions.owner != userInfo.user && !userInfo.groups.includes(autoRunItemPermissions.group) && !(autoRunItemPermissions.world.includes(\"r\") && autoRunItemPermissions.world.includes(\"x\")) && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) continue;\n\t\t\t\tlet link = await modules.fs.read((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.autorun/\" + autoRunFile, resolvedLogon.token);\n\t\t\t\ttry {\n\t\t\t\t\tlink = JSON.parse(link);\n\t\t\t\t} catch {}\n\t\t\t\tif (link.disabled) continue;\n\t\t\t\ttry {\n\t\t\t\t\tlet forkedToken;\n\t\t\t\t\tif (link.automaticLogon) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlet logon = await modules.users.access(link.automaticLogon.username, resolvedLogon.token);\n\t\t\t\t\t\t\tlogon = await logon.getNextPrompt();\n\t\t\t\t\t\t\tfor (let response of link.automaticLogon.responses)\n\t\t\t\t\t\t\t\tif (logon.success == \"intermediate\") logon = await logon.input(response);\n\t\t\t\t\t\t\tif (!logon.success) throw new Error(logon.message);\n\t\t\t\t\t\t\tforkedToken = logon.token;\n\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\tif (autoRunItemPermissions.world.includes(\"r\") && forkedToken) {\n\t\t\t\t\t\t\tlet ownUser = await modules.tokens.info(forkedToken);\n\t\t\t\t\t\t\tlet ownUserInfo = await modules.users.getUserInfo(ownUser.user, true, forkedToken);\n\t\t\t\t\t\t\townUserInfo.securityChecks = [];\n\t\t\t\t\t\t\tawait modules.users.moduser(ownUser.user, ownUserInfo, forkedToken);\n\t\t\t\t\t\t\tawait modules.tokens.revoke(forkedToken);\n\t\t\t\t\t\t\tforkedToken = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!forkedToken) forkedToken = await modules.tokens.fork(resolvedLogon.token);\n\t\t\t\t\tlet appWindow = modules.window(session);\n\t\t\t\t\tawait modules.tasks.exec(link.path, [ ...(link.args || []) ], appWindow, forkedToken);\n\t\t\t\t} catch {}\n\t\t\t}\n\n\t\t\tlet icons = [];\n\t\t\tlet lastIconPlacement = [ 72, 72 ];\n\t\t\ttry {\n\t\t\t\tlet permissions = await modules.fs.permissions((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/desktop\", resolvedLogon.token);\n\t\t\t\tif (permissions.owner != userInfo.user && !userInfo.groups.includes(permissions.group) && !(permissions.world.includes(\"r\") && permissions.world.includes(\"x\")) && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\t\tthrow new Error(\"Permission denied reading desktop icons\");\n\t\t\t\t}\n\t\t\t\ticons = await modules.fs.ls((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/desktop\", resolvedLogon.token);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(\"Failed to read desktop icons:\", e);\n\t\t\t}\n\t\t\tfor (let icon of icons) {\n\t\t\t\tif (icon.split(\"/\").slice(-1)[0].startsWith(\".\")) continue;\n\t\t\t\ttry {\n\t\t\t\t\tlet iconPath = (await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/desktop/\" + icon;\n\t\t\t\t\tlet permissions = await modules.fs.permissions(iconPath, resolvedLogon.token);\n\t\t\t\t\tif (permissions.owner != userInfo.user && !userInfo.groups.includes(permissions.group) && !permissions.world.includes(\"r\") && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\t\t\tthrow new Error(\"Permission denied reading desktop icon\");\n\t\t\t\t\t}\n\t\t\t\t\tlet isDir = await modules.fs.isDirectory(iconPath, resolvedLogon.token);\n\t\t\t\t\tlet linkName = iconPath.split(\"/\").slice(-1)[0];\n\t\t\t\t\tlet appLink = { path: modules.defaultSystem + \"/apps/explorer.js\", args: [ iconPath ], name: linkName, placed: lastIconPlacement, icon: modules.defaultSystem + \"/etc/icons/fileicon.pic\" };\n\t\t\t\t\tif (!isDir) {\n\t\t\t\t\t\tif (linkName.endsWith(\".lnk\")) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tappLink = { placed: lastIconPlacement, icon: modules.defaultSystem + \"/etc/icons/lnk.pic\", ...(JSON.parse(await modules.fs.read(iconPath, resolvedLogon.token))) };\n\t\t\t\t\t\t\t\tappLink._isRealLink = true;\n\t\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet ext = linkName.split(\".\").slice(-1)[0];\n\t\t\t\t\t\t\tappLink.icon = modules.defaultSystem + \"/etc/icons/\" + ext + \".pic\";\n\t\t\t\t\t\t\tlet assocsPermissions = await modules.fs.permissions(modules.defaultSystem + \"/apps/associations\", resolvedLogon.token);\n\t\t\t\t\t\t\tif (assocsPermissions.owner != userInfo.user && !userInfo.groups.includes(assocsPermissions.group) && !(assocsPermissions.world.includes(\"r\") && assocsPermissions.world.includes(\"x\")) && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\t\t\t\t\tthrow new Error(\"Permission denied reading associations\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet associations = await modules.fs.ls(modules.defaultSystem + \"/apps/associations\", resolvedLogon.token);\n\t\t\t\t\t\t\tif (!associations.includes(ext)) appLink.disabled = true;\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tlet associationPermissions = await modules.fs.permissions(modules.defaultSystem + \"/apps/associations/\" + ext, resolvedLogon.token);\n\t\t\t\t\t\t\t\tif (!associationPermissions.world.includes(\"r\") && !userInfo.groups.includes(associationPermissions.group) && associationPermissions.owner != userInfo.user && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\t\t\t\t\t\tthrow new Error(\"Permission denied reading association\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tappLink = { placed: lastIconPlacement, icon: appLink.icon, ...(JSON.parse(await modules.fs.read(modules.defaultSystem + \"/apps/associations/\" + ext, resolvedLogon.token))) };\n\t\t\t\t\t\t\t\tappLink.args = [ ...(appLink.args || []), iconPath ];\n\t\t\t\t\t\t\t\tappLink.name = linkName;\n\t\t\t\t\t\t\t\tdelete appLink.localeDatabaseName;\n\t\t\t\t\t\t\t\tdelete appLink.localeReferenceName;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (appLink.disabled) continue;\n\t\t\t\t\tif (isDir) appLink.icon = modules.defaultSystem + \"/etc/icons/foldericon.pic\";\n\t\t\t\t\tlet iconWindow = modules.window(session, false, true, async function(newx, newy) {\n\t\t\t\t\t\tif (appLink._isRealLink) {\n\t\t\t\t\t\t\tappLink.placed = [ newx, newy ];\n\t\t\t\t\t\t\tdelete appLink._isRealLink;\n\t\t\t\t\t\t\tif (permissions.owner != userInfo.user && !userInfo.groups.includes(permissions.group) && !permissions.world.includes(\"w\") && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\t\t\t\t\tthrow new Error(\"Permission denied writing desktop icon\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tawait modules.fs.write(iconPath, JSON.stringify(appLink), resolvedLogon.token);\n\t\t\t\t\t\t\tappLink._isRealLink = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\ticonWindow.title.innerText = (appLink.localeReferenceName ? modules.locales.get(appLink.localeReferenceName, locale) : null) || (appLink.localeDatabaseName ? (appLink.localeDatabaseName[locale] || appLink.localeDatabaseName[modules.locales.defaultLocale] || appLink.localeDatabaseName[navigator.language.slice(0, 2).toLowerCase()]) : null) || appLink.name;\n\t\t\t\t\tlet iconEl = document.createElement(\"img\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet permissions = await modules.fs.permissions(appLink.icon, resolvedLogon.token);\n\t\t\t\t\t\tif (permissions.owner != userInfo.user && !userInfo.groups.includes(permissions.group) && !permissions.world.includes(\"r\") && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\t\t\t\tthrow new Error(\"Permission denied reading desktop icon picture\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\ticonEl.src = await modules.fs.read(appLink.icon, resolvedLogon.token);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tconsole.error(\"Failed to read desktop icon picture:\", e);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\ticonEl.style = \"width: 100%; height: 100%; position: absolute;\";\n\t\t\t\t\ticonWindow.content.appendChild(iconEl);\n\t\t\t\t\ticonWindow.windowDiv.style.top = appLink.placed[1] + \"px\";\n\t\t\t\t\ticonWindow.windowDiv.style.left = appLink.placed[0] + \"px\";\n\t\t\t\t\ticonEl.addEventListener(\"click\", async function() {\n\t\t\t\t\t\tlet forkedToken;\n\t\t\t\t\t\tif (appLink.automaticLogon) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlet logon = await modules.users.access(appLink.automaticLogon.username, resolvedLogon.token);\n\t\t\t\t\t\t\t\tlogon = await logon.getNextPrompt();\n\t\t\t\t\t\t\t\tfor (let response of appLink.automaticLogon.responses)\n\t\t\t\t\t\t\t\t\tif (logon.success == \"intermediate\") logon = await logon.input(response);\n\t\t\t\t\t\t\t\tif (!logon.success) throw new Error(logon.message);\n\t\t\t\t\t\t\t\tforkedToken = logon.token;\n\t\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!forkedToken) forkedToken = await modules.tokens.fork(resolvedLogon.token);\n\t\t\t\t\t\tlet appWindow = modules.window(session);\n\t\t\t\t\t\tawait modules.tasks.exec(appLink.path, [ ...(appLink.args || []) ], appWindow, forkedToken);\n\t\t\t\t\t});\n\t\t\t\t\tlastIconPlacement = appLink.placed;\n\t\t\t\t\tlastIconPlacement[1] += 136;\n\t\t\t\t\tif (lastIconPlacement[1] > (dom.clientHeight - 136)) {\n\t\t\t\t\t\tlastIconPlacement[0] += 136;\n\t\t\t\t\t\tlastIconPlacement[1] = 72;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(\"Failed to read desktop icon:\", e);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet startMenuChannel = modules.ipc.create();\n\t\t\tmodules.ipc.declareAccess(startMenuChannel, {\n\t\t\t\towner: userInfo.user,\n\t\t\t\tgroup: userInfo.groups[0],\n\t\t\t\tworld: false\n\t\t\t});\n\t\t\tlet taskbar = document.createElement(\"div\");\n\t\t\tlet clock = document.createElement(\"span\");\n\t\t\tlet startButton = document.createElement(\"button\");\n\t\t\tlet startMenu = modules.window(session);\n\t\t\tlet forkedStartMenuToken = await modules.tokens.fork(resolvedLogon.token);\n\n\t\t\tfunction startMenuStub() {\n\t\t\t\tif (startMenu.windowDiv.parentElement == null) startMenu = modules.window(session);\n\t\t\t\tstartMenu.windowDiv.classList.toggle(\"hidden\", true);\n\t\t\t\tstartMenu.title.innerText = modules.locales.get(\"START_MENU\", locale);\n\t\t\t\tstartMenu.content.style.padding = \"8px\";\n\t\t\t\tstartMenu.content.innerText = \"\";\n\t\t\t\tlet description = document.createElement(\"span\");\n\t\t\t\tlet logout = document.createElement(\"button\");\n\t\t\t\tdescription.innerText = modules.locales.get(\"START_MENU_FAILED\", locale);\n\t\t\t\tlogout.innerText = modules.locales.get(\"LOG_OUT_BUTTON\", locale).replace(\"%s\", userInfo.user);\n\t\t\t\tlogout.onclick = _ => modules.logOut(userInfo.user);\n\t\t\t\tstartMenu.content.appendChild(description);\n\t\t\t\tstartMenu.content.appendChild(document.createElement(\"br\"));\n\t\t\t\tstartMenu.content.appendChild(logout);\n\t\t\t\tstartMenu.closeButton.onclick = () => startMenu.windowDiv.classList.toggle(\"hidden\", true);\n\t\t\t\tstartButton.onclick = _ => startMenu.windowDiv.classList.toggle(\"hidden\");\n\t\t\t}\n\n\t\t\tstartMenuStub();\n\t\t\tstartButton.innerText = modules.locales.get(\"START_MENU_BTN\", locale);\n\t\t\tstartButton.style = \"padding: 4px;\";\n\t\t\ttry {\n\t\t\t\tawait modules.tasks.exec(modules.defaultSystem + \"/apps/startMenu.js\", [], startMenu, forkedStartMenuToken, true, startMenuChannel);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(\"Failed to start start menu:\", e);\n\t\t\t\tstartMenuStub();\n\t\t\t}\n\n\t\t\t(async function() {\n\t\t\t\twhile (true) {\n\t\t\t\t\tlet listen = await modules.ipc.listenFor(startMenuChannel);\n\t\t\t\t\tif (listen.run) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlet forkedToken;\n\t\t\t\t\t\t\tif (listen.run.automaticLogon) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tlet logon = await modules.users.access(listen.run.automaticLogon.username, resolvedLogon.token);\n\t\t\t\t\t\t\t\t\tlogon = await logon.getNextPrompt();\n\t\t\t\t\t\t\t\t\tfor (let response of listen.run.automaticLogon.responses)\n\t\t\t\t\t\t\t\t\t\tif (logon.success == \"intermediate\") logon = await logon.input(response);\n\t\t\t\t\t\t\t\t\tif (!logon.success) throw new Error(logon.message);\n\t\t\t\t\t\t\t\t\tforkedToken = logon.token;\n\t\t\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!forkedToken) forkedToken = await modules.tokens.fork(resolvedLogon.token);\n\t\t\t\t\t\t\tlet appWindow = modules.window(session);\n\t\t\t\t\t\t\tawait modules.tasks.exec(listen.run.path, [ ...(listen.run.args || []) ], appWindow, forkedToken);\n\t\t\t\t\t\t} catch {}\n\t\t\t\t\t} else if (listen.success) {\n\t\t\t\t\t\tstartButton.onclick = () => modules.ipc.send(startMenuChannel, { open: true });\n\t\t\t\t\t} else if (listen.dying) {\n\t\t\t\t\t\tstartMenu = modules.window(session);\n\t\t\t\t\t\tstartMenuStub();\n\t\t\t\t\t\tforkedStartMenuToken = await modules.tokens.fork(resolvedLogon.token);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait modules.tasks.exec(modules.defaultSystem + \"/apps/startMenu.js\", [], startMenu, forkedStartMenuToken, true, startMenuChannel);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tconsole.error(\"Failed to start start menu:\", e);\n\t\t\t\t\t\t\tstartMenuStub();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})();\n\n\t\t\ttaskbar.className = \"taskbar\";\n\t\t\tclock.className = \"clock\";\n\t\t\tlet filler = document.createElement(\"div\");\n\t\t\tfiller.className = \"filler\";\n\t\t\tlet battery = document.createElement(\"div\");\n\t\t\tlet networkIcon = document.createElement(\"div\");\n\t\t\tlet pcosNetworkIcon = document.createElement(\"div\");\n\t\t\tlet iconCache = {};\n\t\t\tfor (let iconFile of [\"network_\", \"network_offline_\", \"pcos_network_\", \"pcos_network_offline_\", \"readyToPlay_\", \"batteryChargeFinished_\", \"dying_\", \"charging_\"]) {\n\t\t\t\ttry {\n\t\t\t\t\tlet permissions = await modules.fs.permissions(modules.defaultSystem + \"/etc/icons/\" + iconFile + \"icon.pic\", resolvedLogon.token);\n\t\t\t\t\tif (permissions.owner != userInfo.user && !userInfo.groups.includes(permissions.group) && !permissions.world.includes(\"r\") && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\t\t\tthrow new Error(\"Permission denied reading taskbar icon picture\");\n\t\t\t\t\t}\n\t\t\t\t\ticonCache[iconFile] = await modules.fs.read(modules.defaultSystem + \"/etc/icons/\" + iconFile + \"icon.pic\", resolvedLogon.token);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(\"Failed to read taskbar icon picture:\", e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet toggle = false;\n\t\t\tclock.addEventListener(\"click\", _ => toggle = !toggle);\n\t\t\tliu[liuUser].clockInterval = setInterval(async function() {\n\t\t\t\tclock.innerText = Intl.DateTimeFormat(locale, { timeStyle: toggle ? undefined : \"medium\" }).format()\n\t\t\t\tnetworkIcon.style.backgroundImage = \"url(\" + JSON.stringify(navigator.onLine ? iconCache.network_ : iconCache.network_offline_) + \")\";\n\t\t\t\tnetworkIcon.title = modules.locales.get(\"NETWORK_STATUS_\" + (navigator.onLine ? \"ONLINE\" : \"OFFLINE\"), locale)\n\t\t\t\tpcosNetworkIcon.style.backgroundImage = \"url(\" + JSON.stringify(modules.network.connected ? iconCache.pcos_network_ : iconCache.pcos_network_offline_) + \")\";\n\t\t\t\tpcosNetworkIcon.title = modules.locales.get(\"PCOS_NETWORK_STATUS_\" + (modules.network.connected ? \"ONLINE\" : \"OFFLINE\"), locale).replace(\"%s\", userInfo.privileges.includes(\"GET_HOSTNAME\") ? (modules.network.hostname || modules.locales.get(\"UNKNOWN_PLACEHOLDER\", locale)) : modules.locales.get(\"UNKNOWN_PLACEHOLDER\", locale)).replace(\"%s\", userInfo.privileges.includes(\"GET_NETWORK_ADDRESS\") ? (modules.network.address || \"0\").match(/.{1,4}/g).join(\":\") : modules.locales.get(\"UNKNOWN_PLACEHOLDER\", locale));\n\t\t\t\tif (modules.network.serviceStopped) pcosNetworkIcon.title = modules.locales.get(\"PCOS_NETWORK_STATUS_STOPPED\", locale);\n\t\t\t\tlet batteryStatus = {charging: true, chargingTime: 0, dischargingTime: 0, level: 1};\n\t\t\t\tlet batteryStatusIcon = iconCache.readyToPlay_;\n\t\t\t\tlet batteryStatusDescription = modules.locales.get(\"BATTERY_STATUS_UNAVAILABLE\", locale);\n\t\t\t\tif (navigator.getBattery && userInfo.privileges.includes(\"GET_BATTERY_STATUS\")) {\n\t\t\t\t\tbatteryStatus = await navigator.getBattery();\n\t\t\t\t\tbatteryStatusDescription = modules.locales.get(\"BATTERY_STATUS_\" + (batteryStatus.charging ? \"CHARGING\" : \"DISCHARGING\"), locale)\n\t\t\t\t\t\t.replace(\"%s\", (batteryStatus.level * 100).toFixed(2))\n\t\t\t\t\t\t.replace(\"%s\", modules.userfriendliness.inconsiderateTime(\n\t\t\t\t\t\t\t(batteryStatus.charging ? batteryStatus.chargingTime : batteryStatus.dischargingTime) * 1000\n\t\t\t\t\t\t));\n\t\t\t\t\tif (batteryStatus.level < 0.2) batteryStatusIcon = iconCache.dying_;\n\t\t\t\t\tif (batteryStatus.charging) batteryStatusIcon = batteryStatus.level == 1 ? iconCache.batteryChargeFinished_ : iconCache.charging_;\n\t\t\t\t}\n\t\t\t\tbattery.style.backgroundImage = \"url(\" + JSON.stringify(batteryStatusIcon) + \")\";\n\t\t\t\tbattery.title = batteryStatusDescription;\n\t\t\t}, 500);\n\t\t\t\n\t\t\tbattery.className = \"icon\";\n\t\t\tnetworkIcon.className = \"icon\";\n\t\t\tpcosNetworkIcon.className = \"icon\";\n\t\t\ttaskbar.appendChild(startButton);\n\t\t\ttaskbar.appendChild(filler);\n\t\t\ttaskbar.appendChild(battery);\n\t\t\ttaskbar.appendChild(networkIcon);\n\t\t\ttaskbar.appendChild(pcosNetworkIcon);\n\t\t\ttaskbar.appendChild(clock);\n\t\t\tdom.appendChild(taskbar);\n\t\t}\n\t}\n\twhile (!modules.shuttingDown) {\n\t\tlet useDefaultUser = await modules.fs.permissions(modules.defaultSystem + \"/etc/security/automaticLogon\");\n\t\tuseDefaultUser = !useDefaultUser.world.includes(\"w\");\n\t\tlet defaultUser;\n\t\ttry {\n\t\t\tif (useDefaultUser) defaultUser = await modules.fs.read(modules.defaultSystem + \"/etc/security/automaticLogon\");\n\t\t} catch {}\n\t\tlet sysDom = modules.session.tracker[modules.session.systemSession].html;\n\t\tlet lockWallpaper = \"\";\n\t\tlet lockIsDark = false;\n\t\ttry {\n\t\t\tlockWallpaper = await modules.fs.read(modules.defaultSystem + \"/etc/wallpapers/lockscreen.pic\");\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to read lockscreen.pic:\", e);\n\t\t}\n\t\ttry {\n\t\t\tlockIsDark = (await modules.fs.read(modules.defaultSystem + \"/etc/darkLockScreen\")) == \"true\";\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to read darkLockScreen:\", e);\n\t\t}\n\t\tif (modules.core.bootMode == \"safe\") {\n\t\t\tlockIsDark = true;\n\t\t\tlockWallpaper = \"\";\n\t\t\tif (!insertedLockMessage) {\n\t\t\t\tinsertedLockMessage = true;\n\t\t\t\tlet message = document.createElement(\"span\");\n\t\t\t\tmessage.innerText = modules.locales.get(\"SAFE_MODE_MSG\");\n\t\t\t\tmessage.style = \"position: absolute; right: 8px; bottom: 8px; color: white;\";\n\t\t\t\tsysDom.appendChild(message);\n\t\t\t\tlet message2 = document.createElement(\"span\");\n\t\t\t\tmessage2.innerText = modules.locales.get(\"SAFE_MODE_MSG\");\n\t\t\t\tmessage2.style = \"position: absolute; top: 8px; left: 8px; color: white;\";\n\t\t\t\tsysDom.appendChild(message2);\n\t\t\t}\n\t\t}\n\t\tif (modules.core.bootMode == \"disable-harden\" && !insertedLockMessage) {\n\t\t\tinsertedLockMessage = true;\n\t\t\tlet message = document.createElement(\"span\");\n\t\t\tmessage.innerText = modules.locales.get(\"INSECURE_MODE_MSG\");\n\t\t\tmessage.style = \"position: absolute; right: 8px; bottom: 8px; color: white;\";\n\t\t\tsysDom.appendChild(message);\n\t\t\tlet message2 = document.createElement(\"span\");\n\t\t\tmessage2.innerText = modules.locales.get(\"INSECURE_MODE_MSG\");\n\t\t\tmessage2.style = \"position: absolute; top: 8px; left: 8px; color: white;\";\n\t\t\tsysDom.appendChild(message2);\n\t\t}\n\t\tsysDom.style.background = \"url(\" + JSON.stringify(lockWallpaper) + \")\";\n\t\tif (modules.core.bootMode == \"safe\") sysDom.style.background = \"black\";\n\t\tsysDom.style.backgroundSize = \"100% 100%\";\n\t\tmodules.session.attrib(modules.session.systemSession, \"dark\", lockIsDark);\n\t\tlet logon, resolvedLogon;\n\t\twhile (!modules.shuttingDown) {\n\t\t\tlogon = await modules.authui(modules.session.systemSession, defaultUser, undefined, true);\n\t\t\tresolvedLogon = await waitForLogon(logon);\n\t\t\tif (resolvedLogon.success) break;\n\t\t}\n\t\tif (!resolvedLogon.success) break;\n\t\thandleLogin(resolvedLogon, liu);\n\t\tif (useDefaultUser && defaultUser) {\n\t\t\tlet newWindow = modules.window(modules.session.systemSession);\n\t\t\tnewWindow.title.innerText = modules.locales.get(\"LOG_IN_INVITATION\");\n\t\t\tlet button = document.createElement(\"button\");\n\t\t\tbutton.innerText = modules.locales.get(\"LOG_IN_INVITATION\");\n\t\t\tnewWindow.content.appendChild(button);\n\t\t\tnewWindow.closeButton.classList.toggle(\"hidden\", true);\n\t\t\tawait hookButtonClick(button);\n\t\t\tnewWindow.windowDiv.remove();\n\t\t}\n\t}\n}\n\nasync function serviceLogon() {\n\tlet session = modules.session.mksession();\n\tmodules.session.attrib(session, \"dark\", true);\n\tlet dom = modules.session.tracker[session].html;\n\tdom.style.backgroundColor = \"black\";\n\tlet message = document.createElement(\"span\");\n\tmessage.innerText = \"Service Desktop\";\n\tmessage.style = \"position: absolute; right: 8px; bottom: 8px; color: white;\";\n\tdom.appendChild(message);\n\tlet startButton = document.createElement(\"button\");\n\tstartButton.innerText = modules.locales.get(\"START_MENU_BTN\");\n\tstartButton.style = \"padding: 4px;\";\n\tstartButton.onclick = async function() {\n\t\tlet startMenu = modules.window(session);\n\t\tstartMenu.title.innerText = modules.locales.get(\"START_MENU\");\n\t\tstartMenu.content.style.padding = \"8px\";\n\t\tstartMenu.closeButton.onclick = () => startMenu.windowDiv.remove();\n\t\tlet lockButton = document.createElement(\"button\");\n\t\tlockButton.innerText = modules.locales.get(\"LOCK_BUTTON\");\n\t\tstartMenu.content.appendChild(lockButton);\n\t\tlockButton.onclick = async function() {\n\t\t\tstartMenu.windowDiv.remove();\n\t\t\tawait modules.session.muteAllSessions();\n\t\t\tawait modules.session.activateSession(modules.session.systemSession);\n\t\t}\n\t}\n\tlet taskbar = document.createElement(\"div\");\n\ttaskbar.className = \"taskbar\";\n\n\ttaskbar.appendChild(startButton);\n\tdom.appendChild(taskbar);\n\tmodules.serviceSession = session;\n\tif (modules.core.bootMode != \"safe\") {\n\t\tlet serviceList = [];\n\t\ttry {\n\t\t\tserviceList = await modules.fs.ls(modules.defaultSystem + \"/apps/services\");\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to list services:\", e);\n\t\t}\n\t\tfor (let service of serviceList) {\n\t\t\tlet serviceConfig;\n\t\t\tlet triggerPasswordReset = false;\n\t\t\ttry {\n\t\t\t\tlet permissions = await modules.fs.permissions(modules.defaultSystem + \"/apps/services/\" + service);\n\t\t\t\tif (permissions.world.includes(\"r\")) triggerPasswordReset = true;\n\t\t\t} catch {}\n\t\t\ttry {\n\t\t\t\tserviceConfig = await modules.fs.read(modules.defaultSystem + \"/apps/services/\" + service);\n\t\t\t\tserviceConfig = JSON.parse(serviceConfig);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(\"Failed to read service config of\", service, \":\", e);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (serviceConfig.disabled) continue;p\n\t\t\tlet serviceName = (serviceConfig.localeReferenceName ? modules.locales.get(serviceConfig.localeReferenceName) : null) || (serviceConfig.localeDatabaseName ? (serviceConfig.localeDatabaseName[navigator.language.slice(0, 2).toLowerCase()] || serviceConfig.localeDatabaseName[modules.locales.defaultLocale]) : null) || serviceConfig.name;\n\t\t\tif (!serviceConfig.automaticLogon) {\n\t\t\t\tconsole.error(\"Service\", serviceName, \"(\", service, \") does not have logon credentials set\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet forkedToken;\n\t\t\ttry {\n\t\t\t\tlet logon = await modules.users.access(serviceConfig.automaticLogon.username);\n\t\t\t\tlogon = await logon.getNextPrompt();\n\t\t\t\tfor (let response of serviceConfig.automaticLogon.responses)\n\t\t\t\t\tif (logon.success == \"intermediate\") logon = await logon.input(response);\n\t\t\t\tif (!logon.success) throw new Error(logon.message);\n\t\t\t\tforkedToken = logon.token;\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(\"Failed to create a logon session for\", serviceName, \"(\", service, \"):\", e);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (triggerPasswordReset) {\n\t\t\t\tlet ownUser = await modules.tokens.info(forkedToken);\n\t\t\t\tlet ownUserInfo = await modules.users.getUserInfo(ownUser.user, true, forkedToken);\n\t\t\t\townUserInfo.securityChecks = [];\n\t\t\t\tawait modules.users.moduser(ownUser.user, ownUserInfo, forkedToken);\n\t\t\t\tawait modules.tokens.revoke(forkedToken);\n\t\t\t\tconsole.error(\"Exposed credentials for\", serviceName, \"(\", service, \") have been made invalid\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tawait modules.tasks.exec(serviceConfig.path, [ ...(serviceConfig.args || []) ], modules.window(session), forkedToken, true);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(\"Failed to start service\", serviceName, \"(\", service, \"):\", e);\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction waitForLogon(toHook) {\n\treturn new Promise(function(resolve) {\n\t\ttoHook.hook(resolve);\n\t});\n}\n\nasync function hookButtonClick(button) {\n\treturn new Promise(function(resolve) {\n\t\tbutton.onclick = (e) => resolve(e);\n\t});\n}","f4f6747c19b0d63d3c9f90e14b400a9cd0d997488041d4db3abd8644fef55e72b50ea4109937adf762c32514707c3cce3a4708126b23594c0fece963e1e83ab2":"requireLogon();","3514285bcae42583c3a28d9ba1638a14ad7fb9318951e9b86f02072397b62f01d161a8094c38f38f3d2c7ce42fe83cbbdbd839bacfc657945c13625eb7abd5ba":"function systemKillWaiter() {\n\t// @pcos-app-mode native\n\tmodules.startupWindow.windowDiv.remove();\n\treturn new Promise(function(resolve) {\n\t\tmodules.killSystem = resolve;\n\t});\n}\nreturn await systemKillWaiter();"},"buildInfo":{"for":"1332","version":"1332","when":1751657439181,"signer":"moduleSigner","critical":true,"bootOrder":"50","signature":"62ad8cc6faa8bebca9376d3d89823d3880cd040773aac6b62d733a9864ea4c8eb5326eb9771287740f8600f1e5eb1fdd809a2a69be039ad9518a1949210dae03"}},"50-core.fs":{"backend":{"files":{"apps":{"associations":{"txt":"ab0711ab8c8b156e580eca393b96899f72f5a7a4bc1d16ac984f35c11cbb05e79173cfe878293d56635e1b6584937a0697f2e83b1911a7154b043fb092f281d2"},"authui.js":"2e9372f756bd0f9b74089beb845f2bcae8f866e287762e57d93a93414439858a9288c104d53347a73430bdee4c098d3d4a3c334eee806596a3edf1203940be52","consentui.js":"e9cdcfd4d088838d23a089812b4116c7a9013c0dbd4fe81489c0a3ccc55847f26903e32fabf9b0296a3dc0346fde02d71a39047882ef370e3b53a6747e9e4c30","explorer.js":"27319e226eef242fd363386827cff5c0b09381144537e01a5db85f8c5ded96102bd8ebf158e65c115d95602178cf192efff7ab8c7f5c23ae2bc4e1123d2de142","filePicker.js":"67f1a9bb7125589e33bcf04048c8accadf277d7aaa160f12e3cfdd9301561a067b1ecaabf906ff4bb1bea17f09fbe1383a9b470bc69a3c03d0966fd91bfef14d","links":{"explorer.lnk":"51b0db677634efd56234f996162c104fc8eb35e3568355fd6a6ca7c2570320098c1069a10e6189154d48b9be9a675deecb7eb3252ffe054b35e31feefaca30ab","textEditor.lnk":"65e0c4b53ee364584eb31b101df3843810e0c4a1a7910d45ccb2cddda304bad804f2bb31bf7e0c905755df8ff561250f338e35052dd200f4f407e16489403e6b"},"startMenu.js":"4ca86455118a08ca4c320642698b520b37875a1b30c5d8ae54e5fddae71e2bed22ac6426118dd63834eae773850073b43284ca016f389d810437dfa9e1cd7b19","textEditor.js":"f02338bfde94ec987b039fc009d7341a33b481c8c8ed1437e63759a1a2fac427e6c86828a384f483629a7a9a0b415c5c01ce385420d288d45003ae6169621fed"},"etc":{"tlds.json":"67c5fc94109604848393677451d2edf34a6937b94153e1502d5f173b0238bfc0d8cc025b80219a1d64acac758a06a8c15f10613986da5dcdf4522b2fa932890c"}},"permissions":{"apps/associations/txt":{"world":"rx"},"apps/associations/":{"world":"rx"},"apps/authui.js":{"world":"rx"},"apps/consentui.js":{"world":"rx"},"apps/explorer.js":{"world":"rx"},"apps/filePicker.js":{"world":"rx"},"apps/links/explorer.lnk":{"world":"rx"},"apps/links/textEditor.lnk":{"world":"rx"},"apps/links/":{"world":"rx"},"apps/startMenu.js":{"world":"rx"},"apps/textEditor.js":{"world":"rx"},"apps/":{"world":"rx"},"etc/tlds.json":{"world":"rx"},"etc/":{"world":"rx"},"":{"world":"rx"}}},"files":{"ab0711ab8c8b156e580eca393b96899f72f5a7a4bc1d16ac984f35c11cbb05e79173cfe878293d56635e1b6584937a0697f2e83b1911a7154b043fb092f281d2":"{\"path\":\"system/apps/textEditor.js\",\"localeReferenceName\":\"TEXT_EDITOR\"}","2e9372f756bd0f9b74089beb845f2bcae8f866e287762e57d93a93414439858a9288c104d53347a73430bdee4c098d3d4a3c334eee806596a3edf1203940be52":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: IPC_SEND_PIPE, GET_LOCALE, GET_THEME, ELEVATE_PRIVILEGES, CSP_OPERATIONS\n// signature: 0019e2811eb72fd03404480d896f3e8460d63f6b63b92db572329449b74bd59f81fafe5a20629176f47ebd4a3db6bbb7b0dddfeeb86960066f8c9d8e61a10d01\n// =====END MANIFEST=====\n\nlet ipc;\n(async function() {\n\t// @pcos-app-mode isolatable\n\texec_args = await availableAPIs.getPrivateData() || [];\n\tif (!(exec_args instanceof Array)) return availableAPIs.terminate();\n\tipc = exec_args[0];\n\tif (!ipc) return availableAPIs.terminate();\n\tlet user = exec_args[1];\n\tawait availableAPIs.windowTitleSet(await availableAPIs.lookupLocale(\"LOG_IN_INVITATION\"));\n\tlet checklist = [ \"IPC_SEND_PIPE\", \"GET_LOCALE\", \"GET_THEME\", \"ELEVATE_PRIVILEGES\", \"CSP_OPERATIONS\" ];\n\tlet privileges = await availableAPIs.getPrivileges();\n\tif (!checklist.every(p => privileges.includes(p))) {\n\t\tif (privileges.includes(\"IPC_SEND_PIPE\")) await availableAPIs.sendToPipe({ pipe: ipc, data: { success: false, cancelled: false } });\n\t\treturn availableAPIs.terminate();\n\t}\n\tdocument.body.style.fontFamily = \"'Segoe UI', Tahoma, Geneva, Verdana, sans-serif\";\n\tif (await availableAPIs.isDarkThemed()) document.body.style.color = \"white\";\n\tlet describe = document.createElement(\"b\");\n\tlet form = document.createElement(\"form\");\n\tlet input = document.createElement(\"input\");\n\tlet submit = document.createElement(\"button\");\n\tdocument.body.appendChild(describe);\n\tdocument.body.appendChild(document.createElement(\"br\"));\n\tdocument.body.appendChild(form);\n\tform.appendChild(input);\n\tform.appendChild(submit);\n\tsubmit.innerText = await availableAPIs.lookupLocale(\"ENTER_BUTTON\");\n\tdescribe.innerText = await availableAPIs.lookupLocale(\"USERNAME_PROMPT\");\n\tinput.placeholder = await availableAPIs.lookupLocale(\"USERNAME\");\n\tasync function userSubmit(e) {\n\t\te.stopImmediatePropagation();\n\t\te.preventDefault();\n\t\te.stopPropagation();\n\t\tlet userLogonSession;\n\t\tlet userLogonID;\n\t\tlet desired_username = input.value;\n\t\ttry {\n\t\t\tuserLogonID = await availableAPIs.automatedLogonCreate({ desiredUser: desired_username });\n\t\t\tuserLogonSession = await availableAPIs.automatedLogonGet(userLogonID);\n\t\t} catch {\n\t\t\tdescribe.innerText = await availableAPIs.lookupLocale(\"AUTH_FAILED\") + \" \" + await availableAPIs.lookupLocale(\"USERNAME_PROMPT\");\n\t\t\tinput.placeholder = await availableAPIs.lookupLocale(\"USERNAME\");\n\t\t\tinput.type = \"text\";\n\t\t\tinput.disabled = !!user;\n\t\t\tsubmit.disabled = false;\n\t\t\tinput.value = user || \"\";\n\t\t\tsubmit.addEventListener(\"click\", userSubmit);\n\t\t\treturn;\n\t\t}\n\t\tasync function updateProgress() {\n\t\t\tsubmit.removeEventListener(\"click\", userSubmit);\n\t\t\tinput.value = \"\";\n\t\t\tsubmit.innerText = await availableAPIs.lookupLocale(\"ENTER_BUTTON\");\n\t\t\tif (userLogonSession.success != \"intermediate\") await availableAPIs.automatedLogonDelete(userLogonID);\n\t\t\tif (userLogonSession.success == true) {\n\t\t\t\tawait availableAPIs.sendToPipe({ pipe: ipc, data: userLogonSession });\n\t\t\t\tawait availableAPIs.terminate();\n\t\t\t}\n\t\t\tif (userLogonSession.success == false) {\n\t\t\t\tdescribe.innerText = await availableAPIs.lookupLocale(\"AUTH_FAILED\") + \" \" + await availableAPIs.lookupLocale(\"USERNAME_PROMPT\");\n\t\t\t\tinput.placeholder = await availableAPIs.lookupLocale(\"USERNAME\");\n\t\t\t\tinput.type = \"text\";\n\t\t\t\tinput.disabled = !!user;\n\t\t\t\tsubmit.disabled = false;\n\t\t\t\tinput.value = user || \"\";\n\t\t\t\tsubmit.addEventListener(\"click\", userSubmit);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdescribe.innerText = \"[\" + desired_username + \"] \" + userLogonSession.message;\n\t\t\tinput.placeholder = await availableAPIs.lookupLocale(\"RESPONSE_PLACEHOLDER\");\n\t\t\tinput.type = userLogonSession.type == \"password\" ? \"password\" : \"text\";\n\t\t\tinput.disabled = !userLogonSession.wantsUserInput;\n\t\t\tsubmit.disabled = !userLogonSession.wantsUserInput;\n\t\t\tif (userLogonSession.type == \"zkpp_password\") input.type = \"password\";\n\t\t\tif (userLogonSession.type == \"promise\") {\n\t\t\t\ttry {\n\t\t\t\t\tinput.disabled = true;\n\t\t\t\t\tsubmit.disabled = true;\n\t\t\t\t\tawait availableAPIs.automatedLogonInput({ session: userLogonID });\n\t\t\t\t\tuserLogonSession = await availableAPIs.automatedLogonGet(userLogonID);\n\t\t\t\t} catch {}\n\t\t\t\treturn await updateProgress();\n\t\t\t}\n\t\t\tif (userLogonSession.type == \"informative\") {\n\t\t\t\tinput.disabled = true;\n\t\t\t\tsubmit.disabled = false;\n\t\t\t\tsubmit.innerText = \"OK\";\n\t\t\t\tinput.placeholder = \"--->\";\n\t\t\t}\n\t\t\tsubmit.addEventListener(\"click\", async function updater(e) {\n\t\t\t\te.stopImmediatePropagation();\n\t\t\t\tsubmit.removeEventListener(\"click\", updater);\n\t\t\t\te.preventDefault();\n\t\t\t\te.stopPropagation();\n\t\t\t\ttry {\n\t\t\t\t\tinput.disabled = true;\n\t\t\t\t\tsubmit.disabled = true;\n\t\t\t\t\tif (userLogonSession.type == \"zkpp_password\") {\n\t\t\t\t\t\tlet passwordAsKey = await availableAPIs.cspOperation({\n\t\t\t\t\t\t\tcspProvider: \"basic\",\n\t\t\t\t\t\t\toperation: \"importKey\",\n\t\t\t\t\t\t\tcspArgument: {\n\t\t\t\t\t\t\t\tformat: \"raw\",\n\t\t\t\t\t\t\t\tkeyData: new TextEncoder().encode(input.value),\n\t\t\t\t\t\t\t\talgorithm: \"PBKDF2\",\n\t\t\t\t\t\t\t\textractable: false,\n\t\t\t\t\t\t\t\tkeyUsages: [\"deriveBits\"]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t\tlet rngSeed = await availableAPIs.cspOperation({\n\t\t\t\t\t\t\tcspProvider: \"basic\",\n\t\t\t\t\t\t\toperation: \"deriveBits\",\n\t\t\t\t\t\t\tcspArgument: {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"PBKDF2\",\n\t\t\t\t\t\t\t\t\tsalt: new Uint8Array(32),\n\t\t\t\t\t\t\t\t\titerations: 100000,\n\t\t\t\t\t\t\t\t\thash: \"SHA-256\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tbaseKey: passwordAsKey,\n\t\t\t\t\t\t\t\tlength: 256\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tawait availableAPIs.cspOperation({\n\t\t\t\t\t\t\tcspProvider: \"basic\",\n\t\t\t\t\t\t\toperation: \"unloadKey\",\n\t\t\t\t\t\t\tcspArgument: passwordAsKey\n\t\t\t\t\t\t});\n\t\t\t\t\t\tlet u8aToHex = (u8a) => Array.from(u8a).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\t\tlet hexToU8A = (hex) => Uint8Array.from(hex.match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\t\t\t\tawait availableAPIs.automatedLogonInput({ session: userLogonID, input: u8aToHex(await availableAPIs.cspOperation({\n\t\t\t\t\t\t\tcspProvider: \"tweetnacl\",\n\t\t\t\t\t\t\toperation: \"sign\",\n\t\t\t\t\t\t\tcspArgument: {\n\t\t\t\t\t\t\t\tsecretKey: (await availableAPIs.cspOperation({\n\t\t\t\t\t\t\t\t\tcspProvider: \"tweetnacl\",\n\t\t\t\t\t\t\t\t\toperation: \"deriveKey\",\n\t\t\t\t\t\t\t\t\tcspArgument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"sign\",\n\t\t\t\t\t\t\t\t\t\tseed: new Uint8Array(rngSeed)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t})).secretKey,\n\t\t\t\t\t\t\t\tmessage: hexToU8A(userLogonSession.challenge)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}))});\n\t\t\t\t\t} else await availableAPIs.automatedLogonInput({ session: userLogonID, input: input.value });\n\t\t\t\t\tuserLogonSession = await availableAPIs.automatedLogonGet(userLogonID);\n\t\t\t\t} catch {}\n\t\t\t\treturn await updateProgress();\n\t\t\t});\n\t\t}\n\t\tawait updateProgress();\n\t\treturn false;\n\t}\n\tsubmit.addEventListener(\"click\", userSubmit);\n\tif (user) {\n\t\tinput.disabled = true;\n\t\tinput.value = user;\n\t\tuserSubmit({ preventDefault: () => {}, stopImmediatePropagation: () => {}, stopPropagation: () => {} });\n\t}\n})();\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) {\n\t\ttry {\n\t\t\tawait availableAPIs.sendToPipe({ pipe: ipc, data: { success: false, cancelled: true } });\n\t\t} catch {}\n\t\tawait window.availableAPIs.terminate();\n\t}\n}); null;","e9cdcfd4d088838d23a089812b4116c7a9013c0dbd4fe81489c0a3ccc55847f26903e32fabf9b0296a3dc0346fde02d71a39047882ef370e3b53a6747e9e4c30":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: IPC_SEND_PIPE, GET_LOCALE, GET_THEME, ELEVATE_PRIVILEGES, FS_READ, FS_LIST_PARTITIONS, CSP_OPERATIONS\n// signature: 07f76df3f6f50d633db555c69c2a370f4b5acfa85be5835f625ff10564b1a79fd6ac56387a7f7a92621abac12d2386f6b524d3885bb1c7b41d9125073984e80f\n// =====END MANIFEST=====\n\nlet ipc;\n(async function() {\n\t// @pcos-app-mode isolatable\n\texec_args = await availableAPIs.getPrivateData() || [];\n\tif (!(exec_args instanceof Array)) return availableAPIs.terminate();\n\tipc = exec_args[0];\n\tif (!ipc) return availableAPIs.terminate();\n\tlet user = exec_args[1];\n\ttry {\n\t\tnew Audio(await availableAPIs.fs_read({ path: (await availableAPIs.getSystemMount()) + \"/etc/sounds/ask.aud\" })).play();\n\t} catch (e) {\n\t\tconsole.error(e);\n\t}\n\tawait availableAPIs.windowTitleSet(await availableAPIs.lookupLocale(\"ACCESS_REQUEST_TITLE\"));\n\tlet checklist = [ \"IPC_SEND_PIPE\", \"GET_LOCALE\", \"GET_THEME\", \"ELEVATE_PRIVILEGES\", \"CSP_OPERATIONS\" ];\n\tlet privileges = await availableAPIs.getPrivileges();\n\tif (!checklist.every(p => privileges.includes(p))) {\n\t\tif (privileges.includes(\"IPC_SEND_PIPE\")) await availableAPIs.sendToPipe({ pipe: ipc, data: { success: false, cancelled: false } });\n\t\treturn availableAPIs.terminate();\n\t}\n\tdocument.body.style.fontFamily = \"'Segoe UI', Tahoma, Geneva, Verdana, sans-serif\";\n\tif (await availableAPIs.isDarkThemed()) document.body.style.color = \"white\";\n\tlet describe = document.createElement(\"span\");\n\tlet form = document.createElement(\"form\");\n\tlet input = document.createElement(\"input\");\n\tlet decline = document.createElement(\"button\");\n\tlet submit = document.createElement(\"button\");\n\tlet metadata = JSON.parse(exec_args[2]);\n\tdecline.type = \"button\";\n\tsubmit.type = \"submit\";\n\tdocument.body.appendChild(describe);\n\tdocument.body.appendChild(document.createElement(\"hr\"));\n\tdocument.body.appendChild(form);\n\tform.appendChild(input);\n\tform.appendChild(document.createElement(\"br\"));\n\tform.appendChild(decline);\n\tform.appendChild(submit);\n\tdescribe.innerText = (await availableAPIs.lookupLocale(\"DESCRIBE_TEMPLATE\")).replace(\"%s\", metadata.path.split(\"/\").pop()).replace(\"%s\", metadata.submittedName || metadata.path.split(\"/\").pop()).replace(\"%s\", metadata.submittedIntent);\n\tinput.placeholder = await availableAPIs.lookupLocale(\"USERNAME\");\n\tdecline.innerText = await availableAPIs.lookupLocale(\"DECLINE\");\n\tsubmit.innerText = await availableAPIs.lookupLocale(\"NEXT\");\n\n\tasync function extraData(e) {\n\t\te.stopImmediatePropagation();\n\t\te.preventDefault();\n\t\te.stopPropagation();\n\t\tdescribe.innerText = (await availableAPIs.lookupLocale(\"EXTRA_DESCRIBE_TEMPLATE\")).replace(\"%s\", metadata.path).replace(\"%s\", metadata.submittedName || metadata.path.split(\"/\").pop()).replace(\"%s\", JSON.stringify(metadata.args)).replace(\"%s\", metadata.submittedIntent);\n\t\tdescribe.removeEventListener(\"contextmenu\", extraData);\n\t}\n\n\tdescribe.addEventListener(\"contextmenu\", extraData);\n\n\tasync function userSubmit(e) {\n\t\tdescribe.removeEventListener(\"contextmenu\", extraData);\n\t\te.stopImmediatePropagation();\n\t\te.preventDefault();\n\t\te.stopPropagation();\n\t\tlet userLogonSession;\n\t\tlet userLogonID;\n\t\tlet desired_username = input.value;\n\t\ttry {\n\t\t\tuserLogonID = await availableAPIs.automatedLogonCreate({ desiredUser: desired_username });\n\t\t\tuserLogonSession = await availableAPIs.automatedLogonGet(userLogonID);\n\t\t} catch {\n\t\t\tdescribe.innerText = await availableAPIs.lookupLocale(\"AUTH_FAILED\") + \" \" + await availableAPIs.lookupLocale(\"USERNAME_PROMPT\");\n\t\t\tinput.placeholder = await availableAPIs.lookupLocale(\"USERNAME\");\n\t\t\tinput.type = \"text\";\n\t\t\tinput.disabled = !!user;\n\t\t\tsubmit.disabled = false;\n\t\t\tinput.value = user || \"\";\n\t\t\tsubmit.addEventListener(\"click\", userSubmit);\n\t\t\treturn;\n\t\t}\n\t\tasync function updateProgress() {\n\t\t\tsubmit.removeEventListener(\"click\", userSubmit);\n\t\t\tinput.value = \"\";\n\t\t\tif (userLogonSession.success != \"intermediate\") await availableAPIs.automatedLogonDelete(userLogonID);\n\t\t\tif (userLogonSession.success == true) {\n\t\t\t\tawait availableAPIs.sendToPipe({ pipe: ipc, data: userLogonSession });\n\t\t\t\tawait availableAPIs.terminate();\n\t\t\t}\n\t\t\tif (userLogonSession.success == false) {\n\t\t\t\tdescribe.innerText = await availableAPIs.lookupLocale(\"AUTH_FAILED\") + \" \" + await availableAPIs.lookupLocale(\"USERNAME_PROMPT\");\n\t\t\t\tinput.placeholder = await availableAPIs.lookupLocale(\"USERNAME\");\n\t\t\t\tinput.type = \"text\";\n\t\t\t\tinput.disabled = !!user;\n\t\t\t\tsubmit.disabled = false;\n\t\t\t\tinput.value = user || \"\";\n\t\t\t\tsubmit.addEventListener(\"click\", userSubmit);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdescribe.innerText = \"[\" + desired_username + \"] \" + userLogonSession.message;\n\t\t\tinput.placeholder = await availableAPIs.lookupLocale(\"RESPONSE_PLACEHOLDER\");\n\t\t\tinput.type = userLogonSession.type == \"password\" ? \"password\" : \"text\";\n\t\t\tinput.disabled = !userLogonSession.wantsUserInput;\n\t\t\tsubmit.disabled = !userLogonSession.wantsUserInput;\n\t\t\tif (userLogonSession.type == \"zkpp_password\") input.type = \"password\";\n\t\t\tif (userLogonSession.type == \"promise\") {\n\t\t\t\ttry {\n\t\t\t\t\tinput.disabled = true;\n\t\t\t\t\tsubmit.disabled = true;\n\t\t\t\t\tawait availableAPIs.automatedLogonInput({ session: userLogonID });\n\t\t\t\t\tuserLogonSession = await availableAPIs.automatedLogonGet(userLogonID);\n\t\t\t\t} catch {}\n\t\t\t\treturn await updateProgress();\n\t\t\t}\n\t\t\tif (userLogonSession.type == \"informative\") {\n\t\t\t\tinput.disabled = true;\n\t\t\t\tsubmit.disabled = false;\n\t\t\t\tinput.placeholder = \"\";\n\t\t\t}\n\t\t\tsubmit.addEventListener(\"click\", async function updater(e) {\n\t\t\t\te.stopImmediatePropagation();\n\t\t\t\tsubmit.removeEventListener(\"click\", updater);\n\t\t\t\te.preventDefault();\n\t\t\t\te.stopPropagation();\n\t\t\t\ttry {\n\t\t\t\t\tinput.disabled = true;\n\t\t\t\t\tsubmit.disabled = true;\n\t\t\t\t\tif (userLogonSession.type == \"zkpp_password\") {\n\t\t\t\t\t\tlet passwordAsKey = await availableAPIs.cspOperation({\n\t\t\t\t\t\t\tcspProvider: \"basic\",\n\t\t\t\t\t\t\toperation: \"importKey\",\n\t\t\t\t\t\t\tcspArgument: {\n\t\t\t\t\t\t\t\tformat: \"raw\",\n\t\t\t\t\t\t\t\tkeyData: new TextEncoder().encode(input.value),\n\t\t\t\t\t\t\t\talgorithm: \"PBKDF2\",\n\t\t\t\t\t\t\t\textractable: false,\n\t\t\t\t\t\t\t\tkeyUsages: [\"deriveBits\"]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t\tlet rngSeed = await availableAPIs.cspOperation({\n\t\t\t\t\t\t\tcspProvider: \"basic\",\n\t\t\t\t\t\t\toperation: \"deriveBits\",\n\t\t\t\t\t\t\tcspArgument: {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"PBKDF2\",\n\t\t\t\t\t\t\t\t\tsalt: new Uint8Array(32),\n\t\t\t\t\t\t\t\t\titerations: 100000,\n\t\t\t\t\t\t\t\t\thash: \"SHA-256\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tbaseKey: passwordAsKey,\n\t\t\t\t\t\t\t\tlength: 256\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tawait availableAPIs.cspOperation({\n\t\t\t\t\t\t\tcspProvider: \"basic\",\n\t\t\t\t\t\t\toperation: \"unloadKey\",\n\t\t\t\t\t\t\tcspArgument: passwordAsKey\n\t\t\t\t\t\t});\n\t\t\t\t\t\tlet u8aToHex = (u8a) => Array.from(u8a).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\t\tlet hexToU8A = (hex) => Uint8Array.from(hex.match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\t\t\t\tawait availableAPIs.automatedLogonInput({ session: userLogonID, input: u8aToHex(await availableAPIs.cspOperation({\n\t\t\t\t\t\t\tcspProvider: \"tweetnacl\",\n\t\t\t\t\t\t\toperation: \"sign\",\n\t\t\t\t\t\t\tcspArgument: {\n\t\t\t\t\t\t\t\tsecretKey: (await availableAPIs.cspOperation({\n\t\t\t\t\t\t\t\t\tcspProvider: \"tweetnacl\",\n\t\t\t\t\t\t\t\t\toperation: \"deriveKey\",\n\t\t\t\t\t\t\t\t\tcspArgument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"sign\",\n\t\t\t\t\t\t\t\t\t\tseed: new Uint8Array(rngSeed)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t})).secretKey,\n\t\t\t\t\t\t\t\tmessage: hexToU8A(userLogonSession.challenge)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}))});\n\t\t\t\t\t} else await availableAPIs.automatedLogonInput({ session: userLogonID, input: input.value });\n\t\t\t\t\tuserLogonSession = await availableAPIs.automatedLogonGet(userLogonID);\n\t\t\t\t} catch {}\n\t\t\t\treturn await updateProgress();\n\t\t\t});\n\t\t}\n\t\tawait updateProgress();\n\t\treturn false;\n\t}\n\tsubmit.addEventListener(\"click\", userSubmit);\n\tdecline.addEventListener(\"click\", async function() {\n\t\tawait availableAPIs.sendToPipe({ pipe: ipc, data: { success: false, cancelled: true } });\n\t\tawait availableAPIs.terminate();\n\t});\n\tif (user) {\n\t\tinput.disabled = true;\n\t\tinput.value = user;\n\t}\n})();\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) {\n\t\ttry {\n\t\t\tawait availableAPIs.sendToPipe({ pipe: ipc, data: { success: false, cancelled: true } });\n\t\t} catch {}\n\t\tawait window.availableAPIs.terminate();\n\t}\n}); null;","27319e226eef242fd363386827cff5c0b09381144537e01a5db85f8c5ded96102bd8ebf158e65c115d95602178cf192efff7ab8c7f5c23ae2bc4e1123d2de142":"// =====BEGIN MANIFEST=====\n// link: lrn:FILE_EXPLORER\n// signer: automaticSigner\n// allow: FS_READ, FS_LIST_PARTITIONS, ELEVATE_PRIVILEGES, START_TASK, GET_LOCALE, GET_THEME, MANAGE_TOKENS, FS_REMOVE, FS_BYPASS_PERMISSIONS, FS_UNMOUNT, FS_CHANGE_PERMISSION, FS_MOUNT, GET_FILESYSTEMS, FS_WRITE, LLDISK_LIST_PARTITIONS, GET_USER_INFO\n// signature: 31a4ffe4c58728a3b0c7e312ee419793344e75e255410fd49b709bb6abd01711ad7c4431cf92f61d652b5e5e674148cdd68a6540e5c2d6f4927f0ba58989a002\n// =====END MANIFEST=====\nlet globalToken;\nlet cachedIcons = {};\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.windowTitleSet(await availableAPIs.lookupLocale(\"FILE_EXPLORER\"));\n\tdocument.body.style.fontFamily = \"'Segoe UI', Tahoma, Geneva, Verdana, sans-serif\";\n\tif (await availableAPIs.isDarkThemed()) document.body.style.color = \"white\";\n\tlet privileges = await availableAPIs.getPrivileges();\n\tlet checklist = [ \"FS_READ\", \"FS_LIST_PARTITIONS\" ];\n\tif (!checklist.every(p => privileges.includes(p))) {\n\t\tdocument.body.innerText = await availableAPIs.lookupLocale(\"GRANT_FEXP_PERM\");\n\t\tlet button = document.createElement(\"button\");\n\t\tbutton.innerText = await availableAPIs.lookupLocale(\"GRANT_PERM\");\n\t\tdocument.body.appendChild(button);\n\t\tif (!privileges.includes(\"ELEVATE_PRIVILEGES\")) {\n\t\t\tbutton.disabled = true;\n\t\t\tdocument.body.innerText = await availableAPIs.lookupLocale(\"GRANT_FEXP_PERM_ADM\");\n\t\t\treturn;\n\t\t}\n\t\tawait new Promise(function(resolve) {\n\t\t\tbutton.onclick = async function() {\n\t\t\t\tbutton.disabled = true;\n\t\t\t\tlet currentToken = await availableAPIs.getProcessToken();\n\t\t\t\tlet newToken = await availableAPIs.consentGetToken({\n\t\t\t\t\tintent: await availableAPIs.lookupLocale(\"FILE_EXPLORER_FULL_INTENT\"),\n\t\t\t\t\tname: await availableAPIs.lookupLocale(\"FILE_EXPLORER\")\n\t\t\t\t});\n\t\t\t\tbutton.disabled = false;\n\t\t\t\tif (!newToken) return;\n\t\t\t\tif (privileges.includes(\"MANAGE_TOKENS\")) globalToken = await availableAPIs.forkToken(newToken);\n\t\t\t\tawait availableAPIs.setProcessToken(newToken);\n\t\t\t\tawait availableAPIs.revokeToken(currentToken);\n\t\t\t\tprivileges = await availableAPIs.getPrivileges();\n\t\t\t\tif (checklist.every(p => privileges.includes(p))) resolve();\n\t\t\t\telse document.body.innerText = await availableAPIs.lookupLocale(\"GRANT_FEXP_PERM_USR\");\n\t\t\t}\n\t\t});\n\t}\n\tlet hideHiddenFiles = true;\n\ttry {\n\t\tlet homedir = (await availableAPIs.getUserInfo({ desiredUser: await availableAPIs.getUser() })).homeDirectory;\n\t\thideHiddenFiles = (await availableAPIs.fs_read({\n\t\t\tpath: homedir + \"/.hiddenFiles\",\n\t\t})) != \"show\";\n\t} catch {}\n\tdocument.body.innerText = \"\";\n\tlet mainComponent = document.createElement(\"div\");\n\tlet pathInputForm = document.createElement(\"form\");\n\tlet pathElement = document.createElement(\"input\");\n\tlet browseButton = document.createElement(\"button\");\n\tlet displayResult = document.createElement(\"div\");\n\tlet previousDirectory = \"\";\n\tlet clipboard = {\n\t\tpath: \"\",\n\t\tcut: false,\n\t\tselected: false\n\t};\n\tmainComponent.style.display = \"flex\";\n\tmainComponent.style.flexDirection = \"column\";\n\tmainComponent.style.width = \"100%\";\n\tmainComponent.style.height = \"100%\";\n\tmainComponent.style.position = \"absolute\";\n\tmainComponent.style.top = \"0\";\n\tmainComponent.style.left = \"0\";\n\tmainComponent.style.padding = \"8px\";\n\tmainComponent.style.boxSizing = \"border-box\";\n\tdisplayResult.style.flex = \"1\";\n\tbrowseButton.innerText = await availableAPIs.lookupLocale(\"BROWSE_FEXP\");\n\tpathInputForm.appendChild(pathElement);\n\tpathInputForm.appendChild(browseButton);\n\tmainComponent.appendChild(pathInputForm);\n\tmainComponent.appendChild(displayResult);\n\tdocument.body.appendChild(mainComponent);\n\tlet availableIcons = [];\n\ttry {\n\t\tavailableIcons = await availableAPIs.fs_ls({ path: await availableAPIs.getSystemMount() + \"/etc/icons\" });\n\t} catch {}\n\tdisplayResult.oncontextmenu = async function(e) {\n\t\te.stopImmediatePropagation();\n\t\te.preventDefault();\n\t\te.stopPropagation();\n\t\tdisplayResult.innerText = \"\";\n\t\tlet showHiddenFilesToggle = document.createElement(\"button\");\n\t\tshowHiddenFilesToggle.innerText = await availableAPIs.lookupLocale(\"TOGGLE_HIDDEN_FILES\");\n\t\tshowHiddenFilesToggle.addEventListener(\"click\", async function() {\n\t\t\thideHiddenFiles = !hideHiddenFiles;\n\t\t\ttry {\n\t\t\t\tlet homedir = (await availableAPIs.getUserInfo({ desiredUser: await availableAPIs.getUser() })).homeDirectory;\n\t\t\t\tavailableAPIs.fs_write({\n\t\t\t\t\tpath: homedir + \"/.hiddenFiles\",\n\t\t\t\t\tdata: (hideHiddenFiles ? \"hide\" : \"show\")\n\t\t\t\t});\n\t\t\t} catch {}\n\t\t\tbrowse();\n\t\t});\n\t\tdisplayResult.appendChild(showHiddenFilesToggle);\n\t\tdisplayResult.appendChild(document.createElement(\"hr\"));\n\t\tif (previousDirectory == \"\") {\n\t\t\tlet mountForm = document.createElement(\"form\");\n\t\t\tlet mountpoint = document.createElement(\"input\");\n\t\t\tlet filesystemOptions = document.createElement(\"select\");\n\t\t\tlet autoGenMountOptions = document.createElement(\"select\");\n\t\t\tlet mountOptions = document.createElement(\"textarea\");\n\t\t\tlet mountButton = document.createElement(\"button\");\n\t\t\tmountpoint.placeholder = await availableAPIs.lookupLocale(\"MOUNTPOINT\");\n\t\t\tlet availableFilesystems = await availableAPIs.supportedFilesystems();\n\t\t\tfor (let filesystem of availableFilesystems) {\n\t\t\t\tlet option = document.createElement(\"option\");\n\t\t\t\toption.value = filesystem;\n\t\t\t\toption.innerText = filesystem;\n\t\t\t\tfilesystemOptions.appendChild(option);\n\t\t\t}\n\t\t\tlet availablePartitions = [];\n\t\t\ttry {\n\t\t\t\tavailablePartitions = await availableAPIs.lldaList();\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(e);\n\t\t\t}\n\t\t\tlet defaultPartitionOption = document.createElement(\"option\");\n\t\t\tdefaultPartitionOption.value = \"\";\n\t\t\tdefaultPartitionOption.innerText = await availableAPIs.lookupLocale(\"GENERATE_PROMPT\");\n\t\t\tdefaultPartitionOption.selected = true;\n\t\t\tdefaultPartitionOption.disabled = true;\n\t\t\tdefaultPartitionOption.hidden = true;\n\t\t\tautoGenMountOptions.appendChild(defaultPartitionOption);\n\t\t\tfor (let partition of availablePartitions) {\n\t\t\t\tlet option = document.createElement(\"option\");\n\t\t\t\toption.value = partition;\n\t\t\t\toption.innerText = partition;\n\t\t\t\tautoGenMountOptions.appendChild(option);\n\t\t\t}\n\t\t\tautoGenMountOptions.onchange = function() {\n\t\t\t\tmountOptions.value = JSON.stringify({ partition: autoGenMountOptions.value });\n\t\t\t}\n\t\t\tmountOptions.value = \"{}\";\n\t\t\tmountButton.innerText = await availableAPIs.lookupLocale(\"MOUNT_BUTTON\");\n\t\t\tmountButton.onclick = async function() {\n\t\t\t\ttry {\n\t\t\t\t\tlet options = JSON.parse(mountOptions.value);\n\t\t\t\t\tawait availableAPIs.fs_mount({ mountpoint: mountpoint.value, filesystem: filesystemOptions.value, filesystemOptions: options });\n\t\t\t\t\tbrowse();\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(e);\n\t\t\t\t\tdisplayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", e.name + \": \" + e.message);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmountForm.appendChild(mountpoint);\n\t\t\tmountForm.appendChild(document.createElement(\"br\"));\n\t\t\tmountForm.appendChild(filesystemOptions);\n\t\t\tmountForm.appendChild(document.createElement(\"hr\"));\n\t\t\tmountForm.appendChild(autoGenMountOptions);\n\t\t\tmountForm.appendChild(document.createElement(\"br\"));\n\t\t\tmountForm.appendChild(mountOptions);\n\t\t\tmountForm.appendChild(document.createElement(\"hr\"));\n\t\t\tmountForm.appendChild(mountButton);\n\t\t\tdisplayResult.appendChild(mountForm);\n\t\t} else {\n\t\t\tlet makeDirectoryForm = document.createElement(\"form\");\n\t\t\tlet makeDirectoryInput = document.createElement(\"input\");\n\t\t\tlet makeDirectoryButton = document.createElement(\"button\");\n\t\t\tmakeDirectoryInput.pattern = \"[!-.0-~]+\";\n\t\t\tmakeDirectoryInput.placeholder = await availableAPIs.lookupLocale(\"NEW_DIR_NAME\");\n\t\t\tmakeDirectoryForm.appendChild(makeDirectoryInput);\n\t\t\tmakeDirectoryForm.appendChild(makeDirectoryButton);\n\t\t\tdisplayResult.appendChild(makeDirectoryForm);\n\t\t\tmakeDirectoryButton.innerText = await availableAPIs.lookupLocale(\"MKDIR_BUTTON\");\n\t\t\tmakeDirectoryButton.onclick = async function() {\n\t\t\t\tlet dirName = makeDirectoryInput.value;\n\t\t\t\tif (dirName == \"\") return;\n\t\t\t\ttry {\n\t\t\t\t\tawait availableAPIs.fs_mkdir({ path: previousDirectory + \"/\" + dirName });\n\t\t\t\t\tbrowse();\n\t\t\t\t} catch (e) {\n\t\t\t\t\tdisplayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", await availableAPIs.lookupLocale(e.message));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (clipboard.selected) {\n\t\t\t\tdisplayResult.appendChild(document.createElement(\"hr\"));\n\t\t\t\tlet pasteButton = document.createElement(\"button\");\n\t\t\t\tpasteButton.innerText = await availableAPIs.lookupLocale(\"CLIPBOARD_PASTE\");\n\t\t\t\tpasteButton.onclick = async function() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet copyAllowed = await isDirectory(clipboard.path) == \"file\";\n\t\t\t\t\t\tif (!copyAllowed) throw new Error(await availableAPIs.lookupLocale(\"CLIPBOARD_SOURCE_GONE\"));\n\t\t\t\t\t\tlet readFile = await availableAPIs.fs_read({ path: clipboard.path });\n\t\t\t\t\t\tlet basename = clipboard.path.split(\"/\").slice(-1)[0];\n\t\t\t\t\t\tcopyAllowed = await isDirectory(previousDirectory + \"/\" + basename) == \"unknown\";\n\t\t\t\t\t\tif (!copyAllowed) throw new Error(await availableAPIs.lookupLocale(\"CLIPBOARD_CONFLICT\"));\n\t\t\t\t\t\tawait availableAPIs.fs_write({ path: previousDirectory + \"/\" + basename, data: readFile });\n\t\t\t\t\t\tif (clipboard.cut) await availableAPIs.fs_rm({ path: clipboard.path });\n\t\t\t\t\t\tbrowse();\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tdisplayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", await availableAPIs.lookupLocale(e.message));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdisplayResult.appendChild(pasteButton);\n\t\t\t}\n\t\t}\n\t}\n\tasync function browse() {\n\t\tlet path = pathElement.value;\n\t\tif (path.endsWith(\"/\")) path = path.substring(0, path.length - 1);\n\t\tdisplayResult.innerText = \"\";\n\t\tif (path == \"\") {\n\t\t\tlet partitions = (await availableAPIs.fs_mounts()).sort((a, b) => a.localeCompare(b));\n\t\t\tfor (let partition of partitions) {\n\t\t\t\tif (partition.startsWith(\".\") && hideHiddenFiles) continue;\n\t\t\t\tlet openButton = document.createElement(\"button\");\n\t\t\t\topenButton.innerText = partition;\n\t\t\t\topenButton.onclick = function() {\n\t\t\t\t\tpathElement.value = partition;\n\t\t\t\t\tbrowse();\n\t\t\t\t}\n\t\t\t\topenButton.oncontextmenu = async function(e) {\n\t\t\t\t\te.stopImmediatePropagation();\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\te.stopPropagation();\n\t\t\t\t\tdisplayResult.innerText = \"\";\n\t\t\t\t\tlet unmountButton = document.createElement(\"button\");\n\t\t\t\t\tunmountButton.innerText = await availableAPIs.lookupLocale(\"UNMOUNT_BTN\");\n\t\t\t\t\tunmountButton.onclick = async function() {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait availableAPIs.fs_unmount({ mount: partition });\n\t\t\t\t\t\t\tbrowse();\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tdisplayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", await availableAPIs.lookupLocale(e.message));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tunmountButton.oncontextmenu = async function(e) {\n\t\t\t\t\t\te.stopImmediatePropagation();\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\te.stopPropagation();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait availableAPIs.fs_unmount({ mount: partition, force: true });\n\t\t\t\t\t\t\tbrowse();\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tdisplayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", await availableAPIs.lookupLocale(e.message));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdisplayResult.appendChild(unmountButton);\n\t\t\t\t\tdisplayResult.appendChild(document.createElement(\"hr\"));\n\n\t\t\t\t\tlet deleteButton = document.createElement(\"button\");\n\t\t\t\t\tlet deleteConfirm = false;\n\t\t\t\t\tdeleteButton.innerText = await availableAPIs.lookupLocale(\"REMOVE_BTN\");\n\t\t\t\t\tdeleteButton.onclick = async function() {\n\t\t\t\t\t\tif (!deleteConfirm) {\n\t\t\t\t\t\t\tdeleteButton.style.fontWeight = \"bold\";\n\t\t\t\t\t\t\tdeleteConfirm = true;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait recursiveRemove(partition);\n\t\t\t\t\t\t\tbrowse();\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tdisplayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", await availableAPIs.lookupLocale(e.message));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdisplayResult.appendChild(deleteButton);\n\n\t\t\t\t\tdisplayResult.appendChild(document.createElement(\"br\"));\n\t\t\t\t\tlet permissions = { owner: \"nobody\", group: \"nobody\", world: \"rx\" };\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpermissions = await availableAPIs.fs_permissions({ path: partition });\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tconsole.error(e);\n\t\t\t\t\t}\n\t\t\t\t\tlet chownForm = document.createElement(\"form\");\n\t\t\t\t\tlet chownInput = document.createElement(\"input\");\n\t\t\t\t\tlet chownButton = document.createElement(\"button\");\n\t\t\t\t\tchownInput.value = permissions.owner;\n\t\t\t\t\tchownButton.innerText = await availableAPIs.lookupLocale(\"CHOWN_BUTTON\");\n\t\t\t\t\tchownForm.appendChild(chownInput);\n\t\t\t\t\tchownForm.appendChild(chownButton);\n\t\t\t\t\tdisplayResult.appendChild(chownForm);\n\t\t\t\t\tchownButton.onclick = async function() {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait availableAPIs.fs_chown({ path: partition, newUser: chownInput.value });\n\t\t\t\t\t\t\tbrowse();\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tdisplayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", await availableAPIs.lookupLocale(e.message));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlet chgrpForm = document.createElement(\"form\");\n\t\t\t\t\tlet chgrpInput = document.createElement(\"input\");\n\t\t\t\t\tlet chgrpButton = document.createElement(\"button\");\n\t\t\t\t\tchgrpInput.value = permissions.group;\n\t\t\t\t\tchgrpButton.innerText = await availableAPIs.lookupLocale(\"CHGRP_BUTTON\");\n\t\t\t\t\tchgrpForm.appendChild(chgrpInput);\n\t\t\t\t\tchgrpForm.appendChild(chgrpButton);\n\t\t\t\t\tdisplayResult.appendChild(chgrpForm);\n\t\t\t\t\tchgrpButton.onclick = async function() {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait availableAPIs.fs_chgrp({ path: partition, newGrp: chgrpInput.value });\n\t\t\t\t\t\t\tbrowse();\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tdisplayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", await availableAPIs.lookupLocale(e.message));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlet chmodForm = document.createElement(\"form\");\n\t\t\t\t\tlet chmodInput = document.createElement(\"input\");\n\t\t\t\t\tlet chmodButton = document.createElement(\"button\");\n\t\t\t\t\tchmodInput.value = permissions.world;\n\t\t\t\t\tchownInput.pattern = \"[rwx]+\";\n\t\t\t\t\tchmodButton.innerText = await availableAPIs.lookupLocale(\"CHMOD_BUTTON\");\n\t\t\t\t\tchmodForm.appendChild(chmodInput);\n\t\t\t\t\tchmodForm.appendChild(chmodButton);\n\t\t\t\t\tdisplayResult.appendChild(chmodForm);\n\t\t\t\t\tchmodButton.onclick = async function() {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait availableAPIs.fs_chmod({ path: partition, newPermissions: chmodInput.value });\n\t\t\t\t\t\t\tbrowse();\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tdisplayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", await availableAPIs.lookupLocale(e.message));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdisplayResult.appendChild(openButton);\n\t\t\t}\n\t\t\tdisplayResult.appendChild(document.createElement(\"hr\"));\n\t\t\tlet spaceDisplayer = document.createElement(\"div\");\n\t\t\tlet spaces = await availableAPIs.estimateStorage();\n\t\t\tfor (let space in spaces) {\n\t\t\t\tlet newSpace = document.createElement(\"div\");\n\t\t\t\tnewSpace.innerText = (await availableAPIs.lookupLocale(\"SPACE_SHOWER\")).replace(\"%s\", space).replace(\"%s\", await availableAPIs.ufInfoUnits([spaces[space].used])).replace(\"%s\", await availableAPIs.ufInfoUnits([spaces[space].total])).replace(\"%s\", (spaces[space].used / spaces[space].total * 100).toFixed(2));\n\t\t\t\tspaceDisplayer.appendChild(newSpace);\n\t\t\t}\n\t\t\tdisplayResult.appendChild(spaceDisplayer);\n\t\t\tpreviousDirectory = path;\n\t\t\treturn \"browsed\";\n\t\t}\n\t\ttry {\n\t\t\tlet type = await isDirectory(path);\n\t\t\tif (type == \"directory\") {\n\t\t\t\tlet ls = (await availableAPIs.fs_ls({ path: path })).sort((a, b) => a.localeCompare(b));\n\t\t\t\tfor (let file of ls) {\n\t\t\t\t\tif (file.startsWith(\".\") && hideHiddenFiles) continue;\n\t\t\t\t\tlet openButton = document.createElement(\"button\");\n\t\t\t\t\tlet fileIcon = document.createElement(\"img\");\n\t\t\t\t\tfileIcon.style.width = \"12px\";\n\t\t\t\t\tfileIcon.style.height = \"12px\";\n\t\t\t\t\tlet fileType = file.split(\".\").slice(-1)[0];\n\t\t\t\t\tlet isDir = await isDirectory(path + \"/\" + file);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet wantedIcon;\n\t\t\t\t\t\tif (isDir == \"directory\") wantedIcon = \"foldericon.pic\";\n\t\t\t\t\t\telse if (availableIcons.includes(fileType + \".pic\")) wantedIcon = fileType + \".pic\";\n\t\t\t\t\t\telse wantedIcon = \"fileicon.pic\";\n\t\t\t\t\t\tif (!cachedIcons.hasOwnProperty(wantedIcon)) cachedIcons[wantedIcon] = await availableAPIs.fs_read({ path: await availableAPIs.getSystemMount() + \"/etc/icons/\" + wantedIcon });\n\t\t\t\t\t\tfileIcon.src = cachedIcons[wantedIcon];\n\t\t\t\t\t} catch {}\n\t\t\t\t\topenButton.innerText = file;\n\t\t\t\t\topenButton.insertAdjacentElement(\"afterbegin\", fileIcon);\n\t\t\t\t\topenButton.onclick = function() {\n\t\t\t\t\t\tpathElement.value = path + \"/\" + file;\n\t\t\t\t\t\tbrowse();\n\t\t\t\t\t}\n\t\t\t\t\topenButton.oncontextmenu = async function(e) {\n\t\t\t\t\t\te.stopImmediatePropagation();\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\te.stopPropagation();\n\t\t\t\t\t\tdisplayResult.innerText = \"\";\n\t\t\t\t\t\tlet copyAllow = false;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tcopyAllow = isDir == \"file\";\n\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\tif (copyAllow) {\n\t\t\t\t\t\t\tlet copyButton = document.createElement(\"button\");\n\t\t\t\t\t\t\tcopyButton.innerText = await availableAPIs.lookupLocale(\"CLIPBOARD_COPY\");\n\t\t\t\t\t\t\tcopyButton.onclick = async function() {\n\t\t\t\t\t\t\t\tclipboard = {\n\t\t\t\t\t\t\t\t\tpath: path + \"/\" + file,\n\t\t\t\t\t\t\t\t\tselected: true,\n\t\t\t\t\t\t\t\t\tcut: false\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tbrowse();\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tdisplayResult.appendChild(copyButton);\n\n\t\t\t\t\t\t\tlet cutButton = document.createElement(\"button\");\n\t\t\t\t\t\t\tcutButton.innerText = await availableAPIs.lookupLocale(\"CLIPBOARD_CUT\");\n\t\t\t\t\t\t\tcutButton.onclick = async function() {\n\t\t\t\t\t\t\t\tclipboard = {\n\t\t\t\t\t\t\t\t\tpath: path + \"/\" + file,\n\t\t\t\t\t\t\t\t\tselected: true,\n\t\t\t\t\t\t\t\t\tcut: true\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tbrowse();\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tdisplayResult.appendChild(cutButton);\n\t\t\t\t\t\t\tdisplayResult.appendChild(document.createElement(\"hr\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet deleteButton = document.createElement(\"button\");\n\t\t\t\t\t\tlet deleteConfirm = false;\n\t\t\t\t\t\tdeleteButton.innerText = await availableAPIs.lookupLocale(\"REMOVE_BTN\");\n\t\t\t\t\t\tdeleteButton.onclick = async function() {\n\t\t\t\t\t\t\tif (!deleteConfirm) {\n\t\t\t\t\t\t\t\tdeleteButton.style.fontWeight = \"bold\";\n\t\t\t\t\t\t\t\tdeleteConfirm = true;\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlet isDir = await isDirectory(path + \"/\" + file);\n\t\t\t\t\t\t\t\tif (isDir == \"directory\") await recursiveRemove(path + \"/\" + file);\n\t\t\t\t\t\t\t\telse if (isDir == \"file\") await availableAPIs.fs_rm({ path: path + \"/\" + file });\n\t\t\t\t\t\t\t\tbrowse();\n\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\tdisplayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", await availableAPIs.lookupLocale(e.message));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdisplayResult.appendChild(deleteButton);\n\t\t\t\t\t\tdisplayResult.appendChild(document.createElement(\"br\"));\n\t\t\t\t\t\tlet permissions = { owner: \"nobody\", group: \"nobody\", world: \"rx\" };\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tpermissions = await availableAPIs.fs_permissions({ path: path + \"/\" + file });\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tconsole.error(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet chownForm = document.createElement(\"form\");\n\t\t\t\t\t\tlet chownInput = document.createElement(\"input\");\n\t\t\t\t\t\tlet chownButton = document.createElement(\"button\");\n\t\t\t\t\t\tchownInput.value = permissions.owner;\n\t\t\t\t\t\tchownButton.innerText = await availableAPIs.lookupLocale(\"CHOWN_BUTTON\");\n\t\t\t\t\t\tchownForm.appendChild(chownInput);\n\t\t\t\t\t\tchownForm.appendChild(chownButton);\n\t\t\t\t\t\tdisplayResult.appendChild(chownForm);\n\t\t\t\t\t\tchownButton.onclick = async function() {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tawait availableAPIs.fs_chown({ path: path + \"/\" + file, newUser: chownInput.value });\n\t\t\t\t\t\t\t\tbrowse();\n\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\tdisplayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", await availableAPIs.lookupLocale(e.message));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet chgrpForm = document.createElement(\"form\");\n\t\t\t\t\t\tlet chgrpInput = document.createElement(\"input\");\n\t\t\t\t\t\tlet chgrpButton = document.createElement(\"button\");\n\t\t\t\t\t\tchgrpInput.value = permissions.group;\n\t\t\t\t\t\tchgrpButton.innerText = await availableAPIs.lookupLocale(\"CHGRP_BUTTON\");\n\t\t\t\t\t\tchgrpForm.appendChild(chgrpInput);\n\t\t\t\t\t\tchgrpForm.appendChild(chgrpButton);\n\t\t\t\t\t\tdisplayResult.appendChild(chgrpForm);\n\t\t\t\t\t\tchgrpButton.onclick = async function() {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tawait availableAPIs.fs_chgrp({ path: path + \"/\" + file, newGrp: chgrpInput.value });\n\t\t\t\t\t\t\t\tbrowse();\n\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\tdisplayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", await availableAPIs.lookupLocale(e.message));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet chmodForm = document.createElement(\"form\");\n\t\t\t\t\t\tlet chmodInput = document.createElement(\"input\");\n\t\t\t\t\t\tlet chmodButton = document.createElement(\"button\");\n\t\t\t\t\t\tchmodInput.value = permissions.world;\n\t\t\t\t\t\tchownInput.pattern = \"[rwx]+\";\n\t\t\t\t\t\tchmodButton.innerText = await availableAPIs.lookupLocale(\"CHMOD_BUTTON\");\n\t\t\t\t\t\tchmodForm.appendChild(chmodInput);\n\t\t\t\t\t\tchmodForm.appendChild(chmodButton);\n\t\t\t\t\t\tdisplayResult.appendChild(chmodForm);\n\t\t\t\t\t\tchmodButton.onclick = async function() {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tawait availableAPIs.fs_chmod({ path: path + \"/\" + file, newPermissions: chmodInput.value });\n\t\t\t\t\t\t\t\tbrowse();\n\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\tdisplayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", await availableAPIs.lookupLocale(e.message));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdisplayResult.appendChild(openButton);\n\t\t\t\t}\n\t\t\t\tpreviousDirectory = path;\n\t\t\t} else if (type == \"file\") {\n\t\t\t\tlet hasError = false;\n\t\t\t\tpathElement.value = previousDirectory;\n\t\t\t\tif (path.endsWith(\".js\")) {\n\t\t\t\t\tif (privileges.includes(\"START_TASK\") && privileges.includes(\"ELEVATE_PRIVILEGES\") && privileges.includes(\"MANAGE_TOKENS\")) {\n\t\t\t\t\t\tif (!globalToken) globalToken = await availableAPIs.consentGetToken({\n\t\t\t\t\t\t\tintent: await availableAPIs.lookupLocale(\"FILE_EXPLORER_INTENT\"),\n\t\t\t\t\t\t\tname: await availableAPIs.lookupLocale(\"FILE_EXPLORER\"),\n\t\t\t\t\t\t\tdesiredUser: await availableAPIs.getUser()\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (globalToken) {\n\t\t\t\t\t\t\tlet newToken = await availableAPIs.forkToken(globalToken);\n\t\t\t\t\t\t\tawait availableAPIs.startTask({ file: path, token: newToken });\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdisplayResult.innerText = await availableAPIs.lookupLocale(\"MORE_PERMISSION_DENIED\");\n\t\t\t\t\t\thasError = true;\n\t\t\t\t\t}\n\t\t\t\t} else if (path.endsWith(\".lnk\") && privileges.includes(\"ELEVATE_PRIVILEGES\") && privileges.includes(\"MANAGE_TOKENS\")) {\n\t\t\t\t\tlet file = await availableAPIs.fs_read({ path: path });\n\t\t\t\t\tfile = JSON.parse(file);\n\t\t\t\t\tif (privileges.includes(\"START_TASK\")) {\n\t\t\t\t\t\tif (!globalToken) globalToken = await availableAPIs.consentGetToken({\n\t\t\t\t\t\t\tintent: await availableAPIs.lookupLocale(\"FILE_EXPLORER_INTENT\"),\n\t\t\t\t\t\t\tname: await availableAPIs.lookupLocale(\"FILE_EXPLORER\"),\n\t\t\t\t\t\t\tdesiredUser: await availableAPIs.getUser()\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (globalToken) {\n\t\t\t\t\t\t\tlet newToken = await availableAPIs.forkToken(globalToken);\n\t\t\t\t\t\t\tawait availableAPIs.startTask({ file: file.path, argPassed: [ ...(file.args || []) ], token: newToken });\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdisplayResult.innerText = await availableAPIs.lookupLocale(\"MORE_PERMISSION_DENIED\");\n\t\t\t\t\t\thasError = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet lookUpAssociation = await availableAPIs.fs_ls({ path: await availableAPIs.getSystemMount() + \"/apps/associations\" });\n\t\t\t\t\tlet fileType = path.split(\".\").slice(-1)[0];\n\t\t\t\t\tif (!lookUpAssociation.includes(fileType)) return displayResult.innerText = await availableAPIs.lookupLocale(\"UNKNOWN_FILE_TYPE\");\n\t\t\t\t\tlet file = await availableAPIs.fs_read({ path: await availableAPIs.getSystemMount() + \"/apps/associations/\" + fileType });\n\t\t\t\t\tlet fileLink = JSON.parse(file);\n\t\t\t\t\tif (privileges.includes(\"START_TASK\") && privileges.includes(\"ELEVATE_PRIVILEGES\") && privileges.includes(\"MANAGE_TOKENS\")) {\n\t\t\t\t\t\tif (!globalToken) globalToken = await availableAPIs.consentGetToken({\n\t\t\t\t\t\t\tintent: await availableAPIs.lookupLocale(\"FILE_EXPLORER_INTENT\"),\n\t\t\t\t\t\t\tname: await availableAPIs.lookupLocale(\"FILE_EXPLORER\"),\n\t\t\t\t\t\t\tdesiredUser: await availableAPIs.getUser()\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (globalToken) {\n\t\t\t\t\t\t\tlet newToken = await availableAPIs.forkToken(globalToken);\n\t\t\t\t\t\t\tawait availableAPIs.startTask({ file: fileLink.path, argPassed: [ ...(fileLink.args || []), path ], token: newToken });\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdisplayResult.innerText = await availableAPIs.lookupLocale(\"MORE_PERMISSION_DENIED\");\n\t\t\t\t\t\thasError = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!hasError) await browse();\n\t\t\t} else {\n\t\t\t\tdisplayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", (await availableAPIs.lookupLocale(\"UNKNOWN_FS_STRUCT\")).replace(\"%s\", type));\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tdisplayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", await availableAPIs.lookupLocale(e.message));\n\t\t}\n\t}\n\tif (exec_args[0]) pathElement.value = exec_args[0];\n\tbrowse();\n\tbrowseButton.onclick = browse;\n})();\nasync function recursiveRemove(path) {\n\tlet dirList = await availableAPIs.fs_ls({ path });\n\tfor (let fileIndex in dirList) {\n\t\tlet file = dirList[fileIndex];\n\t\tif (await availableAPIs.fs_isDirectory({ path: path + \"/\" + file })) await recursiveRemove(path + \"/\" + file);\n\t\telse await availableAPIs.fs_rm({ path: path + \"/\" + file });\n\t}\n\tawait availableAPIs.fs_rm({ path });\n}\nasync function isDirectory(path) {\n\ttry {\n\t\tlet isDirectoryVar = await availableAPIs.fs_isDirectory({ path });\n\t\treturn isDirectoryVar ? \"directory\" : \"file\";\n\t} catch {\n\t\treturn \"unknown\";\n\t}\n}\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) {\n\t\ttry {\n\t\t\tif (globalToken) await availableAPIs.revokeToken(globalToken);\n\t\t} catch {}\n\t\tawait window.availableAPIs.terminate();\n\t}\n}); null;","67f1a9bb7125589e33bcf04048c8accadf277d7aaa160f12e3cfdd9301561a067b1ecaabf906ff4bb1bea17f09fbe1383a9b470bc69a3c03d0966fd91bfef14d":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: FS_READ, FS_LIST_PARTITIONS, IPC_SEND_PIPE, GET_LOCALE, GET_THEME, FS_BYPASS_PERMISSIONS, GET_USER_INFO\n// signature: ea6228fcad8ff9208d24d788e81cb81673e4d55501736b5bc481e3ff1e1f0be473f21c9cfb38b82f6689cc4abf5a2edcd6b2dc8b43036e87b1ab6492771f2c03\n// =====END MANIFEST=====\nlet ipcChannel = exec_args[0];\n(async function() {\n\t// @pcos-app-mode isolatable\n\tif (!ipcChannel) return availableAPIs.terminate();\n\tawait availableAPIs.windowTitleSet(await availableAPIs.lookupLocale(\"FILE_PICKER\"));\n\tdocument.body.style.fontFamily = \"'Segoe UI', Tahoma, Geneva, Verdana, sans-serif\";\n\tif (await availableAPIs.isDarkThemed()) document.body.style.color = \"white\";\n\tlet privileges = await availableAPIs.getPrivileges();\n\tlet checklist = [ \"FS_READ\", \"FS_LIST_PARTITIONS\", \"IPC_SEND_PIPE\" ];\n\tif (!checklist.every(p => privileges.includes(p))) {\n\t\tif (privileges.includes(\"IPC_SEND_PIPE\")) await availableAPIs.sendToPipe({ pipe: ipcChannel, data: { success: false, reason: \"permissions\" } });\n\t\treturn availableAPIs.terminate();\n\t}\n\tlet hideHiddenFiles = false;\n\ttry {\n\t\tlet homedir = (await availableAPIs.getUserInfo({ desiredUser: await availableAPIs.getUser() })).homeDirectory;\n\t\thideHiddenFiles = true;\n\t\thideHiddenFiles = (await availableAPIs.fs_read({\n\t\t\tpath: homedir + \"/.hiddenFiles\",\n\t\t})) != \"show\";\n\t} catch {}\n\tdocument.body.innerText = \"\";\n\tlet mainComponent = document.createElement(\"div\");\n\tlet pathInputForm = document.createElement(\"form\");\n\tlet pathElement = document.createElement(\"input\");\n\tpathElement.value = exec_args[2] || \"\";\n\tlet browseButton = document.createElement(\"button\");\n\tlet displayResult = document.createElement(\"div\");\n\tlet newItemInput = document.createElement(\"input\");\n\tlet newItemBrowse = document.createElement(\"button\");\n\tlet newItemContainer = document.createElement(\"div\");\n\tlet previousDirectory = \"\";\n\tlet isDefaultChoice = true;\n\tmainComponent.style.display = \"flex\";\n\tmainComponent.style.flexDirection = \"column\";\n\tmainComponent.style.width = \"100%\";\n\tmainComponent.style.height = \"100%\";\n\tmainComponent.style.position = \"absolute\";\n\tmainComponent.style.top = \"0\";\n\tmainComponent.style.left = \"0\";\n\tmainComponent.style.padding = \"8px\";\n\tmainComponent.style.boxSizing = \"border-box\";\n\tdisplayResult.style.flex = \"1\";\n\tnewItemBrowse.innerText = await availableAPIs.lookupLocale(\"SAVE_BTN\");\n\tnewItemContainer.appendChild(document.createElement(\"hr\"));\n\tnewItemContainer.appendChild(newItemInput);\n\tbrowseButton.innerText = await availableAPIs.lookupLocale(\"BROWSE_FEXP\");\n\tnewItemContainer.appendChild(newItemBrowse);\n\tpathInputForm.appendChild(pathElement);\n\tpathInputForm.appendChild(browseButton);\n\tmainComponent.appendChild(pathInputForm);\n\tmainComponent.appendChild(displayResult);\n\tmainComponent.appendChild(newItemContainer);\n\tdocument.body.appendChild(mainComponent);\n\tnewItemContainer.hidden = exec_args[1] != \"save\";\n\tasync function browse() {\n\t\tlet path = pathElement.value;\n\t\tif (path.endsWith(\"/\")) path = path.substring(0, path.length - 1);\n\t\tdisplayResult.innerText = \"\";\n\t\tif (path == \"\") {\n\t\t\tlet partitions = (await availableAPIs.fs_mounts()).sort((a, b) => a.localeCompare(b));\n\t\t\tfor (let partition of partitions) {\n\t\t\t\tif (partition.startsWith(\".\") && hideHiddenFiles) continue;\n\t\t\t\tlet openButton = document.createElement(\"button\");\n\t\t\t\topenButton.innerText = partition;\n\t\t\t\topenButton.onclick = function() {\n\t\t\t\t\tpathElement.value = partition;\n\t\t\t\t\tbrowse();\n\t\t\t\t}\n\t\t\t\tdisplayResult.appendChild(openButton);\n\t\t\t}\n\t\t\tpreviousDirectory = path;\n\t\t\treturn \"browsed\";\n\t\t}\n\t\ttry {\n\t\t\tlet type = await isDirectory(path);\n\t\t\tif (type == \"directory\") {\n\t\t\t\tlet ls = (await availableAPIs.fs_ls({ path: path })).sort((a, b) => a.localeCompare(b));\n\t\t\t\tfor (let file of ls) {\n\t\t\t\t\tif (file.startsWith(\".\") && hideHiddenFiles) continue;\n\t\t\t\t\tlet openButton = document.createElement(\"button\");\n\t\t\t\t\topenButton.innerText = file;\n\t\t\t\t\topenButton.onclick = function() {\n\t\t\t\t\t\tpathElement.value = path + \"/\" + file;\n\t\t\t\t\t\tbrowse();\n\t\t\t\t\t}\n\t\t\t\t\tdisplayResult.appendChild(openButton);\n\t\t\t\t}\n\t\t\t\tpreviousDirectory = path;\n\t\t\t} else if (type == \"file\" || (type == \"unknown\" && exec_args[1] == \"save\")) {\n\t\t\t\tif (isDefaultChoice) {\n\t\t\t\t\tpathElement.value = path.split(\"/\").slice(0, -1).join(\"/\");\n\t\t\t\t\tnewItemInput.value = path.split(\"/\").slice(-1)[0];\n\t\t\t\t\treturn browse();\n\t\t\t\t}\n\t\t\t\tdisplayResult.innerText = \"\";\n\t\t\t\tawait availableAPIs.sendToPipe({ pipe: ipcChannel, data: { success: true, selected: path } });\n\t\t\t\tawait availableAPIs.terminate();\n\t\t\t} else {\n\t\t\t\tdisplayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", (await availableAPIs.lookupLocale(\"UNKNOWN_FS_STRUCT\")).replace(\"%s\", type));\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tdisplayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", await availableAPIs.lookupLocale(e.message));\n\t\t}\n\t\tisDefaultChoice = false;\n\t}\n\tbrowse();\n\tbrowseButton.onclick = browse;\n\tnewItemBrowse.onclick = async function() {\n\t\tif (previousDirectory == \"\") return displayResult.innerText = (await availableAPIs.lookupLocale(\"FILE_STRUCT_BROWSE_FAIL\")).replace(\"%s\", await availableAPIs.lookupLocale(\"NO_SAVE_IN_MTN\"));\n\t\tpathElement.value = previousDirectory + \"/\" + newItemInput.value;\n\t\tbrowse();\n\t}\n})();\nasync function isDirectory(path) {\n\ttry {\n\t\tlet isDirectoryVar = await availableAPIs.fs_isDirectory({ path });\n\t\treturn isDirectoryVar ? \"directory\" : \"file\";\n\t} catch {\n\t\treturn \"unknown\";\n\t}\n}\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) {\n\t\ttry {\n\t\t\tawait availableAPIs.sendToPipe({ pipe: ipcChannel, data: { success: false, reason: \"closed\" } });\n\t\t} catch {}\n\t\tawait window.availableAPIs.terminate();\n\t}\n}); null;","51b0db677634efd56234f996162c104fc8eb35e3568355fd6a6ca7c2570320098c1069a10e6189154d48b9be9a675deecb7eb3252ffe054b35e31feefaca30ab":"{\"path\":\"system/apps/explorer.js\",\"localeReferenceName\":\"FILE_EXPLORER\"}","65e0c4b53ee364584eb31b101df3843810e0c4a1a7910d45ccb2cddda304bad804f2bb31bf7e0c905755df8ff561250f338e35052dd200f4f407e16489403e6b":"{\"path\":\"system/apps/textEditor.js\",\"localeReferenceName\":\"TEXT_EDITOR\"}","4ca86455118a08ca4c320642698b520b37875a1b30c5d8ae54e5fddae71e2bed22ac6426118dd63834eae773850073b43284ca016f389d810437dfa9e1cd7b19":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: FS_READ, FS_LIST_PARTITIONS, IPC_SEND_PIPE, IPC_LISTEN_PIPE, GET_LOCALE, GET_THEME, FS_BYPASS_PERMISSIONS, SYSTEM_SHUTDOWN, GET_USER_INFO, LOGOUT, GET_SCREEN_INFO, GRAB_ATTENTION, LULL_SYSTEM\n// signature: 2c289df2acf646fafd8899807e3db37300d9adebb173c6b61e9bd4ed3a5330b819dcefbc771fa2a80ee093c6a0f080e9016b31858b4515fb60011d447cb27a00\n// =====END MANIFEST=====\nlet ipcChannel;\nlet shouldShutdown = false;\nlet visibilityState = true;\nlet hexToU8A = (hex) => Uint8Array.from(hex.match(/.{1,2}/g).map(a => parseInt(a, 16)));\nlet u8aToHex = (u8a) => Array.from(u8a).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n(async function() {\n\t// @pcos-app-mode isolatable\n\tipcChannel = await availableAPIs.getPrivateData();\n\tif (!ipcChannel) return availableAPIs.terminate();\n\tawait visibility(false);\n\tawait window.availableAPIs.windowTitleSet(await window.availableAPIs.lookupLocale(\"START_MENU\"));\n\tdocument.body.style.fontFamily = \"'Segoe UI', Tahoma, Geneva, Verdana, sans-serif\";\n\tif (await availableAPIs.isDarkThemed()) document.body.style.color = \"white\";\n\tlet privileges = await availableAPIs.getPrivileges();\n\tlet checklist = [ \"FS_READ\", \"FS_LIST_PARTITIONS\", \"IPC_SEND_PIPE\", \"IPC_LISTEN_PIPE\" ];\n\tif (!checklist.every(p => privileges.includes(p))) return availableAPIs.terminate();\n\tawait availableAPIs.sendToPipe({ pipe: ipcChannel, data: { success: true } });\n\tdocument.body.innerText = \"\";\n\tlet logoutButton = document.createElement(\"button\");\n\tlogoutButton.innerText = (await availableAPIs.lookupLocale(\"LOG_OUT_BUTTON\")).replace(\"%s\", await availableAPIs.getUser());\n\tdocument.body.appendChild(logoutButton);\n\tlogoutButton.onclick = async function() {\n\t\tshouldShutdown = true;\n\t\tawait visibility(false);\n\t\tawait availableAPIs.logOut(await availableAPIs.getUser());\n\t}\n\tlet lockButton = document.createElement(\"button\");\n\tlockButton.innerText = await availableAPIs.lookupLocale(\"LOCK_BUTTON\");\n\tdocument.body.appendChild(lockButton);\n\tlockButton.onclick = async function() {\n\t\tawait visibility(false);\n\t\tawait availableAPIs.lock();\n\t}\n\tif (privileges.includes(\"SYSTEM_SHUTDOWN\")) {\n\t\tlet shutoff = document.createElement(\"button\");\n\t\tshutoff.innerText = await availableAPIs.lookupLocale(\"TURN_OFF_BUTTON\");\n\t\tdocument.body.appendChild(shutoff);\n\t\tshutoff.onclick = async function() {\n\t\t\tshouldShutdown = true;\n\t\t\tawait visibility(false);\n\t\t\tawait availableAPIs.shutdown({ isReboot: false });\n\t\t}\n\t\tlet reboot = document.createElement(\"button\");\n\t\treboot.innerText = await availableAPIs.lookupLocale(\"RESTART_BUTTON\");\n\t\tdocument.body.appendChild(reboot);\n\t\treboot.onclick = async function() {\n\t\t\tshouldShutdown = true;\n\t\t\tawait visibility(false);\n\t\t\tawait availableAPIs.shutdown({ isReboot: true, isKexec: true });\n\t\t}\n\t\treboot.oncontextmenu = async function(e) {\n\t\t\te.stopImmediatePropagation();\n\t\t\te.stopPropagation();\n\t\t\te.preventDefault();\n\t\t\tshouldShutdown = true;\n\t\t\tawait visibility(false);\n\t\t\tawait availableAPIs.shutdown({ isReboot: true, isKexec: false });\n\t\t}\n\t}\n\tif (privileges.includes(\"LULL_SYSTEM\")) {\n\t\tlet lull = document.createElement(\"button\");\n\t\tlull.innerText = await availableAPIs.lookupLocale(\"LULL_SYSTEM\");\n\t\tdocument.body.appendChild(lull);\n\t\tlull.onclick = async function() {\n\t\t\tawait visibility(false);\n\t\t\tawait availableAPIs.lull();\n\t\t}\n\t}\n\ttry {\n\t\tlet enumeration = (await availableAPIs.fs_ls({ path: (await availableAPIs.getSystemMount()) + \"/apps/links\" })).sort((a, b) => a.localeCompare(b));\n\t\tfor (let app of enumeration) {\n\t\t\tlet appLink = await availableAPIs.fs_read({ path: (await availableAPIs.getSystemMount()) + \"/apps/links/\" + app });\n\t\t\tappLink = JSON.parse(appLink);\n\t\t\tif (appLink.disabled) continue;\n\t\t\tlet appBtn = document.createElement(\"button\");\n\t\t\tappBtn.innerText = (appLink.localeReferenceName ? await availableAPIs.lookupLocale(appLink.localeReferenceName) : null) || (appLink.localeDatabaseName ? (appLink.localeDatabaseName[navigator.language.slice(0, 2).toLowerCase()] || appLink.localeDatabaseName[await availableAPIs.osLocale()]) : null) || appLink.name;\n\t\t\tappBtn.title = await availableAPIs.lookupLocale(\"PROVISIONED_PREFERENCE\");\n\t\t\tappBtn.onclick = async function() {\n\t\t\t\tawait visibility(false);\n\t\t\t\tawait availableAPIs.sendToPipe({ pipe: ipcChannel, data: { run: appLink } });\n\t\t\t}\n\t\t\tdocument.body.appendChild(appBtn);\n\t\t}\n\t} catch (e) {\n\t\tconsole.error(\"Failed to enumerate system app links\", e);\n\t}\n\ttry {\n\t\tlet enumeration = await availableAPIs.fs_ls({ path: (await availableAPIs.getUserInfo({ desiredUser: await availableAPIs.getUser() })).homeDirectory + \"/.applinks\" });\n\t\tfor (let app of enumeration) {\n\t\t\tlet appLink = await availableAPIs.fs_read({ path: (await availableAPIs.getUserInfo({ desiredUser: await availableAPIs.getUser() })).homeDirectory + \"/.applinks/\" + app });\n\t\t\tappLink = JSON.parse(appLink);\n\t\t\tif (appLink.disabled) continue;\n\t\t\tlet appBtn = document.createElement(\"button\");\n\t\t\tappBtn.innerText = (appLink.localeReferenceName ? await availableAPIs.lookupLocale(appLink.localeReferenceName) : null) || (appLink.localeDatabaseName ? (appLink.localeDatabaseName[navigator.language.slice(0, 2).toLowerCase()] || appLink.localeDatabaseName[await availableAPIs.osLocale()]) : null) || appLink.name;\n\t\t\tappBtn.onclick = async function() {\n\t\t\t\tawait visibility(false);\n\t\t\t\tawait availableAPIs.sendToPipe({ pipe: ipcChannel, data: { run: appLink } });\n\t\t\t}\n\t\t\tdocument.body.appendChild(appBtn);\n\t\t}\n\t} catch (e) {\n\t\tconsole.error(\"Failed to enumerate user app links\", e);\n\t}\n\n\tonresize = shapeshift;\n\n\twhile (true) {\n\t\tlet listen = await availableAPIs.listenToPipe(ipcChannel);\n\t\tif (listen.open) {\n\t\t\tawait visibility();\n\t\t\tshapeshift();\n\t\t}\n\t}\n})();\n\nasync function visibility(wantedState) {\n\tif (!wantedState) wantedState = !visibilityState;\n\tif (wantedState == visibilityState) return;\n\tawait availableAPIs.windowVisibility(wantedState);\n\tvisibilityState = wantedState;\n}\n\nasync function shapeshift() {\n\tlet screenInfo = await availableAPIs.getScreenInfo();\n\tlet winSize = await availableAPIs.windowSize();\n\tawait availableAPIs.windowRelocate([ screenInfo.height - (winSize.height / 2) - 35 - 8, winSize.width / 2 + 8 ]);\n}\n\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) {\n\t\tawait visibility(false);\n\t\tawait availableAPIs.sendToPipe({ pipe: ipcChannel, data: { dying: true } });\n\t\tawait availableAPIs.terminate();\n\t}\n}); null;","f02338bfde94ec987b039fc009d7341a33b481c8c8ed1437e63759a1a2fac427e6c86828a384f483629a7a9a0b415c5c01ce385420d288d45003ae6169621fed":"// =====BEGIN MANIFEST=====\n// link: lrn:TEXT_EDITOR\n// association: txt\n// signer: automaticSigner\n// allow: FS_READ, FS_WRITE, FS_LIST_PARTITIONS, IPC_CREATE_PIPE, IPC_LISTEN_PIPE, GET_LOCALE, GET_THEME, START_TASK, IPC_SEND_PIPE, FS_BYPASS_PERMISSIONS, GET_USER_INFO\n// signature: e9ad0f530dd0fde2e47b6a333a796d1e3caffb162a07b28052b5ea182eea00b1e8d10d82c553de364af48fdf9eadb10bacac949d7e30e4bce37392b86df56408\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.windowTitleSet(await availableAPIs.lookupLocale(\"TEXT_EDITOR\"));\n\tdocument.body.style.fontFamily = \"'Segoe UI', Tahoma, Geneva, Verdana, sans-serif\";\n\tif (await availableAPIs.isDarkThemed()) document.body.style.color = \"white\";\n\tdocument.documentElement.style.height = \"100%\";\n\tdocument.documentElement.style.width = \"100%\";\n\tdocument.body.style.height = \"100%\";\n\tdocument.body.style.width = \"100%\";\n\tdocument.body.style.margin = \"0\";\n\tlet flexContainer = document.createElement(\"div\");\n\tlet buttonContainer = document.createElement(\"div\");\n\tlet loadButton = document.createElement(\"button\");\n\tlet saveButton = document.createElement(\"button\");\n\tlet statusMessage = document.createElement(\"span\");\n\tlet data = document.createElement(\"textarea\");\n\tlet hr = document.createElement(\"hr\");\n\tlet hrContainer = document.createElement(\"div\");\n\tlet lastFile = \"\";\n\tloadButton.innerText = await availableAPIs.lookupLocale(\"LOAD_BTN\");\n\tsaveButton.innerText = await availableAPIs.lookupLocale(\"SAVE_BTN\");\n\tflexContainer.style.display = \"flex\";\n\tflexContainer.style.flexDirection = \"column\";\n\tflexContainer.style.width = \"100%\";\n\tflexContainer.style.height = \"100%\";\n\tdata.style.flexGrow = 1000;\n\tdata.style.resize = \"none\";\n\tif (await availableAPIs.isDarkThemed()) {\n\t\tdata.style.backgroundColor = \"#2b2a33\";\n\t\tdata.style.color = \"white\";\n\t}\n\tbuttonContainer.appendChild(loadButton);\n\tbuttonContainer.appendChild(saveButton);\n\tbuttonContainer.appendChild(statusMessage);\n\thrContainer.appendChild(hr);\n\tflexContainer.appendChild(buttonContainer);\n\tflexContainer.appendChild(hrContainer);\n\tflexContainer.appendChild(data);\n\tdocument.body.appendChild(flexContainer);\n\ttry {\n\t\tif (exec_args[0]) {\n\t\t\tdata.value = await availableAPIs.fs_read({ path: exec_args[0] });\n\t\t\tlastFile = exec_args[0];\n\t\t\tstatusMessage.innerText = exec_args[0].split(\"/\").pop();\n\t\t}\n\t} catch (e) {\n\t\tstatusMessage.innerText = e.name + \": \" + e.message;\n\t}\n\tloadButton.onclick = async function() {\n\t\tlet ipcPipe = await availableAPIs.createPipe();\n\t\tawait availableAPIs.windowVisibility(false);\n\t\tawait availableAPIs.startTask({ file: (await availableAPIs.getSystemMount()) + \"/apps/filePicker.js\", argPassed: [ipcPipe, \"load\", lastFile] });\n\t\tlet result = await availableAPIs.listenToPipe(ipcPipe);\n\t\tawait availableAPIs.closePipe(ipcPipe);\n\t\tawait availableAPIs.windowVisibility(true);\n\t\ttry {\n\t\t\tif (result.success) {\n\t\t\t\tdata.value = await availableAPIs.fs_read({ path: result.selected });\n\t\t\t\tlastFile = result.selected;\n\t\t\t\tstatusMessage.innerText = result.selected.split(\"/\").pop();\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tstatusMessage.innerText = e.name + \": \" + e.message;\n\t\t}\n\t}\n\tsaveButton.onclick = async function() {\n\t\tlet ipcPipe = await availableAPIs.createPipe();\n\t\tawait availableAPIs.windowVisibility(false);\n\t\tawait availableAPIs.startTask({ file: (await availableAPIs.getSystemMount()) + \"/apps/filePicker.js\", argPassed: [ipcPipe, \"save\", lastFile] });\n\t\tlet result = await availableAPIs.listenToPipe(ipcPipe);\n\t\tawait availableAPIs.closePipe(ipcPipe);\n\t\tawait availableAPIs.windowVisibility(true);\n\t\ttry {\n\t\t\tif (result.success) {\n\t\t\t\tawait availableAPIs.fs_write({ path: result.selected, data: data.value });\n\t\t\t\tlastFile = result.selected;\n\t\t\t\tstatusMessage.innerText = result.selected.split(\"/\").pop();\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tstatusMessage.innerText = e.name + \": \" + e.message;\n\t\t}\n\t}\n})();\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); null;","67c5fc94109604848393677451d2edf34a6937b94153e1502d5f173b0238bfc0d8cc025b80219a1d64acac758a06a8c15f10613986da5dcdf4522b2fa932890c":"{\n\t\"basic\": \"7f00000150434f53334e6574776f726b\",\n\t\"pc\": \"7f00000150434f53334e6574776f726b\"\n}"},"buildInfo":{"for":"1332","version":"1332","when":1751657439197,"signer":"moduleSigner","critical":true,"bootOrder":"50","signature":"1b3abd377564126b380f6f7bfb781c4d0f1d11bff53c74d3b48a33a298894e69302b5a65c518947de85e2e1e31550223f29a68703490d0dce2a278ec62add50f"}},"50-locale-en.fs":{"backend":{"files":{"boot":{"06-localesappend-en.js":"3d09f8bab8e6265b3adf767fe2f7f30c401a508ed2857fb0110ad5910cb6144a2286bd770c9aa5b595213db1f89410ee1625418850ae4ec3a5f8a0232c2109a0"}},"permissions":{"boot/06-localesappend-en.js":{"world":"rx"},"boot/":{"world":"rx"},"":{"world":"rx"}}},"files":{"3d09f8bab8e6265b3adf767fe2f7f30c401a508ed2857fb0110ad5910cb6144a2286bd770c9aa5b595213db1f89410ee1625418850ae4ec3a5f8a0232c2109a0":"modules.locales.en = {\n\t\"UNTITLED_APP\": \"Untitled program\",\n\t\"PERMISSION_DENIED\": \"Permission denied\",\n\t\"MORE_PERMISSION_DENIED\": \"There are not enough permissions to run this program.\",\n\t\"COMPATIBILITY_ISSUE_TITLE\": \"Compatibility issue\",\n\t\"COMPATIBILITY_ISSUE\": \"This program cannot run on this computer as a task. Check the application modes to include \\\"isolatable\\\".\",\n\t\"APP_STARTUP_CRASH_TITLE\": \"Something went wrong\",\n\t\"APP_STARTUP_CRASH\": \"The system failed to execute this program.\",\n\t\"JS_TERMINAL\": \"JavaScript Terminal\",\n\t\"TERMINAL_INVITATION\": \"PCOS 3, build %s\",\n\t\"PCOS_RESTARTING\": \"PCOS is restarting. %s\",\n\t\"PLEASE_WAIT\": \"Please wait.\",\n\t\"POLITE_CLOSE_SIGNAL\": \"Sending polite close.\",\n\t\"ABRUPT_CLOSE_SIGNAL\": \"Sending abrupt close.\",\n\t\"UNMOUNTING_MOUNTS\": \"Unmounting mounts.\",\n\t\"SAFE_TO_CLOSE\": \"It is now safe to close this tab.\",\n\t\"RESTART_BUTTON\": \"Reboot\",\n\t\"RESTARTING\": \"Restarting.\",\n\t\"INSTALL_PCOS\": \"Install PCOS\",\n\t\"INSTALLER_TITLE\": \"PCOS 3 Installer\",\n\t\"CLOSE_INSTALLER_CONFIRMATION\": \"Are you sure you want to stop the installation process? This computer will restart.\",\n\t\"YES\": \"Yes\",\n\t\"NO\": \"No\",\n\t\"INSTALLER_INVITATION\": \"You are installing PCOS 3 build %s on this computer.\",\n\t\"INSTALL_BUTTON\": \"Install\",\n\t\"LIVE_BUTTON\": \"Try out\",\n\t\"INSTALLER_PARTITIONING\": \"Select the boot and data partitions you would like to use.\",\n\t\"PARTITIONING_USE\": \"Use partitions\",\n\t\"PARTITION_DATA\": \"Data partition\",\n\t\"PARTITION_BOOT\": \"Boot partition\",\n\t\"FORMAT_DATA\": \"Format to PCFS\",\n\t\"DATA_INPUT_ALERT\": \"Please enter a data partition name.\",\n\t\"PROMPT_PARTITION_TABLE\": \"This disk does not seem to contain a valid partition table. Do you want to insert a partition table?\",\n\t\"CONFIRM_PARTITION_ERASE\": \"All data on that partition will be erased. Continue?\",\n\t\"BOOT_INPUT_ALERT\": \"Please enter a boot partition name.\",\n\t\"CANNOT_FIND_PARTITION\": \"Can't find a disk partition. Please try formatting the data partition to PCFS.\",\n\t\"PCFS_DETECTION_ERROR\": \"The data partition doesn't seem to contain PCFS. Do you still want to use it?\",\n\t\"INSTALLING_PCOS\": \"Installing PCOS: %s\",\n\t\"CREATING_BOOT_PARTITION\": \"Creating boot partition\",\n\t\"MOUNTING_DATA_PARTITION\": \"Mounting data partition as 'target'\",\n\t\"CHANGING_ROOT_PERMISSIONS\": \"Changing / permissions\",\n\t\"COPYING_FOLDERS\": \"Copying directories\",\n\t\"PREPARING_FOR_COPY\": \"Preparing for copying\",\n\t\"PATCHING_FS\": \"Patching for data mount\",\n\t\"INSTALLATION_SUCCESSFUL\": \"Successful installation. Close window to reboot.\",\n\t\"INSTALLATION_FAILED\": \"Installation of PCOS failed. Please try again. Close window to reboot.\",\n\t\"CREATING_DIR\": \"Creating %s\",\n\t\"COPYING_FILE\": \"Copying %s\",\n\t\"COMPLETE_COPY\": \"Complete copying %s\",\n\t\"REMOVING_OBJECT\": \"Removing %s\",\n\t\"COMPLETE_REMOVE\": \"Complete removing %s\",\n\t\"SHORT_DAYS\": \"%sd\",\n\t\"SHORT_HOURS\": \"%sh\",\n\t\"SHORT_MINUTES\": \"%smin\",\n\t\"SHORT_SECONDS\": \"%ss\",\n\t\"SHORT_MILLISECONDS\": \"%sms\",\n\t\"SHORT_TERABYTES\": \"%sTB\",\n\t\"SHORT_GIGABYTES\": \"%sGB\",\n\t\"SHORT_MEGABYTES\": \"%sMB\",\n\t\"SHORT_KILOBYTES\": \"%sKB\",\n\t\"SHORT_BYTES\": \"%sB\",\n\t\"AUTH_FAILED_NEW\": \"Authentication failed, please use a new instance!\",\n\t\"AUTH_SUCCESS\": \"Authentication successful.\",\n\t\"AUTH_FAILED\": \"Authentication failed.\",\n\t\"PLEASE_WAIT_TIME\": \"Please wait %s\",\n\t\"REPORTING_LOGON\": \"Reporting logon to server...\",\n\t\"TOTP_PC_PROMPT\": \"Enter TOTP-PC code\",\n\t\"TOTP_PROMPT\": \"Enter TOTP code\",\n\t\"ACCESS_NOT_SETUP\": \"Access to this user is not set up\",\n\t\"PASSWORD_PROMPT\": \"Enter password\",\n\t\"ENTER_BUTTON\": \"Enter\",\n\t\"USERNAME_PROMPT\": \"Enter an username.\",\n\t\"USERNAME\": \"Username\",\n\t\"ACCESS_FN_FAIL\": \"No such user.\",\n\t\"PROMPT_GET_FAIL\": \"Something went wrong while getting the authentication prompt.\",\n\t\"LET_TRY_AGAIN\": \"Let's try again.\",\n\t\"RESPONSE_PLACEHOLDER\": \"Response...\",\n\t\"START_MENU_BTN\": \"Start\",\n\t\"START_MENU\": \"Start menu\",\n\t\"LOG_IN_INVITATION\": \"Log in\",\n\t\"LOG_OUT_BUTTON\": \"Log out (%s)\",\n\t\"LOCK_BUTTON\": \"Lock\",\n\t\"TERMINAL_BUTTON\": \"Terminal\",\n\t\"TURN_OFF_BUTTON\": \"Turn off\",\n\t\"PASSWORD\": \"Password\",\n\t\"SET_UP_PCOS\": \"Set up PCOS\",\n\t\"LET_SETUP_SYSTEM\": \"Let's set up the system now.\",\n\t\"SET_UP\": \"Set up\",\n\t\"LET_CREATE_ACCOUNT\": \"Let's create your own user account.\",\n\t\"CREATE\": \"Create\",\n\t\"PASSWORD_INPUT_ALERT\": \"Please enter a password!\",\n\t\"SETUP_SUCCESSFUL\": \"Successful setup. Close window to log in.\",\n\t\"CREATING_USER_STRUCTURE\": \"Creating user structure\",\n\t\"CREATING_USER\": \"Creating user\",\n\t\"INSTALLING_WPS\": \"Installing wallpapers\",\n\t\"INSTALLING_APPS\": \"Installing programs\",\n\t\"INSTALLING_WP2U\": \"Installing wallpaper to user\",\n\t\"REMOVING_2STAGE\": \"Removing second-stage installer\",\n\t\"PATCHING_LOGON\": \"Patching for logon requirement\",\n\t\"CONFIRM\": \"Confirm\",\n\t\"RIGHT_REVIEW\": \"Let's review your rights.\",\n\t\"RIGHT_REVIEW_BTN\": \"Accept license\",\n\t\"DARK_MODE\": \"Dark mode\",\n\t\"INSTALLING_DARKMODE\": \"Installing dark mode preference\",\n\t\"CREATING_USER_HOME\": \"Creating user home directory\",\n\t\"PROVISIONED_PREFERENCE\": \"This setting is managed by the system administrator.\",\n\t\"USERNAME_EXISTS\": \"This user already exists in the system.\",\n\t\"VIDEO_PLAYER\": \"Video player\",\n\t\"INACCESSIBLE_FILE\": \"%s is inaccessible. Ensure you have permissions to access it, and that the object exists.\",\n\t\"FILE_NOT_SPECIFIED\": \"No file specified.\",\n\t\"PICTURE_VIEWER\": \"Picture viewer\",\n\t\"API_TEST_TERM\": \"API Developer's Terminal\",\n\t\"HELP_TERMINAL_APITEST\": \"help - Display help menu\\r\\nclear - Clear terminal\\r\\njs_ree - Execute JavaScript code\\r\\n--- REE API EXPORTS ---\\r\\n\",\n\t\"TERM_COMMAND_NOT_FOUND\": \"%s: command not found\",\n\t\"FILE_EXPLORER\": \"File explorer\",\n\t\"GRANT_FEXP_PERM\": \"Please grant permissions to read file structures and list partitions.\",\n\t\"GRANT_PERM\": \"Grant permissions\",\n\t\"GRANT_FEXP_PERM_ADM\": \"Please consult the administrator to grant privileges to this program to read file structures and list partitions. (FS_READ, FS_LIST_PARTITIONS)\",\n\t\"GRANT_FEXP_PERM_USR\": \"Please grant permissions to read file structures and list partitions using a different user.\",\n\t\"BROWSE_FEXP\": \"Browse\",\n\t\"SPACE_SHOWER\": \"Space in \\\"%s\\\": %s used of %s (%s%)\",\n\t\"FILE_STRUCT_BROWSE_FAIL\": \"Could not browse to this structure:\\n%s\",\n\t\"UNKNOWN_FS_STRUCT\": \"Unknown filesystem structure \\\"%s\\\"\",\n\t\"UNKNOWN_FILE_TYPE\": \"This is an unknown file type.\",\n\t\"TMGR_PERMISSION\": \"Task manager was not permitted to run under this condition. Please contact the system administrator.\\nRequired privileges: %s\",\n\t\"TASK_MANAGER\": \"Task manager\",\n\t\"BASENAME_TASK\": \"Basename\",\n\t\"USER_TASK\": \"User\",\n\t\"TERMINATE_TASK\": \"Terminate\",\n\t\"FULL_PATH_TASK\": \"Full path\",\n\t\"ARGUMENTS_TASK\": \"Arguments\",\n\t\"REMOVING_SETUP_STATE\": \"Removing setup status\",\n\t\"LOGGING_OUT\": \"Logging out...\",\n\t\"PANIC_LINE1\": \"A critical problem has been detected while using the operating system. Its stability is at risk now.\",\n\t\"PANIC_LINE2\": \"Problem code: %s\",\n\t\"PANIC_UNSPECIFIED_ERROR\": \"UNSPECIFIED_ERROR\",\n\t\"PROBLEMATIC_COMPONENT\": \"Problematic component: %s\",\n\t\"PROBLEMATIC_PARAMS\": \"Problematic parameters: %s\",\n\t\"PROBLEMATIC_JS\": \"Problematic JavaScript: %s: %s\",\n\t\"PANIC_LINE3\": \"If you have seen this error message the first time, attempt rebooting.\",\n\t\"PANIC_LINE4\": \"If you see this error message once more, there is something wrong with the system.\",\n\t\"PANIC_LINE5\": \"You can try repairing the filesystem by placing a .fsck file on the system root mountpoint, with the value \\\"recover\\\" in it.\",\n\t\"PANIC_LINE6\": \"Proper shutdown procedure follows now:\",\n\t\"PANIC_TASK_KILLED\": \"task:%s: killed\",\n\t\"PANIC_MOUNT_UNMOUNTED\": \"mount:%s: unmounted\",\n\t\"PANIC_MOUNT_FAILED\": \"mount:%s: %s: %s\",\n\t\"SHORT_YEARS\": \"%sy\",\n\t\"SHORT_MONTHS\": \"%smo\",\n\t\"SYSADMIN_TOOLS_TITLE\": \"Sysadmin Tools\",\n\t\"SYSADMIN_TOOLS_PRIVFAIL\": \"You are not a system administrator.\",\n\t\"REINSTALL_BUTTON\": \"Reinstall OS\",\n\t\"FSCK_BUTTON\": \"Recover lost files\",\n\t\"SWIPE_BUTTON\": \"Wipe system securely\",\n\t\"REINSTALL_DOWNLOADING\": \"Downloading local os.js...\",\n\t\"REINSTALL_DOWNLOAD_FAILED\": \"Failed to download local os.js.\",\n\t\"REINSTALL_DECODING\": \"Parsing os.js as text\",\n\t\"REINSTALL_SETTING\": \"Setting os.js as bootloader\",\n\t\"REMOVING_INSTALLERS\": \"Removing installers...\",\n\t\"SETTING_FSCK_FLAG\": \"Creating .fsck file\",\n\t\"SETTING_FSCK_FLAG_FAILED\": \"Failed to create .fsck file.\",\n\t\"WIPING_SYSTEM\": \"Securely wiping system...\",\n\t\"WIPING_SYSTEM_FAILED\": \"Failed to securely wipe system.\",\n\t\"WORKING_HOURS_UNMET\": \"You attempted to log in outside of your working hours. Try again later.\",\n\t\"NETCONFIG_TITLE\": \"PCOS Network configurator\",\n\t\"NETCONFIG_DENY\": \"There are not enough permissions to configure PCOS Network.\",\n\t\"NETCONFIG_URLF\": \"Proxy URL: \",\n\t\"NETCONFIG_AUTO\": \"Start on OS startup\",\n\t\"NETCONFIG_UC\": \"Customizable: \",\n\t\"NETCONFIG_SAVE\": \"Save config\",\n\t\"NETCONFIG_PREDICT\": \"Predict address\",\n\t\"EMPTY_STATUSBAR\": \"Status\",\n\t\"NETCONFIG_SAVE_OK\": \"Configuration saved successfully\",\n\t\"NETCONFIG_SAVE_FAIL\": \"Failed to save config\",\n\t\"PCOS_STARTING\": \"PCOS is starting...\",\n\t\"FILE_PICKER\": \"File picker\",\n\t\"TEXT_EDITOR\": \"Text editor\",\n\t\"LOAD_BTN\": \"Load\",\n\t\"SAVE_BTN\": \"Save\",\n\t\"NETCONFIG_SYSIDM\": \"No System ID available\",\n\t\"NO_SAVE_IN_MTN\": \"You can't save in the mountpoint directory.\",\n\t\"INSTALLING_WP2L\": \"Installing wallpaper to lock screen\",\n\t\"EXIT\": \"Exit\",\n\t\"DESCRIPTION_FIELD\": \"Description: %s\",\n\t\"REMOVE_BTN\": \"Remove\",\n\t\"UNMOUNT_BTN\": \"Unmount\",\n\t\"INSTALLING_DARKMODE2L\": \"Installing dark mode preference to lock screen\",\n\t\"MESSAGE_ENTER\": \"Enter a message to display\",\n\t\"TIMEOUT_FIELD\": \"Timeout (ms)\",\n\t\"SECRET_FIELD_TXT\": \"Secret (text)\",\n\t\"SECRET_FIELD_HEX\": \"Secret (hex)\",\n\t\"REGENERATE\": \"Regenerate\",\n\t\"START_TIME_FIELD\": \"Start time\",\n\t\"END_TIME_FIELD\": \"End time\",\n\t\"PBKDF2_OPTION\": \"PBKDF2 (Password)\",\n\t\"INFORMATIVE_MESSAGE_OPTION\": \"Informative message\",\n\t\"INFORMATIVE_MESSAGE_DENY_OPTION\": \"Informative message (deny)\",\n\t\"TIMEOUT_OPTION\": \"Timeout\",\n\t\"TIMEOUT_DENY_OPTION\": \"Timeout (deny)\",\n\t\"SERVER_REPORT_OPTION\": \"Server reporting\",\n\t\"PCTOTP_OPTION\": \"PC's TOTP interpretation\",\n\t\"RFCTOTP_OPTION\": \"RFC TOTP\",\n\t\"WORKING_HOURS_OPTION\": \"Working hours\",\n\t\"PERSONAL_SECURITY_TITLE\": \"Personal Security\",\n\t\"PERSONAL_SECURITY_DENY\": \"Not enough privileges were granted for Personal Security.\",\n\t\"ADD_BTN\": \"Add\",\n\t\"OS_LOCALE\": \"en\",\n\t\"SYSTEM_SECURITY_TITLE\": \"System Security\",\n\t\"SYSTEM_SECURITY_DENY\": \"Not enough privileges were granted for System Security.\",\n\t\"EDIT\": \"Edit\",\n\t\"USER_GROUPS\": \"Groups\",\n\t\"USER_HOMEDIR\": \"Home directory\",\n\t\"REMOVE_USER_WITH_HD\": \"Remove user with home directory\",\n\t\"CREATE_HD\": \"Create home directory\",\n\t\"CREATING_HD_OK\": \"The home directory was created successfully.\",\n\t\"CREATING_HD_FAIL\": \"Failed to create the home directory.\",\n\t\"SIGNATURE_VERIFICATION_FAILED\": \"This program claims it is trusted by %s, but the system failed to verify that claim.\",\n\t\"UNKNOWN_PLACEHOLDER\": \"<Unknown>\",\n\t\"NO_APP_ALLOWLIST\": \"The system administrator requires programs to have an allowlist of permissions, but this program didn't have that list.\",\n\t\"DISCARD_BUTTON\": \"Discard lost files\",\n\t\"MOUNTPOINT\": \"Mountpoint\",\n\t\"GENERATE_PROMPT\": \"Generate?\",\n\t\"MOUNT_BUTTON\": \"Mount\",\n\t\"NEW_DIR_NAME\": \"New directory name\",\n\t\"MKDIR_BUTTON\": \"Create directory\",\n\t\"CHOWN_BUTTON\": \"Change owner\",\n\t\"CHGRP_BUTTON\": \"Change group\",\n\t\"CHMOD_BUTTON\": \"Change permissions\",\n\t\"CLIPBOARD_COPY\": \"Copy\",\n\t\"CLIPBOARD_CUT\": \"Cut\",\n\t\"CLIPBOARD_PASTE\": \"Paste\",\n\t\"CLIPBOARD_SOURCE_GONE\": \"The source no longer exists or is no longer a file.\",\n\t\"CLIPBOARD_CONFLICT\": \"The destination directory already has a file or directory with the same name.\",\n\t\"SAFE_MODE_MSG\": \"Safe mode\",\n\t\"INSTALLING_SFX\": \"Installing sound effects\",\n\t\"APP_OR_KEY_SIGNATURE_VERIFICATION_FAILED\": \"Signature verification for the program or the key signing the program failed.\",\n\t\"NO_SUCH_DEVICE\": \"No such device\",\n\t\"READ_ONLY_BMGR\": \"Writes restricted by boot manager.\",\n\t\"READ_ONLY_DEV\": \"Device is read-only\",\n\t\"NO_DIRECTORY_SUPPORT\": \"Device does not support directories\",\n\t\"NO_PERMIS_SUPPORT\": \"Device does not support permissions\",\n\t\"IS_A_DIR\": \"Is a directory\",\n\t\"NO_SUCH_FILE\": \"No such file\",\n\t\"NO_SUCH_DIR\": \"No such directory\",\n\t\"NO_SUCH_FILE_DIR\": \"No such file or directory\",\n\t\"NON_EMPTY_DIR\": \"Non-empty directory\",\n\t\"IS_A_FILE\": \"Is a file\",\n\t\"DIR_EXISTS\": \"Directory already exists\",\n\t\"FS_ACTION_FAILED\": \"Failed to perform this file system action.\",\n\t\"UNAUTHORIZED_ACTION\": \"The program does not have permissions to perform this action.\",\n\t\"CREATION_CHECK_FAILED\": \"Failed to check if this object is being created.\",\n\t\"PERMISSION_CHANGE_FAILED\": \"Failed to change permissions for this object.\",\n\t\"UPDATE_EXTRA_FAIL\": \"Failed to update apps, wallpapers, sounds.\",\n\t\"UPDATE_BOOT_FAIL\": \"Failed to update boot files.\",\n\t\"UPDATE_BUTTON\": \"Update OS\",\n\t\"TOGGLE_HIDDEN_FILES\": \"Hide/unhide files\",\n\t\"AUTORUN_NECESSITIES_FAILED\": \"Failed to run one of your autorun files. The system will not log you in.\",\n\t\"CRYPTO_TOOLS_TITLE\": \"Cryptographic Tools\",\n\t\"CRYPTO_TOOLS_NOPERM\": \"Not enough privileges were given to use Cryptographic Tools.\",\n\t\"CRYPTO_RNG\": \"Random generation\",\n\t\"CRYPTO_HASH\": \"Hashing\",\n\t\"CRYPTO_KEYGEN\": \"Key generation\",\n\t\"CRYPTO_ENCRYPT\": \"Encryption\",\n\t\"CRYPTO_DECRYPT\": \"Decryption\",\n\t\"CRYPTO_SIGN\": \"Signing\",\n\t\"CRYPTO_VERIFY\": \"Verification\",\n\t\"CRYPTO_DERIVEBITS\": \"Bit derivation\",\n\t\"GENERATE\": \"Generate\",\n\t\"RAW_HEX_DATA\": \"Raw data (hex)\",\n\t\"CRYPTO_HASH_FIELD\": \"Hash algorithm: \",\n\t\"CRYPTO_PLAINTEXT_FIELD\": \"Plaintext: \",\n\t\"ALGORITHM_FIELD\": \"Algorithm: \",\n\t\"LENGTH_FIELD\": \"Length: \",\n\t\"CRYPTO_NC_FIELD\": \"Named curve: \",\n\t\"IMPORT_AS_FIELD\": \"Import as: \",\n\t\"CRYPTO_KEY_FIELD\": \"Key: \",\n\t\"CRYPTO_CIPHERTEXT_FIELD\": \"Ciphertext (hex): \",\n\t\"CRYPTO_SIGNATURE_FIELD\": \"Signature (hex): \",\n\t\"CRYPTO_KEYGEN_MSG\": \"Generating key(s)...\",\n\t\"CRYPTO_KEYGEN_SYMM\": \"Is a symmetric key type\",\n\t\"CRYPTO_KEYGEN_EXPFAIL\": \"Export failed, check export settings\",\n\t\"CRYPTO_RNGOUT_FIELD\": \"Random numbers (hex): \",\n\t\"CRYPTO_KEYGEN_ACTION\": \"Generate key(s)\",\n\t\"CRYPTO_HASH_ACTION\": \"Hash\",\n\t\"CRYPTO_ENCRYPT_ACTION\": \"Encrypt\",\n\t\"CRYPTO_DECRYPT_ACTION\": \"Decrypt\",\n\t\"CRYPTO_SIGN_ACTION\": \"Sign\",\n\t\"CRYPTO_VERIFY_ACTION\": \"Verify\",\n\t\"CRYPTO_DERIVEBITS_ACTION\": \"Derive bits\",\n\t\"CRYPTO_PUBKEY_FIELD\": \"Public key: \",\n\t\"CRYPTO_PRIVKEY_FIELD\": \"Private key: \",\n\t\"CRYPTO_BASEKEY_FIELD\": \"Base key: \",\n\t\"CRYPTO_HASHOUT_FIELD\": \"Hash value (hex): \",\n\t\"CRYPTO_MODLEN_FIELD\": \"Modulus length: \",\n\t\"CRYPTO_PUBEXP_FIELD\": \"Public exponent (hex): \",\n\t\"EXPORT_AS_FIELD\": \"Export as: \",\n\t\"CRYPTO_KEYUSE_FIELD\": \"Key usages:\",\n\t\"CRYPTO_PLAINTEXTAS_FIELD\": \"Process plaintext as: \",\n\t\"CRYPTO_IV_FIELD\": \"IV (hex): \",\n\t\"CRYPTO_CTR_FIELD\": \"Counter (hex): \",\n\t\"CRYPTO_VERIFIED_CHECKBOX\": \"Verified successfully\",\n\t\"CRYPTO_SALT_FIELD\": \"Salt (hex): \",\n\t\"CRYPTO_DERIVEOUT_FIELD\": \"Derived bits (hex): \",\n\t\"CRYPTO_ITERATIONS_FIELD\": \"Iterations: \",\n\t\"PATH_INCLUDES_EMPTY\": \"The specified path includes an object with an empty name.\",\n\t\"BASIC_CURL_USAGE\": \"Usage: basiccurl [source] [output]\",\n\t\"BASIC_CURL_DESCRIPTION\": \"Downloads the specified source and saves it to the specified output.\",\n\t\"NO_ARGUMENTS\": \"No arguments specified\",\n\t\"CAT_USAGE\": \"Usage: cat [file1] <file2> <file3> ... <fileN>\",\n\t\"CAT_DESCRIPTION\": \"Concatenates the specified files and outputs to CLI output\",\n\t\"CHGRP_USAGE\": \"Usage: chgrp [group] [file]\",\n\t\"CHGRP_DESCRIPTION\": \"Changes the owning group of the specified file\",\n\t\"CHMOD_USAGE\": \"Usage: chmod [mode] [file]\",\n\t\"CHMOD_DESCRIPTION\": \"Changes what everyone may do with the specified file\",\n\t\"CHMOD_MODE_DESCRIPTION\": \"[mode] may consist of characters r (Read), w (Write) and x (eXecute).\",\n\t\"CHMOD_MODE_CONVERT\": \"[mode] number to string table: 0 - \\\"\\\", 1 - \\\"x\\\", 2 - \\\"w\\\", 3 - \\\"wx\\\", 4 - \\\"r\\\", 5 - \\\"rx\\\", 6 - \\\"rw\\\", 7 - \\\"rwx\\\"\",\n\t\"CHOWN_USAGE\": \"Usage: chown [user] [file]\",\n\t\"CHOWN_DESCRIPTION\": \"Changes the owning user of the specified file\",\n\t\"CP_USAGE\": \"Usage: cp <options> [source] [destination]\",\n\t\"CP_DESCRIPTION\": \"Copies files or directories from the source to the destination.\",\n\t\"OPT_RECURSIVE_DESCRIPTION\": \"--recursive: run on directories\",\n\t\"OPT_FORCE_DESCRIPTION\": \"--force: do not fail immediately in case of an error\",\n\t\"ARGUMENT_COUNT_MISMATCH\": \"Too much or not enough arguments\",\n\t\"DF_HEADER\": \"Medium\\tSize\\tUsed\\tAvail\\tUse%\",\n\t\"LS_USAGE\": \"Usage: ls [directory]\",\n\t\"LS_DESCRIPTION\": \"Lists the contents of the specified directory.\",\n\t\"LS_MOUNTPOINT_LIST\": \"You have the following mountpoints: \",\n\t\"MOUNTPOINT_SYSTEM\": \"system\",\n\t\"PASSWD_NEW_PROMPT\": \"Setting a new password for your user account.\",\n\t\"PASSWD_2FACTOR_LOSS_WARN\": \"Any previously set up additional factors will be removed.\",\n\t\"PASSWD_PROMPT\": \"New password: \",\n\t\"PASSWD_CONFIRM_PROMPT\": \"Re-enter password: \",\n\t\"PASSWD_FEEDBACK\": \"New password set\",\n\t\"PASSWD_MISMATCH\": \"Sorry, passwords do not match.\",\n\t\"PING_USAGE\": \"Usage: ping <--internet> [networkAddress]\",\n\t\"PING_DESCRIPTION\": \"Sends a request to the specified address to verify its availability.\",\n\t\"PING_INTERNET_OPTION\": \"--internet: send a ping to the Internet instead of PCOS Network\",\n\t\"PIVOT_ROOT_USAGE\": \"Usage: pivot_root [mountpoint]\",\n\t\"PIVOT_ROOT_DESCRIPTION\": \"Makes the specified mountpoint the new default system mountpoint for every program.\",\n\t\"REAL_TERMINAL_NAME\": \"Terminal\",\n\t\"REAL_TERMINAL_BUILTIN_LIST\": \"Built-in commands:\",\n\t\"REAL_TERMINAL_HELP_USEDESC\": \"help - Display the list, description and usage of all available built-in commands.\",\n\t\"REAL_TERMINAL_CLEAR_USEDESC\": \"clear - Clear everything displayed on the terminal right now.\",\n\t\"REAL_TERMINAL_SUGRAPH_USEDESC\": \"sugraph <desiredUsername> - Switch the terminal user using a graphical utility.\",\n\t\"REAL_TERMINAL_SU_USEDESC\": \"su <desiredUsername> - Switch the terminal user.\",\n\t\"REAL_TERMINAL_GRAPHIC_USEDESC\": \"graphic <boolean> - Enable or disable running new applications outside of background.\",\n\t\"REAL_TERMINAL_EXIT_USEDESC\": \"exit - Exit the terminal.\",\n\t\"REAL_TERMINAL_LOGON_REQUIRED\": \"(internal): You must run sugraph %s before running this program.\",\n\t\"RM_USAGE\": \"Usage: rm <options> [file]\",\n\t\"RM_DESCRIPTION\": \"Removes the specified file or directory.\",\n\t\"RKL_USAGE\": \"Usage: runKlvlCode [codeFile]\",\n\t\"RKL_DESCRIPTION\": \"Runs the specified code file in the kernel level.\",\n\t\"WRITE_USAGE\": \"Usage: write [file] [data]\",\n\t\"WRITE_DESCRIPTION\": \"Writes data to the specified file.\",\n\t\"CP_PERMISSIONS_OPTION\": \"--permissions: сopy the permissions of the original files\",\n\t\"REAL_TERMINAL_DEFAULT_PATH_FIELD\": \"Default path: %s\",\n\t\"REAL_TERMINAL_PUSHPATH_USEDESC\": \"pushpath [path] - Add a new path to explore to find commands.\",\n\t\"REAL_TERMINAL_RESETPATH_USEDESC\": \"resetpath - Reset the list of paths to explore to the default path.\",\n\t\"REAL_TERMINAL_LSPATH_USEDESC\": \"lspath - See the current list of paths to explore and the default path.\",\n\t\"MKDIR_USAGE\": \"Usage: mkdir [directory]\",\n\t\"MKDIR_DESCRIPTION\": \"Creates a new directory in the specified path.\",\n\t\"NEXT\": \"Next\",\n\t\"DESCRIBE_TEMPLATE\": \"Program: %s (%s)\\nIntent: %s\",\n\t\"EXTRA_DESCRIBE_TEMPLATE\": \"Program: %s (%s)\\nArguments: %s\\nIntent: %s\",\n\t\"DECLINE\": \"Decline\",\n\t\"ACCESS_REQUEST_TITLE\": \"Access request\",\n\t\"REAL_TERMINAL_INTENT\": \"Launch commands with your permissions\",\n\t\"PERSONAL_SECURITY_INTENT\": \"Manage your security settings\",\n\t\"FILE_EXPLORER_INTENT\": \"Launch programs and open files\",\n\t\"FILE_EXPLORER_FULL_INTENT\": \"Browse files, launch programs, and open files\",\n\t\"CRYPTO_TOOLS_INTENT\": \"Perform cryptographic operations\",\n\t\"SYSTEM_SECURITY_INTENT\": \"Management of the system-wide user account setup\",\n\t\"FORMAT_USAGE\": \"Usage: format [filesystem_type] [partition] <overwrite>\",\n\t\"FORMAT_DESCRIPTION\": \"Prepares the selected partition for use.\",\n\t\"FORMAT_FSTYPE\": \"Filesystem types: pcfs (corresponds to mountpoint PCFSiDBMount), pcfs_crypt (PCFSiDBAESCryptMount), pcfs_crypt_monokey (PCFSiDBAESCryptMount), pcfs_crypt_filetable_monokey (PCFSiDBAESCryptMount), pcbm:<data_partition> (like code in boot partition), null (DELETE the partition)\",\n\t\"FORMAT_OVERWRITE_WARN\": \"The partition already contains data. Set the overwrite parameter to 'overwrite' to remove data anyway. In that case, ALL DATA ON THE PARTITION MAY BE REMOVED.\",\n\t\"FORMAT_UNKNOWN_FSTYPE\": \"Unknown target formatting\",\n\t\"LLDA_USAGE\": \"Usage: llda_tool [action] [parameters]\",\n\t\"LLDA_ACTION_EXPORT\": \"action export: [input partition] [output file]\",\n\t\"LLDA_ACTION_IMPORT\": \"action import: [input file] [output partition]\",\n\t\"LLDA_ACTION_IMPORTSTRING\": \"action importstring: [input file] [output partition]\",\n\t\"LLDA_ACTION_COPY\": \"action copy: [input partition] [output partition]\",\n\t\"LLDA_ACTION_REMOVE\": \"action remove: [partition]\",\n\t\"LLDA_ACTION_LIST\": \"action list\",\n\t\"LLDA_DISCLAIMER\": \"When using this tool you may encounter LOSS OF DATA!\",\n\t\"LLDA_UNKNOWN_ACTION\": \"Unknown action\",\n\t\"INITDISK_OVERWRITE_WARN\": \"The system disk already contains partitioning data. Set the overwrite parameter to 'overwrite' to remove data anyway. In that case, ALL DATA ON THE DISK MAY BE REMOVED.\",\n\t\"INITDISK_USAGE\": \"Usage: initdisk [whatever] <overwrite>\",\n\t\"INITDISK_DESCRIPTION\": \"Prepares the system disk for use.\",\n\t\"MOUNT_USAGE\": \"Usage: mount [options] [fs_type] [mountpoint]\",\n\t\"MOUNT_DESCRIPTION\": \"Mounts a filesystem.\",\n\t\"MOUNT_KNOWN_FS\": \"Known filesystems: %s\",\n\t\"MOUNT_KNOWN_PPART\": \"--partition=[dataPartition] - Specify the data partition\",\n\t\"MOUNT_KNOWN_PINPA\": \"--interactivePassword - Ask for the password interactively\",\n\t\"MOUNT_KNOWN_PPASS\": \"--password=[password] - Specify the password\",\n\t\"MOUNT_KNOWN_PKEY\": \"--key=[hexKey] - Specify the encryption key\",\n\t\"MOUNT_KNOWN_PTYPE\": \"--type=[type] - For ramMount, specify type=run to create /run\",\n\t\"MOUNT_KNOWN_PURL\": \"--url=[URL] - Specify the URL\",\n\t\"MOUNT_KNOWN_PINPI\": \"--inputPipeId=[pipeId] - Specify the input pipe\",\n\t\"MOUNT_KNOWN_POUPI\": \"--outputPipeId=[pipeId] - Specify the output pipe\",\n\t\"MOUNTINFO_USAGE\": \"Usage: mountinfo [mountpoint]\",\n\t\"MOUNTINFO_DESCRIPTION\": \"Get information about a mountpoint.\",\n\t\"UMOUNT_USAGE\": \"Usage: umount <options> [mountpoint]\",\n\t\"UMOUNT_DESCRIPTION\": \"Unmounts a filesystem.\",\n\t\"UMOUNT_OPT_SYNCONLY\": \"--sync-only - Only sync the filesystem, not unmount (overrides --force)\",\n\t\"UMOUNT_OPT_FORCE\": \"--force - Force unmount the filesystem, do not sync\",\n\t\"CALC_TITLE\": \"Calculator\",\n\t\"CALC_BASIC_MODE\": \"Calculator: Basic mode\",\n\t\"CALC_ADVANCED_MODE\": \"Calculator: Advanced mode\",\n\t\"CALC_ADD\": \"Add\",\n\t\"CALC_SUBTRACT\": \"Subtract\",\n\t\"CALC_MULTIPLY\": \"Multiply\",\n\t\"CALC_DIVIDE\": \"Divide\",\n\t\"CALC_ADVMODE_BTN\": \"Advanced mode\",\n\t\"CALC_BASICMODE_BTN\": \"Basic mode\",\n\t\"CALC_OPERAND\": \"Operand %s\",\n\t\"CALC_TOMIXED_BTN\": \"Convert to mixed fraction\",\n\t\"CALC_TOIMPR_BTN\": \"Convert to improper fraction\",\n\t\"CALC_GCD\": \"GCD\",\n\t\"CALC_FACTORIAL\": \"Factorial\",\n\t\"CALC_GCD_PAGE\": \"Greatest common divisor\",\n\t\"ZKPP_OPTION\": \"ZKPP (Password)\",\n\t\"SECONDSTAGE_INSTALLER_INTENT\": \"Complete the OS configuration\",\n\t\"SETUP_FAILED\": \"Setting up PCOS failed. Please try again by rebooting.\",\n\t\"WARNING_PRIVILEGES\": \"Be careful with this feature! You may compromise system security.\",\n\t\"USER_EXT_PRIVILEGES\": \"Extended privilege set\",\n\t\"LULL_SYSTEM\": \"Sleep mode\",\n\t\"SYSTEM_IMAGING\": \"System imaging\",\n\t\"CREATE_IMAGE\": \"Create system image\",\n\t\"RESTORE_IMAGE\": \"Restore system image\",\n\t\"SELECT_FILE_PROMPT\": \"Select file: \",\n\t\"REBOOT_ON_RESTORE\": \"Reboot after restoring\",\n\t\"MERGE_STATES\": \"Merge image states\",\n\t\"LISTING_PARTITIONS_FAILED\": \"Failed to list partitions.\",\n\t\"READING_PARTITION_FAILED\": \"Failed to read partition %s\",\n\t\"LISTING_DATA_FAILED\": \"Failed to list data.\",\n\t\"READING_DATA_FAILED\": \"Failed to read data.\",\n\t\"WRITING_IMAGE_FAILED\": \"Failed to write image.\",\n\t\"SUCCESSFUL_OP\": \"The process was successfully completed.\",\n\t\"FAILED_OP\": \"The process has failed.\",\n\t\"READING_IMAGE_FAILED\": \"Failed to read image.\",\n\t\"WRITING_PARTITION_FAILED\": \"Failed to write partition %s\",\n\t\"WRITING_DATA_FAILED\": \"Failed to write data.\",\n\t\"DELETING_PARTITION_FAILED\": \"Failed to delete partition %s\",\n\t\"DELETING_DATA_FAILED\": \"Failed to delete data.\",\n\t\"SHUTTING_DOWN_FAILED\": \"Failed to shut the system down.\",\n\t\"NETWORK_STATUS_ONLINE\": \"You are connected to a local area network.\",\n\t\"NETWORK_STATUS_OFFLINE\": \"You aren't connected to any sort of network.\",\n\t\"PCOS_NETWORK_STATUS_ONLINE\": \"You are connected to PCOS Network. (hostname: %s, address: %s)\",\n\t\"PCOS_NETWORK_STATUS_OFFLINE\": \"You are disconnected from PCOS Network.\",\n\t\"PCOS_NETWORK_STATUS_STOPPED\": \"The PCOS Network service was stopped.\",\n\t\"START_MENU_FAILED\": \"The start menu has failed to launch. You can log out instead.\",\n\t\"SYSTEM_BUILT_AT\": \"System built at %s\",\n\t\"REAL_TERMINAL_VER_USEDESC\": \"ver - Show the build version and time\",\n\t\"BLANK_PRIVILEGE_FLAG\": \"Blank user privileges\",\n\t\"INSTALLING_SYSTEM_APPHARDEN\": \"Installing program security rules\",\n\t\"INSTALLING_NET_CONF\": \"Installing PCOS Network configuration\",\n\t\"NETWORK_ADDRESS_FIELD\": \"Network address: %s\",\n\t\"NETWORK_AUTOHOST_FIELD\": \"Automatic hostname: %s\",\n\t\"NETCONFIG_HOSTNAME\": \"Hostname: \",\n\t\"DIFF_USAGE\": \"Usage: diff [original] [new] [difference]\",\n\t\"DIFF_DESCRIPTION\": \"Calculates the difference between two files.\",\n\t\"PATCH_USAGE\": \"Usage: patch [original] [difference] [new]\",\n\t\"PATCH_DESCRIPTION\": \"Calculates the 'sum' of the original and the difference.\",\n\t\"CURRENT_OSFILE_VERSION\": \"Current OS file version: build %s\",\n\t\"DOWNLOADING_OS_PATCH\": \"Downloading OS file patch from %s (address %s)\",\n\t\"HANDOFF_UPDATE\": \"Handing off the update process to updateos.js\",\n\t\"SYSTEM_UP_TO_DATE\": \"The system is up to date\",\n\t\"POWER_USAGE\": \"Usage: power <options> <r|reboot|restart|k|kexec>\",\n\t\"POWER_DESCRIPTION\": \"Powers down or restarts the system. Supplying nothing to power makes a shutdown.\",\n\t\"POWER_FORCE\": \"--force: don't wait for processes, reboot or power down immediately\",\n\t\"POWER_KEXEC\": \"--kexec: reboot without reloading the page or firmware (automatically toggles reboot)\",\n\t\"UPDATEFW_BUTTON\": \"Update firmware\",\n\t\"UPDATEFW_DOWNLOADING\": \"Downloading local init.js...\",\n\t\"UPDATEFW_DOWNLOAD_FAILED\": \"Failed to download local init.js.\",\n\t\"UPDATEFW_DECODING\": \"Parsing init.js as text\",\n\t\"UPDATEFW_SETTING\": \"Setting init.js as firmware\",\n\t\"ADDUSER_USAGE\": \"Usage: adduser <options> [username]\",\n\t\"ADDUSER_DESCRIPTION\": \"Creates a new user account.\",\n\t\"ADDUSER_SKIP_PASSWD\": \"--skip-passwd: don't prompt for a password\",\n\t\"ADDUSER_SKIP_HOME\": \"--skip-home: don't create a home directory\",\n\t\"ADDUSER_GROUPS\": \"--groups: group to add (specify multiple times for multiple groups)\",\n\t\"ADDUSER_HOME\": \"--home: custom home directory\",\n\t\"NEW_USER_CREATION\": \"Creating new user \\\"%s\\\"\",\n\t\"BLOCKUSER_USAGE\": \"Usage: blockuser <username>\",\n\t\"BLOCKUSER_DESCRIPTION\": \"Blocks a user account.\",\n\t\"DELUSER_USAGE\": \"Usage: deluser <options> [username]\",\n\t\"DELUSER_DESCRIPTION\": \"Deletes a user account.\",\n\t\"DELUSER_HOMEDIR\": \"--homedir: delete the home directory\",\n\t\"OLD_USER_DELETION\": \"Deleting old user \\\"%s\\\"\",\n\t\"BATTERY_STATUS_UNAVAILABLE\": \"The battery status is unavailable.\",\n\t\"BATTERY_STATUS_CHARGING\": \"The battery is charging (%s%, %suntil full)\",\n\t\"BATTERY_STATUS_DISCHARGING\": \"The battery is discharging (%s%, %sof play)\",\n\t\"PATCH_HUNK_COUNT\": \"Patch hunks: %s\",\n\t\"SERVER_SIGNATURE_VERIFICATION_FAILED\": \"Signature verification for the server failed.\",\n\t\"NETWORK_UNREACHABLE\": \"Network is unreachable.\",\n\t\"ADDRESS_UNREACHABLE\": \"Address is unreachable.\",\n\t\"NETWORK_CLOSED\": \"The network has closed.\",\n\t\"CONNECTION_DROPPED\": \"The connection has been dropped.\",\n\t\"BLOG_BROWSER_NAME\": \"Blog Browser\",\n\t\"BLOG_BROWSER_LOADING\": \"Hold on, loading this page...\",\n\t\"BLOG_BROWSER_PROTO\": \"There's no such protocol. This version only supports the bdp:// protocol.\",\n\t\"BLOG_BROWSER_GATESET\": \"To set a connful gate, use the username part of the URL: bdp://gate@myblog.pc\",\n\t\"HOSTNAME_RESOLUTION_FAILED\": \"Failed to resolve hostname.\",\n\t\"BLOG_BROWSER_POSTCLOSE\": \"This interactive post has been closed.\",\n\t\"BLOG_BROWSER_FILEPOST\": \"This is a file post. You can save it to this system.\",\n\t\"BLOG_BROWSER_DLFILEPOST\": \"You have downloaded this file post.\",\n\t\"BLOG_BROWSER_LOADING_PROGRESS\": \"Loading this post (%s of %s chunks received)\",\n\t\"BLOG_BROWSER_NOVERIFY\": \"You have enabled an option to disable the verification of the server. This is not recommended as the network proxy can execute a man-in-the-middle attack and see your information. Would you let that happen?\",\n\t\"BLOG_BROWSER_NOSANDBOX\": \"You have enabled an option to pass through all APIs of your operating system. This is not recommended as the blog post can do anything as if it were the blog browser application. Would you let that happen?\",\n\t\"NETWORKFS_USAGE\": \"Usage: networkfs <options> [url] [mountpoint]\",\n\t\"NETWORKFS_DESCRIPTION\": \"Mounts a filesystem available over PCOS Network.\",\n\t\"NETWORKFS_NOVERIFY\": \"--no-verification: Don't verify the server's key\",\n\t\"NETWORKFS_KEY\": \"--key=[path]: Path to key for mutual verification\",\n\t\"NETWORKFS_PROTO\": \"This version only supports the netfs:// protocol.\",\n\t\"NETCONFIG_UPDATES\": \"Updates from: \",\n\t\"NETWORK_UPDATES_FIELD\": \"Updates from: %s\",\n\t\"LOCALE_NAME\": \"English\",\n\t\"SETTING_LOCALE_PREFERENCE\": \"Setting locale preference\",\n\t\"LANGUAGE_SELECT\": \"Your language: \",\n\t\"CHANGE_LOCALE\": \"Change language\",\n\t\"INSTALLER_INTENT\": \"Start the OS installation\",\n\t\"MOUNT_EXISTS\": \"Mount already exists\",\n\t\"INSECURE_MODE_MSG\": \"Insecure configuration!\",\n\t\"MODULE_REQUIRED\": \"The module \\\"%s\\\" is required for this function. Contact the system administrator.\",\n\t\"CREATING_DIRECTORY_STRUCTURE\": \"Creating directory structures\",\n\t\"GENERATING_KERNEL\": \"Generating system kernel\",\n\t\"WORK_IN_PROGRESS_AFTER_MODULAR\": \"This function is a work-in-progress after modularization.\",\n\t\"REGENERATE_KERNEL\": \"Regenerate system kernel\",\n\t\"REGENERATING_KERNEL_FAILED\": \"Failed to regenerate system kernel\",\n\t\"TECHNICAL_LIMITATIONS\": \"This file can't be created due to technical limitations.\"\n};\n"},"buildInfo":{"for":"1332","version":"1332","when":1751657439208,"signer":"moduleSigner","critical":false,"bootOrder":"50","signature":"c262d83fbf175d8dcbe060b2f9075715e3eac2d7f9cb83b321d71fdc53c5c558247363d033e6016058c2663d6cb118955c26f217de7ac87d17235bb8b1d1ce00"}},"50-locale-ru.fs":{"backend":{"files":{"boot":{"06-localesappend-ru.js":"9bfef015f7be0eba1e7bff1930435f2f708e8ce2d1b534a42298ab628a043b986254b6ba9dd11096c748ac5a6e3d8ecae8e46c66ab6be6199839fa1420d35620"}},"permissions":{"boot/06-localesappend-ru.js":{"world":"rx"},"boot/":{"world":"rx"},"":{"world":"rx"}}},"files":{"9bfef015f7be0eba1e7bff1930435f2f708e8ce2d1b534a42298ab628a043b986254b6ba9dd11096c748ac5a6e3d8ecae8e46c66ab6be6199839fa1420d35620":"modules.locales.ru = {\n\t\"UNTITLED_APP\": \"Безымянная программа\",\n\t\"PERMISSION_DENIED\": \"Отказано в доступе\",\n\t\"MORE_PERMISSION_DENIED\": \"Недостаточно прав для запуска этой программы.\",\n\t\"COMPATIBILITY_ISSUE_TITLE\": \"Проблема с совместимостью\",\n\t\"COMPATIBILITY_ISSUE\": \"Эта программа не может запускаться на этом компьютере как задача. Проверьте, есть ли у приложения режим \\\"isolatable\\\".\",\n\t\"APP_STARTUP_CRASH_TITLE\": \"Что-то пошло не так\",\n\t\"APP_STARTUP_CRASH\": \"Системе не удалось запустить эту программу.\",\n\t\"JS_TERMINAL\": \"Терминал JavaScript\",\n\t\"TERMINAL_INVITATION\": \"PCOS 3, сборка %s\",\n\t\"PCOS_RESTARTING\": \"PCOS перезагружается. %s\",\n\t\"PLEASE_WAIT\": \"Пожалуйста, подождите.\",\n\t\"POLITE_CLOSE_SIGNAL\": \"Отправка сигнала закрытия.\",\n\t\"ABRUPT_CLOSE_SIGNAL\": \"Отправка аварийного закрытия.\",\n\t\"UNMOUNTING_MOUNTS\": \"Размонтирование точек монтирования.\",\n\t\"SAFE_TO_CLOSE\": \"Теперь эту вкладку можно закрыть.\",\n\t\"RESTART_BUTTON\": \"Перезапустить\",\n\t\"RESTARTING\": \"Выполняется перезагрузка.\",\n\t\"INSTALL_PCOS\": \"Установить PCOS\",\n\t\"INSTALLER_TITLE\": \"Установщик PCOS 3\",\n\t\"CLOSE_INSTALLER_CONFIRMATION\": \"Вы уверены, что хотите остановить установку? Этот компьютер перезапустится.\",\n\t\"YES\": \"Да\",\n\t\"NO\": \"Нет\",\n\t\"INSTALLER_INVITATION\": \"Вы устанавливаете PCOS 3 сборки %s на этом компьютере.\",\n\t\"INSTALL_BUTTON\": \"Установить\",\n\t\"LIVE_BUTTON\": \"Попробовать\",\n\t\"INSTALLER_PARTITIONING\": \"Выберите разделы загрузки и данных, которые вы хотите использовать.\",\n\t\"PARTITIONING_USE\": \"Использовать разделы\",\n\t\"PARTITION_DATA\": \"Раздел данных\",\n\t\"PARTITION_BOOT\": \"Раздел загрузки\",\n\t\"FORMAT_DATA\": \"Форматировать в PCFS\",\n\t\"DATA_INPUT_ALERT\": \"Введите имя раздела данных.\",\n\t\"PROMPT_PARTITION_TABLE\": \"Этот диск, кажется, не содержит таблицу разделов. Вы хотите вставить таблицу разделов?\",\n\t\"CONFIRM_PARTITION_ERASE\": \"Все данные на этом разделе будут удалены. Продолжить?\",\n\t\"BOOT_INPUT_ALERT\": \"Введите имя раздела загрузки.\",\n\t\"CANNOT_FIND_PARTITION\": \"Не удаётся найти раздел диска. Попробуйте форматировать раздел данных в PCFS.\",\n\t\"PCFS_DETECTION_ERROR\": \"Раздел данных, кажется, не содержит PCFS. Вы хотите использовать его?\",\n\t\"INSTALLING_PCOS\": \"Установка PCOS: %s\",\n\t\"CREATING_BOOT_PARTITION\": \"Создание раздела загрузки\",\n\t\"MOUNTING_DATA_PARTITION\": \"Монтирование раздела данных как 'target'\",\n\t\"CHANGING_ROOT_PERMISSIONS\": \"Изменение разрешений /\",\n\t\"COPYING_FOLDERS\": \"Копирование каталогов\",\n\t\"PREPARING_FOR_COPY\": \"Подготовка к копированию\",\n\t\"PATCHING_FS\": \"Изменение для монтирования раздела данных\",\n\t\"INSTALLATION_SUCCESSFUL\": \"Установка успешна. Закройте окно для перезагрузки.\",\n\t\"INSTALLATION_FAILED\": \"Установка не удалась. Попробуйте ещё раз. Закройте окно для перезагрузки.\",\n\t\"CREATING_DIR\": \"Создание %s\",\n\t\"COPYING_FILE\": \"Копирование %s\",\n\t\"COMPLETE_COPY\": \"Копирование %s завершено\",\n\t\"REMOVING_OBJECT\": \"Удаление %s\",\n\t\"COMPLETE_REMOVE\": \"Удаление %s завершено\",\n\t\"SHORT_DAYS\": \"%sдн\",\n\t\"SHORT_HOURS\": \"%sч\",\n\t\"SHORT_MINUTES\": \"%sмин\",\n\t\"SHORT_SECONDS\": \"%sс\",\n\t\"SHORT_MILLISECONDS\": \"%sмс\",\n\t\"SHORT_TERABYTES\": \"%sТБ\",\n\t\"SHORT_GIGABYTES\": \"%sГБ\",\n\t\"SHORT_MEGABYTES\": \"%sМБ\",\n\t\"SHORT_KILOBYTES\": \"%sКБ\",\n\t\"SHORT_BYTES\": \"%sБ\",\n\t\"AUTH_FAILED_NEW\": \"Аутентификация не удалась, пожалуйста, используйте новую сессию!\",\n\t\"AUTH_SUCCESS\": \"Аутентификация успешна!\",\n\t\"AUTH_FAILED\": \"Аутентификация не удалась.\",\n\t\"PLEASE_WAIT_TIME\": \"Пожалуйста, подождите %s\",\n\t\"REPORTING_LOGON\": \"Сообщаю о входе в систему серверу...\",\n\t\"TOTP_PC_PROMPT\": \"Введите код TOTP-PC\",\n\t\"TOTP_PROMPT\": \"Введите код TOTP\",\n\t\"ACCESS_NOT_SETUP\": \"Доступ к данному пользователю не настроен\",\n\t\"PASSWORD_PROMPT\": \"Введите пароль\",\n\t\"ENTER_BUTTON\": \"Ввод\",\n\t\"USERNAME_PROMPT\": \"Введите имя пользователя\",\n\t\"USERNAME\": \"Имя пользователя\",\n\t\"ACCESS_FN_FAIL\": \"Нет такого пользователя.\",\n\t\"PROMPT_GET_FAIL\": \"Что-то пошло не так при получении вопроса аутентификации.\",\n\t\"LET_TRY_AGAIN\": \"Давайте попробуем ещё раз.\",\n\t\"RESPONSE_PLACEHOLDER\": \"Ответ...\",\n\t\"START_MENU_BTN\": \"Пуск\",\n\t\"START_MENU\": \"Меню \\\"Пуск\\\"\",\n\t\"LOG_IN_INVITATION\": \"Войти в систему\",\n\t\"LOG_OUT_BUTTON\": \"Выйти (%s)\",\n\t\"LOCK_BUTTON\": \"Заблокировать\",\n\t\"TERMINAL_BUTTON\": \"Терминал\",\n\t\"TURN_OFF_BUTTON\": \"Выключить\",\n\t\"PASSWORD\": \"Пароль\",\n\t\"SET_UP_PCOS\": \"Настройка PCOS\",\n\t\"LET_SETUP_SYSTEM\": \"Давайте теперь настроим систему.\",\n\t\"SET_UP\": \"Настроить\",\n\t\"LET_CREATE_ACCOUNT\": \"Давайте создадим вашу учётную запись.\",\n\t\"CREATE\": \"Создать\",\n\t\"PASSWORD_INPUT_ALERT\": \"Введите пароль.\",\n\t\"SETUP_SUCCESSFUL\": \"Настройка успешна. Закройте окно для входа в систему.\",\n\t\"CREATING_USER_STRUCTURE\": \"Создание структуры пользователей\",\n\t\"CREATING_USER\": \"Создание пользователя\",\n\t\"INSTALLING_WPS\": \"Установка фонов\",\n\t\"INSTALLING_APPS\": \"Установка программ\",\n\t\"INSTALLING_WP2U\": \"Установка фона на пользователя\",\n\t\"REMOVING_2STAGE\": \"Удаление установщика 2-го этапа\",\n\t\"PATCHING_LOGON\": \"Изменение для требования входа в систему\",\n\t\"CONFIRM\": \"Подтвердить\",\n\t\"RIGHT_REVIEW\": \"Давайте рассмотрим ваши права.\",\n\t\"RIGHT_REVIEW_BTN\": \"Принять лицензию\",\n\t\"DARK_MODE\": \"Тёмная тема\",\n\t\"INSTALLING_DARKMODE\": \"Установка предпочтения тёмной темы\",\n\t\"CREATING_USER_HOME\": \"Создание домашнего каталога пользователя\",\n\t\"PROVISIONED_PREFERENCE\": \"Эта настройка управляется системным администратором.\",\n\t\"USERNAME_EXISTS\": \"Этот пользователь уже существует в системе.\",\n\t\"VIDEO_PLAYER\": \"Видеопроигрыватель\",\n\t\"INACCESSIBLE_FILE\": \"%s недоступен. Убедитесь, что у вас есть разрешения на доступ к нему, и что объект существует.\",\n\t\"FILE_NOT_SPECIFIED\": \"Файл не указан.\",\n\t\"PICTURE_VIEWER\": \"Просмотр изображений\",\n\t\"API_TEST_TERM\": \"Терминал API-разработчика\",\n\t\"HELP_TERMINAL_APITEST\": \"help - Показать справочное меню\\r\\nclear - Очистить терминал\\r\\njs_ree - Запустить код JavaScript\\r\\n--- ЭКСПОРТИРОВАННЫЕ ИПП СОВ ---\\r\\n\",\n\t\"TERM_COMMAND_NOT_FOUND\": \"%s: команда не найдена\",\n\t\"FILE_EXPLORER\": \"Проводник\",\n\t\"GRANT_FEXP_PERM\": \"Пожалуйста, предоставьте разрешения на чтение файловых структур и просмотр списка разделов.\",\n\t\"GRANT_PERM\": \"Предоставить разрешения\",\n\t\"GRANT_FEXP_PERM_ADM\": \"Свяжитесь с администратором, чтобы предоставить разрешения на чтение файловых структур и просмотр списка разделов. (FS_READ, FS_LIST_PARTITIONS)\",\n\t\"GRANT_FEXP_PERM_USR\": \"Пожалуйста, предоставьте разрешения на чтение файловых структур и просмотр списка разделов используя иную учётную запись.\",\n\t\"BROWSE_FEXP\": \"Просмотр\",\n\t\"SPACE_SHOWER\": \"Хранение в \\\"%s\\\": использовано %s из %s (%s%)\",\n\t\"FILE_STRUCT_BROWSE_FAIL\": \"Невозможно просмотреть структуру:\\n%s\",\n\t\"UNKNOWN_FS_STRUCT\": \"Неизвестная файловая структура \\\"%s\\\"\",\n\t\"UNKNOWN_FILE_TYPE\": \"Это неизвестный тип файла.\",\n\t\"TMGR_PERMISSION\": \"Диспетчеру задач не разрешено запускаться при этих условиях. Свяжитесь с системным администратором\\nТребуемые разрешения: %s\",\n\t\"TASK_MANAGER\": \"Диспетчер задач\",\n\t\"BASENAME_TASK\": \"Имя\",\n\t\"USER_TASK\": \"Пользователь\",\n\t\"TERMINATE_TASK\": \"Завершить\",\n\t\"FULL_PATH_TASK\": \"Полный путь\",\n\t\"ARGUMENTS_TASK\": \"Параметры\",\n\t\"REMOVING_SETUP_STATE\": \"Удаление статуса установки\",\n\t\"LOGGING_OUT\": \"Выход из системы...\",\n\t\"PANIC_LINE1\": \"При использовании операционной системы была обнаружена критическая ошибка. Стабильность системы под угрозой.\",\n\t\"PANIC_LINE2\": \"Код ошибки: %s\",\n\t\"PANIC_UNSPECIFIED_ERROR\": \"НЕУКАЗАННАЯ_ОШИБКА\",\n\t\"PROBLEMATIC_COMPONENT\": \"Проблемный компонент: %s\",\n\t\"PROBLEMATIC_PARAMS\": \"Проблемные параметры: %s\",\n\t\"PROBLEMATIC_JS\": \"Проблемный JavaScript: %s: %s\",\n\t\"PANIC_LINE3\": \"Если вы видите эту ошибку в первый раз, попробуйте перезагрузить систему.\",\n\t\"PANIC_LINE4\": \"Если вы видите эту ошибку ещё раз, это значит, что что-то не так с системой.\",\n\t\"PANIC_LINE5\": \"Вы можете попытаться восстановить файловую систему, расположив файл .fsck в корневой точке монтирования системы, со значением \\\"recover\\\" в нём.\",\n\t\"PANIC_LINE6\": \"Далее выполняется процедура завершения работы:\",\n\t\"PANIC_TASK_KILLED\": \"задача:%s: убита\",\n\t\"PANIC_MOUNT_UNMOUNTED\": \"точка:%s: размонтирована\",\n\t\"PANIC_MOUNT_FAILED\": \"точка:%s: %s: %s\",\n\t\"SHORT_YEARS\": \"%sг\",\n\t\"SHORT_MONTHS\": \"%sмес\",\n\t\"SYSADMIN_TOOLS_TITLE\": \"Утилиты для сисадминов\",\n\t\"SYSADMIN_TOOLS_PRIVFAIL\": \"Вы не являетесь системным администратором.\",\n\t\"REINSTALL_BUTTON\": \"Переустановить ОС\",\n\t\"FSCK_BUTTON\": \"Восстановить потерянные файлы\",\n\t\"SWIPE_BUTTON\": \"Безопасно удалить систему\",\n\t\"REINSTALL_DOWNLOADING\": \"Скачивание местного os.js...\",\n\t\"REINSTALL_DOWNLOAD_FAILED\": \"Не удалось скачать местный os.js.\",\n\t\"REINSTALL_DECODING\": \"Обработка os.js как текст\",\n\t\"REINSTALL_SETTING\": \"Задание os.js как загрузчика\",\n\t\"REMOVING_INSTALLERS\": \"Удаление установщиков...\",\n\t\"SETTING_FSCK_FLAG\": \"Создание файла .fsck...\",\n\t\"SETTING_FSCK_FLAG_FAILED\": \"Не удалось создать файл .fsck.\",\n\t\"WIPING_SYSTEM\": \"Безопасное удаление системы...\",\n\t\"WIPING_SYSTEM_FAILED\": \"Не удалось безопасно удалить систему.\",\n\t\"WORKING_HOURS_UNMET\": \"Вы попытались войти в систему вне рабочего времени. Повторите попытку позже.\",\n\t\"NETCONFIG_TITLE\": \"Конфигурация PCOS Network\",\n\t\"NETCONFIG_DENY\": \"Недостаточно разрешений для конфигурации PCOS Network.\",\n\t\"NETCONFIG_URLF\": \"URL прокси: \",\n\t\"NETCONFIG_AUTO\": \"Запускать при загрузке ОС\",\n\t\"NETCONFIG_UC\": \"Изменяемое: \",\n\t\"NETCONFIG_SAVE\": \"Сохранить конфиг.\",\n\t\"NETCONFIG_PREDICT\": \"Предсказать адрес\",\n\t\"EMPTY_STATUSBAR\": \"Статус\",\n\t\"NETCONFIG_SAVE_OK\": \"Конфигурация успешно сохранена\",\n\t\"NETCONFIG_SAVE_FAIL\": \"Конфигурация НЕ сохранена!\",\n\t\"PCOS_STARTING\": \"PCOS приступает к работе...\",\n\t\"FILE_PICKER\": \"Выбор файла\",\n\t\"TEXT_EDITOR\": \"Текстовый редактор\",\n\t\"LOAD_BTN\": \"Загрузить\",\n\t\"SAVE_BTN\": \"Сохранить\",\n\t\"NETCONFIG_SYSIDM\": \"System ID недоступен\",\n\t\"NO_SAVE_IN_MTN\": \"Нельзя выполнять сохранение в папке монтирований.\",\n\t\"INSTALLING_WP2L\": \"Установка фона на экран блокировки\",\n\t\"EXIT\": \"Выйти\",\n\t\"DESCRIPTION_FIELD\": \"Описание: %s\",\n\t\"REMOVE_BTN\": \"Удалить\",\n\t\"UNMOUNT_BTN\": \"Размонтировать\",\n\t\"INSTALLING_DARKMODE2L\": \"Установка предпочтения тёмной темы на экран блокировки\",\n\t\"MESSAGE_ENTER\": \"Введите сообщение для отображения\",\n\t\"TIMEOUT_FIELD\": \"Ожидание (мс)\",\n\t\"SECRET_FIELD_TXT\": \"Секретное значение (текст)\",\n\t\"SECRET_FIELD_HEX\": \"Секретное значение (шестнадцатиричное)\",\n\t\"REGENERATE\": \"Регенерировать\",\n\t\"START_TIME_FIELD\": \"Время начала\",\n\t\"END_TIME_FIELD\": \"Время конца\",\n\t\"PBKDF2_OPTION\": \"PBKDF2 (Пароль)\",\n\t\"INFORMATIVE_MESSAGE_OPTION\": \"Информативное сообщение\",\n\t\"INFORMATIVE_MESSAGE_DENY_OPTION\": \"Информативное сообщение (отказ)\",\n\t\"TIMEOUT_OPTION\": \"Ожидание\",\n\t\"TIMEOUT_DENY_OPTION\": \"Ожидание (отказ)\",\n\t\"SERVER_REPORT_OPTION\": \"Сообщение серверу\",\n\t\"PCTOTP_OPTION\": \"Интерпретация TOTP от PC\",\n\t\"RFCTOTP_OPTION\": \"TOTP по RFC\",\n\t\"WORKING_HOURS_OPTION\": \"График работы\",\n\t\"PERSONAL_SECURITY_TITLE\": \"Личная безопасность\",\n\t\"PERSONAL_SECURITY_DENY\": \"Было предоставлено недостаточно привилегий для запуска Личной безопасности.\",\n\t\"ADD_BTN\": \"Добавить\",\n\t\"OS_LOCALE\": \"ru\",\n\t\"SYSTEM_SECURITY_TITLE\": \"Безопасность системы\",\n\t\"SYSTEM_SECURITY_DENY\": \"Было предоставлено недостаточно привилегий для запуска Безопасности системы.\",\n\t\"EDIT\": \"Редактировать\",\n\t\"USER_GROUPS\": \"Группы\",\n\t\"USER_HOMEDIR\": \"Домашний каталог\",\n\t\"REMOVE_USER_WITH_HD\": \"Удалить с домашним каталогом\",\n\t\"CREATE_HD\": \"Создать домашний каталог\",\n\t\"CREATING_HD_OK\": \"Домашний каталог успешно создан.\",\n\t\"CREATING_HD_FAIL\": \"Не удалось создать домашний каталог.\",\n\t\"SIGNATURE_VERIFICATION_FAILED\": \"Эта программа утверждает, что ей доверяет %s, но системе не удалось проверить это утверждение.\",\n\t\"UNKNOWN_PLACEHOLDER\": \"<Неизвестно>\",\n\t\"NO_APP_ALLOWLIST\": \"Системный администратор требует, чтобы у программ был белый список разрешений, но у этого программы нет этого списка.\",\n\t\"DISCARD_BUTTON\": \"Удалить потерянные файлы\",\n\t\"MOUNTPOINT\": \"Точка монтирования\",\n\t\"GENERATE_PROMPT\": \"Сгенерировать?\",\n\t\"MOUNT_BUTTON\": \"Монтировать\",\n\t\"NEW_DIR_NAME\": \"Имя нового каталога\",\n\t\"MKDIR_BUTTON\": \"Создать каталог\",\n\t\"CHOWN_BUTTON\": \"Сменить владельца\",\n\t\"CHGRP_BUTTON\": \"Сменить группу\",\n\t\"CHMOD_BUTTON\": \"Сменить разрешения\",\n\t\"CLIPBOARD_COPY\": \"Копировать\",\n\t\"CLIPBOARD_CUT\": \"Вырезать\",\n\t\"CLIPBOARD_PASTE\": \"Вставить\",\n\t\"CLIPBOARD_SOURCE_GONE\": \"Источник больше не существует или не файл.\",\n\t\"CLIPBOARD_CONFLICT\": \"В папке назначения уже есть файл или каталог с таким именем.\",\n\t\"SAFE_MODE_MSG\": \"Безопасный режим\",\n\t\"INSTALLING_SFX\": \"Установка звуковых эффектов\",\n\t\"APP_OR_KEY_SIGNATURE_VERIFICATION_FAILED\": \"Проверка подписи программы или ключа, который подписал программу не удалась.\",\n\t\"NO_SUCH_DEVICE\": \"Нет такого устройства\",\n\t\"READ_ONLY_BMGR\": \"Записи ограничены загрузчиком ОС.\",\n\t\"READ_ONLY_DEV\": \"Устройство только для чтения\",\n\t\"NO_DIRECTORY_SUPPORT\": \"Устройство не поддерживает каталоги\",\n\t\"NO_PERMIS_SUPPORT\": \"Устройство не поддерживает разрешения\",\n\t\"IS_A_DIR\": \"Является каталогом\",\n\t\"NO_SUCH_FILE\": \"Нет такого файла\",\n\t\"NO_SUCH_DIR\": \"Нет такого каталога\",\n\t\"NO_SUCH_FILE_DIR\": \"Нет такого файла или каталога\",\n\t\"NON_EMPTY_DIR\": \"Непустой каталог\",\n\t\"IS_A_FILE\": \"Является файлом\",\n\t\"DIR_EXISTS\": \"Каталог уже существует\",\n\t\"FS_ACTION_FAILED\": \"Не удалось выполнить это действие с файловой системой.\",\n\t\"UNAUTHORIZED_ACTION\": \"У программы нет прав на это действие.\",\n\t\"CREATION_CHECK_FAILED\": \"Не удалось проверить, создаётся ли этот объект.\",\n\t\"PERMISSION_CHANGE_FAILED\": \"Не удалось изменить разрешения для этого объекта.\",\n\t\"UPDATE_EXTRA_FAIL\": \"Не удалось обновить приложения, фоны, звуки.\",\n\t\"UPDATE_BOOT_FAIL\": \"Не удалось обновить файлы загрузки.\",\n\t\"UPDATE_BUTTON\": \"Обновить ОС\",\n\t\"TOGGLE_HIDDEN_FILES\": \"Скрыть/показать файлы\",\n\t\"AUTORUN_NECESSITIES_FAILED\": \"Не удалось запустить один из ваших файлов автозапуска. Система не позволит выполнить вход.\",\n\t\"CRYPTO_TOOLS_TITLE\": \"Утилиты для криптографии\",\n\t\"CRYPTO_TOOLS_NOPERM\": \"Недостаточно прав для использования утилит для криптографии.\",\n\t\"CRYPTO_RNG\": \"Случайная генерация\",\n\t\"CRYPTO_HASH\": \"Хэширование\",\n\t\"CRYPTO_KEYGEN\": \"Генерация ключей\",\n\t\"CRYPTO_ENCRYPT\": \"Шифрование\",\n\t\"CRYPTO_DECRYPT\": \"Расшифровка\",\n\t\"CRYPTO_SIGN\": \"Подписывание\",\n\t\"CRYPTO_VERIFY\": \"Проверка подписи\",\n\t\"CRYPTO_DERIVEBITS\": \"Преобразование\",\n\t\"GENERATE\": \"Генерировать\",\n\t\"RAW_HEX_DATA\": \"Прямые данные (шестнадцатиричные)\",\n\t\"CRYPTO_HASH_FIELD\": \"Алгоритм хэширования: \",\n\t\"CRYPTO_PLAINTEXT_FIELD\": \"Простой текст: \",\n\t\"ALGORITHM_FIELD\": \"Алгоритм: \",\n\t\"LENGTH_FIELD\": \"Длина: \",\n\t\"CRYPTO_NC_FIELD\": \"Имя кривой: \",\n\t\"IMPORT_AS_FIELD\": \"Импортировать как: \",\n\t\"CRYPTO_KEY_FIELD\": \"Ключ: \",\n\t\"CRYPTO_CIPHERTEXT_FIELD\": \"Шифр (шестнадцатиричный): \",\n\t\"CRYPTO_SIGNATURE_FIELD\": \"Подпись (шестнадцатиричная): \",\n\t\"CRYPTO_KEYGEN_MSG\": \"Генерация ключа (ключей)...\",\n\t\"CRYPTO_KEYGEN_SYMM\": \"Является симметричным типом ключа\",\n\t\"CRYPTO_KEYGEN_EXPFAIL\": \"Не удалось экспортировать, проверьте настройки экспорта\",\n\t\"CRYPTO_RNGOUT_FIELD\": \"Случайные числа (шестнадцатиричные): \",\n\t\"CRYPTO_KEYGEN_ACTION\": \"Сгенерировать ключ(и)\",\n\t\"CRYPTO_HASH_ACTION\": \"Хэшировать\",\n\t\"CRYPTO_ENCRYPT_ACTION\": \"Зашифровать\",\n\t\"CRYPTO_DECRYPT_ACTION\": \"Расшифровать\",\n\t\"CRYPTO_SIGN_ACTION\": \"Подписать\",\n\t\"CRYPTO_VERIFY_ACTION\": \"Проверить подпись\",\n\t\"CRYPTO_DERIVEBITS_ACTION\": \"Преобразовать\",\n\t\"CRYPTO_PUBKEY_FIELD\": \"Открытый ключ: \",\n\t\"CRYPTO_PRIVKEY_FIELD\": \"Закрытый ключ: \",\n\t\"CRYPTO_BASEKEY_FIELD\": \"Базовый ключ: \",\n\t\"CRYPTO_HASHOUT_FIELD\": \"Значение хэша (шестнадцатиричное): \",\n\t\"CRYPTO_MODLEN_FIELD\": \"Длина модуля: \",\n\t\"CRYPTO_PUBEXP_FIELD\": \"Открытая экспонента (шестнадцатиричная): \",\n\t\"EXPORT_AS_FIELD\": \"Экспортировать как: \",\n\t\"CRYPTO_KEYUSE_FIELD\": \"Использования ключа:\",\n\t\"CRYPTO_PLAINTEXTAS_FIELD\": \"Обработать простой текст как: \",\n\t\"CRYPTO_IV_FIELD\": \"Вектор инициализации (шестнадцатиричный): \",\n\t\"CRYPTO_CTR_FIELD\": \"Счётчик (шестнадцатиричный): \",\n\t\"CRYPTO_VERIFIED_CHECKBOX\": \"Проверено успешно\",\n\t\"CRYPTO_SALT_FIELD\": \"Соль (шестнадцатиричная): \",\n\t\"CRYPTO_DERIVEOUT_FIELD\": \"Преобразование (шестнадцатиричное): \",\n\t\"CRYPTO_ITERATIONS_FIELD\": \"Итераций: \",\n\t\"PATH_INCLUDES_EMPTY\": \"В указанном пути есть объект с пустым именем.\",\n\t\"BASIC_CURL_USAGE\": \"Использование: basiccurl [источник] [выход]\",\n\t\"BASIC_CURL_DESCRIPTION\": \"Скачивает указаный источник и записывает его в указанный выход.\",\n\t\"NO_ARGUMENTS\": \"Параметры не указаны\",\n\t\"CAT_USAGE\": \"Использование: cat [файл1] <файл2> <файл3> ... <файлN>\",\n\t\"CAT_DESCRIPTION\": \"Складывает эти файлы и выводит их в выход консоли\",\n\t\"CHGRP_USAGE\": \"Использование: chgrp [группа] [файл]\",\n\t\"CHGRP_DESCRIPTION\": \"Изменяет владеющую группу файлы\",\n\t\"CHMOD_USAGE\": \"Использование: chmod [режим] [файл]\",\n\t\"CHMOD_DESCRIPTION\": \"Задаёт, что могут делать все с файлом.\",\n\t\"CHMOD_MODE_DESCRIPTION\": \"[режим] может состоять из символов r (Read, чтение), w (Write, запись) и x (eXecute, исполнение).\",\n\t\"CHMOD_MODE_CONVERT\": \"Конвертация чисел [режима] в строку: 0 - \\\"\\\", 1 - \\\"x\\\", 2 - \\\"w\\\", 3 - \\\"wx\\\", 4 - \\\"r\\\", 5 - \\\"rx\\\", 6 - \\\"rw\\\", 7 - \\\"rwx\\\"\",\n\t\"CHOWN_USAGE\": \"Использование: chown [пользователь] [файл]\",\n\t\"CHOWN_DESCRIPTION\": \"Изменяет владеющего пользователя файлы\",\n\t\"CP_USAGE\": \"Использование: cp <параметры> [источник] [назначение]\",\n\t\"CP_DESCRIPTION\": \"Копирует файлы или каталоги в указанное назначение.\",\n\t\"OPT_RECURSIVE_DESCRIPTION\": \"--recursive: запускать на каталогах\",\n\t\"OPT_FORCE_DESCRIPTION\": \"--force: не выходить сразу при ошибке\",\n\t\"ARGUMENT_COUNT_MISMATCH\": \"Слишком много или слишком мало аргументов\",\n\t\"DF_HEADER\": \"Хранилище\\tРазмер\\tИспользовано\\tДост\\tИспользовано%\",\n\t\"LS_USAGE\": \"Использование: ls [каталог]\",\n\t\"LS_DESCRIPTION\": \"Отображает содержимое указанного каталога.\",\n\t\"LS_MOUNTPOINT_LIST\": \"У вас следующие точки монтирования: \",\n\t\"MOUNTPOINT_SYSTEM\": \"системная\",\n\t\"PASSWD_NEW_PROMPT\": \"Установка нового пароля для вашей учётной записи.\",\n\t\"PASSWD_2FACTOR_LOSS_WARN\": \"Раннее установленные дополнительные факторы будут удалены.\",\n\t\"PASSWD_PROMPT\": \"Новый пароль: \",\n\t\"PASSWD_CONFIRM_PROMPT\": \"Повторите пароль: \",\n\t\"PASSWD_FEEDBACK\": \"Задан новый пароль\",\n\t\"PASSWD_MISMATCH\": \"Пароли не совпадают.\",\n\t\"PING_USAGE\": \"Использование: ping <--internet> [адресСети]\",\n\t\"PING_DESCRIPTION\": \"Отправляет запрос на указанный адрес для проверки его доступности.\",\n\t\"PING_INTERNET_OPTION\": \"--internet: отправить ping в Интернет, а не в PCOS Network\",\n\t\"PIVOT_ROOT_USAGE\": \"Использование: pivot_root [точкаМонтирования]\",\n\t\"PIVOT_ROOT_DESCRIPTION\": \"Устанавливает указанную точку монтирования как системную для всех программ.\",\n\t\"REAL_TERMINAL_NAME\": \"Терминал\",\n\t\"REAL_TERMINAL_BUILTIN_LIST\": \"Встроенные команды:\",\n\t\"REAL_TERMINAL_HELP_USEDESC\": \"help - Показать список, использование и описание встроенных команд.\",\n\t\"REAL_TERMINAL_CLEAR_USEDESC\": \"clear - Стереть всё, что сейчас в терминале.\",\n\t\"REAL_TERMINAL_SUGRAPH_USEDESC\": \"sugraph <нужноеИмя> - Переключить пользователя терминала с помощью графического интерфейса.\",\n\t\"REAL_TERMINAL_SU_USEDESC\": \"su <нужноеИмя> - Переключить пользователя терминала.\",\n\t\"REAL_TERMINAL_GRAPHIC_USEDESC\": \"graphic <булево> - Включить или выключить запуск новых программ вне фонового режима.\",\n\t\"REAL_TERMINAL_EXIT_USEDESC\": \"exit - Выйти из терминала.\",\n\t\"REAL_TERMINAL_LOGON_REQUIRED\": \"(внутреннее): Перед запуском программы необходимо запустить sugraph %s.\",\n\t\"RM_USAGE\": \"Использование: rm <параметры> [файл]\",\n\t\"RM_DESCRIPTION\": \"Удаляет указанный файл или каталог.\",\n\t\"RKL_USAGE\": \"Использование: runKlvlCode [файлСКодом]\",\n\t\"RKL_DESCRIPTION\": \"Запускает указанный файл с кодом на уровне ядра.\",\n\t\"WRITE_USAGE\": \"Использование: write [файл] [данные]\",\n\t\"WRITE_DESCRIPTION\": \"Записывает данные в указанный файл.\",\n\t\"CP_PERMISSIONS_OPTION\": \"--permissions: скопировать разрешения файлов\",\n\t\"REAL_TERMINAL_DEFAULT_PATH_FIELD\": \"Путь по умолчанию: %s\",\n\t\"REAL_TERMINAL_PUSHPATH_USEDESC\": \"pushpath [путь] - Добавить новый путь для просмотра команд.\",\n\t\"REAL_TERMINAL_RESETPATH_USEDESC\": \"resetpath - Сбросить список путей для просмотра команд к значению пути по умолчанию.\",\n\t\"REAL_TERMINAL_LSPATH_USEDESC\": \"lspath - Просмотреть текущие пути для просмотра команд и путь по умолчанию.\",\n\t\"MKDIR_USAGE\": \"Использование: mkdir [каталог]\",\n\t\"MKDIR_DESCRIPTION\": \"Создаёт новый каталог в указанном пути.\",\n\t\"NEXT\": \"Далее\",\n\t\"DESCRIBE_TEMPLATE\": \"Программа: %s (%s)\\nНамерение: %s\",\n\t\"EXTRA_DESCRIBE_TEMPLATE\": \"Программа: %s (%s)\\nПараметры: %s\\nНамерение: %s\",\n\t\"DECLINE\": \"Отклонить\",\n\t\"ACCESS_REQUEST_TITLE\": \"Запрос доступа\",\n\t\"REAL_TERMINAL_INTENT\": \"Запуск команд с вашими разрешениями\",\n\t\"PERSONAL_SECURITY_INTENT\": \"Управлять вашими настройками безопасности\",\n\t\"FILE_EXPLORER_INTENT\": \"Запускать программы и открывать файлы\",\n\t\"FILE_EXPLORER_FULL_INTENT\": \"Просматривать файлы, запускать программы и открывать файлы\",\n\t\"CRYPTO_TOOLS_INTENT\": \"Выполнять криптографические операции\",\n\t\"SYSTEM_SECURITY_INTENT\": \"Управление настройками учётных записей по всей системе\",\n\t\"FORMAT_USAGE\": \"Использование: format [тип_фс] [раздел] <перезапись>\",\n\t\"FORMAT_DESCRIPTION\": \"Готовит указанный раздел к использованию.\",\n\t\"FORMAT_FSTYPE\": \"Типы файловых систем: pcfs (соответствует точке монтирования PCFSiDBMount), pcfs_crypt (PCFSiDBAESCryptMount), pcfs_crypt_monokey (PCFSiDBAESCryptMount), pcfs_crypt_filetable_monokey (PCFSiDBAESCryptMount), pcbm:<раздел_данных> (как код загрузочного раздела), null (УДАЛИТЬ раздел)\",\n\t\"FORMAT_OVERWRITE_WARN\": \"Раздел уже содержит данные. Установите параметр перезаписи равным 'overwrite' для продолжения в любом случае. В таком случае ВСЕ ДАННЫЕ НА РАЗДЕЛЕ МОГУТ БЫТЬ УДАЛЕНЫ.\",\n\t\"FORMAT_UNKNOWN_FSTYPE\": \"Неизвестное целевое форматирование\",\n\t\"LLDA_USAGE\": \"Использование: llda_tool [действие] [параметры]\",\n\t\"LLDA_ACTION_EXPORT\": \"действие export: [раздел ввода] [файл вывода]\",\n\t\"LLDA_ACTION_IMPORT\": \"действие import: [файл ввода] [раздел вывода]\",\n\t\"LLDA_ACTION_IMPORTSTRING\": \"действие importstring: [файл ввода] [раздел вывода]\",\n\t\"LLDA_ACTION_COPY\": \"действие copy: [раздел ввода] [раздел вывода]\",\n\t\"LLDA_ACTION_REMOVE\": \"действие remove: [раздел]\",\n\t\"LLDA_ACTION_LIST\": \"действие list\",\n\t\"LLDA_DISCLAIMER\": \"При использовании утилиты можно столкнуться с ПОТЕРЕЙ ДАННЫХ!\",\n\t\"LLDA_UNKNOWN_ACTION\": \"Неизвестное действие\",\n\t\"INITDISK_OVERWRITE_WARN\": \"Системный диск уже сожержит таблицу разделов. Установите параметр перезаписи равным 'overwrite' для продолжения в любом случае. В таком случае ВСЕ ДАННЫЕ НА ДИСКЕ МОГУТ БЫТЬ УДАЛЕНЫ.\",\n\t\"INITDISK_USAGE\": \"Использование: initdisk [что угодно] <перезапись>\",\n\t\"INITDISK_DESCRIPTION\": \"Готовит системный диск к использованию.\",\n\t\"MOUNT_USAGE\": \"Использование: mount [параметры] [тип_фс] [точка_монтирования]\",\n\t\"MOUNT_DESCRIPTION\": \"Монтирует файловую систему.\",\n\t\"MOUNT_KNOWN_FS\": \"Известные типы файловых систем: %s\",\n\t\"MOUNT_KNOWN_PPART\": \"--partition=[разделДанных] - Указать раздел данных\",\n\t\"MOUNT_KNOWN_PINPA\": \"--interactivePassword - Интерактивно спрашивать пароль\",\n\t\"MOUNT_KNOWN_PPASS\": \"--password=[пароль] - Указать пароль\",\n\t\"MOUNT_KNOWN_PKEY\": \"--key=[прямойКлюч] - Указать ключ шифрования\",\n\t\"MOUNT_KNOWN_PTYPE\": \"--type=[тип] - Для ramMount, укажите type=run для авто-создания /run\",\n\t\"MOUNT_KNOWN_PURL\": \"--url=[URL] - Указать URL\",\n\t\"MOUNT_KNOWN_PINPI\": \"--inputPipeId=[идКанала] - Указать канал ввода\",\n\t\"MOUNT_KNOWN_POUPI\": \"--outputPipeId=[идКанала] - Указать канал вывода\",\n\t\"MOUNTINFO_USAGE\": \"Использование: mountinfo [точка_монтирования]\",\n\t\"MOUNTINFO_DESCRIPTION\": \"Получить информацию о точке монтирования.\",\n\t\"UMOUNT_USAGE\": \"Использование: umount <параметры> [точка_монтирования]\",\n\t\"UMOUNT_DESCRIPTION\": \"Размонтирует файловую систему.\",\n\t\"UMOUNT_OPT_SYNCONLY\": \"--sync-only - Только синхронизация, а не размонтирование (перезаписывает --force)\",\n\t\"UMOUNT_OPT_FORCE\": \"--force - Принудительно размонтировать, не синхронизовать\",\n\t\"CALC_TITLE\": \"Калькулятор\",\n\t\"CALC_BASIC_MODE\": \"Калькулятор: Основные операции\",\n\t\"CALC_ADVANCED_MODE\": \"Калькулятор: Расширенный режим\",\n\t\"CALC_ADD\": \"Сумма\",\n\t\"CALC_SUBTRACT\": \"Разность\",\n\t\"CALC_MULTIPLY\": \"Произведение\",\n\t\"CALC_DIVIDE\": \"Частное\",\n\t\"CALC_ADVMODE_BTN\": \"Расширенный режим\",\n\t\"CALC_BASICMODE_BTN\": \"Основные операции\",\n\t\"CALC_OPERAND\": \"Операнд %s\",\n\t\"CALC_TOMIXED_BTN\": \"Перевести в смешанную дробь\",\n\t\"CALC_TOIMPR_BTN\": \"Перевести в неправильную дробь\",\n\t\"CALC_GCD\": \"НОД\",\n\t\"CALC_FACTORIAL\": \"Факториал\",\n\t\"CALC_GCD_PAGE\": \"Наибольший общий делитель\",\n\t\"ZKPP_OPTION\": \"ZKPP (Пароль)\",\n\t\"SECONDSTAGE_INSTALLER_INTENT\": \"Завершить конфигурацию ОС\",\n\t\"SETUP_FAILED\": \"Настройка не удалась. Попробуйте ещё раз, перезапустив систему.\",\n\t\"WARNING_PRIVILEGES\": \"Будьте осторожны с этой функцией! Вы можете понизить уровень безопасности системы.\",\n\t\"USER_EXT_PRIVILEGES\": \"Расширенный набор разрешений\",\n\t\"LULL_SYSTEM\": \"Режим сна\",\n\t\"SYSTEM_IMAGING\": \"Образы системы\",\n\t\"CREATE_IMAGE\": \"Создать образ системы\",\n\t\"RESTORE_IMAGE\": \"Восстановить образ системы\",\n\t\"SELECT_FILE_PROMPT\": \"Выберите файл: \",\n\t\"REBOOT_ON_RESTORE\": \"Перезагрузить после восстановления\",\n\t\"MERGE_STATES\": \"Слиять состояния образов\",\n\t\"LISTING_PARTITIONS_FAILED\": \"Не удалось получить список разделов.\",\n\t\"READING_PARTITION_FAILED\": \"Не удалось прочитать раздел %s\",\n\t\"LISTING_DATA_FAILED\": \"Не удалось получить список данных.\",\n\t\"READING_DATA_FAILED\": \"Не удалось прочитать данные.\",\n\t\"WRITING_IMAGE_FAILED\": \"Не удалось записать образ.\",\n\t\"SUCCESSFUL_OP\": \"Процесс был успешно завершён.\",\n\t\"FAILED_OP\": \"Процесс завершён безуспешно.\",\n\t\"READING_IMAGE_FAILED\": \"Не удалось прочитать образ.\",\n\t\"WRITING_PARTITION_FAILED\": \"Не удалось записать раздел %s\",\n\t\"WRITING_DATA_FAILED\": \"Не удалось записать данные.\",\n\t\"DELETING_PARTITION_FAILED\": \"Не удалось удалить раздел %s\",\n\t\"DELETING_DATA_FAILED\": \"Не удалось удалить данные.\",\n\t\"SHUTTING_DOWN_FAILED\": \"Не удалось завершить работу системы.\",\n\t\"NETWORK_STATUS_ONLINE\": \"Вы подключены к локальной вычислительной сети.\",\n\t\"NETWORK_STATUS_OFFLINE\": \"Вы не подключены ни к какой сети.\",\n\t\"PCOS_NETWORK_STATUS_ONLINE\": \"Вы подключены к PCOS Network. (имя: %s, адрес: %s)\",\n\t\"PCOS_NETWORK_STATUS_OFFLINE\": \"Вы отключены от PCOS Network.\",\n\t\"PCOS_NETWORK_STATUS_STOPPED\": \"Служба PCOS Network была остановлена.\",\n\t\"START_MENU_FAILED\": \"Не удалось запустить меню \\\"Пуск\\\". Вместо этого можно выполнить выход из системы.\",\n\t\"SYSTEM_BUILT_AT\": \"Система скомпилирована %s\",\n\t\"REAL_TERMINAL_VER_USEDESC\": \"ver - Показать номер и время компиляции системы\",\n\t\"BLANK_PRIVILEGE_FLAG\": \"Нулевые привилегии\",\n\t\"INSTALLING_SYSTEM_APPHARDEN\": \"Установка правил безопасности программ\",\n\t\"INSTALLING_NET_CONF\": \"Установка конфигурации PCOS Network\",\n\t\"NETWORK_ADDRESS_FIELD\": \"Сетевой адрес: %s\",\n\t\"NETWORK_AUTOHOST_FIELD\": \"Автоматическое имя: %s\",\n\t\"NETCONFIG_HOSTNAME\": \"Имя в сети: \",\n\t\"DIFF_USAGE\": \"Использование: diff [оригинал] [новый] [разность]\",\n\t\"DIFF_DESCRIPTION\": \"Вычисляет разность между двумя файлами.\",\n\t\"PATCH_USAGE\": \"Использование: patch [оригинал] [разность] [новый]\",\n\t\"PATCH_DESCRIPTION\": \"Вычисляет 'сумму' оригинального файла и разности.\",\n\t\"CURRENT_OSFILE_VERSION\": \"Текущая версия файла: сборка %s\",\n\t\"DOWNLOADING_OS_PATCH\": \"Скачивание разности сборок с сервера %s (адрес %s)\",\n\t\"HANDOFF_UPDATE\": \"Перенаправление процесса обновления updateos.js\",\n\t\"SYSTEM_UP_TO_DATE\": \"Обновления отсутствуют\",\n\t\"POWER_USAGE\": \"Использование: power <параметры> <r|reboot|restart|k|kexec>\",\n\t\"POWER_DESCRIPTION\": \"Выключает или перезагружает систему. Указывание ничего приводит к завершению работы.\",\n\t\"POWER_FORCE\": \"--force: не ждать процессов, перезагрузиться или выключиться немедленно\",\n\t\"POWER_KEXEC\": \"--kexec: перезагрузить систему, не перезагружая страницу или прошивку (автоматически выбирает reboot)\",\n\t\"UPDATEFW_BUTTON\": \"Обновить прошивку\",\n\t\"UPDATEFW_DOWNLOADING\": \"Скачивание местного init.js...\",\n\t\"UPDATEFW_DOWNLOAD_FAILED\": \"Не удалось скачать местный init.js.\",\n\t\"UPDATEFW_DECODING\": \"Обработка init.js как текст\",\n\t\"UPDATEFW_SETTING\": \"Задание init.js как прошивки\",\n\t\"ADDUSER_USAGE\": \"Использование: adduser <параметры> [пользователь]\",\n\t\"ADDUSER_DESCRIPTION\": \"Создать новую учётную запись пользователя.\",\n\t\"ADDUSER_SKIP_PASSWD\": \"--skip-passwd: не спрашивать пароль\",\n\t\"ADDUSER_SKIP_HOME\": \"--skip-home: не создавать домашнюю директорию\",\n\t\"ADDUSER_GROUPS\": \"--groups: добавить в группы (указать несколько раз, чтобы добавить в несколько групп)\",\n\t\"ADDUSER_HOME\": \"--home: своя домашняя директория\",\n\t\"NEW_USER_CREATION\": \"Создание нового пользователя \\\"%s\\\"\",\n\t\"BLOCKUSER_USAGE\": \"Использование: blockuser <пользователь>\",\n\t\"BLOCKUSER_DESCRIPTION\": \"Блокирует учётную запись пользователя.\",\n\t\"DELUSER_USAGE\": \"Использование: deluser <параметры> [пользователь]\",\n\t\"DELUSER_DESCRIPTION\": \"Удаляет учётную запись пользователя.\",\n\t\"DELUSER_HOMEDIR\": \"--homedir: удалять домашнюю директорию\",\n\t\"OLD_USER_DELETION\": \"Удаление старого пользователя \\\"%s\\\"\",\n\t\"BATTERY_STATUS_UNAVAILABLE\": \"Статус батареи недоступен.\",\n\t\"BATTERY_STATUS_CHARGING\": \"Батарея заряжается (%s%, %sдо полной)\",\n\t\"BATTERY_STATUS_DISCHARGING\": \"Батарея разряжается (%s%, %sигры)\",\n\t\"PATCH_HUNK_COUNT\": \"Фраз разности: %s\",\n\t\"SERVER_SIGNATURE_VERIFICATION_FAILED\": \"Проверка подписи сервера не удалась.\",\n\t\"NETWORK_UNREACHABLE\": \"Сеть недоступна.\",\n\t\"ADDRESS_UNREACHABLE\": \"Адрес недоступен.\",\n\t\"NETWORK_CLOSED\": \"Сеть была закрыта.\",\n\t\"CONNECTION_DROPPED\": \"Соединение была закрыта.\",\n\t\"BLOG_BROWSER_NAME\": \"Обозреватель блогов\",\n\t\"BLOG_BROWSER_LOADING\": \"Подождите, страница загружается...\",\n\t\"BLOG_BROWSER_PROTO\": \"Нет такого протокола. Эта версия поддерживает только протокол bdp://.\",\n\t\"BLOG_BROWSER_GATESET\": \"Для того, чтобы задать ворота, используйте часть имени пользователя: bdp://gate@myblog.pc\",\n\t\"HOSTNAME_RESOLUTION_FAILED\": \"Не удалось преобразовать имя компьютера.\",\n\t\"BLOG_BROWSER_POSTCLOSE\": \"Этот интерактивный пост был закрыт.\",\n\t\"BLOG_BROWSER_FILEPOST\": \"Это пост-файл. Вы можете скачать его на этот компьютер.\",\n\t\"BLOG_BROWSER_DLFILEPOST\": \"Вы скачали этот пост-файл.\",\n\t\"BLOG_BROWSER_LOADING_PROGRESS\": \"Загрузка поста (получено %s из %s частей)\",\n\t\"BLOG_BROWSER_NOVERIFY\": \"Вы включили параметр, пропускающий проверку сервера. Это не рекомендуется, так как сетевой прокси-сервер сможет выполнить атаку \\\"человек посередине\\\" и тем самым, получить доступ к вашим данным. Вы бы позволили этому случиться?\",\n\t\"BLOG_BROWSER_NOSANDBOX\": \"Вы включили параметр пробрасывания всех ИПП вашей операционной системы. Это не рекомендуется, так как пост может выполнять любое действие, как будто он является этим приложением. Вы бы позволили этому случиться?\",\n\t\"NETWORKFS_USAGE\": \"Использование: networkfs <параметры> [url] [точка_монтирования]\",\n\t\"NETWORKFS_DESCRIPTION\": \"Монтирует файловую систему, доступную через PCOS Network.\",\n\t\"NETWORKFS_NOVERIFY\": \"--no-verification: Не проверять ключ сервера\",\n\t\"NETWORKFS_KEY\": \"--key=[путь]: Путь до ключа для взаимной проверки\",\n\t\"NETWORKFS_PROTO\": \"Данная версия поддерживает только протокол netfs://.\",\n\t\"NETCONFIG_UPDATES\": \"Обновления: \",\n\t\"NETWORK_UPDATES_FIELD\": \"Обновления с: %s\",\n\t\"LOCALE_NAME\": \"Русский (Russian)\",\n\t\"SETTING_LOCALE_PREFERENCE\": \"Установка предпочитаемого языка\",\n\t\"LANGUAGE_SELECT\": \"Ваш язык: \",\n\t\"CHANGE_LOCALE\": \"Изменить язык\",\n\t\"INSTALLER_INTENT\": \"Начать конфигурацию ОС\",\n\t\"MOUNT_EXISTS\": \"Монтирование уже существует\",\n\t\"INSECURE_MODE_MSG\": \"Небезопасные параметры!\",\n\t\"MODULE_REQUIRED\": \"Для этой функции требуется модуль \\\"%s\\\". Обратитесь к системному администратору.\",\n\t\"CREATING_DIRECTORY_STRUCTURE\": \"Создание структуры каталогов\",\n\t\"GENERATING_KERNEL\": \"Создание ядра системы\",\n\t\"WORK_IN_PROGRESS_AFTER_MODULAR\": \"Эта функция находится в работе после модуляризации.\",\n\t\"REGENERATE_KERNEL\": \"Повторно создать ядро системы\",\n\t\"TECHNICAL_LIMITATIONS\": \"Этот файл нельзя создать из-за технических ограничений.\"\n};"},"buildInfo":{"for":"1332","version":"1332","when":1751657439209,"signer":"moduleSigner","critical":false,"bootOrder":"50","signature":"97907b71a81b80b021d1a5b574d5351e2334b056db602e9289068cb9cd49e70ae694d3ef1beda54868c7945848404840fa67ec346546a223ff8fca316db52c02"}},"50-pcos-wallpapers.fs":{"backend":{"files":{"etc":{"wallpapers":{"pcos-beta.pic":"1f8996b59565c100ae21137638e11c59edbfd93ed74566def5ee49ed8512a4706c2d1f53a4d2b210d82dc4ed15aea0606325dfb9ebc2d97aa009d72bbcaf3593","pcos-dark-beta.pic":"70d84e7c9ac167e5c6b2f849916f94ed05f914efe4598e1cf4e3a29182250628ed4a1431314b959da8fc1629406200041f32f0339d392754f252fc53b53b58b0","pcos-lock-beta.pic":"406e44551a5867d3c545b80bde2c3b3b95f100b978ae9e0b042493ce2af7e69f661aaea205753bd68eacc589b1edeb245eed225ff089c72924db7c8aacb1533f"}}},"permissions":{"etc/wallpapers/pcos-beta.pic":{"world":"rx"},"etc/wallpapers/pcos-dark-beta.pic":{"world":"rx"},"etc/wallpapers/pcos-lock-beta.pic":{"world":"rx"},"etc/wallpapers/":{"world":"rx"},"etc/":{"world":"rx"},"":{"world":"rx"}}},"files":{"1f8996b59565c100ae21137638e11c59edbfd93ed74566def5ee49ed8512a4706c2d1f53a4d2b210d82dc4ed15aea0606325dfb9ebc2d97aa009d72bbcaf3593":"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTkyMCIgaGVpZ2h0PSIxMDgwIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+Cgk8ZGVmcz4KCQk8bGluZWFyR3JhZGllbnQgaWQ9IkJnR3JhZGllbnQiIHgxPSIwIiB4Mj0iMCIgeTE9IjAiIHkyPSIxIj4KCQkJPHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iIzAwYmZmZiIgLz4KCQkJPHN0b3Agb2Zmc2V0PSIxMDAlIiBzdG9wLWNvbG9yPSIjYTcwMGZmIiAvPgoJCTwvbGluZWFyR3JhZGllbnQ+Cgk8L2RlZnM+Cgk8Zz4KCQk8cmVjdCB4PSIwIiB5PSIwIiB3aWR0aD0iMTkyMCIgaGVpZ2h0PSIxMDgwIiBmaWxsPSJ1cmwoI0JnR3JhZGllbnQpIiAvPgoJCTx0ZXh0IHg9IjM1IiB5PSIxNTAiIGNsYXNzPSJzZWdvZWZvbnQiIGZpbGw9IiNmZmZmZmYiPlBDT1MgMzwvdGV4dD4KCQk8dGV4dCB4PSIxNTU1IiB5PSIxMDMwIiBjbGFzcz0ic2Vnb2Vmb250IiBmaWxsPSIjMzAzMDMwIj50ZXN0IGJ1aWxkPC90ZXh0PgoJPC9nPgoJPHN0eWxlPgoJCS5zZWdvZWZvbnQgewoJCQlmb250LWZhbWlseTogJ1NlZ29lIFVJJywgVGFob21hLCBHZW5ldmEsIFZlcmRhbmEsIHNhbnMtc2VyaWY7CgkJCWZvbnQtc2l6ZTogNjRweDsKCQkJZm9udC13ZWlnaHQ6IGJvbGQ7CgkJfQoJPC9zdHlsZT4KPC9zdmc+Cg==","70d84e7c9ac167e5c6b2f849916f94ed05f914efe4598e1cf4e3a29182250628ed4a1431314b959da8fc1629406200041f32f0339d392754f252fc53b53b58b0":"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTkyMCIgaGVpZ2h0PSIxMDgwIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+Cgk8ZGVmcz4KCQk8bGluZWFyR3JhZGllbnQgaWQ9IkJnR3JhZGllbnQiIHgxPSIwIiB4Mj0iMCIgeTE9IjAiIHkyPSIxIj4KCQkJPHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iIzAwMDAwMCIgLz4KCQkJPHN0b3Agb2Zmc2V0PSIxMDAlIiBzdG9wLWNvbG9yPSIjYTcwMGZmIiAvPgoJCTwvbGluZWFyR3JhZGllbnQ+Cgk8L2RlZnM+Cgk8Zz4KCQk8cmVjdCB4PSIwIiB5PSIwIiB3aWR0aD0iMTkyMCIgaGVpZ2h0PSIxMDgwIiBmaWxsPSJ1cmwoI0JnR3JhZGllbnQpIiAvPgoJCTx0ZXh0IHg9IjM1IiB5PSIxNTAiIGNsYXNzPSJzZWdvZWZvbnQiIGZpbGw9IiNhNzAwZmYiPlBDT1MgMzwvdGV4dD4KCQk8dGV4dCB4PSIxNTU1IiB5PSIxMDMwIiBjbGFzcz0ic2Vnb2Vmb250IiBmaWxsPSIjMzAzMDMwIj50ZXN0IGJ1aWxkPC90ZXh0PgoJPC9nPgoJPHN0eWxlPgoJCS5zZWdvZWZvbnQgewoJCQlmb250LWZhbWlseTogJ1NlZ29lIFVJJywgVGFob21hLCBHZW5ldmEsIFZlcmRhbmEsIHNhbnMtc2VyaWY7CgkJCWZvbnQtc2l6ZTogNjRweDsKCQkJZm9udC13ZWlnaHQ6IGJvbGQ7CgkJfQoJPC9zdHlsZT4KPC9zdmc+Cg==","406e44551a5867d3c545b80bde2c3b3b95f100b978ae9e0b042493ce2af7e69f661aaea205753bd68eacc589b1edeb245eed225ff089c72924db7c8aacb1533f":"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTkyMCIgaGVpZ2h0PSIxMDgwIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+Cgk8ZGVmcz4KCQk8bGluZWFyR3JhZGllbnQgaWQ9IkJnR3JhZGllbnQiIHgxPSIwIiB4Mj0iMCIgeTE9IjAiIHkyPSIxIj4KCQkJPHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iIzAwYmZmZiIgLz4KCQkJPHN0b3Agb2Zmc2V0PSI1MCUiIHN0b3AtY29sb3I9IiNhNzAwZmYiIC8+CgkJCTxzdG9wIG9mZnNldD0iMTAwJSIgc3RvcC1jb2xvcj0iIzAwMDAwMCIgLz4KCQk8L2xpbmVhckdyYWRpZW50PgoJPC9kZWZzPgoJPGc+CgkJPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjE5MjAiIGhlaWdodD0iMTA4MCIgZmlsbD0idXJsKCNCZ0dyYWRpZW50KSIgLz4KCQk8dGV4dCB4PSI4MDAiIHk9IjIwMCIgY2xhc3M9InNlZ29lZm9udCIgZmlsbD0iIzAwMDAwMCIgZm9udC1zaXplPSI3MnB4IiBmb250LXdlaWdodD0iYm9sZCI+UENPUyAzPC90ZXh0PgoJCTx0ZXh0IHg9Ijg2MCIgeT0iMjQwIiBjbGFzcz0ic2Vnb2Vmb250IiBmaWxsPSIjNDA0MDQwIiBmb250LXNpemU9IjM2cHgiPmxvY2tlZDwvdGV4dD4KCQk8dGV4dCB4PSIxNTU1IiB5PSIxMDUwIiBjbGFzcz0ic2Vnb2Vmb250IiBmaWxsPSIjNDA0MDQwIiBmb250LXNpemU9IjcycHgiIGZvbnQtd2VpZ2h0PSJib2xkIj50ZXN0IGJ1aWxkPC90ZXh0PgoJPC9nPgoJPHN0eWxlPgoJCS5zZWdvZWZvbnQgewoJCQlmb250LWZhbWlseTogJ1NlZ29lIFVJJywgVGFob21hLCBHZW5ldmEsIFZlcmRhbmEsIHNhbnMtc2VyaWY7CgkJfQoJPC9zdHlsZT4KPC9zdmc+Cg=="},"buildInfo":{"for":"1332","version":"1332","when":1751657439218,"signer":"moduleSigner","critical":false,"bootOrder":"50","signature":"93da3e0c0e034d7bb0788a1d95a45a713ce7fcaedd3fcbaf3d52d968e3c37d3bce1f709ec9de44b981ca785bf4a3c736f1d0bf98168385c7ac901a68b0ae6f07"}},"50-installer.fs":{"backend":{"files":{"apps":{"installer.js":"2bcd3a7454231d48a9dfe3d3127604c80278c9f64415b5f82082eb956f2d67c58e8f1dcf3acd0a05cf0bb4e73491a146cf282f0c6c9ca74591c78261d0f630b2"}},"permissions":{"apps/installer.js":{"world":"rx"},"apps/":{"world":"rx"},"":{"world":"rx"}}},"files":{"2bcd3a7454231d48a9dfe3d3127604c80278c9f64415b5f82082eb956f2d67c58e8f1dcf3acd0a05cf0bb4e73491a146cf282f0c6c9ca74591c78261d0f630b2":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: GET_LOCALE, GET_THEME, GET_BUILD, RUN_KLVL_CODE, LLDISK_WRITE, LLDISK_READ, FS_READ, FS_WRITE, FS_BYPASS_PERMISSIONS, FS_REMOVE, FS_LIST_PARTITIONS, SYSTEM_SHUTDOWN, FS_CHANGE_PERMISSION, LLDISK_LIST_PARTITIONS, FS_MOUNT, CSP_OPERATIONS, LLDISK_INIT_PARTITIONS, IPC_SEND_PIPE, GET_SERVER_URL, SET_USER_INFO, SET_DEFAULT_SYSTEM, RESOLVE_NAME, CONNFUL_CONNECT, CONNFUL_DISCONNECT, CONNFUL_WRITE, CONNFUL_READ, CONNFUL_ADDRESS_GET, CONNFUL_IDENTITY_GET\n// signature: b18f37e82024c870543a35122272c567c4b3b96a2de7dc81a26bb643d19a503ec5c0ef78482b037238ff86a7a69216d20e6ba26d9afe87e4ca8bcf5c418a5103\n// =====END MANIFEST=====\nlet onClose = () => availableAPIs.terminate();\n(async function() {\n\t// @pcos-app-mode isolatable\n\tlet networkDefaultURL = new URL(await availableAPIs.runningServer());\n\tnetworkDefaultURL.protocol = \"ws\" + (networkDefaultURL.protocol == \"https:\" ? \"s\" : \"\") + \":\";\n\tnetworkDefaultURL.pathname = \"\";\n\tconst networkSymbols = \"abcdefghijklmnopqrstuvwxyz0123456789_-\";\n\tlet automatic_configuration = {\n\t\t/* startInstall: true,\n\t\tacceptEULA: true,\n\t\tpartitioning: {\n\t\t\tdata: \"data\",\n\t\t\tboot: \"boot\",\n\t\t\tformat: true,\n\t\t\tautoInitNewInstalls: true\n\t\t},\n\t\tautoRestart: \"kexec\",\n\t\tdefaultLocale: \"en\", */\n\t\tsecondstage: {\n\t\t\tcreateAccount: {\n\t\t\t\t/*password: \"password\",\n\t\t\t\tdarkMode: true,\n\t\t\t\tcreate: true,\n\t\t\t\tdefaultLocale: \"en\",*/\n\t\t\t\tusername: \"root\",\n\t\t\t\tlockUsername: true\n\t\t\t},\n\t\t\tappHarden: {\n\t\t\t\trequireSignature: true,\n\t\t\t\trequireAllowlist: true\n\t\t\t},\n\t\t\tnetwork: {\n\t\t\t\turl: networkDefaultURL.toString(),\n\t\t\t\tucBits: 1,\n\t\t\t\thostname: new Array(16).fill(0).map(a => networkSymbols[Math.floor(Math.random() * networkSymbols.length)]).join(\"\"),\n\t\t\t\tupdates: \"pcosserver.pc\"\n\t\t\t}\n\t\t}\n\t};\n\tdocument.body.style.fontFamily = \"'Segoe UI', Tahoma, Geneva, Verdana, sans-serif\";\n\tif (await availableAPIs.isDarkThemed()) document.body.style.color = \"white\";\n\tawait availableAPIs.windowTitleSet(await availableAPIs.lookupLocale(\"INSTALL_PCOS\"));\n\tlet privileges = await availableAPIs.getPrivileges();\n\tlet checklist = [ \"GET_BUILD\", \"RUN_KLVL_CODE\", \"LLDISK_WRITE\", \"LLDISK_READ\", \"FS_READ\", \"FS_WRITE\", \"FS_BYPASS_PERMISSIONS\", \"FS_REMOVE\", \"FS_LIST_PARTITIONS\", \"SYSTEM_SHUTDOWN\", \"FS_CHANGE_PERMISSION\", \"LLDISK_LIST_PARTITIONS\", \"FS_MOUNT\", \"CSP_OPERATIONS\", \"LLDISK_INIT_PARTITIONS\", \"GET_SERVER_URL\" ];\n\tif (!checklist.every(p => privileges.includes(p))) return availableAPIs.terminate();\n\tlet installed_modules = [\n\t\t\"50-bootable.fs\", \"50-core.fs\", \"50-diff.fs\", \"00-keys.fs\", \"50-pcos-icons.fs\", \"50-pcos-sounds.fs\", \"50-pcos-wallpapers.fs\", \"50-sysadmin.fs\",\n\t\t\"50-terminal-disks.fs\", \"50-terminal-network.fs\", \"50-terminal-users.fs\", \"50-terminal.fs\", \"50-tweetnacl.fs\", \"50-xterm.fs\", \"50-blogBrowser.fs\",\n\t\t\"50-calculator.fs\", \"50-crypto-tools.fs\", \"50-multimedia.fs\"\n\t];\n\tlet downloadFromBdpOnMissing = \"bdp://pcosserver.pc\";\n\tawait availableAPIs.closeability(false);\n\tawait new Promise(async function(resolve) {\n\t\tlet locales = await availableAPIs.installedLocales();\n\t\tlet localeSelect = document.createElement(\"select\");\n\t\tlet localeZero = document.createElement(\"option\");\n\t\tlocaleZero.value = \"\";\n\t\tlocaleZero.innerText = \" 🌐 Language 🌐 \";\n\t\tlocaleZero.selected = true;\n\t\tlocaleZero.disabled = true;\n\t\tlocaleZero.hidden = true;\n\t\tlocaleSelect.appendChild(localeZero);\n\t\tfor (let locale of locales) {\n\t\t\tlet option = document.createElement(\"option\");\n\t\t\toption.value = locale;\n\t\t\toption.innerText = await availableAPIs.lookupOtherLocale({ key: \"LOCALE_NAME\", locale });\n\t\t\tlocaleSelect.appendChild(option);\n\t\t}\n\t\tlocaleSelect.addEventListener(\"change\", async function() {\n\t\t\tawait availableAPIs.runKlvlCode(\"modules.locales.defaultLocale = \" + JSON.stringify(localeSelect.value));\n\t\t\tinstalled_modules.push(\"50-locale-\" + localeSelect.value + \".fs\");\n\t\t\tawait availableAPIs.windowTitleSet(await availableAPIs.lookupLocale(\"INSTALL_PCOS\"));\n\t\t\tlocaleSelect.remove();\n\t\t\tawait availableAPIs.closeability(true);\n\t\t\tresolve();\n\t\t});\n\t\tif (automatic_configuration.defaultLocale) {\n\t\t\tlocaleSelect.value = automatic_configuration.defaultLocale;\n\t\t\tlocaleSelect.dispatchEvent(new Event(\"change\"));\n\t\t}\n\t\tdocument.body.appendChild(localeSelect);\n\t});\n\tif (exec_args[0]) onClose = async function() {\n\t\tmainInstallerContent.hidden = true;\n\t\tcloseContent.hidden = false;\n\t\tawait availableAPIs.closeability(false);\n\t}\n\tconst licenseText = `Copyright (c) 2024 PCsoft\nOriginal Source Code Repository: https://github.com/PC-trollbox/pcos3\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n---\nUsed libraries:\n\txterm.js:\n\t\tCopyright (c) 2017-2022, The xterm.js authors (https://github.com/xtermjs/xterm.js/graphs/contributors) (MIT License)\n\t\tCopyright (c) 2014-2017, SourceLair, Private Company (www.sourcelair.com) (MIT License)\n\t\tCopyright (c) 2012-2013, Christopher Jeffrey (MIT License)\n\ttweetnacl.js:\n\t\tPublic domain, https://github.com/dchest/tweetnacl-js\n\tfast-myers-diff (minified and modified):\n\t\tCopyright 2021 Logan R. Kearsley (https://github.com/gliese1337/fast-myers-diff)`;\n\tlet mainInstallerContent = document.createElement(\"div\");\n\tlet closeContent = document.createElement(\"div\");\n\tlet header = document.createElement(\"b\");\n\tlet postHeader = document.createElement(\"br\");\n\tlet description = document.createElement(\"span\");\n\tlet content = document.createElement(\"div\");\n\tlet button = document.createElement(\"button\");\n\tlet liveButton = document.createElement(\"button\");\n\tlet confirmDescription = document.createElement(\"p\");\n\tlet buttonYes = document.createElement(\"button\");\n\tlet buttonNo = document.createElement(\"button\");\n\n\tcloseContent.hidden = true;\n\n\tmainInstallerContent.style = \"position: absolute; top: 0; left: 0; width: 100%; height: 100%; padding: 8px; box-sizing: border-box;\";\n\tcloseContent.style = \"position: absolute; top: 0; left: 0; width: 100%; height: 100%; padding: 8px; box-sizing: border-box;\";\n\n\tconfirmDescription.innerText = await availableAPIs.lookupLocale(\"CLOSE_INSTALLER_CONFIRMATION\");\n\tbuttonYes.innerText = await availableAPIs.lookupLocale(\"YES\");\n\tbuttonNo.innerText = await availableAPIs.lookupLocale(\"NO\");\n\theader.innerText = await availableAPIs.lookupLocale(\"INSTALLER_TITLE\");\n\tdescription.innerText = (await availableAPIs.lookupLocale(\"INSTALLER_INVITATION\")).replace(\"%s\", await availableAPIs.getVersion());\n\tbutton.innerText = await availableAPIs.lookupLocale(\"INSTALL_BUTTON\");\n\tliveButton.innerText = await availableAPIs.lookupLocale(\"LIVE_BUTTON\");\n\n\tmainInstallerContent.appendChild(header);\n\tmainInstallerContent.appendChild(postHeader);\n\tmainInstallerContent.appendChild(description);\n\tmainInstallerContent.appendChild(content);\n\tmainInstallerContent.appendChild(button);\n\tmainInstallerContent.appendChild(document.createElement(\"br\"));\n\tif (exec_args[0]) mainInstallerContent.appendChild(liveButton);\n\n\tcloseContent.appendChild(confirmDescription);\n\tcloseContent.appendChild(buttonYes);\n\tcloseContent.insertAdjacentText(\"beforeend\", \" \");\n\tcloseContent.appendChild(buttonNo);\n\n\tdocument.body.appendChild(mainInstallerContent);\n\tdocument.body.appendChild(closeContent);\n\n\tbuttonNo.onclick = async function() {\n\t\tmainInstallerContent.hidden = false;\n\t\tcloseContent.hidden = true;\n\t\tawait availableAPIs.closeability(true);\n\t}\n\tbuttonYes.onclick = function() {\n\t\tonClose = () => availableAPIs.terminate();\n\t\tavailableAPIs.shutdown({\n\t\t\tisReboot: true\n\t\t});\n\t}\n\n\tbutton.onclick = async function() {\n\t\theader.remove();\n\t\tpostHeader.remove();\n\t\tliveButton.remove();\n\t\tcontent.innerHTML = \"\";\n\t\tdescription.innerText = await availableAPIs.lookupLocale(\"RIGHT_REVIEW\");\n\t\tlet textareaLicense = document.createElement(\"textarea\");\n\t\ttextareaLicense.readOnly = true;\n\t\ttextareaLicense.style.width = \"100%\";\n\t\ttextareaLicense.style.height = \"100%\";\n\t\tcontent.style.height = \"100%\";\n\t\ttextareaLicense.value = licenseText;\n\t\tcontent.appendChild(textareaLicense);\n\t\tbutton.innerText = await availableAPIs.lookupLocale(\"RIGHT_REVIEW_BTN\");\n\t\tbutton.onclick = async function() {\n\t\t\tcontent.innerHTML = \"\";\n\t\t\tcontent.style.height = \"\";\n\t\t\tdescription.innerText = await availableAPIs.lookupLocale(\"LET_CREATE_ACCOUNT\");\n\t\t\tbutton.innerText = await availableAPIs.lookupLocale(\"CREATE\");\n\t\t\tlet useraccountname = document.createElement(\"input\");\n\t\t\tlet useraccountpassword = document.createElement(\"input\");\n\t\t\tlet darkmode = document.createElement(\"input\");\n\t\t\tlet darkmode_lb = document.createElement(\"label\");\n\t\t\tuseraccountname.placeholder = await availableAPIs.lookupLocale(\"USERNAME\");\n\t\t\tuseraccountpassword.placeholder = await availableAPIs.lookupLocale(\"PASSWORD\");\n\t\t\tuseraccountpassword.type = \"password\";\n\t\t\tdarkmode.type = \"checkbox\";\n\t\t\tdarkmode.id = \"darkmode\";\n\t\t\tdarkmode_lb.innerText = await availableAPIs.lookupLocale(\"DARK_MODE\");\n\t\t\tdarkmode_lb.htmlFor = \"darkmode\";\n\t\t\tcontent.appendChild(useraccountname);\n\t\t\tcontent.appendChild(document.createElement(\"br\"));\n\t\t\tcontent.appendChild(useraccountpassword);\n\t\t\tcontent.appendChild(document.createElement(\"br\"));\n\t\t\tcontent.appendChild(darkmode);\n\t\t\tcontent.appendChild(darkmode_lb);\n\t\t\tbutton.onclick = async function() {\n\t\t\t\tlet username = useraccountname.value;\n\t\t\t\tlet password = useraccountpassword.value;\n\t\t\t\tif (!username) return;\n\t\t\t\tif (username.includes(\"/\")) return;\n\t\t\t\tif (!password) return;\n\t\t\t\tlet homedir = username == \"root\" ? (\"target/root\") : (\"target/home/\" + username);\n\t\t\t\tlet darkModeChecked = darkmode.checked;\n\t\t\t\tcontent.innerHTML = \"\";\n\t\t\t\tdescription.innerText = await availableAPIs.lookupLocale(\"INSTALLER_PARTITIONING\");\n\t\t\t\tbutton.innerText = await availableAPIs.lookupLocale(\"PARTITIONING_USE\");\n\t\t\t\tlet partitionDataInput = document.createElement(\"input\");\n\t\t\t\tlet partitionDataFormat = document.createElement(\"button\");\n\t\t\t\tlet partitionBootInput = document.createElement(\"input\");\n\t\t\t\tpartitionDataInput.placeholder = await availableAPIs.lookupLocale(\"PARTITION_DATA\");\n\t\t\t\tpartitionDataFormat.innerText = await availableAPIs.lookupLocale(\"FORMAT_DATA\");\n\t\t\t\tpartitionBootInput.placeholder = await availableAPIs.lookupLocale(\"PARTITION_BOOT\");\n\t\t\t\tpartitionDataInput.value = \"data\";\n\t\t\t\tpartitionBootInput.value = \"boot\";\n\t\t\t\tcontent.appendChild(partitionDataInput);\n\t\t\t\tcontent.insertAdjacentText(\"beforeend\", \" \");\n\t\t\t\tcontent.appendChild(partitionDataFormat);\n\t\t\t\tcontent.appendChild(document.createElement(\"br\"));\n\t\t\t\tcontent.appendChild(partitionBootInput);\n\t\t\t\tlet initSyncEnd;\n\t\t\t\tlet initSync = new Promise(_ => initSyncEnd = _);\n\t\t\t\tpartitionDataFormat.onclick = async function() {\n\t\t\t\t\tif (!partitionDataInput.value) return await htmlAlert(await availableAPIs.lookupLocale(\"DATA_INPUT_ALERT\"));\n\t\t\t\t\tlet newInstall = false;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait availableAPIs.lldaList();\n\t\t\t\t\t} catch {\n\t\t\t\t\t\tnewInstall = true;\n\t\t\t\t\t\tif (!automatic_configuration?.partitioning?.autoInitNewInstalls) \n\t\t\t\t\t\t\tif (!(await htmlConfirm(await availableAPIs.lookupLocale(\"PROMPT_PARTITION_TABLE\")))) return;\n\t\t\t\t\t\tawait availableAPIs.lldaInitPartitions();\n\t\t\t\t\t}\n\t\t\t\t\tlet confirmErasePart = true;\n\t\t\t\t\tif (!automatic_configuration?.partitioning?.format && !(automatic_configuration?.partitioning?.autoInitNewInstalls && newInstall))\n\t\t\t\t\t\tconfirmErasePart = await htmlConfirm(await availableAPIs.lookupLocale(\"CONFIRM_PARTITION_ERASE\"));\n\t\t\t\t\tif (confirmErasePart) {\n\t\t\t\t\t\tlet partData = await availableAPIs.lldaRead({ partition: partitionDataInput.value });\n\t\t\t\t\t\tlet partId;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tpartId = partData.id;\n\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\tif (!partId) partId = (await availableAPIs.cspOperation({\n\t\t\t\t\t\t\tcspProvider: \"basic\",\n\t\t\t\t\t\t\toperation: \"random\",\n\t\t\t\t\t\t\tcspArgument: new Uint8Array(64)\n\t\t\t\t\t\t})).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\")\n\t\t\t\t\t\tawait availableAPIs.lldaWrite({\n\t\t\t\t\t\t\tpartition: partitionDataInput.value,\n\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\tfiles: {},\n\t\t\t\t\t\t\t\tpermissions: {},\n\t\t\t\t\t\t\t\tid: partId\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tinitSyncEnd();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbutton.onclick = async function() {\n\t\t\t\t\tlet diskDataPartition = partitionDataInput.value;\n\t\t\t\t\tlet diskBootPartition = partitionBootInput.value;\n\t\t\t\t\tif (!diskDataPartition) return await htmlAlert(await availableAPIs.lookupLocale(\"DATA_INPUT_ALERT\"));\n\t\t\t\t\tif (!diskBootPartition) return await htmlAlert(await availableAPIs.lookupLocale(\"BOOT_INPUT_ALERT\"));\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!(await availableAPIs.lldaList()).includes(diskDataPartition)) throw new Error();\n\t\t\t\t\t} catch {\n\t\t\t\t\t\treturn await htmlAlert(await availableAPIs.lookupLocale(\"CANNOT_FIND_PARTITION\"));\n\t\t\t\t\t}\n\n\t\t\t\t\tlet tempCopy = Object.keys((await availableAPIs.lldaRead({ partition: diskDataPartition })) || {});\n\t\t\t\t\tif (!tempCopy.includes(\"files\") || !tempCopy.includes(\"permissions\"))\n\t\t\t\t\t\tif (!(await htmlConfirm(await availableAPIs.lookupLocale(\"PCFS_DETECTION_ERROR\")))) return;\n\n\t\t\t\t\ttempCopy = null;\n\t\t\t\t\tcontent.innerHTML = \"\";\n\t\t\t\t\tbutton.hidden = true;\n\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"PLEASE_WAIT\"));\n\t\t\t\t\tawait availableAPIs.closeability(false);\n\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"CREATING_BOOT_PARTITION\"));\n\t\t\t\t\tawait availableAPIs.lldaWrite({\n\t\t\t\t\t\tpartition: diskBootPartition,\n\t\t\t\t\t\tdata: `\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst AsyncFunction = (async () => {}).constructor;\n\t\t\t\t\t\tlet pre_boot_part = coreExports.disk.partition(${JSON.stringify(diskDataPartition)}).getData();\n\t\t\t\t\t\tlet pre_boot_modules = pre_boot_part?.files;\n\t\t\t\t\t\tif (!pre_boot_modules) {\n\t\t\t\t\t\t\tcoreExports.tty_bios_api.println(\"No files were found in the storage partition\");\n\t\t\t\t\t\t\tthrow new Error(\"No files were found in the storage partition\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpre_boot_modules = pre_boot_modules[coreExports.bootSection || \"boot\"];\n\t\t\t\t\t\tif (!pre_boot_modules) {\n\t\t\t\t\t\t\tcoreExports.tty_bios_api.println(\"No boot modules were found\");\n\t\t\t\t\t\t\tthrow new Error(\"No boot modules were found\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet pre_boot_module_list = Object.keys(pre_boot_modules);\n\t\t\t\t\t\tpre_boot_module_list = pre_boot_module_list.sort((a, b) => a.localeCompare(b));\n\t\t\t\t\t\tlet pre_boot_module_script = \"\";\n\t\t\t\t\t\tfor (let module of pre_boot_module_list) {\n\t\t\t\t\t\t\tif (coreExports.bootMode == \"logboot\") pre_boot_module_script += \"coreExports.tty_bios_api.println(\" + JSON.stringify(module) + \");\\\\n\";\n\t\t\t\t\t\t\tpre_boot_module_script += await coreExports.idb.readPart(pre_boot_part.id + \"-\" + pre_boot_modules[module]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tawait new AsyncFunction(pre_boot_module_script)();\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tcoreExports.tty_bios_api.println(\"Boot failed\");\n\t\t\t\t\t\tcoreExports.tty_bios_api.println(\"Press Enter to continue and log this error locally\");\n\t\t\t\t\t\tawait coreExports.tty_bios_api.inputLine();\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t\t`});\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"MOUNTING_DATA_PARTITION\"));\n\t\t\t\t\t\tawait availableAPIs.fs_mount({\n\t\t\t\t\t\t\tmountpoint: \"target\",\n\t\t\t\t\t\t\tfilesystem: \"PCFSiDBMount\",\n\t\t\t\t\t\t\tfilesystemOptions: {\n\t\t\t\t\t\t\t\tpartition: diskDataPartition\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"CHANGING_ROOT_PERMISSIONS\"));\n\t\t\t\t\t\tawait availableAPIs.fs_chmod({ path: \"target\", newPermissions: \"rx\" });\n\t\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"COPYING_FOLDERS\"));\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\trecursiveRemove(\"target/modules\");\n\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait availableAPIs.fs_mkdir({ path: \"target/modules\" });\n\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\tlet modules = await availableAPIs.fs_ls({ path: (await availableAPIs.getSystemMount()) + \"/modules\" });\n\t\t\t\t\t\tfor (let module of installed_modules) {\n\t\t\t\t\t\t\tif (!modules.includes(module)) {\n\t\t\t\t\t\t\t\tif (downloadFromBdpOnMissing) try {\n\t\t\t\t\t\t\t\t\tlet fetchModule = await bdpGet(new URL(\"/module_repository/\" + module, downloadFromBdpOnMissing));\n\t\t\t\t\t\t\t\t\tif (fetchModule.error) throw new Error(fetchModule.error);\n\t\t\t\t\t\t\t\t\tawait availableAPIs.fs_write({ path: \"target/modules/\" + module, data: fetchModule.content });\n\t\t\t\t\t\t\t\t\tmodules.push(module);\n\t\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\t\tconsole.error(\"Failed to fetch module\", module, \":\", e);\n\t\t\t\t\t\t\t\t\tthrow new Error(\"Module required (\" + module + \")\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse throw new Error(\"Module required (\" + module + \")\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tawait availableAPIs.fs_write({\n\t\t\t\t\t\t\t\t\tpath: \"target/modules/\" + module,\n\t\t\t\t\t\t\t\t\tdata: await availableAPIs.fs_read({\n\t\t\t\t\t\t\t\t\t\tpath: (await availableAPIs.getSystemMount()) + \"/modules/\" + module\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"CREATING_DIRECTORY_STRUCTURE\"));\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait availableAPIs.fs_mkdir({ path: \"target/apps\" });\n\t\t\t\t\t\t\tawait availableAPIs.fs_mkdir({ path: \"target/apps/associations\" });\n\t\t\t\t\t\t\tawait availableAPIs.fs_mkdir({ path: \"target/apps/links\" });\n\t\t\t\t\t\t\tawait availableAPIs.fs_mkdir({ path: \"target/boot\" });\n\t\t\t\t\t\t\tawait availableAPIs.fs_mkdir({ path: \"target/etc\" });\n\t\t\t\t\t\t\tawait availableAPIs.fs_mkdir({ path: \"target/etc/wallpapers\" });\n\t\t\t\t\t\t\tawait availableAPIs.fs_mkdir({ path: \"target/etc/icons\" });\n\t\t\t\t\t\t\tawait availableAPIs.fs_mkdir({ path: \"target/etc/sounds\" });\n\t\t\t\t\t\t\tawait availableAPIs.fs_mkdir({ path: \"target/etc/keys\" });\n\t\t\t\t\t\t\tawait availableAPIs.fs_mkdir({ path: \"target/etc/security\" });\n\t\t\t\t\t\t\tawait availableAPIs.fs_chmod({\n\t\t\t\t\t\t\t\tpath: \"target/etc/security\",\n\t\t\t\t\t\t\t\tnewPermissions: \"\"\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tawait availableAPIs.fs_mkdir({ path: \"target/root\" });\n\t\t\t\t\t\t\tawait availableAPIs.fs_mkdir({ path: \"target/home\" });\n\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"PATCHING_FS\"));\n\t\t\t\t\t\tlet systemCode = \"let localSystemMount = \\\".storage\\\";\\nlet mountOptions = {\\n\\tpartition: \" + JSON.stringify(diskDataPartition) + \"\\n};\\ntry {\\n\\tmodules.fs.mounts[localSystemMount] = await modules.mounts.PCFSiDBMount(mountOptions);\\n\\tmodules.defaultSystem = localSystemMount;\\n} catch (e) {\\n\\tawait panic(\\\"SYSTEM_PARTITION_MOUNTING_FAILED\\\", { underlyingJS: e, name: \\\"fs.mounts\\\", params: [localSystemMount, mountOptions]});\\n}\\n\";\n\t\t\t\t\t\tawait availableAPIs.fs_write({ path: \"target/boot/01-fsboot.js\", data: systemCode });\n\t\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"SETTING_LOCALE_PREFERENCE\"));\n\t\t\t\t\t\tawait availableAPIs.fs_write({ path: \"target/boot/06-localeset.js\", data: \"modules.locales.defaultLocale = \" + JSON.stringify(await availableAPIs.osLocale()) + \";\\n\" });\n\t\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"GENERATING_KERNEL\"));\n\t\t\t\t\t\tlet entireBoot = [];\n\t\t\t\t\t\tlet entireBootFiles = [];\n\t\t\t\t\t\tlet bootFiles = await availableAPIs.fs_ls({ path: \"target/boot\" });\n\t\t\t\t\t\tif (bootFiles.includes(\"00-compiled.js\")) bootFiles.splice(bootFiles.indexOf(\"00-compiled.js\"), 1);\n\t\t\t\t\t\tif (bootFiles.includes(\"99-zzpatchfinisher.js\")) bootFiles.splice(bootFiles.indexOf(\"99-zzpatchfinisher.js\"), 1);\n\t\t\t\t\t\tfor (let bootFile of bootFiles) {\n\t\t\t\t\t\t\tentireBootFiles.push(bootFile);\n\t\t\t\t\t\t\tentireBoot.push([ bootFile, await availableAPIs.fs_read({\n\t\t\t\t\t\t\t\tpath: \"target/boot/\" + bootFile\n\t\t\t\t\t\t\t}) ]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmodules = (await availableAPIs.fs_ls({ path: \"target/modules\" })).sort((a, b) => a.localeCompare(b));\n\t\t\t\t\t\tfor (let module of modules) {\n\t\t\t\t\t\t\tlet moduleFile = JSON.parse(await availableAPIs.fs_read({ path: \"target/modules/\" + module }));\n\t\t\t\t\t\t\tfor (let bootFile in (moduleFile.backend.files.boot || [])) {\n\t\t\t\t\t\t\t\tif (entireBootFiles.includes(bootFile)) continue;\n\t\t\t\t\t\t\t\tentireBoot.push([ bootFile, moduleFile.files[moduleFile.backend.files.boot[bootFile]] ]);\n\t\t\t\t\t\t\t\tentireBootFiles.push(bootFile);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tentireBoot = entireBoot.sort((a, b) => a[0].localeCompare(b[0]))\n\t\t\t\t\t\t\t.map(a => \"// modules/.../boot/\" + a[0] + \"\\n\" + a[1]).join(\"\\n\");\n\t\t\t\t\t\tawait availableAPIs.fs_write({ path: \"target/boot/00-compiled.js\", data: entireBoot + \"\\nreturn;/*\" });\n\t\t\t\t\t\tawait availableAPIs.fs_write({ path: \"target/boot/99-zzpatchfinisher.js\", data: \"*/\" });\n\t\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"INSTALLING_SYSTEM_APPHARDEN\"));\n\t\t\t\t\t\tif (automatic_configuration.secondstage.appHarden) await availableAPIs.fs_write({\n\t\t\t\t\t\t\tpath: \"target/etc/appHarden\",\n\t\t\t\t\t\t\tdata: JSON.stringify(automatic_configuration.secondstage.appHarden)\n\t\t\t\t\t\t});\n\t\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"INSTALLING_NET_CONF\"));\n\t\t\t\t\t\tif (automatic_configuration.secondstage.network) await availableAPIs.fs_write({\n\t\t\t\t\t\t\tpath: \"target/etc/network.json\",\n\t\t\t\t\t\t\tdata: JSON.stringify(automatic_configuration.secondstage.network)\n\t\t\t\t\t\t});\n\t\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"CREATING_USER\"));\n\t\t\t\t\t\tlet salt = await availableAPIs.cspOperation({\n\t\t\t\t\t\t\tcspProvider: \"basic\",\n\t\t\t\t\t\t\toperation: \"random\",\n\t\t\t\t\t\t\tcspArgument: new Uint8Array(64)\n\t\t\t\t\t\t});\n\t\t\t\t\t\tlet u8aToHex = (u8a) => Array.from(u8a).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\t\tlet key = await availableAPIs.cspOperation({\n\t\t\t\t\t\t\tcspProvider: \"basic\",\n\t\t\t\t\t\t\toperation: \"importKey\",\n\t\t\t\t\t\t\tcspArgument: {\n\t\t\t\t\t\t\t\tformat: \"raw\",\n\t\t\t\t\t\t\t\tkeyData: new TextEncoder().encode(password),\n\t\t\t\t\t\t\t\talgorithm: { name: \"PBKDF2\" },\n\t\t\t\t\t\t\t\textractable: false,\n\t\t\t\t\t\t\t\tkeyUsages: [\"deriveBits\", \"deriveKey\"]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tlet derived = new Uint8Array(await availableAPIs.cspOperation({\n\t\t\t\t\t\t\tcspProvider: \"basic\",\n\t\t\t\t\t\t\toperation: \"deriveBits\",\n\t\t\t\t\t\t\tcspArgument: {\n\t\t\t\t\t\t\t\talgorithm: {\n\t\t\t\t\t\t\t\t\tname: \"PBKDF2\",\n\t\t\t\t\t\t\t\t\tsalt: salt,\n\t\t\t\t\t\t\t\t\titerations: 100000,\n\t\t\t\t\t\t\t\t\thash: \"SHA-256\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tbaseKey: key,\n\t\t\t\t\t\t\t\tlength: 256\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}));\n\t\t\t\t\t\tawait availableAPIs.cspOperation({ cspProvider: \"basic\", operation: \"unloadKey\", cspArgument: key });\n\t\t\t\t\t\tlet currentMount = await availableAPIs.getSystemMount();\n\t\t\t\t\t\tawait availableAPIs.setSystemMount(\"target\");\n\t\t\t\t\t\tawait availableAPIs.fs_write({\n\t\t\t\t\t\t\tpath: \"target/etc/security/users\",\n\t\t\t\t\t\t\tdata: JSON.stringify({authui: {\n\t\t\t\t\t\t\t\tsecurityChecks: [],\n\t\t\t\t\t\t\t\tgroups: [\"authui\"],\n\t\t\t\t\t\t\t\thomeDirectory: \"system\",\n\t\t\t\t\t\t\t\tblankPrivileges: true,\n\t\t\t\t\t\t\t\tadditionalPrivilegeSet: [ \"IPC_SEND_PIPE\", \"GET_LOCALE\", \"GET_THEME\", \"ELEVATE_PRIVILEGES\", \"FS_READ\", \"FS_LIST_PARTITIONS\", \"CSP_OPERATIONS\" ]\n\t\t\t\t\t\t\t}})\n\t\t\t\t\t\t});\n\t\t\t\t\t\tawait availableAPIs.fs_chmod({ path: \"target/etc/security/users\", newPermissions: \"\" });\n\t\t\t\t\t\tawait availableAPIs.setUserInfo({\n\t\t\t\t\t\t\tdesiredUser: username,\n\t\t\t\t\t\t\tinfo: {\n\t\t\t\t\t\t\t\tsecurityChecks: [\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\ttype: \"pbkdf2\",\n\t\t\t\t\t\t\t\t\t\thash: u8aToHex(derived),\n\t\t\t\t\t\t\t\t\t\tsalt: u8aToHex(salt)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\tgroups: [ username, \"users\" ],\n\t\t\t\t\t\t\t\thomeDirectory: \"system\" + homedir.slice(6),\n\t\t\t\t\t\t\t\tblankPrivileges: false\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tawait availableAPIs.setSystemMount(currentMount);\n\t\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"CREATING_USER_HOME\"));\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait availableAPIs.fs_mkdir({ path: homedir });\n\t\t\t\t\t\t\tawait availableAPIs.fs_chown({ path: homedir, newUser: username });\n\t\t\t\t\t\t\tawait availableAPIs.fs_chgrp({ path: homedir, newGrp: username });\n\t\t\t\t\t\t\tawait availableAPIs.fs_chmod({ path: homedir, newPermissions: \"rx\" });\n\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait availableAPIs.fs_mkdir({ path: homedir + \"/desktop\" });\n\t\t\t\t\t\t\tawait availableAPIs.fs_chown({ path: homedir + \"/desktop\", newUser: username });\n\t\t\t\t\t\t\tawait availableAPIs.fs_chgrp({ path: homedir + \"/desktop\", newGrp: username });\n\t\t\t\t\t\t\tawait availableAPIs.fs_chmod({ path: homedir + \"/desktop\", newPermissions: \"rx\" });\n\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"INSTALLING_WP2U\"));\n\t\t\t\t\t\tlet wallpaperModule;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\twallpaperModule = JSON.parse(await availableAPIs.fs_read({ path: \"target/modules/50-pcos-wallpapers.fs\" }));\n\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\tif (wallpaperModule) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tawait availableAPIs.fs_write({\n\t\t\t\t\t\t\t\t\tpath: homedir + \"/.wallpaper\",\n\t\t\t\t\t\t\t\t\tdata: wallpaperModule.files[wallpaperModule.backend.files.etc.wallpapers[\"pcos\" + (darkModeChecked ? \"-dark\" : \"\") + \"-beta.pic\"]]\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tawait availableAPIs.fs_chown({ path: homedir + \"/.wallpaper\", newUser: username });\n\t\t\t\t\t\t\t\tawait availableAPIs.fs_chgrp({ path: homedir + \"/.wallpaper\", newGrp: username });\n\t\t\t\t\t\t\t\tawait availableAPIs.fs_chmod({ path: homedir + \"/.wallpaper\", newPermissions: \"rx\" });\n\t\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"INSTALLING_WP2L\"));\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait availableAPIs.fs_write({\n\t\t\t\t\t\t\t\tpath: \"target/etc/wallpapers/lockscreen.pic\",\n\t\t\t\t\t\t\t\tdata: wallpaperModule.files[wallpaperModule.backend.files.etc.wallpapers[\"pcos-lock-beta.pic\"]]\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\tdescription.innerHTML = (await availableAPIs.lookupLocale(\"INSTALLING_PCOS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"INSTALLING_DARKMODE\"));\n\t\t\t\t\t\tawait availableAPIs.fs_write({\n\t\t\t\t\t\t\tpath: homedir + \"/.darkmode\",\n\t\t\t\t\t\t\tdata: darkModeChecked.toString()\n\t\t\t\t\t\t});\n\t\t\t\t\t\tawait availableAPIs.fs_chown({ path: homedir + \"/.darkmode\", newUser: username });\n\t\t\t\t\t\tawait availableAPIs.fs_chgrp({ path: homedir + \"/.darkmode\", newGrp: username });\n\t\t\t\t\t\tawait availableAPIs.fs_chmod({ path: homedir + \"/.darkmode\", newPermissions: \"rx\" });\n\t\t\t\t\t\tdescription.innerHTML = await availableAPIs.lookupLocale(\"INSTALLATION_SUCCESSFUL\");\n\t\t\t\t\t\tif (!automatic_configuration.autoRestart) await availableAPIs.closeability(true);\n\t\t\t\t\t\tonClose = function() {\n\t\t\t\t\t\t\tonClose = () => availableAPIs.terminate();\n\t\t\t\t\t\t\tavailableAPIs.shutdown({\n\t\t\t\t\t\t\t\tisReboot: true,\n\t\t\t\t\t\t\t\tisKexec: automatic_configuration.autoRestart == \"kexec\"\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (automatic_configuration.autoRestart) onClose();\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tconsole.error(e);\n\t\t\t\t\t\tdescription.innerHTML = await availableAPIs.lookupLocale(\"INSTALLATION_FAILED\");\n\t\t\t\t\t\tawait availableAPIs.closeability(true);\n\t\t\t\t\t\tonClose = function() {\n\t\t\t\t\t\t\tonClose = () => availableAPIs.terminate();\n\t\t\t\t\t\t\tavailableAPIs.shutdown({\n\t\t\t\t\t\t\t\tisReboot: true\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (automatic_configuration.partitioning) {\n\t\t\t\t\tpartitionDataInput.value = automatic_configuration.partitioning.data || \"data\";\n\t\t\t\t\tpartitionBootInput.value = automatic_configuration.partitioning.boot || \"boot\";\n\t\t\t\t\tlet newInstall = false;\n\t\t\t\t\ttry { await availableAPIs.lldaList(); } catch { newInstall = true; }\n\t\t\t\t\tif (automatic_configuration.partitioning.format || (newInstall && automatic_configuration.partitioning.autoInitNewInstalls)) {\n\t\t\t\t\t\tpartitionDataFormat.click();\n\t\t\t\t\t\tawait initSync;\n\t\t\t\t\t}\n\t\t\t\t\tbutton.click();\n\t\t\t\t}\n\t\t\t}\n\t\t\tuseraccountname.value = automatic_configuration.secondstage.createAccount.username || useraccountname.value;\n\t\t\tuseraccountpassword.value = automatic_configuration.secondstage.createAccount.password || \"\";\n\t\t\tdarkmode.checked = automatic_configuration.secondstage.createAccount.darkMode || darkmode.checked;\n\t\t\tuseraccountname.disabled = automatic_configuration.secondstage.createAccount.lockUsername;\n\t\t\tif (automatic_configuration.secondstage.createAccount.lockUsername) useraccountname.title = await availableAPIs.lookupLocale(\"PROVISIONED_PREFERENCE\");\n\t\t\tif (automatic_configuration.secondstage.createAccount.create) button.click();\n\t\t}\n\t\tif (automatic_configuration.acceptEULA) button.click();\n\t}\n\tliveButton.onclick = async function() {\n\t\theader.remove();\n\t\tpostHeader.remove();\n\t\tliveButton.remove();\n\t\tcontent.innerHTML = \"\";\n\t\tdescription.innerText = await availableAPIs.lookupLocale(\"RIGHT_REVIEW\");\n\t\tlet textareaLicense = document.createElement(\"textarea\");\n\t\ttextareaLicense.readOnly = true;\n\t\ttextareaLicense.style.width = \"100%\";\n\t\ttextareaLicense.style.height = \"100%\";\n\t\tcontent.style.height = \"100%\";\n\t\ttextareaLicense.value = licenseText;\n\t\tcontent.appendChild(textareaLicense);\n\t\tbutton.innerText = await availableAPIs.lookupLocale(\"RIGHT_REVIEW_BTN\");\n\t\tbutton.onclick = async function() {\n\t\t\tcontent.innerHTML = \"\";\n\t\t\tcontent.style.height = \"\";\n\t\t\tawait availableAPIs.sendToPipe({\n\t\t\t\tpipe: exec_args[0],\n\t\t\t\tdata: true\n\t\t\t});\n\t\t\tawait availableAPIs.terminate();\n\t\t}\n\t}\n\tif (automatic_configuration.startInstall) button.click()\n})();\n\nasync function htmlAlert(msg) {\n\tlet overlay = document.createElement(\"div\");\n\tlet overlayingMessage = document.createElement(\"div\");\n\tlet description = document.createElement(\"span\");\n\tlet buttonAccept = document.createElement(\"button\");\n\toverlay.style = \"position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: black; opacity: 85%;\";\n\toverlayingMessage.style = \"position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; padding: 8px; box-sizing: border-box; color: white;\";\n\tdescription.innerText = msg;\n\tbuttonAccept.innerText = \"Ok\";\n\toverlayingMessage.appendChild(description);\n\toverlayingMessage.appendChild(document.createElement(\"hr\"));\n\toverlayingMessage.appendChild(buttonAccept);\n\tdocument.body.appendChild(overlay);\n\tdocument.body.appendChild(overlayingMessage);\n\treturn new Promise(function(resolve) {\n\t\tbuttonAccept.onclick = function() {\n\t\t\toverlay.remove();\n\t\t\toverlayingMessage.remove();\n\t\t\tresolve();\n\t\t}\n\t});\n}\n\nasync function htmlConfirm(msg) {\n\tlet overlay = document.createElement(\"div\");\n\tlet overlayingMessage = document.createElement(\"div\");\n\tlet description = document.createElement(\"span\");\n\tlet buttonAccept = document.createElement(\"button\");\n\tlet buttonDecline = document.createElement(\"button\");\n\toverlay.style = \"position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: black; opacity: 85%;\";\n\toverlayingMessage.style = \"position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; padding: 8px; box-sizing: border-box; color: white;\";\n\tdescription.innerText = msg;\n\tbuttonAccept.innerText = await availableAPIs.lookupLocale(\"YES\");\n\tbuttonDecline.innerText = await availableAPIs.lookupLocale(\"NO\");\n\toverlayingMessage.appendChild(description);\n\toverlayingMessage.appendChild(document.createElement(\"hr\"));\n\toverlayingMessage.appendChild(buttonAccept);\n\toverlayingMessage.appendChild(buttonDecline);\n\tdocument.body.appendChild(overlay);\n\tdocument.body.appendChild(overlayingMessage);\n\treturn new Promise(function(resolve) {\n\t\tbuttonAccept.onclick = function() {\n\t\t\toverlay.remove();\n\t\t\toverlayingMessage.remove();\n\t\t\tresolve(true);\n\t\t}\n\t\tbuttonDecline.onclick = function() {\n\t\t\toverlay.remove();\n\t\t\toverlayingMessage.remove();\n\t\t\tresolve(false);\n\t\t}\n\t});\n}\n\nasync function recursiveCopy(source, destination, permissions) {\n\tfor (let sourceFile of await availableAPIs.fs_ls({ path: source })) {\n\t\tlet destinationFile = destination + \"/\" + sourceFile;\n\t\tif (await availableAPIs.fs_isDirectory({ path: source + \"/\" + sourceFile })) {\n\t\t\ttry {\n\t\t\t\tawait availableAPIs.fs_mkdir({ path: destinationFile });\n\t\t\t} catch {}\n\t\t\tawait recursiveCopy(source + \"/\" + sourceFile, destinationFile, permissions);\n\t\t} else {\n\t\t\tawait availableAPIs.fs_write({\n\t\t\t\tpath: destinationFile,\n\t\t\t\tdata: await availableAPIs.fs_read({ path: source + \"/\" + sourceFile })\n\t\t\t});\n\t\t}\n\t\tif (permissions) {\n\t\t\tlet originalPermissions = await availableAPIs.fs_permissions({ path: source + \"/\" + sourceFile });\n\t\t\tawait availableAPIs.fs_chmod({ path: destinationFile, newPermissions: originalPermissions.world });\n\t\t\tawait availableAPIs.fs_chgrp({ path: destinationFile, newGrp: originalPermissions.group });\n\t\t\tawait availableAPIs.fs_chown({ path: destinationFile, newUser: originalPermissions.owner });\n\t\t}\n\t}\n}\n\nasync function recursiveRemove(target) {\n\tfor (let targetFile of await availableAPIs.fs_ls({ path: target })) {\n\t\ttargetFile = target + \"/\" + targetFile;\n\t\tif (await availableAPIs.fs_isDirectory({ path: targetFile })) await recursiveRemove(targetFile);\n\t\tawait availableAPIs.fs_rm({ path: targetFile });\n\t}\n}\n\nasync function bdpGet(path) {\n\tlet url = new URL(path);\n\tif (url.protocol != \"bdp:\") throw new Error(await availableAPIs.lookupLocale(\"BLOG_BROWSER_PROTO\"));\n\tif (url.port) throw new Error(await availableAPIs.lookupLocale(\"BLOG_BROWSER_GATESET\"));\n\tlet hostname = url.hostname, address;\n\tif (url.hostname.includes(\"[\")) {\n\t\thostname = IPv6Decompressor(url.hostname.slice(1, -1)).replaceAll(\":\", \"\");\n\t\taddress = hostname;\n\t} else address = await availableAPIs.resolve(hostname);\n\tif (!address) throw new Error(await availableAPIs.lookupLocale(\"HOSTNAME_RESOLUTION_FAILED\"));\n\tlet connection = await availableAPIs.connfulConnect({\n\t\tgate: url.username || \"blog\",\n\t\taddress,\n\t\tverifyByDomain: hostname\n\t});\n\tawait availableAPIs.connfulConnectionSettled(connection);\n\tawait availableAPIs.connfulWrite({\n\t\tconnectionID: connection,\n\t\tdata: url.pathname + url.search,\n\t\thost: hostname\n\t});\n\tlet data = await availableAPIs.connfulRead(connection);\n\tdata = JSON.parse(data);\n\tlet chunks = [];\n\twhile (chunks.length != data.length) {\n\t\tlet newData = await availableAPIs.connfulRead(connection);\n\t\tnewData = JSON.parse(newData);\n\t\tchunks[newData.ctr] = newData.chunk;\n\t}\n\ttry {\n\t\tawait availableAPIs.connfulClose(connection);\n\t} catch {}\n\treturn { ...data, content: chunks.join(\"\") };\n}\n\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) onClose();\n}); "},"buildInfo":{"for":"1332","version":"1332","when":1751657439204,"signer":"moduleSigner","critical":false,"bootOrder":"50","signature":"7e3897e2f3a71f7fe4f6d7c3d6e0ba73628e3a56e43263876ee23a82daee8484cd5325fe6e1fb3879841a6e96831a4720afe2f2772c4c8b7bade62eeae68e30b"}},"50-installer-modules.fs":{"backend":{"files":{"boot":{"01-fsmodule-pre.js":"c2cf187631159d2129636ae877d7318b3eb7c004cacf1a4640d67afa853049e6f12aa39c1bd11891e793fed50fd546289c851c480c37db76a0bedab9be29ed02","02-postmodule.js":"d49b625f88f1b092b830a4c887e2955527bd6169bc065d861441d2a0eabe95a30a96850dd41d8191a7a19d052a1c1d7be68af2fff200e32f2f394416395bbd12"}},"permissions":{"boot/01-fsmodule-pre.js":{"world":"rx"},"boot/02-postmodule.js":{"world":"rx"},"boot/":{"world":"rx"},"":{"world":"rx"}}},"files":{"c2cf187631159d2129636ae877d7318b3eb7c004cacf1a4640d67afa853049e6f12aa39c1bd11891e793fed50fd546289c851c480c37db76a0bedab9be29ed02":"// @pcos-app-mode native\nmodules.fs.mounts[\".installer\"] = modules.mounts.ramMount({});\nmodules.defaultSystem = \".installer\";\n// Directory structure\nmodules.fs.mkdir(\".installer/modules\");\nmodules.fs.mkdir(\".installer/root\");\nmodules.fs.mkdir(\".installer/root/.autorunNecessity\");\nmodules.fs.mkdir(\".installer/root/desktop\");\nmodules.fs.mkdir(\".installer/apps\");\nmodules.fs.mkdir(\".installer/apps/associations\");\nmodules.fs.mkdir(\".installer/apps/links\");\nmodules.fs.mkdir(\".installer/etc\");\nmodules.fs.mkdir(\".installer/etc/wallpapers\");\nmodules.fs.mkdir(\".installer/etc/security\");\nmodules.fs.write(\".installer/etc/appHarden\", JSON.stringify({\n\trequireSignature: true,\n\trequireAllowlist: true\n}));\nmodules.fs.write(\".installer/etc/security/users\", JSON.stringify({\n\troot: {\n\t\tsecurityChecks: [ { type: \"timeout\", timeout: 0 } ],\n\t\tgroups: [\"root\"],\n\t\thomeDirectory: \"system/root\"\n\t},\n\tauthui: {\n\t\tsecurityChecks: [],\n\t\tgroups: [\"authui\"],\n\t\thomeDirectory: \"system\",\n\t\tblankPrivileges: true,\n\t\tadditionalPrivilegeSet:  [ \"IPC_SEND_PIPE\", \"GET_LOCALE\", \"GET_THEME\", \"ELEVATE_PRIVILEGES\", \"FS_READ\", \"FS_LIST_PARTITIONS\", \"CSP_OPERATIONS\" ]\n\t}\n}));\nmodules.fs.write(\".installer/etc/security/automaticLogon\", \"root\");\nmodules.fs.write(\".installer/root/.darkmode\", \"false\");\nlet autorunEntry = JSON.stringify({\n\tlocaleReferenceName: \"INSTALLER_TITLE\",\n\tpath: \"system/apps/installer.js\"\n});\nmodules.fs.write(\".installer/root/.autorunNecessity/installer.lnk\", autorunEntry);\nmodules.fs.write(\".installer/root/desktop/installer.lnk\", autorunEntry);\nlet networkDefaultURL = new URL(location.origin);\nnetworkDefaultURL.protocol = \"ws\" + (networkDefaultURL.protocol == \"https:\" ? \"s\" : \"\") + \":\";\nnetworkDefaultURL.pathname = \"\";\nmodules.fs.write(\".installer/etc/network.json\", JSON.stringify({\n\turl: networkDefaultURL.toString(),\n\tucBits: 1,\n\tupdates: \"pcosserver.pc\"\n}));","d49b625f88f1b092b830a4c887e2955527bd6169bc065d861441d2a0eabe95a30a96850dd41d8191a7a19d052a1c1d7be68af2fff200e32f2f394416395bbd12":"// Insert wallpapers\ntry { modules.fs.write(\"system/etc/wallpapers/lockscreen.pic\", await modules.fs.read(\"system/etc/wallpapers/pcos-lock-beta.pic\")); } catch {}\ntry { modules.fs.write(\"system/root/.wallpaper\", await modules.fs.read(\"system/etc/wallpapers/pcos-beta.pic\")); } catch {}"},"buildInfo":{"for":"1332","version":"1332","when":1751657439203,"signer":"moduleSigner","critical":false,"bootOrder":"50","signature":"24b24b11e70ab87b16854097740877405c79f811ec626c6babce4ccaff6c68655523d28381255d42d0754c597b4e66995ca0fd0cd2a6e4bf8836e6cf0ecccb0a"}}};
coreExports.tty_bios_api.println("Booting from module bundle");
let entireBoot = [];
const AsyncFunction = (async () => {}).constructor;
for (let installerModule in installerModuleBundle) {
	let reviewingModule = installerModuleBundle[installerModule];
	if (reviewingModule.backend.files.boot) {
		for (let bootFile in reviewingModule.backend.files.boot) {
			entireBoot.push([ bootFile, reviewingModule.files[reviewingModule.backend.files.boot[bootFile]] ]);
		}
	}
}
entireBoot.push(["01-fsmodule-start.js", 'let installerModuleBundle = ' + JSON.stringify(installerModuleBundle) + '; for (let installerModule in installerModuleBundle) { await modules.fs.write(".installer/modules/" + installerModule, JSON.stringify(installerModuleBundle[installerModule])); }']);
entireBoot = entireBoot.sort((a, b) => a[0].localeCompare(b[0])).map(a => a[1]).join("\n");
return new AsyncFunction(entireBoot)();