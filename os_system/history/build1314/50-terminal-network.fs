{"backend":{"files":{"apps":{"basiccurl.js":"2be34a664e445f581adbd80cd2584862f15c46a0d643004df252b0dfa5c24a6b48442f2d33368e9164a75e30e0d19e5a2ba8ea76f96f29553f79bea30d1641ba","diffupdate.js":"d9b76925583f92aeddd49ab051425f8e6aad18239a77b00be08b68134d8a4eb0f71fc758084fd5be1e428887e4d0d6a24315a306e5115f950684caa2770574b6","netinfo.js":"82ab2375cf39097e3513bf8d73f79775e37b228c6d90c4fa2667f5080d8a749a870511ac5365bfc8613b6cf9b6ad10a58cc312bc1b61ed0985f3141eead02245","networkfs.js":"5e14e8a54623bf7e829ec01dcd8fd4acd7d5aaca206ad04cac7456adde35427c1f162b0e3954e53df1fd4a68ef4ead3dd7006abe5680b8826313e11b17033974","ping.js":"d26bceda19eb0c72e6bf0453acf2ac04ccfb9ef390ba679f869d5dace616279d7765af316d497d8d2b79d790fdada8ea88ab49e9d70fb08677ef222a8dbeb9e0","renetworkd.js":"d9fc559b1004a01adafe9c07244ebb9c6305878a4e1cf3a05b71fd1df20ad18ec052bdf39f2bd06ab986b8b857dc0b25daec294c7c1243e58f90e10a39de8299","updatefw.js":"a364c81d85a7c6e9dab7d7efde403cedfdd175fe0b6a029f796fcdedfa1860adfd691dc731f1aa4ce66e3477ab35f63f19f077840c24a6063107e759fd2b09c6","updateos.js":"f3481b80b2bde53b28f19d5b29f11ffd0d9a0a2c20ab80d94f82e932a2fb4bb5885f84d8e3221ad718940a4783b050fc48317d56daa5161e86d23c8b730ce3ac"}},"permissions":{"apps/basiccurl.js":{"world":"rx"},"apps/diffupdate.js":{"world":"rx"},"apps/netinfo.js":{"world":"rx"},"apps/networkfs.js":{"world":"rx"},"apps/ping.js":{"world":"rx"},"apps/renetworkd.js":{"world":"rx"},"apps/updatefw.js":{"world":"rx"},"apps/updateos.js":{"world":"rx"},"apps/":{"world":"rx"},"":{"world":"rx"}}},"files":{"2be34a664e445f581adbd80cd2584862f15c46a0d643004df252b0dfa5c24a6b48442f2d33368e9164a75e30e0d19e5a2ba8ea76f96f29553f79bea30d1641ba":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: GET_LOCALE, FS_READ, FS_WRITE, FETCH_SEND, FS_BYPASS_PERMISSIONS, FS_CHANGE_PERMISSION\n// signature: f715c4801e289de93efe7f69563141b28fbc3abdd35c5f74b8bac91b59dca6aa6d28bb4f4b99becbfa5bb0ec30ff89ed6781a3163501c7015bc158eb65407699\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.windowVisibility(false);\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"basiccurl: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\tif (!exec_args.length) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"BASIC_CURL_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"BASIC_CURL_DESCRIPTION\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"basiccurl: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\ttry {\n\t\tlet downloadedFile = await availableAPIs.fetchSend({\n\t\t\turl: exec_args[0],\n\t\t\tinit: {}\n\t\t});\n\t\tdownloadedFile = downloadedFile.arrayBuffer;\n\t\tdownloadedFile = new TextDecoder().decode(downloadedFile);\n\t\tawait availableAPIs.fs_write({ path: exec_args[1], data: downloadedFile });\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"basiccurl: \" + await availableAPIs.lookupLocale(e.message) + \"\\r\\n\");\n\t}\n\tawait availableAPIs.terminate();\n})();\n\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); null;","d9b76925583f92aeddd49ab051425f8e6aad18239a77b00be08b68134d8a4eb0f71fc758084fd5be1e428887e4d0d6a24315a306e5115f950684caa2770574b6":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: GET_LOCALE, FS_READ, FS_WRITE, FS_BYPASS_PERMISSIONS, PATCH_DIFF, RESOLVE_NAME, CONNFUL_CONNECT, CONNFUL_READ, CONNFUL_WRITE, CONNFUL_DISCONNECT, FS_LIST_PARTITIONS, CSP_OPERATIONS, START_TASK, LIST_TASKS, GET_UPDATE_SERVICE, CONNFUL_IDENTITY_GET\n// allow: FS_WRITE, RUN_KLVL_CODE, IPC_CREATE_PIPE, IPC_LISTEN_PIPE, GET_LOCALE, FS_LIST_PARTITIONS, SYSTEM_SHUTDOWN, FS_READ, FS_BYPASS_PERMISSIONS\n// signature: 3915ca4cc1a2f684b2a348e7ead3687898c0917bc24c68a2e1c89b92dde11fe5b3c17640c9c0c0b1c88e4252f929ee2f2f7650b653a733f0d95678d941aa5fae\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.attachCLI();\n\tlet pargs = {};\n\tlet ppos = [];\n\tfor (let arg of exec_args) {\n\t\tif (arg.startsWith(\"--\")) {\n\t\t\tlet key = arg.split(\"=\")[0].slice(2);\n\t\t\tlet value = arg.split(\"=\").slice(1).join(\"=\");\n\t\t\tif (arg.split(\"=\")[1] == null) value = true;\n\t\t\tif (pargs.hasOwnProperty(key)) {\n\t\t\t\tlet ogValues = pargs[key];\n\t\t\t\tif (ogValues instanceof Array) pargs[key] = [ ...ogValues, value ];\n\t\t\t\telse pargs[key] = [ ogValues, value ];\n\t\t\t} else pargs[key] = value;\n\t\t} else ppos.push(arg);\n\t}\n\tif (!pargs[\"override-modules\"]) {\n\t\tawait availableAPIs.toMyCLI(\"diffupdate no longer works on modular systems and will be replaced with a better version.\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"To run diffupdate anyway, re-run with --override-modules.\\r\\n\");\n\t\treturn await availableAPIs.terminate();\n\t}\n\ttry {\n\t\tlet etcls = await availableAPIs.fs_ls({\n\t\t\tpath: (await availableAPIs.getSystemMount()) + \"/etc\"\n\t\t});\n\t\tlet from = \"scratch\";\n\t\tlet originalVersion = \"\";\n\t\tif (etcls.includes(\"diffupdate_cache.js\")) {\n\t\t\toriginalVersion = await availableAPIs.fs_read({\n\t\t\t\tpath: (await availableAPIs.getSystemMount()) + \"/etc/diffupdate_cache.js\"\n\t\t\t});\n\t\t\tfrom = originalVersion.split(\"\\n\")[5].match(/\\d\\w+/)[0];\n\t\t}\n\t\tawait availableAPIs.toMyCLI((await availableAPIs.lookupLocale(\"CURRENT_OSFILE_VERSION\")).replace(\"%s\", from) + \"\\r\\n\");\n\t\tlet serverDomainOrAddress = ppos[0] || ((await availableAPIs.getUpdateService()) || \"pcosserver.pc\");\n\t\tlet serverAddress = serverDomainOrAddress;\n\t\tif (!serverAddress.includes(\":\")) serverAddress = await availableAPIs.resolve(serverAddress);\n\t\tif (!serverAddress) throw new Error(await availableAPIs.lookupLocale(\"HOSTNAME_RESOLUTION_FAILED\"));\n\t\tserverAddress = serverAddress.replaceAll(\":\", \"\");\n\t\tawait availableAPIs.toMyCLI((await availableAPIs.lookupLocale(\"DOWNLOADING_OS_PATCH\")).replace(\"%s\", serverDomainOrAddress).replace(\"%s\", serverAddress.match(/.{1,4}/g).join(\":\")) + \"\\r\\n\");\n\t\tlet connection = await availableAPIs.connfulConnect({\n\t\t\tgate: \"deltaUpdate\",\n\t\t\taddress: serverAddress,\n\t\t\tverifyByDomain: serverDomainOrAddress.includes(\":\") ? serverAddress : serverDomainOrAddress,\n\t\t\tdoNotVerifyServer: pargs[\"fingerprint\"] || pargs[\"no-verification\"] || pargs[\"view-fingerprint\"]\n\t\t});\n\t\tawait availableAPIs.connfulConnectionSettled(connection);\n\t\tif (pargs[\"fingerprint\"] || pargs[\"view-fingerprint\"]) {\n\t\t\tlet identity = await availableAPIs.connfulIdentityGet(connection);\n\t\t\tlet hash = await availableAPIs.cspOperation({\n\t\t\t\tcspProvider: \"basic\",\n\t\t\t\toperation: \"digest\",\n\t\t\t\tcspArgument: {\n\t\t\t\t\talgorithm: \"SHA-256\",\n\t\t\t\t\tdata: new TextEncoder().encode(identity)\n\t\t\t\t}\n\t\t\t});\n\t\t\thash = Array.from(new Uint8Array(hash)).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\tif (pargs[\"view-fingerprint\"]) await availableAPIs.toMyCLI(\"--fingerprint=\" + hash + \"\\r\\n\");\n\t\t\tif (pargs[\"fingerprint\"] != hash) {\n\t\t\t\tawait availableAPIs.connfulDisconnect(connection);\n\t\t\t\tif (!pargs[\"view-fingerprint\"]) await availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"SERVER_SIGNATURE_VERIFICATION_FAILED\") + \"\\r\\n\");\n\t\t\t\treturn await availableAPIs.terminate();\n\t\t\t}\n\t\t}\n\t\tawait availableAPIs.connfulWrite({\n\t\t\tconnectionID: connection,\n\t\t\tdata: JSON.stringify({ from, handlesCtr: true })\n\t\t})\n\t\tlet patch = [];\n\t\twhile (true) {\n\t\t\tlet a = JSON.parse(await availableAPIs.connfulRead(connection));\n\t\t\tif (a.final) break;\n\t\t\tpatch[a.ctr] = a.hunk;\n\t\t\tawait availableAPIs.toMyCLI(\"\\r\" + (await availableAPIs.lookupLocale(\"PATCH_HUNK_COUNT\")).replace(\"%s\", patch.length));\n\t\t}\n\t\tawait availableAPIs.connfulDisconnect(connection);\n\t\tawait availableAPIs.toMyCLI(\"\\r\" + (await availableAPIs.lookupLocale(\"PATCH_HUNK_COUNT\")).replace(\"%s\", patch.length) + \"\\r\\n\");\n\t\tif (patch.length == 0) {\n\t\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"SYSTEM_UP_TO_DATE\") + \"\\r\\n\");\n\t\t\treturn await availableAPIs.terminate();\n\t\t}\n\t\tawait availableAPIs.fs_write({\n\t\t\tpath: (await availableAPIs.getSystemMount()) + \"/etc/diffupdate_cache.js\",\n\t\t\tdata: (await availableAPIs.patchDiff({\n\t\t\t\toperation: \"applyPatch\",\n\t\t\t\targs: [ originalVersion, patch ]\n\t\t\t})).join(\"\")\n\t\t});\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"HANDOFF_UPDATE\") + \"\\r\\n\");\n\t\tlet task = await availableAPIs.startTask({\n\t\t\tfile: (await availableAPIs.getSystemMount()) + \"/apps/updateos.js\",\n\t\t\targPassed: [ (await availableAPIs.getSystemMount()) + \"/etc/diffupdate_cache.js\" ],\n\t\t\tsilent: true\n\t\t});\n\t\tawait availableAPIs.waitTermination(task);\n\t\tawait availableAPIs.terminate();\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"diffupdate: \" + await availableAPIs.lookupLocale(e.message) + \"\\r\\n\");\n\t\tawait availableAPIs.terminate();\n\t}\n})();\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); null;","82ab2375cf39097e3513bf8d73f79775e37b228c6d90c4fa2667f5080d8a749a870511ac5365bfc8613b6cf9b6ad10a58cc312bc1b61ed0985f3141eead02245":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: GET_LOCALE, GET_NETWORK_ADDRESS, GET_HOSTNAME, GET_UPDATE_SERVICE\n// signature: 098ffea59d54692c850ee8239c03f2fbab3f72cc258a6c4f1cf10db8e7b450830513a95e70770d26fbe57ff2879068239d4ea74a9fdaefee4edc71d6555b1710\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"netinfo: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n    \n\ttry {\n\t\tawait availableAPIs.toMyCLI((await availableAPIs.lookupLocale(\"NETWORK_ADDRESS_FIELD\")).replace(\"%s\", (await availableAPIs.getNetworkAddress())?.match(/.{1,4}/g)?.join(\":\") || await availableAPIs.lookupLocale(\"UNKNOWN_PLACEHOLDER\")) + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI((await availableAPIs.lookupLocale(\"NETWORK_AUTOHOST_FIELD\")).replace(\"%s\", (await availableAPIs.getHostname() || await availableAPIs.lookupLocale(\"UNKNOWN_PLACEHOLDER\"))) + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI((await availableAPIs.lookupLocale(\"NETWORK_UPDATES_FIELD\")).replace(\"%s\", (await availableAPIs.getUpdateService() || await availableAPIs.lookupLocale(\"UNKNOWN_PLACEHOLDER\"))) + \"\\r\\n\");\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"netinfo: \" + await availableAPIs.lookupLocale(e.message) + \"\\r\\n\");\n\t}\n\tawait availableAPIs.terminate();\n})();\n\n\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); ","5e14e8a54623bf7e829ec01dcd8fd4acd7d5aaca206ad04cac7456adde35427c1f162b0e3954e53df1fd4a68ef4ead3dd7006abe5680b8826313e11b17033974":"// =====BEGIN MANIFEST=====\n// allow: GET_LOCALE, RESOLVE_NAME, CONNFUL_CONNECT, IPC_CREATE_PIPE, FS_MOUNT, IPC_LISTEN_PIPE, CONNFUL_WRITE, CONNFUL_READ, IPC_SEND_PIPE, FS_READ\n// signer: automaticSigner\n// signature: 2e2c053fc7ff952edfae874299124ce1ef72e9a8f1ad03e002fb9d10519d51db0300496f401ac68d7747b5ca8fd1290f32761cd7ee4c7abba7502f1e103a7afe\n// =====END MANIFEST=====\nfunction IPv6Decompressor(ip) {\n\tlet array = ip.split(\":\");\n\tarray = array.slice(0, 8);\n\tlet foundTwoOrMoreZeroes = array.indexOf(\"\");\n\twhile (array.length != 8 && foundTwoOrMoreZeroes !== null) array.splice(foundTwoOrMoreZeroes, 0, \"0000\");\n\tarray = array.map(a => parseInt(a || \"0\", 16).toString(16).padStart(4, \"0\"));\n\treturn array.join(\":\");\n}\n(async function() {\n\t// @pcos-app-mode isolatable\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"networkfs: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\tawait availableAPIs.attachCLI();\n\tlet pargs = {};\n\tlet ppos = [];\n\tfor (let arg of exec_args) {\n\t\tif (arg.startsWith(\"--\")) {\n\t\t\tlet key = arg.split(\"=\")[0].slice(2);\n\t\t\tlet value = arg.split(\"=\").slice(1).join(\"=\");\n\t\t\tif (arg.split(\"=\")[1] == null) value = true;\n\t\t\tif (pargs.hasOwnProperty(key)) {\n\t\t\t\tlet ogValues = pargs[key];\n\t\t\t\tif (ogValues instanceof Array) pargs[key] = [ ...ogValues, value ];\n\t\t\t\telse pargs[key] = [ ogValues, value ];\n\t\t\t} else pargs[key] = value;\n\t\t} else ppos.push(arg);\n\t}\n\n\tif (ppos.length < 2) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"NETWORKFS_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"NETWORKFS_DESCRIPTION\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"NETWORKFS_NOVERIFY\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"NETWORKFS_KEY\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"networkfs: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\tawait availableAPIs.terminate();\n\t}\n\tlet inPipe, outPipe, conn;\n\ttry {\n\t\tlet url = new URL(ppos[0]);\n\t\tif (url.protocol != \"netfs:\") throw new Error(await availableAPIs.lookupLocale(\"NETWORKFS_PROTO\"));\n\t\tif (url.port) throw new Error(await availableAPIs.lookupLocale(\"BLOG_BROWSER_GATESET\"));\n\t\tlet hostname = url.hostname, address;\n\t\tif (url.hostname.includes(\"[\")) {\n\t\t\thostname = IPv6Decompressor(url.hostname.slice(1, -1)).replaceAll(\":\", \"\");\n\t\t\taddress = hostname;\n\t\t} else address = await availableAPIs.resolve(hostname);\n\t\tif (!address) throw new Error(await availableAPIs.lookupLocale(\"HOSTNAME_RESOLUTION_FAILED\"));\n\t\tconn = await availableAPIs.connfulConnect({\n\t\t\tgate: url.username || \"netfs\",\n\t\t\taddress,\n\t\t\tverifyByDomain: hostname,\n\t\t\tkey: pargs.key ? JSON.parse(await availableAPIs.fs_read({\n\t\t\t\tpath: pargs.key\n\t\t\t})).key : undefined,\n\t\t\tprivate: pargs.key ? JSON.parse(await availableAPIs.fs_read({\n\t\t\t\tpath: pargs.key\n\t\t\t})).private : undefined,\n\t\t\tdoNotVerifyServer: pargs[\"no-verification\"]\n\t\t});\n\t\tawait availableAPIs.connfulConnectionSettled(conn);\n\t\tinPipe = await availableAPIs.createPipe();\n\t\toutPipe = await availableAPIs.createPipe();\n\t\tlet pipe2conn = (async function() {\n\t\t\twhile (true) {\n\t\t\t\tlet listenToPipe = await availableAPIs.listenToPipe(inPipe);\n\t\t\t\tavailableAPIs.connfulWrite({\n\t\t\t\t\tconnectionID: conn,\n\t\t\t\t\tdata: JSON.stringify(listenToPipe)\n\t\t\t\t});\n\t\t\t}\n\t\t})();\n\t\tlet conn2pipe = (async function() {\n\t\t\twhile (true) {\n\t\t\t\tlet networkListen = await availableAPIs.connfulRead(conn);\n\t\t\t\tavailableAPIs.sendToPipe({\n\t\t\t\t\tpipe: outPipe,\n\t\t\t\t\tdata: JSON.parse(networkListen)\n\t\t\t\t});\n\t\t\t}\n\t\t})();\n\t\tawait availableAPIs.fs_mount({\n\t\t\tmountpoint: ppos[1],\n\t\t\tfilesystem: \"IPCMount\",\n\t\t\tfilesystemOptions: {\n\t\t\t\tinputPipeId: inPipe,\n\t\t\t\toutputPipeId: outPipe\n\t\t\t}\n\t\t});\n\t\tawait Promise.all([pipe2conn, conn2pipe]);\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"networkfs: \" + await availableAPIs.lookupLocale(e.message) + \"\\r\\n\");\n\t}\n\tawait availableAPIs.terminate();\n})();\n\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); null;","d26bceda19eb0c72e6bf0453acf2ac04ccfb9ef390ba679f869d5dace616279d7765af316d497d8d2b79d790fdada8ea88ab49e9d70fb08677ef222a8dbeb9e0":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: GET_LOCALE, FETCH_SEND, PCOS_NETWORK_PING, RESOLVE_NAME\n// signature: c28d58bcd4020d63cd84e616bb0eed2c4de24b4eb5db3b2fd10a544078d7922f7ea643307ea79e108ee8e77362aa8a3024f3f75fffec76ba7437449d14e434e4\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.windowVisibility(false);\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"ping: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\tif (!exec_args.length) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"PING_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"PING_DESCRIPTION\") + \"\\r\\n\")\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"PING_INTERNET_OPTION\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"ping: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\tif (exec_args.includes(\"--internet\")) {\n\t\texec_args = exec_args.filter(a => a != \"--internet\");\n\t\tif (!exec_args.length) {\n\t\t\tawait availableAPIs.toMyCLI(\"ping: No URL specified\\r\\n\");\n\t\t\treturn availableAPIs.terminate();\n\t\t}\n\t\tawait availableAPIs.toMyCLI(\"Pinging \" + exec_args[0] + \" via HTTP...\\r\\n\");\n\t\tfor (let i = 1; i <= 4; i++) {\n\t\t\tawait new Promise((resolve) => setTimeout(() => resolve(\"ping\"), 500));\n\t\t\tlet time = performance.now();\n\t\t\ttry {\n\t\t\t\tif ((await Promise.race([availableAPIs.fetchSend({\n\t\t\t\t\turl: exec_args[0],\n\t\t\t\t\tinit: {\n\t\t\t\t\t\tnoArrayBuffer: true,\n\t\t\t\t\t\tmode: \"no-cors\"\n\t\t\t\t\t}\n\t\t\t\t}), new Promise((resolve) => setTimeout(() => resolve(\"timeout\"), 30000))])) == \"timeout\") throw new Error(\"Response timed out\");\n\t\t\t\ttime = performance.now() - time;\n\t\t\t\tawait availableAPIs.toMyCLI(\"http_seq=\" + i + \" time=\" + time.toFixed(2) + \" ms\\r\\n\");\n\t\t\t} catch (e) {\n\t\t\t\ttime = performance.now() - time;\n\t\t\t\tawait availableAPIs.toMyCLI(\"http_seq=\" + i + \" time=\" + time.toFixed(2) + \" ms err=\" + e.name + \": \" + e.message + \"\\r\\n\");\n\t\t\t}\n\t\t}\n\t\treturn availableAPIs.terminate();\n\t}\n\tlet pingedAddress;\n\tif (exec_args[0].includes(\":\")) pingedAddress = exec_args[0].replaceAll(\":\", \"\");\n\telse {\n\t\ttry {\n\t\t\tpingedAddress = await Promise.race([\n\t\t\t\tavailableAPIs.resolve(exec_args[0]),\n\t\t\t\tnew Promise((resolve) => setTimeout(() => resolve(\"timeout\"), 30000))\n\t\t\t])\n\t\t\tif (pingedAddress == \"timeout\") throw new Error(\"Resolution timed out\");\n\t\t\tif (!pingedAddress) throw new Error(\"Could not resolve hostname\");\n\t\t} catch (e) {\n\t\t\tawait availableAPIs.toMyCLI(\"ping: \" + exec_args[0] + \": \" + e.name + \": \" + e.message + \"\\r\\n\");\n\t\t\treturn await availableAPIs.terminate();\n\t\t}\n\t}\n\tawait availableAPIs.toMyCLI(\"Pinging \" + exec_args[0] + \" (\" + pingedAddress.match(/.{1,4}/g).join(\":\") + \") via PCOS Network...\\r\\n\");\n\tfor (let i = 1; i <= 4; i++) {\n\t\tawait new Promise((resolve) => setTimeout(() => resolve(\"ping\"), 500));\n\t\tlet time = performance.now();\n\t\ttry {\n\t\t\tlet race = await Promise.race([availableAPIs.networkPing(pingedAddress), new Promise((resolve) => setTimeout(() => resolve(\"timeout\"), 30000))]);\n\t\t\tif (race == \"timeout\") throw new Error(\"Response timed out\");\n\t\t\ttime = performance.now() - time;\n\t\t\tawait availableAPIs.toMyCLI(\"count=\" + i + \" time=\" + time.toFixed(2) + \" ms\\r\\n\");\n\t\t} catch (e) {\n\t\t\ttime = performance.now() - time;\n\t\t\tawait availableAPIs.toMyCLI(\"count=\" + i + \" time=\" + time.toFixed(2) + \" ms err=\" + e.name + \": \" + e.message + \"\\r\\n\");\n\t\t}\n\t}\n\tawait availableAPIs.terminate();\n})();\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); null;","d9fc559b1004a01adafe9c07244ebb9c6305878a4e1cf3a05b71fd1df20ad18ec052bdf39f2bd06ab986b8b857dc0b25daec294c7c1243e58f90e10a39de8299":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: GET_LOCALE, RELOAD_NETWORK_CONFIG\n// signature: 0aef25b3af456da17facb8a3702141cc6e9725693e503f25313cf368b20e9d210f213eb3ac7d40db6bb499b6ded8feb7d89895a7ff63664949471214ac8e82a8\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.windowVisibility(false);\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"renetworkd: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\ttry {\n\t\tawait availableAPIs.reloadNetworkConfig();\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"renetworkd: \" + await availableAPIs.lookupLocale(e.message) + \"\\r\\n\");\n\t}\n\tawait availableAPIs.terminate();\n})();\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); null;","a364c81d85a7c6e9dab7d7efde403cedfdd175fe0b6a029f796fcdedfa1860adfd691dc731f1aa4ce66e3477ab35f63f19f077840c24a6063107e759fd2b09c6":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: FETCH_SEND, SET_FIRMWARE, SYSTEM_SHUTDOWN, GET_LOCALE, FS_READ, FS_BYPASS_PERMISSIONS\n// signature: a890d44c2c4e38a49cf53239b78e5a4e9f52f1919dbbd3ae6f0ab554638b4867f73c5d714dec8f886dbac2ba10c4a3bc0dd8516888609149b792fd99ee186d04\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.windowVisibility(false);\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"updatefw: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"UPDATEFW_DOWNLOADING\") + \"\\r\\n\");\n\tlet fwArchive;\n\tif (!exec_args.length) {\n\t\ttry {\n\t\t\tfwArchive = await availableAPIs.fetchSend({\n\t\t\t\turl: \"/init.js\",\n\t\t\t\tinit: {}\n\t\t\t});\n\t\t\tif (!fwArchive.ok) throw new Error(\"Non-OK response (\" + fwArchive.status + \" \" + fwArchive.statusText + \")\");\n\t\t} catch (e) {\n\t\t\tconsole.error(e);\n\t\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"UPDATEFW_DOWNLOAD_FAILED\") + \"\\r\\n\");\n\t\t\treturn await availableAPIs.terminate();\n\t\t}\n\t} else {\n\t\ttry {\n\t\t\tfwArchive = { arrayBuffer: new TextEncoder().encode(await availableAPIs.fs_read({\n\t\t\t\tpath: exec_args[0]\n\t\t\t})) };\n\t\t} catch (e) {\n\t\t\tconsole.error(e);\n\t\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"UPDATEFW_DOWNLOAD_FAILED\") + \"\\r\\n\");\n\t\t\treturn await availableAPIs.terminate();\n\t\t}\n\t}\n\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"UPDATEFW_DECODING\") + \"\\r\\n\");\n\tfwArchive = fwArchive.arrayBuffer;\n\tfwArchive = new TextDecoder().decode(fwArchive);\n\ttry {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"UPDATEFW_SETTING\") + \"\\r\\n\");\n\t\tawait availableAPIs.setFirmware(fwArchive);\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"RESTARTING\") + \"\\r\\n\");\n\t\tawait availableAPIs.shutdown({\n\t\t\tisReboot: true\n\t\t});\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"updatefw: \" + await availableAPIs.lookupLocale(e.message) + \"\\r\\n\");\n\t}\n\tawait availableAPIs.terminate();\n})();\n\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); null;","f3481b80b2bde53b28f19d5b29f11ffd0d9a0a2c20ab80d94f82e932a2fb4bb5885f84d8e3221ad718940a4783b050fc48317d56daa5161e86d23c8b730ce3ac":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: FETCH_SEND, FS_WRITE, RUN_KLVL_CODE, IPC_CREATE_PIPE, IPC_LISTEN_PIPE, GET_LOCALE, FS_LIST_PARTITIONS, SYSTEM_SHUTDOWN, FS_READ, FS_BYPASS_PERMISSIONS\n// signature: 7d0efd744b72f02204296f03250e36933bef4038775efecd9c1c85c4084f3f2c414064abe8cce6a69e751f55b41ad85d754d1f536617d9bdf796b58b62b46bd1\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"updateos: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\tlet pargs = {};\n\tlet ppos = [];\n\tfor (let arg of exec_args) {\n\t\tif (arg.startsWith(\"--\")) {\n\t\t\tlet key = arg.split(\"=\")[0].slice(2);\n\t\t\tlet value = arg.split(\"=\").slice(1).join(\"=\");\n\t\t\tif (arg.split(\"=\")[1] == null) value = true;\n\t\t\tif (pargs.hasOwnProperty(key)) {\n\t\t\t\tlet ogValues = pargs[key];\n\t\t\t\tif (ogValues instanceof Array) pargs[key] = [ ...ogValues, value ];\n\t\t\t\telse pargs[key] = [ ogValues, value ];\n\t\t\t} else pargs[key] = value;\n\t\t} else ppos.push(arg);\n\t}\n\tif (!pargs[\"override-modules\"]) {\n\t\tawait availableAPIs.toMyCLI(\"updateos no longer works on modular systems and will be replaced with a better version.\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"To run updateos anyway, re-run with --override-modules.\\r\\n\");\n\t\treturn await availableAPIs.terminate();\n\t}\n\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"REINSTALL_DOWNLOADING\") + \"\\r\\n\");\n\tlet osArchive;\n\tif (!ppos[0]) {\n\t\ttry {\n\t\t\tosArchive = await availableAPIs.fetchSend({\n\t\t\t\turl: ppos.url || \"/os.js\",\n\t\t\t\tinit: {}\n\t\t\t});\n\t\t\tif (!osArchive.ok) throw new Error(\"Non-OK response (\" + osArchive.status + \" \" + osArchive.statusText + \")\");\n\t\t} catch (e) {\n\t\t\tconsole.error(e);\n\t\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"REINSTALL_DOWNLOAD_FAILED\") + \"\\r\\n\");\n\t\t\treturn await availableAPIs.terminate();\n\t\t}\n\t} else {\n\t\ttry {\n\t\t\tosArchive = { arrayBuffer: new TextEncoder().encode(await availableAPIs.fs_read({\n\t\t\t\tpath: exec_args[0]\n\t\t\t})) };\n\t\t} catch (e) {\n\t\t\tconsole.error(e);\n\t\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"REINSTALL_DOWNLOAD_FAILED\") + \"\\r\\n\");\n\t\t\treturn await availableAPIs.terminate();\n\t\t}\n\t}\n\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"REINSTALL_DECODING\") + \"\\r\\n\");\n\tosArchive = osArchive.arrayBuffer;\n\tosArchive = new TextDecoder().decode(osArchive);\n\tlet files = osArchive.split(/\\/\\/ [0-9]+-.+.js\\n/g).slice(1);\n\tlet names = osArchive.match(/\\/\\/ [0-9]+-.+.js/g);\n\tlet appIndex = names.indexOf(\"// \" + \"1\" + \"5-ap\" + \"ps.js\");\n\tlet apps = files[appIndex].match(/async function (.+)Installer\\(target, token\\)/g).map(a => a.split(\" \")[2].split(\"(\")[0]);\n\tapps.splice(apps.indexOf(\"autoinstallerInstaller\"), 1);\n\tapps.splice(apps.indexOf(\"installerInstaller\"), 1);\n\tapps.splice(apps.indexOf(\"secondstageInstaller\"), 1);\n\tlet pipeResult = false;\n\ttry {\n\t\tlet ipcPipe = await availableAPIs.createPipe();\n\t\tpipeResult = availableAPIs.listenToPipe(ipcPipe);\n\t\tlet installerCode = \"\";\n\t\tfor (let app of apps) installerCode += `await ${app}(modules.defaultSystem, ${JSON.stringify(await availableAPIs.getProcessToken())});\\n`;\n\t\tawait availableAPIs.runKlvlCode(`(async function() {\n\t\t\ttry {\n\t\t\t\t${files[appIndex]}\n\t\t\t\t${installerCode}\n\t\t\t\tmodules.ipc.send(${JSON.stringify(ipcPipe)}, true);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(e);\n\t\t\t\tmodules.ipc.send(${JSON.stringify(ipcPipe)}, false);\n\t\t\t}\n\t\t})();`);\n\t\tpipeResult = await pipeResult;\n\t\tawait availableAPIs.closePipe(ipcPipe);\n\t} catch {}\n\tif (!pipeResult) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"UPDATE_EXTRA_FAIL\") + \"\\r\\n\");\n\t\treturn await availableAPIs.terminate();\n\t}\n\tfiles.splice(appIndex, 1);\n\tnames.splice(appIndex, 1);\n\tlet installerIndex = names.indexOf(\"// 1\" + \"0\" + \"-ins\" + \"taller.js\");\n\tfiles.splice(installerIndex, 1);\n\tnames.splice(installerIndex, 1);\n\tlet secondStageIndex = names.indexOf(\"// 1\" + \"7\" + \"-instal\" + \"ler-seconds\" + \"tage.js\");\n\tfiles.splice(secondStageIndex, 1);\n\tnames.splice(secondStageIndex, 1);\n\tfor (let file in files) {\n\t\tlet name = names[file].split(\" \").slice(1).join(\" \");\n\t\tlet content = files[file];\n\t\ttry {\n\t\t\tawait availableAPIs.toMyCLI(\"\\t/boot/\" + name + \"\\r\\n\");\n\t\t\tawait availableAPIs.fs_write({\n\t\t\t\tpath: (await availableAPIs.getSystemMount()) + \"/boot/\" + name,\n\t\t\t\tdata: content\n\t\t\t});\n\t\t} catch {\n\t\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"UPDATE_BOOT_FAIL\") + \"\\r\\n\");\n\t\t\treturn await availableAPIs.terminate();\n\t\t}\n\t}\n\tif (!pargs[\"no-reboot\"]) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"RESTARTING\") + \"\\r\\n\");\n\t\ttry {\n\t\t\tawait availableAPIs.shutdown({\n\t\t\t\tisReboot: true,\n\t\t\t\tisKexec: true\n\t\t\t});\n\t\t} catch (e) {\n\t\t\tawait availableAPIs.toMyCLI(\"updateos: \" + await availableAPIs.lookupLocale(e.message) + \"\\r\\n\");\n\t\t}\n\t}\n\tawait availableAPIs.terminate();\n})();\n\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); null;"},"buildInfo":{"for":"1314","when":1750514397592,"signer":"moduleSigner","critical":false,"signature":"7bb3b89e518707dca2d1fe283c9cdb3463daf55102befde4a7c7c05702fb806344388033eb89815d9c222a7a02bf4188aa3aafe73dfdd55210cdcd0242fe83e3"}}