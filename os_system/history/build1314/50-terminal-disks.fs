{"backend":{"files":{"apps":{"df.js":"ae1416fc647fc264b48f7f9ca789dbbc7016da71632296a9884173f11b06eede436ec202fa3acca024b25312ae0487ce71a73c6771c6537244362d62794ef791","format.js":"d73e303940aa8bf997bbebde0700064e821150fd862a78af538e9c804b37d866b7559b35d90b8bd66e14512669614f9d042b51f0d01ced35ff2fbd23c89171b0","initdisk.js":"f66e5ab29384fdf8fb4898b35f7ff7b296acb0e06bb55c31b2576d69cbeac0ed90a5a40cdca99e1bf6f8e16d76fc64af39c91865195622ac2727d3d553856011","llda_tool.js":"e7f17821b3fe58c3f8fe070d605cc57dcaace394d5e9af90b05a6e95c88f271b0f06311a17213568b84304abf4aafa29e29a6f30309a871043338404ad53d922","mount.js":"f7346e9f0ee5ed4d38b909290ccf39b45b71d8699b38c22c2fdc644f4a3aeff3464c769a2675e9d569a4ead5aab5c259b0ad5cfd9c2660e7c251b67efce0437c","mountinfo.js":"7434ce3e3e453de3c5b8b06c9341e7bf3261319407b830a2a920925e07a4a4731b28ea6dd8ff6599cb1df284aae15973bbf21ceec4d2538ab88f86010d6a36de","pivot_root.js":"b5da7c2105dbb1ff1de82d475d866e115557034aaaca75bc3473c4729ca11bd16a9b148d83602adecae27ef28c3e41fa3e97145e5853fbcb9746d0ab71b2acf2","umount.js":"29aad004bf0e4fbe30f6762657a8f8769ab4758454d5a902404d2a28b71c9754c475063eccf162b5cbfb4bb7b4042d435a7bb545709e54e4ff02875a93cde6d0"}},"permissions":{"apps/df.js":{"world":"rx"},"apps/format.js":{"world":"rx"},"apps/initdisk.js":{"world":"rx"},"apps/llda_tool.js":{"world":"rx"},"apps/mount.js":{"world":"rx"},"apps/mountinfo.js":{"world":"rx"},"apps/pivot_root.js":{"world":"rx"},"apps/umount.js":{"world":"rx"},"apps/":{"world":"rx"},"":{"world":"rx"}}},"files":{"ae1416fc647fc264b48f7f9ca789dbbc7016da71632296a9884173f11b06eede436ec202fa3acca024b25312ae0487ce71a73c6771c6537244362d62794ef791":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: GET_LOCALE, FS_LIST_PARTITIONS\n// signature: d852621ca93c1197824d11981d2fff438367885c13eb3dd2976f4ceefb200fdcddb666873d51607b819e9964421bb7fd4ffdb0890cc6936ab16e2042950d917a\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.windowVisibility(false);\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"df: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\tlet human = exec_args.includes(\"-h\") || exec_args.includes(\"--human-readable\");\n\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"DF_HEADER\") + \"\\r\\n\");\n\tlet estimateStorage = await availableAPIs.estimateStorage();\n\tfor (let medium in estimateStorage) {\n\t\tlet displayedSize = estimateStorage[medium].total;\n\t\tif (human) displayedSize = await availableAPIs.ufInfoUnits([estimateStorage[medium].total, true]);\n\t\tlet displayedUsed = estimateStorage[medium].used;\n\t\tif (human) displayedUsed = await availableAPIs.ufInfoUnits([estimateStorage[medium].used, true]);\n\t\tlet displayedFree = estimateStorage[medium].free;\n\t\tif (human) displayedFree = await availableAPIs.ufInfoUnits([estimateStorage[medium].free, true]);\n\t\tawait availableAPIs.toMyCLI(medium + \"\\t\" + displayedSize + \"\\t\" + displayedUsed + \"\\t\" + displayedFree + \"\\t\" + Math.floor(estimateStorage[medium].used / estimateStorage[medium].total * 100) + \"%\\r\\n\");\n\t}\n\tawait availableAPIs.terminate();\n})();\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); null;","d73e303940aa8bf997bbebde0700064e821150fd862a78af538e9c804b37d866b7559b35d90b8bd66e14512669614f9d042b51f0d01ced35ff2fbd23c89171b0":"// =====BEGIN MANIFEST=====\n// allow: GET_LOCALE, LLDISK_LIST_PARTITIONS, LLDISK_WRITE, LLDISK_REMOVE, LLDISK_READ, CSP_OPERATIONS\n// signer: automaticSigner\n// signature: cc196067ec18a3584138fdbbae3396f68fd7259d40801443f09b33e7b4168f5f3bce3dffda4c2d56e386c5f01293e1eba9eb8f01ddc2e76921b44926bfcbaade\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.windowVisibility(false);\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"format: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\tif (!exec_args.length) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"FORMAT_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"FORMAT_DESCRIPTION\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"FORMAT_FSTYPE\") + \"\\r\\n\")\n\t\tawait availableAPIs.toMyCLI(\"format: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\tif (exec_args.length < 2 || exec_args.length > 3) {\n\t\tawait availableAPIs.toMyCLI(\"format: \" + await availableAPIs.lookupLocale(\"ARGUMENT_COUNT_MISMATCH\") + \"\\r\\n\");\n\t\treturn await availableAPIs.terminate();\n\t}\n\t\n\tlet knownNames;\n\ttry {\n\t\tknownNames = await availableAPIs.lldaList();\n\t\tif (knownNames.includes(exec_args[1]) && exec_args[2] != \"overwrite\") {\n\t\t\tawait availableAPIs.toMyCLI(\"format: \" + await availableAPIs.lookupLocale(\"FORMAT_OVERWRITE_WARN\") + \"\\r\\n\");\n\t\t\treturn await availableAPIs.terminate();\n\t\t}\n\n\t\tlet u8aToHex = (u8a) => Array.from(u8a).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\tif (exec_args[0] == \"pcfs\") {\n\t\t\tlet prevId = (await availableAPIs.lldaRead({ partition: exec_args[1] }))?.id || u8aToHex(await availableAPIs.cspOperation({\n\t\t\t\tcspProvider: \"basic\",\n\t\t\t\toperation: \"random\",\n\t\t\t\tcspArgument: new Uint8Array(64)\n\t\t\t}));\n\t\t\tawait availableAPIs.lldaWrite({\n\t\t\t\tpartition: exec_args[1],\n\t\t\t\tdata: {\n\t\t\t\t\tfiles: {},\n\t\t\t\t\tpermissions: {},\n\t\t\t\t\tid: prevId\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (exec_args[0].startsWith(\"pcfs_crypt\")) {\n\t\t\tlet monokey = exec_args[0].endsWith(\"_monokey\");\n\t\t\tlet prevId = (await availableAPIs.lldaRead({ partition: exec_args[1] }))?.id || u8aToHex(await availableAPIs.cspOperation({\n\t\t\t\tcspProvider: \"basic\",\n\t\t\t\toperation: \"random\",\n\t\t\t\tcspArgument: new Uint8Array(64)\n\t\t\t}));\n\t\t\tlet salt = u8aToHex(await availableAPIs.cspOperation({\n\t\t\t\tcspProvider: \"basic\",\n\t\t\t\toperation: \"random\",\n\t\t\t\tcspArgument: new Uint8Array(32)\n\t\t\t}));\n\t\t\tawait availableAPIs.lldaWrite({\n\t\t\t\tpartition: exec_args[1],\n\t\t\t\tdata: {\n\t\t\t\t\tfiles: {},\n\t\t\t\t\tpermissions: {},\n\t\t\t\t\tid: prevId,\n\t\t\t\t\tcryptodata: {\n\t\t\t\t\t\tpasswordLockingInitial: monokey,\n\t\t\t\t\t\tsalt: salt\n\t\t\t\t\t},\n\t\t\t\t\tencryptedFileTable: exec_args[0].endsWith(\"_filetable_monokey\")\n\t\t\t\t}\n\t\t\t})\n\t\t} else if (exec_args[0].startsWith(\"pcbm:\")) {\n\t\t\tlet diskDataPartition = exec_args[0].split(\":\").slice(1).join(\":\");\n\t\t\tawait availableAPIs.lldaWrite({\n\t\t\t\tpartition: exec_args[1],\n\t\t\t\tdata: `try {\n\t\t\t\t\tconst AsyncFunction = (async () => {}).constructor;\n\t\t\t\t\tlet pre_boot_part = coreExports.disk.partition(${JSON.stringify(diskDataPartition)}).getData();\n\t\t\t\t\tlet pre_boot_modules = pre_boot_part?.files;\n\t\t\t\t\tif (!pre_boot_modules) {\n\t\t\t\t\t\tcoreExports.tty_bios_api.println(\"No files were found in the storage partition\");\n\t\t\t\t\t\tthrow new Error(\"No files were found in the storage partition\");\n\t\t\t\t\t}\n\t\t\t\t\tpre_boot_modules = pre_boot_modules[coreExports.bootSection || \"boot\"];\n\t\t\t\t\tif (!pre_boot_modules) {\n\t\t\t\t\t\tcoreExports.tty_bios_api.println(\"No boot modules were found\");\n\t\t\t\t\t\tthrow new Error(\"No boot modules were found\");\n\t\t\t\t\t}\n\t\t\t\t\tlet pre_boot_module_list = Object.keys(pre_boot_modules);\n\t\t\t\t\tpre_boot_module_list = pre_boot_module_list.sort((a, b) => a.localeCompare(b));\n\t\t\t\t\tlet pre_boot_module_script = \"\";\n\t\t\t\t\tfor (let module of pre_boot_module_list) {\n\t\t\t\t\t\tif (coreExports.bootMode == \"logboot\") pre_boot_module_script += \"coreExports.tty_bios_api.println(\" + JSON.stringify(module) + \");\\\\n\";\n\t\t\t\t\t\tpre_boot_module_script += await coreExports.idb.readPart(pre_boot_part.id + \"-\" + pre_boot_modules[module]);\n\t\t\t\t\t}\n\t\t\t\t\tawait new AsyncFunction(pre_boot_module_script)();\n\t\t\t\t} catch (e) {\n\t\t\t\t\tcoreExports.tty_bios_api.println(\"Boot failed\");\n\t\t\t\t\tcoreExports.tty_bios_api.println(\"Press Enter to continue and log this error locally\");\n\t\t\t\t\tawait coreExports.tty_bios_api.inputLine();\n\t\t\t\t\tthrow e;\n\t\t\t\t}`\n\t\t\t});\n\t\t} else if (exec_args[0] == \"null\") {\n\t\t\tawait availableAPIs.lldaRemove({\n\t\t\t\tpartition: exec_args[1]\n\t\t\t});\n\t\t} else {\n\t\t\tawait availableAPIs.toMyCLI(\"format: \" + await availableAPIs.lookupLocale(\"FORMAT_UNKNOWN_FSTYPE\") + \"\\r\\n\");\n\t\t}\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"format: \" + e.name + \": \" + await availableAPIs.lookupLocale(e.message) + \" (\" + e.message + \")\\r\\n\");\n\t\treturn await availableAPIs.terminate();\n\t}\n\t\n\tawait availableAPIs.terminate();\n})();\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); null;","f66e5ab29384fdf8fb4898b35f7ff7b296acb0e06bb55c31b2576d69cbeac0ed90a5a40cdca99e1bf6f8e16d76fc64af39c91865195622ac2727d3d553856011":"// =====BEGIN MANIFEST=====\n// allow: GET_LOCALE, LLDISK_LIST_PARTITIONS, LLDISK_INIT_PARTITIONS\n// signer: automaticSigner\n// signature: ee09a3bd868dede8abc7d582166877b3c1b7793fc16991bbd1b6376f6f0b850d6f78d925fd38101e718aa3c59f5accbd2afbc09220098283853c846a99324856\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.windowVisibility(false);\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"initdisk: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\tif (!exec_args.length) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"INITDISK_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"INITDISK_DESCRIPTION\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"initdisk: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\tif (exec_args.length > 2) {\n\t\tawait availableAPIs.toMyCLI(\"initdisk: \" + await availableAPIs.lookupLocale(\"ARGUMENT_COUNT_MISMATCH\") + \"\\r\\n\");\n\t\treturn await availableAPIs.terminate();\n\t}\n\t\n\ttry {\n\t\tawait availableAPIs.lldaList();\n\t\tif (exec_args[1] != \"overwrite\") {\n\t\t\tawait availableAPIs.toMyCLI(\"initdisk: \" + await availableAPIs.lookupLocale(\"INITDISK_OVERWRITE_WARN\") + \"\\r\\n\");\n\t\t\treturn await availableAPIs.terminate();\n\t\t}\n\t} catch {}\n\t\n\ttry {\n\t\tawait availableAPIs.lldaInitPartitions();\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"initdisk: \" + await availableAPIs.lookupLocale(e.message) + \"\\r\\n\");\n\t}\n\tawait availableAPIs.terminate();\n})();\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); null;","e7f17821b3fe58c3f8fe070d605cc57dcaace394d5e9af90b05a6e95c88f271b0f06311a17213568b84304abf4aafa29e29a6f30309a871043338404ad53d922":"// =====BEGIN MANIFEST=====\n// allow: GET_LOCALE, LLDISK_WRITE, LLDISK_READ, FS_READ, FS_WRITE, FS_BYPASS_PERMISSIONS, LLDISK_LIST_PARTITIONS, LLDISK_REMOVE\n// signer: automaticSigner\n// signature: b1c374f20753b96762376470abf7b883a4e7264b65ba21cdbd72e4246bd6e8d7d96ea03d72e11a46609b594b1605731365c7c568ffa6c6b085ff83fbb58de841\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.windowVisibility(false);\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"llda_tool: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\tif (!exec_args.length) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_ACTION_EXPORT\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_ACTION_IMPORT\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_ACTION_IMPORTSTRING\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_ACTION_COPY\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_ACTION_REMOVE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_ACTION_LIST\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"LLDA_DISCLAIMER\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"llda_tool: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\n\ttry {\n\t\tif (exec_args[0] == \"export\") {\n\t\t\tawait availableAPIs.fs_write({\n\t\t\t\tpath: exec_args[2],\n\t\t\t\tdata: JSON.stringify(await availableAPIs.lldaRead({ partition: exec_args[1] }))\n\t\t\t});\n\t\t} else if (exec_args[0] == \"import\") {\n\t\t\tawait availableAPIs.lldaWrite({ partition: exec_args[2], data: JSON.parse(await availableAPIs.fs_read({ path: exec_args[1] })) });\n\t\t} else if (exec_args[0] == \"importstring\") {\n\t\t\tawait availableAPIs.lldaWrite({ partition: exec_args[2], data: await availableAPIs.fs_read({ path: exec_args[1] }) });\n\t\t} else if (exec_args[0] == \"copy\") {\n\t\t\tawait availableAPIs.lldaWrite({ partition: exec_args[2], data: await availableAPIs.lldaRead({ partition: exec_args[1] }) });\n\t\t} else if (exec_args[0] == \"remove\") {\n\t\t\tawait availableAPIs.lldaRemove({ partition: exec_args[1] });\n\t\t} else if (exec_args[0] == \"list\") {\n\t\t\tawait availableAPIs.toMyCLI(JSON.stringify(await availableAPIs.lldaList()) + \"\\r\\n\");\n\t\t} else {\n\t\t\tawait availableAPIs.toMyCLI(\"llda_tool: \" + await availableAPIs.lookupLocale(\"LLDA_UNKNOWN_ACTION\") + \"\\r\\n\");\n\t\t}\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"llda_tool: \" + await availableAPIs.lookupLocale(e.message) + \"\\r\\n\");\n\t}\n\t\n\tawait availableAPIs.terminate();\n})();\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); null;","f7346e9f0ee5ed4d38b909290ccf39b45b71d8699b38c22c2fdc644f4a3aeff3464c769a2675e9d569a4ead5aab5c259b0ad5cfd9c2660e7c251b67efce0437c":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: GET_LOCALE, FS_MOUNT, GET_FILESYSTEMS\n// signature: ab19ec87042c0f52ede8a118b8dc85f815658528bbada2b004e9f87b23f06f06e54f882fa244a609cb0603d287bc50f9e8ad537d2f870370090a3034399ee4c7\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"mount: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\n\tlet pargs = {};\n\tlet ppos = [];\n\tfor (let arg of exec_args) {\n\t\tif (arg.startsWith(\"--\")) {\n\t\t\tlet key = arg.split(\"=\")[0].slice(2);\n\t\t\tlet value = arg.split(\"=\").slice(1).join(\"=\");\n\t\t\tif (arg.split(\"=\")[1] == null) value = true;\n\t\t\tif (pargs.hasOwnProperty(key)) {\n\t\t\t\tlet ogValues = pargs[key];\n\t\t\t\tif (ogValues instanceof Array) pargs[key] = [ ...ogValues, value ];\n\t\t\t\telse pargs[key] = [ ogValues, value ];\n\t\t\t} else pargs[key] = value;\n\t\t} else ppos.push(arg);\n\t}\n\n\tif (ppos.length < 2) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"MOUNT_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"MOUNT_DESCRIPTION\") + \"\\r\\n\");\n\t\ttry {\n\t\t\tawait availableAPIs.toMyCLI((await availableAPIs.lookupLocale(\"MOUNT_KNOWN_FS\")).replace(\"%s\", (await availableAPIs.supportedFilesystems()).join(\", \")) + \"\\r\\n\");\n\t\t} catch {\n\t\t\tawait availableAPIs.toMyCLI((await availableAPIs.lookupLocale(\"MOUNT_KNOWN_FS\")).replace(\"%s\", await availableAPIs.lookupLocale(\"UNKNOWN_PLACEHOLDER\")) + \"\\r\\n\");\n\t\t}\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PPART\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PINPA\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PPASS\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PKEY\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PTYPE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PURL\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_PINPI\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"MOUNT_KNOWN_POUPI\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"mount: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\n\ttry {\n\t\tawait availableAPIs.fs_mount({\n\t\t\tmountpoint: ppos[1],\n\t\t\tfilesystem: ppos[0],\n\t\t\tfilesystemOptions: pargs\n\t\t});\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"mount: \" + await availableAPIs.lookupLocale(e.message) + \"\\r\\n\");\n\t}\n\tawait availableAPIs.terminate();\n})();\n\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); ","7434ce3e3e453de3c5b8b06c9341e7bf3261319407b830a2a920925e07a4a4731b28ea6dd8ff6599cb1df284aae15973bbf21ceec4d2538ab88f86010d6a36de":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: GET_LOCALE, FS_LIST_PARTITIONS, GET_FILESYSTEMS\n// signature: eed93e038969bb339e0db38d8907bd104905cd52683e5d6eb6d83551b4ae0464a760213eb6670b4115cb1f72342842ddc67faa5da9a35e288da1f4d3c7e0339c\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"mountinfo: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\n\tlet pargs = {};\n\tlet ppos = [];\n\tfor (let arg of exec_args) {\n\t\tif (arg.startsWith(\"--\")) {\n\t\t\tlet key = arg.split(\"=\")[0].slice(2);\n\t\t\tlet value = arg.split(\"=\").slice(1).join(\"=\");\n\t\t\tif (arg.split(\"=\")[1] == null) value = true;\n\t\t\tif (pargs.hasOwnProperty(key)) {\n\t\t\t\tlet ogValues = pargs[key];\n\t\t\t\tif (ogValues instanceof Array) pargs[key] = [ ...ogValues, value ];\n\t\t\t\telse pargs[key] = [ ogValues, value ];\n\t\t\t} else pargs[key] = value;\n\t\t} else ppos.push(arg);\n\t}\n\n\tif (ppos.length < 1) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"MOUNTINFO_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"MOUNTINFO_DESCRIPTION\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"mountinfo: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\n\ttry {\n\t\tawait availableAPIs.toMyCLI(JSON.stringify(await availableAPIs.fs_mountInfo(ppos[0]), null, \"\\t\").replaceAll(\"\\n\", \"\\r\\n\") + \"\\r\\n\");\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"mountinfo: \" + await availableAPIs.lookupLocale(e.message) + \"\\r\\n\");\n\t}\n\tawait availableAPIs.terminate();\n})();\n\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); ","b5da7c2105dbb1ff1de82d475d866e115557034aaaca75bc3473c4729ca11bd16a9b148d83602adecae27ef28c3e41fa3e97145e5853fbcb9746d0ab71b2acf2":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: GET_LOCALE, SET_DEFAULT_SYSTEM\n// signature: 6bb49f340d8933347db82ca5f93a80fa12cc1c018fa6cbb8f17fe9337d0283907b4cc93061765c75ed295e368e1fa5e35522667673a3d7017bd526bf8091e667\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.windowVisibility(false);\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"pivot_root: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\tif (!exec_args.length) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"PIVOT_ROOT_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"PIVOT_ROOT_DESCRIPTION\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"pivot_root: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\tawait availableAPIs.setSystemMount(exec_args[0]);\n\tawait availableAPIs.terminate();\n})();\n\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); null;","29aad004bf0e4fbe30f6762657a8f8769ab4758454d5a902404d2a28b71c9754c475063eccf162b5cbfb4bb7b4042d435a7bb545709e54e4ff02875a93cde6d0":"// =====BEGIN MANIFEST=====\n// signer: automaticSigner\n// allow: GET_LOCALE, FS_UNMOUNT, GET_FILESYSTEMS\n// signature: 336054bafe4f2f08f13f638986553d81c00e17df51607cac211b27b7fd803044dff5493bfcf24e7362fcb5b720492816616ca02a1e62e7e557f0e921d56de142\n// =====END MANIFEST=====\n(async function() {\n\t// @pcos-app-mode isolatable\n\tawait availableAPIs.attachCLI();\n\tif (!(await availableAPIs.getPrivileges()).includes(\"GET_LOCALE\")) { await availableAPIs.toMyCLI(\"umount: Locale permission denied\\r\\n\");\n\t\treturn await availableAPIs.terminate();\t}\n\n\tlet pargs = {};\n\tlet ppos = [];\n\tfor (let arg of exec_args) {\n\t\tif (arg.startsWith(\"--\")) {\n\t\t\tlet key = arg.split(\"=\")[0].slice(2);\n\t\t\tlet value = arg.split(\"=\").slice(1).join(\"=\");\n\t\t\tif (arg.split(\"=\")[1] == null) value = true;\n\t\t\tif (pargs.hasOwnProperty(key)) {\n\t\t\t\tlet ogValues = pargs[key];\n\t\t\t\tif (ogValues instanceof Array) pargs[key] = [ ...ogValues, value ];\n\t\t\t\telse pargs[key] = [ ogValues, value ];\n\t\t\t} else pargs[key] = value;\n\t\t} else ppos.push(arg);\n\t}\n\n\tif (ppos.length < 1) {\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"UMOUNT_USAGE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(await availableAPIs.lookupLocale(\"UMOUNT_DESCRIPTION\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"UMOUNT_OPT_SYNCONLY\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"\\t\" + await availableAPIs.lookupLocale(\"UMOUNT_OPT_FORCE\") + \"\\r\\n\");\n\t\tawait availableAPIs.toMyCLI(\"umount: \" + await availableAPIs.lookupLocale(\"NO_ARGUMENTS\") + \"\\r\\n\");\n\t\treturn availableAPIs.terminate();\n\t}\n\n\ttry {\n\t\tawait availableAPIs[\"fs_\" + (pargs[\"sync-only\"] == true ? \"sync\" : \"unmount\")]({\n\t\t\tmount: ppos[0],\n\t\t\tforce: pargs.force\n\t\t});\n\t} catch (e) {\n\t\tawait availableAPIs.toMyCLI(\"umount: \" + await availableAPIs.lookupLocale(e.message) + \"\\r\\n\");\n\t}\n\tawait availableAPIs.terminate();\n})();\n\naddEventListener(\"signal\", async function(e) {\n\tif (e.detail == 15) await window.availableAPIs.terminate();\n}); "},"buildInfo":{"for":"1314","when":1750514397589,"signer":"moduleSigner","critical":false,"signature":"a7e3e47c7cd5f0ae77e6e930720cfb243d79b81617337c2b92fc16013ce3504234a42add320ed168935c309703b54907e11636f35ad166d28eaffc2380ebb89a"}}