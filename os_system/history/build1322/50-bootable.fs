{"backend":{"files":{"boot":{"00-pcos.js":"9ead681e2a15255ac4c0026c600c634f3763aa526870570fde3974503de8bd8e878e45419f8de13f5f36934b7e422573f7eca11127bcb2c3aeffb8a472796de9","00-pcosksk.js":"e801c2a5ea7e9f4e37f4a7b2f296c8534c0ba1e7b625688249248874f634f2c7b20910a07593fc7be8549f7e870fcb7cd32a8238be1f42c219aef7f737aae95e","01-fs.js":"aa77929337074590ddb529a1dc0ce8ac1746785ca5b4de00ea2a9779abc3d2dafddd3cbbd705ab7332018a56c920b48cead7e5ac13fc43e2fec57734fb220306","01-fsck.js":"71bb841368dc2616022942ba7afb643358ba6806a796d23f3d83dbb43cc17abf98d340987d5fdce71489a610fbef5de3dd2006433da024749d2e231af2372988","01-fsmodules.js":"712255d2912dadb01c8f3fc354a9fa79786256f508a70ce45ca70f2545d8fa1d70a397ce5a0c2cc9973f7e4fa208a7a255e43888ab8fc6974c9b04ff252af788","02-ui.js":"b7a04becb1071e7ca86f16550a2672774ef8ea03b02c9dbbb64199ec343ca96bcc6008842cee550950e7fdcb2d2f680e28b2c17950de1083c6af4f8fe487c5d9","04-ipc.js":"3128c725891c0635c14800ebc1fc795e1f70096aaa833006d7b0cace8a65bc11c5e9b861388bd6dfa8eca9af5943e5330fd1f3099e9a44950995648373c4e86d","04-websockets.js":"fe53a5e6ca891475c253b94084ed733da9db6f656a4851247cec6d2937e2df967845b1b9913332566a932ff8023810bb304350f49392c7fe7a7177699c3d9acc","05-lull.js":"461c13b94e49a0dd7911d5f600436158f83bb9f7be90c514365d73f8732afd4d4c4378133965d612733e01b76c3bb5610a2c670f6cf03a77d56ca2b3076ef946","05-network.js":"60a3f733cee1e10c07364c67b817ebb981779851a8a1521deb9baebeaa44b675338e516ad659b5cb4eaaf653e7f49986376044c64ccbd14968e700ed853e6979","05-reeapis.js":"044d19c1aabc454fc5adef9a2da13d8b0e7aeff49e78992646407f8af85f26042b87559c014451cf88db3639b3c33c272b86cb712efd1a676d00bfda6bf17dee","06-csp.js":"793f0634e3428d92d45695e1661c7384219a05ea7835f1fab6bdd2cad7ebd17058cb647a7b26b0010de4ff5da553056e88432fd75ed3f1efadcbf16d831b85f7","06-locales.js":"f3775a6f2543705abbec6bd4a39e146c339870abaefbc6af74823ac47ce654647131263e28544eb39b22418ccd820c882d7b9acb9ae17f9cdabc016ae0a9d06b","07-tasks.js":"62851c8b6b8c91d7c59c3f780457e4595190eb68ce9ea92454607d37d4defd33308b8f2f9ff6329ee1c7eb69e81de742856594b3ba7c48fc60cba07036903384","09-logout.js":"ea49eeb03da7f291bcca718c66707941ee97ad35d9e449c4965dc65d6191f302221b3a26a7382bcba68385111e60fb0d0dc6e26e3f0d71833707cc8ad8fc537e","09-restart.js":"78707e166657c8a3b6d0997299044330539e8a92ec9ffaa5d22629606df7adf2d27b4d15dc2a0e8eca946f28dbe2025ad2c972eb3b4c1dc99b40362f99090fa0","11-userfriendliness.js":"cb627a1b3712e5104d109c2d586be5802b00c1b0c53282399787eb0c56286ef5825c89dfa73e58934349e6f2b1b7d8c13321d457ce55b135952f2c3ed284c695","12-tokens.js":"a87b3e3dc1c97b19fc2bfb4eaf98e8c2cbfa93edc73aead2946b6d2e8a300eb4aeaafa16258a9c2a17764a6bd489d7bdb393fc026925c359a5075e5c06bc8b08","12-users.js":"1a01c6ed5fe0e35a492069fe7b1b4064ce84d194ebbcf577eec8ae33b2eda9eab28d2115a3e4509f07bb2ceffc48d6de2875c5ee8cac0e6e60e00715b1b932ed","13-authui.js":"a2cef86f80e0a583cd5a8c68d4c2dd015144c641ed6f29a77200723c9c13518e4ba755f948bbd9c733cac64996992ae24c25f181f5e96a429c20cfa774b3a785","13-consentui.js":"486052a755358f960bdd4717fa4990e7e1dfb74a117b224dbc7558b0cedab080008231a2a7e3a1dde5e7c55ad1306cf29f584bd7c64790db35f7b5b3be22c080","14-logon-requirement.js":"b807e8ec228387673b3e104db8358b0033f679a01bb5f4ab176668b14b0b17c8e14dfeb0db34f6d325b10437e50dcca6c1cbcee4ac0939ce9448aa7c05bd4606","18-logon-requirement-enforce.js":"9185ec44ce0547e97c4e4345a52d2a94cd82ca57d9e12fb6bdc9d8aef31b7d83c203f2ec5ef847c70d028c5b9375ff489cc5337dcf1a765bcae5bd0a773dabe1","99-finished.js":"5b7bce196960695304c640c861c0a7de3e90b3cb79d4ae3a2559b7d7427b5808d2c09d1c004d4b7c6a042a9f4a4c6182230a9653a44361eccf0dd4e2bd3a62f1"}},"permissions":{"boot/00-pcos.js":{"world":"rx"},"boot/00-pcosksk.js":{"world":"rx"},"boot/01-fs.js":{"world":"rx"},"boot/01-fsck.js":{"world":"rx"},"boot/01-fsmodules.js":{"world":"rx"},"boot/02-ui.js":{"world":"rx"},"boot/04-ipc.js":{"world":"rx"},"boot/04-websockets.js":{"world":"rx"},"boot/05-lull.js":{"world":"rx"},"boot/05-network.js":{"world":"rx"},"boot/05-reeapis.js":{"world":"rx"},"boot/06-csp.js":{"world":"rx"},"boot/06-locales.js":{"world":"rx"},"boot/07-tasks.js":{"world":"rx"},"boot/09-logout.js":{"world":"rx"},"boot/09-restart.js":{"world":"rx"},"boot/11-userfriendliness.js":{"world":"rx"},"boot/12-tokens.js":{"world":"rx"},"boot/12-users.js":{"world":"rx"},"boot/13-authui.js":{"world":"rx"},"boot/13-consentui.js":{"world":"rx"},"boot/14-logon-requirement.js":{"world":"rx"},"boot/18-logon-requirement-enforce.js":{"world":"rx"},"boot/99-finished.js":{"world":"rx"},"boot/":{"world":"rx"},"":{"world":"rx"}}},"files":{"9ead681e2a15255ac4c0026c600c634f3763aa526870570fde3974503de8bd8e878e45419f8de13f5f36934b7e422573f7eca11127bcb2c3aeffb8a472796de9":"// @pcos-app-mode native\nconst pcos_version = \"1322\";\nconst build_time = 1750599835998;\n \nlet modules = {\n\tcore: coreExports,\n\tpcos_version,\n\tbuild_time\n};\nglobalThis.modules = modules;\n\nasync function panic(code, component) {\n\tmodules.shuttingDown = true;\n\tif (modules.session) modules.session.muteAllSessions();\n\tlet baseLocales = {\n\t\t\"PANIC_LINE1\": \"A critical problem has been detected while using the operating system. Its stability is at risk now.\",\n\t\t\"PANIC_LINE2\": \"Problem code: %s\",\n\t\t\"PANIC_UNSPECIFIED_ERROR\": \"UNSPECIFIED_ERROR\",\n\t\t\"PROBLEMATIC_COMPONENT\": \"Problematic component: %s\",\n\t\t\"PROBLEMATIC_PARAMS\": \"Problematic parameters: %s\",\n\t\t\"PROBLEMATIC_JS\": \"Problematic JavaScript: %s: %s\",\n\t\t\"PANIC_LINE3\": \"If you have seen this error message the first time, attempt rebooting.\",\n\t\t\"PANIC_LINE4\": \"If you see this error message once more, there is something wrong with the system.\",\n\t\t\"PANIC_LINE5\": \"You can try repairing the filesystem by placing a .fsck file on the system root mountpoint, with the value \\\"recover\\\" in it.\",\n\t\t\"PANIC_LINE6\": \"Proper shutdown procedure follows now:\",\n\t\t\"PANIC_TASK_KILLED\": \"task:%s: killed\",\n\t\t\"PANIC_MOUNT_UNMOUNTED\": \"mount:%s: unmounted\",\n\t\t\"PANIC_MOUNT_FAILED\": \"mount:%s: %s: %s\"\n\t}\n\tlet currentLocales = modules.locales;\n\tif (currentLocales) currentLocales = currentLocales[navigator.language.slice(0, 2).toLowerCase()];\n\tif (!currentLocales) currentLocales = baseLocales;\n\tif (!Object.keys(baseLocales).every(key => currentLocales.hasOwnProperty(key))) currentLocales = baseLocales;\n\n\tmodules.core.tty_bios_api.println(currentLocales.PANIC_LINE1);\n\tmodules.core.tty_bios_api.println(currentLocales.PANIC_LINE2.replace(\"%s\", (code || currentLocales.PANIC_UNSPECIFIED_ERROR)));\n\tif (component) {\n\t\tif (component.name) modules.core.tty_bios_api.println(currentLocales.PROBLEMATIC_COMPONENT.replace(\"%s\", component.name));\n\t\tif (component.params) modules.core.tty_bios_api.println(currentLocales.PROBLEMATIC_PARAMS.replace(\"%s\", JSON.stringify(component.params, null, \"\\t\")));\n\t\tif (component.underlyingJS) {\n\t\t\tmodules.core.tty_bios_api.println(currentLocales.PROBLEMATIC_JS.replace(\"%s\", component.underlyingJS.name).replace(\"%s\", component.underlyingJS.message));\n\t\t\tif (component.underlyingJS.stack) modules.core.tty_bios_api.println(component.underlyingJS.stack);\n\t\t}\n\t}\n\tmodules.core.tty_bios_api.println(currentLocales.PANIC_LINE3);\n\tmodules.core.tty_bios_api.println(currentLocales.PANIC_LINE4);\n\tmodules.core.tty_bios_api.println(currentLocales.PANIC_LINE5);\n\tmodules.core.tty_bios_api.println(currentLocales.PANIC_LINE6);\n\ttry {\n\t\tmodules.websocket._handles[modules.network.ws].ws.onclose = null;\n\t\tmodules.websocket._handles[modules.network.ws].ws.close();\n\t\tdelete modules.websocket._handles[modules.network.ws];\n\t} catch {}\n\tif (modules.tasks) for (let task in modules.tasks.tracker) {\n\t\tmodules.core.tty_bios_api.println(currentLocales.PANIC_TASK_KILLED.replace(\"%s\", modules.tasks.tracker[task].file));\n\t\tmodules.tasks.tracker[task].ree.closeDown();\n\t}\n\tif (modules.fs) for (let mount in modules.fs.mounts) {\n\t\ttry {\n\t\t\tawait modules.fs.unmount(mount);\n\t\t\tmodules.core.tty_bios_api.println(currentLocales.PANIC_MOUNT_UNMOUNTED.replace(\"%s\", mount));\n\t\t} catch (e) {\n\t\t\tmodules.core.tty_bios_api.println(currentLocales.PANIC_MOUNT_FAILED.replace(\"%s\", mount).replace(\"%s\", e.name).replace(\"%s\", e.message));\n\t\t}\n\t}\n\tif (modules.session) modules.session.destroy();\n\tthrow (component ? component.underlyingJS : null) || code || \"UNSPECIFIED_ERROR\";\n}\n\nfunction startupMemo() {\n\tmodules.core.tty_bios_api.println(\"PCsoft PCOS 3, build \" + pcos_version);\n\tmodules.core.tty_bios_api.println(\"Logical processors: \" + navigator.hardwareConcurrency);\n\tmodules.core.tty_bios_api.println(\"Memory available: \" + ((navigator.deviceMemory * 1024) || \"<unavailable>\") + \" MB\");\n}\nstartupMemo();","e801c2a5ea7e9f4e37f4a7b2f296c8534c0ba1e7b625688249248874f634f2c7b20910a07593fc7be8549f7e870fcb7cd32a8238be1f42c219aef7f737aae95e":"async function ksk() {\n\t// @pcos-app-mode native\n\t// Key signing key\n\tlet ksk = {\"kty\":\"EC\",\"x\":\"2iqPpmoqWFYGIjoCYAZvyDeGN2MeB2kkEdKeSswMPEc\",\"y\":\"6ZSKXt7HqvB8cWya7j9dC6x36DDgHLndX6qeMMnh7s4\",\"crv\":\"P-256\"};\n\tif (ksk.stub == \"present\") {\n\t\tlet e = new Error(\"The key signing key was not built into this build.\");\n\t\tpanic(\"KEY_SIGNING_KEY_NOT_BUILT\", {\n\t\t\tname: \"ksk\",\n\t\t\tparams: [ \"stub\" ],\n\t\t\tunderlyingJS: e\n\t\t});\n\t\tthrow e;\n\t}\n\tif (ksk.stub != \"present\") modules.ksk = ksk;\n\tif (modules.ksk) {\n\t\ttry {\n\t\t\tmodules.ksk_imported = await crypto.subtle.importKey(\"jwk\", modules.ksk, {\n\t\t\t\tname: \"ECDSA\",\n\t\t\t\tnamedCurve: \"P-256\"\n\t\t\t}, false, [\"verify\"]);\n\t\t} catch (e) {\n\t\t\tpanic(\"KEY_SIGNING_KEY_IMPORT_FAILED\", {\n\t\t\t\tname: \"ksk\",\n\t\t\t\tunderlyingJS: e\n\t\t\t});\n\t\t\tthrow e;\n\t\t}\n\t}\n}\nawait ksk();","aa77929337074590ddb529a1dc0ce8ac1746785ca5b4de00ea2a9779abc3d2dafddd3cbbd705ab7332018a56c920b48cead7e5ac13fc43e2fec57734fb220306":"function loadFs() {\n\t// @pcos-app-mode native\n\tlet fs = {\n\t\tread: async function(file, sessionToken) {\n\t\t\tlet mount = file.split(\"/\")[0];\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\treturn await this.mounts[mount].read(file.split(\"/\").slice(1).join(\"/\"), sessionToken);\n\t\t},\n\t\twrite: async function(file, data, sessionToken) {\n\t\t\tlet filePath = file.split(\"/\").slice(1);\n\t\t\tif (filePath.includes(\"\")) throw new Error(\"PATH_INCLUDES_EMPTY\");\n\t\t\tlet mount = file.split(\"/\")[0];\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\tif (modules.core.bootMode == \"readonly\") throw new Error(\"READ_ONLY_BMGR\");\n\t\t\tif (this.mounts[mount].read_only) throw new Error(\"READ_ONLY_DEV\");\n\t\t\treturn await this.mounts[mount].write(file.split(\"/\").slice(1).join(\"/\"), data, sessionToken);\n\t\t},\n\t\trm: async function(file, sessionToken) {\n\t\t\tlet mount = file.split(\"/\")[0];\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\tif (modules.core.bootMode == \"readonly\") throw new Error(\"READ_ONLY_BMGR\");\n\t\t\tif (this.mounts[mount].read_only) throw new Error(\"READ_ONLY_DEV\");\n\t\t\treturn await this.mounts[mount].rm(file.split(\"/\").slice(1).join(\"/\"), sessionToken);\n\t\t},\n\t\tmkdir: async function(folder, sessionToken) {\n\t\t\tlet filePath = folder.split(\"/\").slice(1);\n\t\t\tif (filePath.includes(\"\")) throw new Error(\"PATH_INCLUDES_EMPTY\");\n\t\t\tlet mount = folder.split(\"/\")[0];\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\tif (modules.core.bootMode == \"readonly\") throw new Error(\"READ_ONLY_BMGR\");\n\t\t\tif (this.mounts[mount].read_only) throw new Error(\"READ_ONLY_DEV\");\n\t\t\tif (!this.mounts[mount].directory_supported) throw new Error(\"NO_DIRECTORY_SUPPORT\");\n\t\t\treturn await this.mounts[mount].mkdir(folder.split(\"/\").slice(1).join(\"/\"), sessionToken);\n\t\t},\n\t\tpermissions: async function(folder, sessionToken) {\n\t\t\tlet mount = folder.split(\"/\")[0];\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\tif (!this.mounts[mount].permissions_supported) return { owner: randomNames, group: randomNames, world: \"rwx\" };\n\t\t\treturn await this.mounts[mount].permissions(folder.split(\"/\").slice(1).join(\"/\"), sessionToken);\n\t\t},\n\t\tlsmounts: function() {\n\t\t\treturn Object.keys(this.mounts);\n\t\t},\n\t\tunmount: async function(mount, sessionToken, force) {\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\tif (!this.mounts[mount].read_only && modules.core.bootMode != \"readonly\" && !force) await this.sync(mount, sessionToken);\n\t\t\tif (!force) await this.mounts[mount].unmount(sessionToken);\n\t\t\tdelete this.mounts[mount];\n\t\t},\n\t\tchown: async function(file, owner, sessionToken) {\n\t\t\tlet filePath = file.split(\"/\").slice(1);\n\t\t\tif (filePath.includes(\"\")) throw new Error(\"PATH_INCLUDES_EMPTY\");\n\t\t\tlet mount = file.split(\"/\")[0];\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\tif (modules.core.bootMode == \"readonly\") throw new Error(\"READ_ONLY_BMGR\");\n\t\t\tif (this.mounts[mount].read_only) throw new Error(\"READ_ONLY_DEV\");\n\t\t\tif (!this.mounts[mount].permissions_supported) throw new Error(\"NO_PERMIS_SUPPORT\");\n\t\t\treturn await this.mounts[mount].chown(file.split(\"/\").slice(1).join(\"/\"), owner, sessionToken);\n\t\t},\n\t\tchgrp: async function(file, group, sessionToken) {\n\t\t\tlet filePath = file.split(\"/\").slice(1);\n\t\t\tif (filePath.includes(\"\")) throw new Error(\"PATH_INCLUDES_EMPTY\");\n\t\t\tlet mount = file.split(\"/\")[0];\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\tif (modules.core.bootMode == \"readonly\") throw new Error(\"READ_ONLY_BMGR\");\n\t\t\tif (this.mounts[mount].read_only) throw new Error(\"READ_ONLY_DEV\");\n\t\t\tif (!this.mounts[mount].permissions_supported) throw new Error(\"NO_PERMIS_SUPPORT\");\n\t\t\treturn await this.mounts[mount].chgrp(file.split(\"/\").slice(1).join(\"/\"), group, sessionToken);\n\t\t},\n\t\tchmod: async function(file, permissions, sessionToken) {\n\t\t\tlet filePath = file.split(\"/\").slice(1);\n\t\t\tif (filePath.includes(\"\")) throw new Error(\"PATH_INCLUDES_EMPTY\");\n\t\t\tlet mount = file.split(\"/\")[0];\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\tif (modules.core.bootMode == \"readonly\") throw new Error(\"READ_ONLY_BMGR\");\n\t\t\tif (this.mounts[mount].read_only) throw new Error(\"READ_ONLY_DEV\");\n\t\t\tif (!this.mounts[mount].permissions_supported) throw new Error(\"NO_PERMIS_SUPPORT\");\n\t\t\treturn await this.mounts[mount].chmod(file.split(\"/\").slice(1).join(\"/\"), permissions, sessionToken);\n\t\t},\n\t\tls: async function(folder, sessionToken) {\n\t\t\tlet mount = folder.split(\"/\")[0];\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\treturn await this.mounts[mount].ls(folder.split(\"/\").slice(1).join(\"/\"), sessionToken);\n\t\t},\n\t\tisDirectory: async function(path, sessionToken) {\n\t\t\tlet mount = path.split(\"/\")[0];\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\tif (!path.split(\"/\").slice(1).join(\"/\")) return true;\n\t\t\tif (!this.mounts[mount].directory_supported) return false;\n\t\t\treturn await this.mounts[mount].isDirectory(path.split(\"/\").slice(1).join(\"/\"), sessionToken);\n\t\t},\n\t\tmountInfo: async function(mount) {\n\t\t\treturn {\n\t\t\t\tread_only: this.mounts[mount].read_only || false,\n\t\t\t\tpermissions_supported: this.mounts[mount].permissions_supported || false,\n\t\t\t\tdirectory_supported: this.mounts[mount].directory_supported || false,\n\t\t\t\tfilesystem: this.mounts[mount].filesystem || \"unknown\"\n\t\t\t}\n\t\t},\n\t\tsync: async function(mount, sessionToken) {\n\t\t\tif (!this.mounts.hasOwnProperty(mount)) throw new Error(\"NO_SUCH_DEVICE\");\n\t\t\tif (!this.mounts[mount].read_only && modules.core.bootMode != \"readonly\") return await this.mounts[mount].sync(sessionToken);\n\t\t},\n\t\tmounts: {}\n\t}\n\t\n\tasync function PCFSiDBMount(options) {\n\t\tlet partition;\n\t\ttry {\n\t\t\tpartition = modules.core.disk.partition(options.partition);\n\t\t\tpartition = partition.getData();\n\t\t} catch (e) {\n\t\t\tthrow new Error(\"PARTITION_FAILED: \" + e.toString() + \"\\n---begin stack---\\n\" + e.stack + \"\\n---end stack---\");\n\t\t}\n\t\tif (!Object.keys(partition).includes(\"files\") || !Object.keys(partition).includes(\"permissions\") || !Object.keys(partition).includes(\"id\")) throw new Error(\"PARTITION_NOT_PCFS\");\n\t\tlet partitionId = partition.id;\n\t\tpartition = null;\n\t\treturn {\n\t\t\tread: async function(key) {\n\t\t\t\tlet pathParts = key.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_FILE\");\n\t\t\t\t}\n\t\t\t\tif (typeof files === \"object\") throw new Error(\"IS_A_DIR\");\n\t\t\t\treturn String(await modules.core.idb.readPart(partitionId + \"-\" + files));\n\t\t\t},\n\t\t\twrite: async function(key, value) {\n\t\t\t\tkey = String(key);\n\t\t\t\tvalue = String(value);\n\t\t\t\tlet existenceChecks = key.split(\"/\").slice(0, -1);\n\t\t\t\tif (existenceChecks[0] == \"\") existenceChecks = existenceChecks.slice(1);\n\t\t\t\tif (existenceChecks[existenceChecks.length - 1] == \"\") existenceChecks = existenceChecks.slice(0, -1);\n\t\t\t\tlet basename = key.split(\"/\").slice(-1)[0];\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of existenceChecks) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files[basename] === \"object\") throw new Error(\"IS_A_DIR\");\n\t\t\t\tlet id = files[basename] || crypto.getRandomValues(new Uint8Array(64)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tawait modules.core.idb.writePart(partitionId + \"-\" + id, value);\n\t\t\t\tif (!files.hasOwnProperty(basename)) this.backend = this._recursive_op(this.backend, \"files/\" + key, { type: \"write\", value: id });\n\t\t\t},\n\t\t\trm: async function(key) {\n\t\t\t\tkey = String(key);\n\t\t\t\tlet pathParts = key.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_FILE_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files === \"object\" && Object.keys(files).length > 0) throw new Error(\"NON_EMPTY_DIR\");\n\t\t\t\tif (typeof files === \"string\") await modules.core.idb.removePart(partitionId + \"-\" + files);\n\t\t\t\tthis.backend = this._recursive_op(this.backend, \"files/\" + key, { type: \"delete\" });\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tdelete backend.permissions[key];\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tls: async function(directory) {\n\t\t\t\tdirectory = String(directory);\n\t\t\t\tlet pathParts = directory.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files !== \"object\") throw new Error(\"IS_A_FILE\");\n\t\t\t\treturn Object.keys(files);\n\t\t\t},\n\t\t\tmkdir: async function(directory) {\n\t\t\t\tdirectory = String(directory);\n\t\t\t\tlet existenceChecks = directory.split(\"/\").slice(0, -1);\n\t\t\t\tif (existenceChecks[0] == \"\") existenceChecks = existenceChecks.slice(1);\n\t\t\t\tif (existenceChecks[existenceChecks.length - 1] == \"\") existenceChecks = existenceChecks.slice(0, -1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of existenceChecks) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (Object.keys(files).includes(directory.split(\"/\").slice(-1)[0])) throw new Error(\"DIR_EXISTS\");\n\t\t\t\tthis.backend = this._recursive_op(this.backend, \"files/\" + directory, { type: \"write\", value: {} });\n\t\t\t},\n\t\t\tpermissions: async function(file) {\n\t\t\t\tfile = String(file);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet permissions = this.backend.permissions[properFile] || {};\n\t\t\t\treturn {\n\t\t\t\t\towner: permissions.owner || randomNames,\n\t\t\t\t\tgroup: permissions.group || randomNames,\n\t\t\t\t\tworld: permissions.world || \"\",\n\t\t\t\t\trandom: !(permissions.owner || permissions.group || permissions.world) ? true : undefined\n\t\t\t\t};\n\t\t\t},\n\t\t\tchown: async function(file, owner) {\n\t\t\t\tfile = String(file);\n\t\t\t\towner = String(owner);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.owner = owner;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tchgrp: async function(file, group) {\n\t\t\t\tfile = String(file);\n\t\t\t\tgroup = String(group);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.group = group;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tchmod: async function(file, permissions) {\n\t\t\t\tfile = String(file);\n\t\t\t\tpermissions = String(permissions);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.world = permissions;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tsync: async function() {\n\t\t\t\tawait modules.core.disk.sync();\n\t\t\t},\n\t\t\tisDirectory: function(key) {\n\t\t\t\tkey = String(key);\n\t\t\t\tlet pathParts = key.split(\"/\").slice(0, -1);\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet basename = key.split(\"/\").slice(-1)[0];\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (!files.hasOwnProperty(basename)) throw new Error(\"NO_SUCH_FILE_DIR\");\n\t\t\t\tif (typeof files[basename] === \"object\") return true;\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tunmount: () => true,\n\t\t\t_recursive_op: function(obj, path, action, stage = 0) {\n\t\t\t\tif (path.split(\"/\").length == (stage + 1)) {\n\t\t\t\t\tif (action.type == \"delete\") delete obj[path.split(\"/\").slice(-1)[0]];\n\t\t\t\t\tif (action.type == \"write\") obj[path.split(\"/\").slice(-1)[0]] = action.value;\n\t\t\t\t} else obj[path.split(\"/\")[stage]] = this._recursive_op(obj[path.split(\"/\")[stage]], path, action, stage + 1);\n\t\t\t\treturn obj;\n\t\t\t},\n\t\t\tdirectory_supported: true,\n\t\t\tread_only: !!options.read_only,\n\t\t\tfilesystem: \"PCFS\",\n\t\t\tpermissions_supported: true,\n\t\t\tpartition: null,\n\t\t\tget backend() {\n\t\t\t\tif (!this.partition) this.partition = modules.core.disk.partition(options.partition);\n\t\t\t\treturn this.partition.getData();\n\t\t\t},\n\t\t\tset backend(data) {\n\t\t\t\tif (!this.partition) this.partition = modules.core.disk.partition(options.partition);\n\t\t\t\tthis.partition.setData(data);\n\t\t\t}\n\t\t};\n\t};\n\n\tasync function PCFSiDBAESCryptMount(options) {\n\t\tlet partition;\n\t\ttry {\n\t\t\tpartition = modules.core.disk.partition(options.partition);\n\t\t\tpartition = partition.getData();\n\t\t} catch (e) {\n\t\t\tthrow new Error(\"PARTITION_FAILED: \" + e.toString() + \"\\n---begin stack---\\n\" + e.stack + \"\\n---end stack---\");\n\t\t}\n\t\tif (!Object.keys(partition).includes(\"files\") || !Object.keys(partition).includes(\"permissions\") || !Object.keys(partition).includes(\"cryptodata\") || !Object.keys(partition).includes(\"id\")) throw new Error(\"PARTITION_NOT_PCFS_ENCRYPTED\");\n\t\tif (options.interactivePassword) {\n\t\t\tlet passwordInput = \"\";\n\t\t\tlet tbi = modules.core.tty_bios_api;\n\t\t\tfunction outputPasswordAsking() {\n\t\t\t\ttbi.clear();\n\t\t\t\ttbi.println(\"|--------------------------------------------|\")\n\t\t\t\ttbi.println(\"| Mounting encrypted partition               |\");\n\t\t\t\ttbi.println(\"|--------------------------------------------|\");\n\t\t\t\ttbi.println(\"| Enter your password. Typed \" + passwordInput.length + \" characters. \" + \" \".repeat(Math.max((3 - (passwordInput.length).toString().length), 0)) + \"|\");\n\t\t\t\ttbi.println(\"| Press Enter to mount.                      |\");\n\t\t\t\ttbi.println(\"|--------------------------------------------|\");\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\toutputPasswordAsking();\n\t\t\t\tlet key = await tbi.inputKey();\n\t\t\t\tif (key.key == \"Enter\") break;\n\t\t\t\tif (key.key.length == 1) passwordInput += key.key;\n\t\t\t\tif (key.key == \"Backspace\") passwordInput = passwordInput.slice(0, -1);\n\t\t\t}\n\t\t\toptions.password = passwordInput;\n\t\t}\n\t\tif (options.password) options.key = await modules.core.pbkdf2(options.password, partition.cryptodata.salt);\n\t\tif (!options.key) throw new Error(\"GETTING_KEY_FAILED\");\n\t\tlet importedKey = await crypto.subtle.importKey(\"raw\", Uint8Array.from(options.key.match(/.{1,2}/g).map(a => parseInt(a, 16))), { name: \"AES-GCM\" }, false, [ \"encrypt\", \"decrypt\" ]);\n\t\toptions.key = options.key.length + \"L\";\n\t\toptions.password = options.password.length + \"L\";\n\t\tif (partition.cryptodata.passwordLockingInitial) {\n\t\t\tlet baseData = crypto.getRandomValues(new Uint8Array(32));\n\t\t\tlet iv = crypto.getRandomValues(new Uint8Array(16));\n\t\t\tlet ct = new Uint8Array(await crypto.subtle.encrypt({ name: \"AES-GCM\", iv }, importedKey, baseData));\n\t\t\tlet passwordLocking = new Uint8Array(iv.length + ct.length);\n\t\t\tpasswordLocking.set(iv);\n\t\t\tpasswordLocking.set(ct, iv.length);\n\t\t\tpartition.cryptodata.passwordLocking = passwordLocking.reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\tif (partition.encryptedFileTable) {\n\t\t\t\tlet fileIV = crypto.getRandomValues(new Uint8Array(16));\n\t\t\t\tlet fileCT = new Uint8Array(await crypto.subtle.encrypt({ name: \"AES-GCM\", iv: fileIV }, importedKey, new TextEncoder().encode(JSON.stringify({\n\t\t\t\t\tfiles: partition.files,\n\t\t\t\t\tpermissions: partition.permissions\n\t\t\t\t}))));\n\t\t\t\tpartition.files = {};\n\t\t\t\tpartition.permissions = {};\n\t\t\t\tlet ept = new Uint8Array(fileIV.length + fileCT.length);\n\t\t\t\tept.set(fileIV);\n\t\t\t\tept.set(fileCT, fileIV.length);\n\t\t\t\tpartition.encryptedFileTable = ept.reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t}\n\t\t\tdelete partition.cryptodata.passwordLockingInitial;\n\t\t\tmodules.core.disk.partition(options.partition).setData(partition);\n\t\t}\n\t\tif (partition.cryptodata.passwordLocking) {\n\t\t\tlet iv = new Uint8Array(partition.cryptodata.passwordLocking.slice(0, 32).match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\tlet ct = new Uint8Array(partition.cryptodata.passwordLocking.slice(32).match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\tawait crypto.subtle.decrypt({ name: \"AES-GCM\", iv }, importedKey, ct);\n\t\t}\n\t\tlet partitionId = partition.id;\n\t\tpartition = null;\n\t\treturn {\n\t\t\tread: async function(key) {\n\t\t\t\tkey = String(key);          \n\t\t\t\tlet pathParts = key.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tlet files = (await this.getBackend()).files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_FILE\");\n\t\t\t\t}\n\t\t\t\tif (typeof files === \"object\") throw new Error(\"IS_A_DIR\");\n\t\t\t\tlet part = await modules.core.idb.readPart(partitionId + \"-\" + files);\n\t\t\t\tlet iv = new Uint8Array(part.slice(0, 32).match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\t\tlet ct = new Uint8Array(part.slice(32).match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\t\treturn new TextDecoder().decode(new Uint8Array(await crypto.subtle.decrypt({ name: \"AES-GCM\", iv }, this.key, ct)));\n\t\t\t},\n\t\t\twrite: async function(key, value) {\n\t\t\t\tkey = String(key);\n\t\t\t\tvalue = String(value);\n\t\t\t\tlet existenceChecks = key.split(\"/\").slice(0, -1);\n\t\t\t\tif (existenceChecks[0] == \"\") existenceChecks = existenceChecks.slice(1);\n\t\t\t\tif (existenceChecks[existenceChecks.length - 1] == \"\") existenceChecks = existenceChecks.slice(0, -1);\n\t\t\t\tlet basename = key.split(\"/\").slice(-1)[0];\n\t\t\t\tlet files = (await this.getBackend()).files;\n\t\t\t\tfor (let part of existenceChecks) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files[basename] === \"object\") throw new Error(\"IS_A_DIR\");\n\t\t\t\tlet id = files[basename] || crypto.getRandomValues(new Uint8Array(64)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet newIV = crypto.getRandomValues(new Uint8Array(16));\n\t\t\t\tlet newCT = new Uint8Array(await crypto.subtle.encrypt({ name: \"AES-GCM\", iv: newIV }, this.key, new TextEncoder().encode(value)));\n\t\t\t\tlet newPart = new Uint8Array(newIV.length + newCT.length);\n\t\t\t\tnewPart.set(newIV);\n\t\t\t\tnewPart.set(newCT, newIV.length);\n\t\t\t\tnewPart = newPart.reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tawait modules.core.idb.writePart(partitionId + \"-\" + id, newPart);\n\t\t\t\tif (!files.hasOwnProperty(basename)) await this.setBackend(this._recursive_op(await this.getBackend(), \"files/\" + key, { type: \"write\", value: id }));\n\t\t\t},\n\t\t\trm: async function(key) {\n\t\t\t\tkey = String(key);\n\t\t\t\tlet pathParts = key.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet files = (await this.getBackend()).files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_FILE_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files === \"object\" && Object.keys(files).length > 0) throw new Error(\"NON_EMPTY_DIR\");\n\t\t\t\tif (typeof files === \"string\") await modules.core.idb.removePart(partitionId + \"-\" + files);\n\t\t\t\tawait this.setBackend(this._recursive_op(await this.getBackend(), \"files/\" + key, { type: \"delete\" }));\n\t\t\t\tlet backend = await this.getBackend();\n\t\t\t\tdelete backend.permissions[key];\n\t\t\t\tawait this.setBackend(backend);\n\t\t\t},\n\t\t\tls: async function(directory) {\n\t\t\t\tdirectory = String(directory);\n\t\t\t\tlet pathParts = directory.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet files = (await this.getBackend()).files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files !== \"object\") throw new Error(\"IS_A_FILE\");\n\t\t\t\treturn Object.keys(files);\n\t\t\t},\n\t\t\tmkdir: async function(directory) {\n\t\t\t\tdirectory = String(directory);\n\t\t\t\tlet existenceChecks = directory.split(\"/\").slice(0, -1);\n\t\t\t\tif (existenceChecks[0] == \"\") existenceChecks = existenceChecks.slice(1);\n\t\t\t\tif (existenceChecks[existenceChecks.length - 1] == \"\") existenceChecks = existenceChecks.slice(0, -1);\n\t\t\t\tlet files = (await this.getBackend()).files;\n\t\t\t\tfor (let part of existenceChecks) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (Object.keys(files).includes(directory.split(\"/\").slice(-1)[0])) throw new Error(\"DIR_EXISTS\");\n\t\t\t\tawait this.setBackend(this._recursive_op(await this.getBackend(), \"files/\" + directory, { type: \"write\", value: {} }));\n\t\t\t},\n\t\t\tpermissions: async function(file) {\n\t\t\t\tfile = String(file);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet permissions = (await this.getBackend()).permissions[properFile] || {};\n\t\t\t\treturn {\n\t\t\t\t\towner: permissions.owner || randomNames,\n\t\t\t\t\tgroup: permissions.group || randomNames,\n\t\t\t\t\tworld: permissions.world || \"\",\n\t\t\t\t\trandom: !(permissions.owner || permissions.group || permissions.world) ? true : undefined\n\t\t\t\t};\n\t\t\t},\n\t\t\tchown: async function(file, owner) {\n\t\t\t\tfile = String(file);\n\t\t\t\towner = String(owner);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tlet backend = await this.getBackend();\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.owner = owner;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tawait this.setBackend(backend);\n\t\t\t},\n\t\t\tchgrp: async function(file, group) {\n\t\t\t\tfile = String(file);\n\t\t\t\tgroup = String(group);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tlet backend = await this.getBackend();\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.group = group;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tawait this.setBackend(backend);\n\t\t\t},\n\t\t\tchmod: async function(file, permissions) {\n\t\t\t\tfile = String(file);\n\t\t\t\tpermissions = String(permissions);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tlet backend = await this.getBackend();\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.world = permissions;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tawait this.setBackend(backend);\n\t\t\t},\n\t\t\tisDirectory: async function(key) {\n\t\t\t\tkey = String(key);\n\t\t\t\tlet pathParts = key.split(\"/\").slice(0, -1);\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet basename = key.split(\"/\").slice(-1)[0];\n\t\t\t\tlet files = (await this.getBackend()).files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (!files.hasOwnProperty(basename)) throw new Error(\"NO_SUCH_FILE_DIR\");\n\t\t\t\tif (typeof files[basename] === \"object\") return true;\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tsync: async function() {\n\t\t\t\tawait modules.core.disk.sync();\n\t\t\t},\n\t\t\tunmount: () => true,\n\t\t\t_recursive_op: function(obj, path, action, stage = 0) {\n\t\t\t\tif (path.split(\"/\").length == (stage + 1)) {\n\t\t\t\t\tif (action.type == \"delete\") delete obj[path.split(\"/\").slice(-1)[0]];\n\t\t\t\t\tif (action.type == \"write\") obj[path.split(\"/\").slice(-1)[0]] = action.value;\n\t\t\t\t} else obj[path.split(\"/\")[stage]] = this._recursive_op(obj[path.split(\"/\")[stage]], path, action, stage + 1);\n\t\t\t\treturn obj;\n\t\t\t},\n\t\t\tdirectory_supported: true,\n\t\t\tfilesystem: \"PCFS-AES\",\n\t\t\tread_only: !!options.read_only,\n\t\t\tpermissions_supported: true,\n\t\t\tpartition: null,\n\t\t\tgetBackend: async function() {\n\t\t\t\tif (!this.partition) this.partition = modules.core.disk.partition(options.partition);\n\t\t\t\tlet returnedData = this.partition.getData();\n\t\t\t\tif (returnedData.encryptedFileTable) {\n\t\t\t\t\tlet iv = new Uint8Array(returnedData.encryptedFileTable.slice(0, 32).match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\t\t\tlet ct = new Uint8Array(returnedData.encryptedFileTable.slice(32).match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\t\t\treturn JSON.parse(new TextDecoder().decode(new Uint8Array(await crypto.subtle.decrypt({ name: \"AES-GCM\", iv }, this.key, ct))));   \n\t\t\t\t}\n\t\t\t\treturn returnedData;\n\t\t\t},\n\t\t\tsetBackend: async function(data) {\n\t\t\t\tif (!this.partition) this.partition = modules.core.disk.partition(options.partition);\n\t\t\t\tlet returnedData = this.partition.getData();\n\t\t\t\tif (returnedData.encryptedFileTable) {\n\t\t\t\t\tlet newIV = crypto.getRandomValues(new Uint8Array(16));\n\t\t\t\t\tlet newCT = new Uint8Array(await crypto.subtle.encrypt({ name: \"AES-GCM\", iv: newIV }, this.key, new TextEncoder().encode(JSON.stringify(data))));\n\t\t\t\t\tlet newPart = new Uint8Array(newIV.length + newCT.length);\n\t\t\t\t\tnewPart.set(newIV);\n\t\t\t\t\tnewPart.set(newCT, newIV.length);\n\t\t\t\t\tnewPart = newPart.reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\t\treturn this.partition.setData({ ...returnedData, encryptedFileTable: newPart });\n\t\t\t\t}\n\t\t\t\tthis.partition.setData(data);\n\t\t\t},\n\t\t\tkey: importedKey\n\t\t};\n\t};\n\t\n\tfunction ramMount(options) {\n\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\treturn {\n\t\t\tread: async function(key) {\n\t\t\t\tkey = String(key);\n\t\t\t\tlet pathParts = key.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_FILE\");\n\t\t\t\t}\n\t\t\t\tif (typeof files === \"object\") throw new Error(\"IS_A_DIR\");\n\t\t\t\treturn String(this.ramFiles.get(files));\n\t\t\t},\n\t\t\twrite: async function(key, value) {\n\t\t\t\tkey = String(key);\n\t\t\t\tvalue = String(value);\n\t\t\t\tlet existenceChecks = key.split(\"/\").slice(0, -1);\n\t\t\t\tif (existenceChecks[0] == \"\") existenceChecks = existenceChecks.slice(1);\n\t\t\t\tif (existenceChecks[existenceChecks.length - 1] == \"\") existenceChecks = existenceChecks.slice(0, -1);\n\t\t\t\tlet basename = key.split(\"/\").slice(-1)[0];\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of existenceChecks) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files[basename] === \"object\") throw new Error(\"IS_A_DIR\");\n\t\t\t\tlet id = files[basename] || crypto.getRandomValues(new Uint8Array(64)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tthis.ramFiles.set(id, value);\n\t\t\t\tif (!files.hasOwnProperty(basename)) this.backend = this._recursive_op(this.backend, \"files/\" + key, { type: \"write\", value: id });\n\t\t\t},\n\t\t\trm: async function(key) {\n\t\t\t\tkey = String(key);\n\t\t\t\tlet pathParts = key.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_FILE_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files === \"object\" && Object.keys(files).length > 0) throw new Error(\"NON_EMPTY_DIR\");\n\t\t\t\tif (typeof files === \"string\") this.ramFiles.delete(files);\n\t\t\t\tthis.backend = this._recursive_op(this.backend, \"files/\" + key, { type: \"delete\" });\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tdelete backend.permissions[key];\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tls: async function(directory) {\n\t\t\t\tdirectory = String(directory);\n\t\t\t\tlet pathParts = directory.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files !== \"object\") throw new Error(\"IS_A_FILE\");\n\t\t\t\treturn Object.keys(files);\n\t\t\t},\n\t\t\tmkdir: async function(directory) {\n\t\t\t\tdirectory = String(directory);\n\t\t\t\tlet existenceChecks = directory.split(\"/\").slice(0, -1);\n\t\t\t\tif (existenceChecks[0] == \"\") existenceChecks = existenceChecks.slice(1);\n\t\t\t\tif (existenceChecks[existenceChecks.length - 1] == \"\") existenceChecks = existenceChecks.slice(0, -1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of existenceChecks) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (Object.keys(files).includes(directory.split(\"/\").slice(-1)[0])) throw new Error(\"DIR_EXISTS\");\n\t\t\t\tthis.backend = this._recursive_op(this.backend, \"files/\" + directory, { type: \"write\", value: {} });\n\t\t\t},\n\t\t\tpermissions: async function(file) {\n\t\t\t\tfile = String(file);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet permissions = this.backend.permissions[properFile] || {};\n\t\t\t\treturn {\n\t\t\t\t\towner: permissions.owner || randomNames,\n\t\t\t\t\tgroup: permissions.group || randomNames,\n\t\t\t\t\tworld: permissions.world || \"\",\n\t\t\t\t\trandom: !(permissions.owner || permissions.group || permissions.world) ? true : undefined\n\t\t\t\t};\n\t\t\t},\n\t\t\tchown: async function(file, owner) {\n\t\t\t\tfile = String(file);\n\t\t\t\towner = String(owner);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.owner = owner;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tchgrp: async function(file, group) {\n\t\t\t\tfile = String(file);\n\t\t\t\tgroup = String(group);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.group = group;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tchmod: async function(file, permissions) {\n\t\t\t\tfile = String(file);\n\t\t\t\tpermissions = String(permissions);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.world = permissions;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tisDirectory: function(key) {\n\t\t\t\tkey = String(key);\n\t\t\t\tlet pathParts = key.split(\"/\").slice(0, -1);\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet basename = key.split(\"/\").slice(-1)[0];\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (!files.hasOwnProperty(basename)) throw new Error(\"NO_SUCH_FILE_DIR\");\n\t\t\t\tif (typeof files[basename] === \"object\") return true;\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\t_recursive_op: function(obj, path, action, stage = 0) {\n\t\t\t\tif (path.split(\"/\").length == (stage + 1)) {\n\t\t\t\t\tif (action.type == \"delete\") delete obj[path.split(\"/\").slice(-1)[0]];\n\t\t\t\t\tif (action.type == \"write\") obj[path.split(\"/\").slice(-1)[0]] = action.value;\n\t\t\t\t} else obj[path.split(\"/\")[stage]] = this._recursive_op(obj[path.split(\"/\")[stage]], path, action, stage + 1);\n\t\t\t\treturn obj;\n\t\t\t},\n\t\t\tsync: () => true,\n\t\t\tunmount: () => true,\n\t\t\tdirectory_supported: true,\n\t\t\tread_only: !!options.read_only,\n\t\t\tfilesystem: \"extramfs\",\n\t\t\tpermissions_supported: true,\n\t\t\tbackend: options.type == \"run\" ? { files: { run: {} }, permissions: {\n\t\t\t\t\"\": {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"rx\"\n\t\t\t\t},\n\t\t\t\trun: {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"rwx\"\n\t\t\t\t}\n\t\t\t}} : { files: {}, permissions: {\n\t\t\t\t\"\": {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"rx\"\n\t\t\t\t}\n\t\t\t} },\n\t\t\tramFiles: new Map()\n\t\t};\n\t}\n\t\n\tfunction preferenceMount(options) {\n\t\treturn {\n\t\t\tread: a => JSON.stringify(modules.core.prefs.read(a), null, \"\\t\"),\n\t\t\twrite: (a, b) => modules.core.prefs.write(a, JSON.parse(b)),\n\t\t\trm: a => modules.core.prefs.rm(a),\n\t\t\tls: a => modules.core.prefs.ls(a),\n\t\t\tpermissions: function() {\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\treturn {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t},\n\t\t\tchown: _ => !1,\n\t\t\tchgrp: _ => !1,\n\t\t\tchmod: _ => !1,\n\t\t\tsync: () => true,\n\t\t\tunmount: () => true,\n\t\t\tdirectory_supported: false,\n\t\t\tread_only: !!options.read_only,\n\t\t\tfilesystem: \"preffs\",\n\t\t\tpermissions_supported: true\n\t\t};\n\t}\n\n\tasync function SFSPMount(options) {\n\t\tlet session, serverData;\n\t\ttry {\n\t\t\tsession = await fetch(options.url + \"/session\");\n\t\t\tsession = await session.json();\n\t\t\tserverData = await fetch(options.url + \"/properties\", {\n\t\t\t\tmethod: \"POST\",\n\t\t\t\theaders: {\n\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t},\n\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t...options,\n\t\t\t\t\tsessionToken: session\n\t\t\t\t})\n\t\t\t});\n\t\t\tserverData = await serverData.json();\n\t\t} catch (e) {\n\t\t\tthrow new Error(\"Could not connect to server\");\n\t\t}\n\t\treturn {\n\t\t\tread: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"read\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\twrite: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"write\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\trm: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"rm\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\tls: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"ls\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\tmkdir: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"mkdir\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\tpermissions: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"permissions\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\tchown: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"chown\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\tchgrp: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"chgrp\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\tchmod: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"chmod\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\tsync: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"sync\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\tisDirectory: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"isDirectory\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\tunmount: async function(...a) {\n\t\t\t\tlet req = await fetch(options.url + \"/file_operation\", {\n\t\t\t\t\tmethod: \"POST\",\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t\"Content-Type\": \"application/json\"\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\t\tsessionToken: session,\n\t\t\t\t\t\toperation: \"unmount\",\n\t\t\t\t\t\tparameters: a\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t\tif (!req.ok) throw (await req.json());\n\t\t\t\treturn await req.json();\n\t\t\t},\n\t\t\t...serverData\n\t\t};\n\t};\n\n\tasync function IPCMount(options) { // ChatGPT code below\n\t\tif (!options.inputPipeId || !options.outputPipeId) throw new Error(\"PIPE_IDS_REQUIRED\");\n\t\n\t\tconst inputPipeId = options.inputPipeId;\n\t\tconst outputPipeId = options.outputPipeId;\n\t\tlet lock = false;\n\t\n\t\tasync function acquireLock() {\n\t\t\treturn new Promise((resolve) => {\n\t\t\t\tconst tryLock = () => {\n\t\t\t\t\tif (!lock) {\n\t\t\t\t\t\tlock = true;\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsetTimeout(tryLock, 10); // retry after 10ms\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tsetTimeout(tryLock, 10);\n\t\t\t});\n\t\t}\n\t\n\t\tasync function releaseLock() {\n\t\t\tlock = false;\n\t\t}\n\t\n\t\t// Function to send request and receive response\n\t\tasync function ipcRequest(action, payload = {}) {\n\t\t\tawait acquireLock();\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tmodules.ipc.listenFor(outputPipeId).then((response) => {\n\t\t\t\t\treleaseLock();\n\t\t\t\t\tif (response.error) return reject(new Error(response.error));\n\t\t\t\t\treturn resolve(response.data);\n\t\t\t\t});\n\t\t\t\tmodules.ipc.send(inputPipeId, { action, ...payload });\n\t\t\t});\n\t\t}\n\t\n\t\t// Initial request to get filesystem properties\n\t\tconst filesystemData = await ipcRequest(\"properties\", { data: options });\n\t\n\t\treturn {\n\t\t\tread: async function(key) {\n\t\t\t\treturn ipcRequest(\"read\", { key: String(key) });\n\t\t\t},\n\t\t\twrite: async function(key, value) {\n\t\t\t\treturn ipcRequest(\"write\", { key: String(key), value: String(value) });\n\t\t\t},\n\t\t\trm: async function(key) {\n\t\t\t\treturn ipcRequest(\"rm\", { key: String(key) });\n\t\t\t},\n\t\t\tls: async function(directory) {\n\t\t\t\treturn ipcRequest(\"ls\", { directory: String(directory) });\n\t\t\t},\n\t\t\tmkdir: async function(directory) {\n\t\t\t\treturn ipcRequest(\"mkdir\", { directory: String(directory) });\n\t\t\t},\n\t\t\tpermissions: async function(file) {\n\t\t\t\treturn ipcRequest(\"permissions\", { file: String(file) });\n\t\t\t},\n\t\t\tchown: async function(file, owner) {\n\t\t\t\treturn ipcRequest(\"chown\", { file: String(file), owner: String(owner) });\n\t\t\t},\n\t\t\tchgrp: async function(file, group) {\n\t\t\t\treturn ipcRequest(\"chgrp\", { file: String(file), group: String(group) });\n\t\t\t},\n\t\t\tchmod: async function(file, permissions) {\n\t\t\t\treturn ipcRequest(\"chmod\", { file: String(file), permissions: String(permissions) });\n\t\t\t},\n\t\t\tisDirectory: async function(key) {\n\t\t\t\treturn ipcRequest(\"isDirectory\", { key: String(key) });\n\t\t\t},\n\t\t\tsync: async function() {\n\t\t\t\treturn ipcRequest(\"sync\");\n\t\t\t},\n\t\t\tunmount: async function() {\n\t\t\t\treturn ipcRequest(\"unmount\");\n\t\t\t},\n\t\t\t...filesystemData\n\t\t};\n\t} // ChatGPT code ends here\n\n\tasync function fileMount(options) {\n\t\tlet file = JSON.parse(await modules.fs.read(options.srcFile));\n\t\tlet backend = file.backend;\n\t\tdelete file.backend;\n\t\tlet files = file.files;\n\t\tdelete file.files;\n\t\treturn {\n\t\t\tread: async function(key) {\n\t\t\t\tkey = String(key);\n\t\t\t\tlet pathParts = key.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_FILE\");\n\t\t\t\t}\t\n\t\t\t\tif (typeof files === \"object\") throw new Error(\"IS_A_DIR\");\n\t\t\t\treturn String(this.files[files]);\n\t\t\t},\n\t\t\twrite: async function(key, value) {\n\t\t\t\tkey = String(key);\n\t\t\t\tvalue = String(value);\n\t\t\t\tlet existenceChecks = key.split(\"/\").slice(0, -1);\n\t\t\t\tif (existenceChecks[0] == \"\") existenceChecks = existenceChecks.slice(1);\n\t\t\t\tif (existenceChecks[existenceChecks.length - 1] == \"\") existenceChecks = existenceChecks.slice(0, -1);\n\t\t\t\tlet basename = key.split(\"/\").slice(-1)[0];\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of existenceChecks) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files[basename] === \"object\") throw new Error(\"IS_A_DIR\");\n\t\t\t\tlet id = files[basename] || crypto.getRandomValues(new Uint8Array(64)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tthis.files[id] = value;\n\t\t\t\tif (!files.hasOwnProperty(basename)) this.backend = this._recursive_op(this.backend, \"files/\" + key, { type: \"write\", value: id });\n\t\t\t},\n\t\t\trm: async function(key) {\n\t\t\t\tkey = String(key);\n\t\t\t\tlet pathParts = key.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_FILE_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files === \"object\" && Object.keys(files).length > 0) throw new Error(\"NON_EMPTY_DIR\");\n\t\t\t\tif (typeof files === \"string\") delete this.files[files];\n\t\t\t\tthis.backend = this._recursive_op(this.backend, \"files/\" + key, { type: \"delete\" });\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tdelete backend.permissions[key];\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tls: async function(directory) {\n\t\t\t\tdirectory = String(directory);\n\t\t\t\tlet pathParts = directory.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (typeof files !== \"object\") throw new Error(\"IS_A_FILE\");\n\t\t\t\treturn Object.keys(files);\n\t\t\t},\n\t\t\tmkdir: async function(directory) {\n\t\t\t\tdirectory = String(directory);\n\t\t\t\tlet existenceChecks = directory.split(\"/\").slice(0, -1);\n\t\t\t\tif (existenceChecks[0] == \"\") existenceChecks = existenceChecks.slice(1);\n\t\t\t\tif (existenceChecks[existenceChecks.length - 1] == \"\") existenceChecks = existenceChecks.slice(0, -1);\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of existenceChecks) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (Object.keys(files).includes(directory.split(\"/\").slice(-1)[0])) throw new Error(\"DIR_EXISTS\");\n\t\t\t\tthis.backend = this._recursive_op(this.backend, \"files/\" + directory, { type: \"write\", value: {} });\n\t\t\t},\n\t\t\tpermissions: async function(file) {\n\t\t\t\tfile = String(file);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet permissions = this.backend.permissions[properFile] || {};\n\t\t\t\treturn {\n\t\t\t\t\towner: permissions.owner || randomNames,\n\t\t\t\t\tgroup: permissions.group || randomNames,\n\t\t\t\t\tworld: permissions.world || \"\",\n\t\t\t\t\trandom: !(permissions.owner || permissions.group || permissions.world) ? true : undefined\n\t\t\t\t};\n\t\t\t},\n\t\t\tchown: async function(file, owner) {\n\t\t\t\tfile = String(file);\n\t\t\t\towner = String(owner);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.owner = owner;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tchgrp: async function(file, group) {\n\t\t\t\tfile = String(file);\n\t\t\t\tgroup = String(group);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.group = group;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tchmod: async function(file, permissions) {\n\t\t\t\tfile = String(file);\n\t\t\t\tpermissions = String(permissions);\n\t\t\t\tlet properFile = file.split(\"/\")\n\t\t\t\tif (properFile[0] == \"\") properFile = properFile.slice(1);\n\t\t\t\tif (properFile[properFile.length - 1] == \"\") properFile = properFile.slice(0, -1);\n\t\t\t\tproperFile = properFile.join(\"/\");\n\t\t\t\tlet backend = this.backend;\n\t\t\t\tlet randomNames = crypto.getRandomValues(new Uint8Array(8)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\tlet filePermissions = backend.permissions[properFile] || {\n\t\t\t\t\towner: randomNames,\n\t\t\t\t\tgroup: randomNames,\n\t\t\t\t\tworld: \"\",\n\t\t\t\t};\n\t\t\t\tfilePermissions.world = permissions;\n\t\t\t\tbackend.permissions[properFile] = filePermissions;\n\t\t\t\tthis.backend = backend;\n\t\t\t},\n\t\t\tisDirectory: function(key) {\n\t\t\t\tkey = String(key);\n\t\t\t\tlet pathParts = key.split(\"/\").slice(0, -1);\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tlet basename = key.split(\"/\").slice(-1)[0];\n\t\t\t\tlet files = this.backend.files;\n\t\t\t\tfor (let part of pathParts) {\n\t\t\t\t\tfiles = files[part];\n\t\t\t\t\tif (!files) throw new Error(\"NO_SUCH_DIR\");\n\t\t\t\t}\n\t\t\t\tif (!files.hasOwnProperty(basename)) throw new Error(\"NO_SUCH_FILE_DIR\");\n\t\t\t\tif (typeof files[basename] === \"object\") return true;\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\t_recursive_op: function(obj, path, action, stage = 0) {\n\t\t\t\tif (path.split(\"/\").length == (stage + 1)) {\n\t\t\t\t\tif (action.type == \"delete\") delete obj[path.split(\"/\").slice(-1)[0]];\n\t\t\t\t\tif (action.type == \"write\") obj[path.split(\"/\").slice(-1)[0]] = action.value;\n\t\t\t\t} else obj[path.split(\"/\")[stage]] = this._recursive_op(obj[path.split(\"/\")[stage]], path, action, stage + 1);\n\t\t\t\treturn obj;\n\t\t\t},\n\t\t\tsync: async function() {\n\t\t\t\treturn await modules.fs.write(options.srcFile, JSON.stringify({ ...file, backend: this.backend, files: this.files }));\n\t\t\t},\n\t\t\tunmount: () => true,\n\t\t\tdirectory_supported: true,\n\t\t\tread_only: !!options.read_only,\n\t\t\tfilesystem: \"filefs\",\n\t\t\tpermissions_supported: true,\n\t\t\tbackend: backend,\n\t\t\tfiles: files\n\t\t};\n\t}\n\n\tasync function overlayMount(options) {\n\t\treturn {\n\t\t\tread: function(key, token) {\n\t\t\t\treturn this._basic_first_op(\"read\", key, token);\n\t\t\t},\n\t\t\twrite: function(key, value, token) {\n\t\t\t\treturn this._basic_first_op(\"write\", key, value, token);\n\t\t\t},\n\t\t\trm: function(key, token) {\n\t\t\t\treturn this._basic_first_op(\"rm\", key, token);\n\t\t\t},\n\t\t\tls: async function(directory, token) {\n\t\t\t\tlet listing = [], commonErrorMessages = {}, errors = 0;\n\t\t\t\tfor (let mount of options.mounts) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlisting.push(...(await modules.fs.ls(mount + \"/\" + directory, token)));\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\terrors++;\n\t\t\t\t\t\tcommonErrorMessages[e.message] = (commonErrorMessages[e.message] || 0) + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (errors == options.mounts.length) throw new Error(Object.entries(commonErrorMessages).sort((a, b) => b[1] - a[1])[0][0]);\n\t\t\t\treturn Array.from(new Set(listing));\n\t\t\t},\n\t\t\tmkdir: function(directory, token) {\n\t\t\t\treturn this._basic_first_op(\"mkdir\", directory, token);\n\t\t\t},\n\t\t\tpermissions: async function(file, token) {\n\t\t\t\tlet commonErrorMessages = {}, checkedHowMany = 0;\n\t\t\t\tfor (let mount of options.mounts) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcheckedHowMany++;\n\t\t\t\t\t\tlet permissions = await modules.fs.permissions(mount + \"/\" + file, token);\n\t\t\t\t\t\tif (permissions.random && checkedHowMany != options.mounts.length)\n\t\t\t\t\t\t\tthrow new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\t\treturn permissions;\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tcommonErrorMessages[e.message] = (commonErrorMessages[e.message] || 0) + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow new Error(Object.entries(commonErrorMessages).sort((a, b) => b[1] - a[1])[0][0]);\n\t\t\t},\n\t\t\tchown: function(file, owner, token) {\n\t\t\t\treturn this._basic_first_op(\"chown\", file, owner, token);\n\t\t\t},\n\t\t\tchgrp: function(file, group, token) {\n\t\t\t\treturn this._basic_first_op(\"chgrp\", file, group, token);\n\t\t\t},\n\t\t\tchmod: function(file, permissions, token) {\n\t\t\t\treturn this._basic_first_op(\"chmod\", file, permissions, token);\n\t\t\t},\n\t\t\tisDirectory: function(key, token) {\n\t\t\t\treturn this._basic_first_op(\"isDirectory\", key, token);\n\t\t\t},\n\t\t\tsync: function(token) {\n\t\t\t\treturn this._every_op(\"sync\", token);\n\t\t\t},\n\t\t\tunmount: function(token) {\n\t\t\t\tif (options.autoManage) return this._every_op(\"unmount\", token);\n\t\t\t},\n\t\t\t_basic_first_op: async function(op, key, ...args) {\n\t\t\t\tlet pathParts = key.split(\"/\");\n\t\t\t\tif (pathParts[0] == \"\") pathParts = pathParts.slice(1);\n\t\t\t\tif (pathParts[pathParts.length - 1] == \"\") pathParts = pathParts.slice(0, -1);\n\t\t\t\tkey = pathParts.join(\"/\");\n\t\t\t\tlet previousKey = key.split(\"/\").slice(0, -1).join(\"/\");\n\t\t\t\tlet basename = key.split(\"/\").slice(-1).join(\"/\");\n\t\t\t\tlet lookedForMount;\n\t\t\t\tfor (let mount of options.mounts) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet listing = await modules.fs.ls(mount + \"/\" + previousKey, args[args.length - 1]);\n\t\t\t\t\t\tif (listing.includes(basename)) {\n\t\t\t\t\t\t\tlookedForMount = mount;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch {}\n\t\t\t\t}\n\t\t\t\tif (lookedForMount) return modules.fs[op](lookedForMount + \"/\" + key, ...args);\n\t\t\t\tlet commonErrorMessages = {};\n\t\t\t\tfor (let mount of options.mounts) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn await modules.fs[op](mount + \"/\" + key, ...args);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tcommonErrorMessages[e.message] = (commonErrorMessages[e.message] || 0) + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow new Error(Object.entries(commonErrorMessages).sort((a, b) => b[1] - a[1])[0][0]);\n\t\t\t},\n\t\t\t_every_op: async function(op) {\n\t\t\t\tlet commonErrorMessages = {}, gotError;\n\t\t\t\tfor (let mount of options.mounts) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait modules.fs[op](mount);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tgotError = true;\n\t\t\t\t\t\tcommonErrorMessages[e.message] = (commonErrorMessages[e.message] || 0) + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (gotError) throw new Error(Object.entries(commonErrorMessages).sort((a, b) => b[1] - a[1])[0][0]);\n\t\t\t},\n\t\t\tdirectory_supported: true,\n\t\t\tread_only: !!options.read_only,\n\t\t\tfilesystem: \"overlayfs\",\n\t\t\tpermissions_supported: true\n\t\t};\n\t}\n\t\n\tfs.mounts[\"ram\"] = ramMount({\n\t\ttype: \"run\"\n\t});\n\tmodules.mounts = {\n\t\tPCFSiDBMount,\n\t\tPCFSiDBAESCryptMount,\n\t\tramMount,\n\t\tpreferenceMount,\n\t\tSFSPMount,\n\t\tIPCMount,\n\t\tfileMount,\n\t\toverlayMount\n\t};\n\tmodules.fs = fs;\n\tmodules.defaultSystem = \"ram\";\n}\n\nloadFs();","71bb841368dc2616022942ba7afb643358ba6806a796d23f3d83dbb43cc17abf98d340987d5fdce71489a610fbef5de3dd2006433da024749d2e231af2372988":"async function fsck() {\n\t// @pcos-app-mode native\n\tfunction println(str) {\n\t\tmodules.core.tty_bios_api.println(str);\n\t\treturn new Promise(function(resolve) {\n\t\t\trequestAnimationFrame(resolve);\n\t\t})\n\t}\n\tlet fsckMode;\n\ttry {\n\t\tfsckMode = await modules.fs.read(modules.defaultSystem + \"/.fsck\");\n\t\tawait modules.fs.rm(modules.defaultSystem + \"/.fsck\");\n\t} catch {\n\t\tawait println(\"Skipping file system checking.\");\n\t\treturn;\n\t}\n\tasync function scanLLDA() {\n\t\tlet fs = modules.fs;\n\t\tif (fs.mounts[modules.defaultSystem].read_only) {\n\t\t\tawait println(\"File system is read-only.\");\n\t\t\treturn { lldaPoints: \"abort\", lldaId: \"abort\" };\n\t\t}\n\t\tif (fs.mounts[modules.defaultSystem].partition.getData) {\n\t\t\tlet llda = fs.mounts[modules.defaultSystem].partition.getData().files;\n\t\t\tlet lldaId = fs.mounts[modules.defaultSystem].partition.getData().id;\n\t\t\tllda = Object.values(llda);\n\t\t\twhile (llda.some(a => typeof a === \"object\")) llda = llda.map(a => typeof a === \"object\" ? Object.values(a) : a).flat(); \n\t\t\treturn { lldaPoints: llda, lldaId: lldaId };\n\t\t} else {\n\t\t\tawait println(\"Low-level disk access is impossible.\");\n\t\t\treturn { lldaPoints: \"abort\", lldaId: \"abort\" };\n\t\t}\n\t}\n\tawait println(\"A file system check has been requested.\");\n\tawait println(\"Scanning for file points.\");\n\tlet { lldaPoints, lldaId } = await scanLLDA();\n\tif (lldaPoints === \"abort\") {\n\t\tawait println(\"Skipping file system checking.\");\n\t\treturn;\n\t}\n\tawait println(\"File points found: \" + lldaPoints.length);\n\tawait println(\"Reading indexedDB keys.\");\n\tlet idb_keys = modules.core.idb._db.transaction(\"disk\").objectStore(\"disk\").getAllKeys();\n\tidb_keys = await new Promise(function(resolve) {\n\t\tidb_keys.onsuccess = () => resolve(idb_keys.result);\n\t});\n\tidb_keys.splice(idb_keys.indexOf(\"disk\"), 1);\n\tawait println(\"IndexedDB keys found: \" + idb_keys.length);\n\tawait println(\"Filtering IndexedDB keys...\");\n\tif (fsckMode != \"discard-all\") idb_keys = idb_keys.filter(a => a.startsWith(lldaId + \"-\")).map(a => a.slice(lldaId.length + 1));\n\tawait println(\"Filtered keys: \" + idb_keys.length);\n\tlet missingFiles = idb_keys.filter(a => !lldaPoints.includes(a.slice(fsckMode == \"discard-all\" ? (lldaId + \"-\").length : 0)));\n\tawait println(\"Missing files: \" + missingFiles.length);\n\tlet llda = modules.fs.mounts[modules.defaultSystem].partition.getData();\n\tif (fsckMode == \"recover\") {\n\t\ttry {\n\t\t\tawait modules.fs.mkdir(modules.defaultSystem + \"/lost+found\");\n\t\t\tawait println(\"Created lost+found directory.\");\n\t\t} catch {\n\t\t\tawait println(\"Lost+found directory already exists.\");\n\t\t}\n\t\tfor (let file of missingFiles) {\n\t\t\tawait println(\"Moving \" + file + \" to lost+found.\");\n\t\t\tllda.files[\"lost+found\"][file] = file;\n\t\t}\n\t} else if (fsckMode == \"discard\" || fsckMode == \"discard-all\") {\n\t\tfor (let file of missingFiles) {\n\t\t\tawait println(\"Deleting \" + file + \".\");\n\t\t\tawait modules.core.idb.removePart((fsckMode == \"discard\" ? (lldaId + \"-\") : \"\") + file);\n\t\t}\n\t} else {\n\t\tawait println(\"Unsure what to do, not doing anything.\");\n\t}\n\tawait println(\"Saving modified file table.\");\n\tmodules.fs.mounts[modules.defaultSystem].partition.setData(llda);\n\tawait modules.core.idb.sync();\n\tawait println(\"File system check complete.\");\n}\nawait fsck();","712255d2912dadb01c8f3fc354a9fa79786256f508a70ce45ca70f2545d8fa1d70a397ce5a0c2cc9973f7e4fa208a7a255e43888ab8fc6974c9b04ff252af788":"async function loadModules() {\n\tlet hexToU8A = (hex) => Uint8Array.from(hex.match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\tlet u8aToHex = (u8a) => Array.from(u8a).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\tlet khrlSignatures = [];\n\tasync function loadKHRL() {\n\t\tlet khrlFiles = await modules.fs.ls(\".00-keys.fs/etc/keys/khrl\");\n\t\tfor (let khrlFile of khrlFiles) {\n\t\t\tlet khrl = JSON.parse(await modules.fs.read(\".00-keys.fs/etc/keys/khrl/\" + khrlFile));\n\t\t\tlet khrlSignature = khrl.signature;\n\t\t\tdelete khrl.signature;\n\t\t\tif (await crypto.subtle.verify({\n\t\t\t\tname: \"ECDSA\",\n\t\t\t\thash: {\n\t\t\t\t\tname: \"SHA-256\"\n\t\t\t\t}\n\t\t\t}, modules.ksk_imported, hexToU8A(khrlSignature), new TextEncoder().encode(JSON.stringify(khrl.list)))) {\n\t\t\t\tkhrlSignatures.push(...khrl.list);\n\t\t\t}\n\t\t}\n\t}\n\tasync function recursiveKeyVerify(key, khrl) {\n\t\tif (!key) throw new Error(\"NO_KEY\");\n\t\tlet hash = u8aToHex(new Uint8Array(await crypto.subtle.digest(\"SHA-256\", new TextEncoder().encode((key.keyInfo?.key || key.key).x + \"|\" + (key.keyInfo?.key || key.key).y))));\n\t\tif (khrl.includes(hash)) throw new Error(\"KEY_REVOKED\");\n\t\tlet signedByKey = modules.ksk_imported;\n\t\tif (key.keyInfo && key.keyInfo?.signedBy) {\n\t\t\tsignedByKey = JSON.parse(await modules.fs.read(\".00-keys.fs/etc/keys/\" + key.keyInfo.signedBy));\n\t\t\tif (!signedByKey.keyInfo) throw new Error(\"NOT_KEYS_V2\");\n\t\t\tif (!signedByKey.keyInfo.usages.includes(\"keyTrust\")) throw new Error(\"NOT_KEY_AUTHORITY\");\n\t\t\tawait recursiveKeyVerify(signedByKey, khrl);\n\t\t\tsignedByKey = await crypto.subtle.importKey(\"jwk\", signedByKey.keyInfo.key, {\n\t\t\t\tname: \"ECDSA\",\n\t\t\t\tnamedCurve: \"P-256\"\n\t\t\t}, false, [\"verify\"]);\n\t\t}\n\t\tif (!await crypto.subtle.verify({\n\t\t\tname: \"ECDSA\",\n\t\t\thash: {\n\t\t\t\tname: \"SHA-256\"\n\t\t\t}\n\t\t}, signedByKey, hexToU8A(key.signature), new TextEncoder().encode(JSON.stringify(key.key || key.keyInfo)))) throw new Error(\"KEY_SIGNATURE_VERIFICATION_FAILED\");\n\t\treturn true;\n\t}\n\ttry {\n\t\tlet moduleList = (await modules.fs.ls(modules.defaultSystem + \"/modules\")).sort((a, b) => a.localeCompare(b));\n\t\tfor (let moduleName of moduleList) {\n\t\t\tlet fullModuleFile = JSON.parse(await modules.fs.read(modules.defaultSystem + \"/modules/\" + moduleName));\n\t\t\tlet fullModuleSignature = fullModuleFile.buildInfo.signature;\n\t\t\tdelete fullModuleFile.buildInfo.signature;\n\t\t\tif (moduleName == \"00-keys.fs\") {\n\t\t\t\ttry {\n\t\t\t\t\tfullModuleFile = JSON.stringify(fullModuleFile);\n\t\t\t\t\tif (!(await crypto.subtle.verify({\n\t\t\t\t\t\tname: \"ECDSA\",\n\t\t\t\t\t\thash: {\n\t\t\t\t\t\t\tname: \"SHA-256\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}, modules.ksk_imported, hexToU8A(fullModuleSignature), new TextEncoder().encode(fullModuleFile)))) throw new Error(\"MODULE_SIGNATURE_VERIFICATION_FAILED\");\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (modules.core.bootMode != \"disable-harden\") await panic(\"KEYS_MODULE_VERIFICATION_FAILED\", {\n\t\t\t\t\t\tname: \"/modules/00-keys.fs\",\n\t\t\t\t\t\tparams: [modules.defaultSystem],\n\t\t\t\t\t\tunderlyingJS: e\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlet critical = fullModuleFile.buildInfo.critical;\n\t\t\t\ttry {\n\t\t\t\t\tlet signingKey = JSON.parse(await modules.fs.read(\".00-keys.fs/etc/keys/\" + fullModuleFile.buildInfo.signer));\n\t\t\t\t\tawait recursiveKeyVerify(signingKey, khrlSignatures);\n\t\t\t\t\tif (!signingKey.keyInfo.usages.includes(\"moduleTrust\")) throw new Error(\"NOT_MODULE_SIGNING_KEY\");\n\t\t\t\t\tlet importSigningKey = await crypto.subtle.importKey(\"jwk\", signingKey.keyInfo.key, {\n\t\t\t\t\t\tname: \"ECDSA\",\n\t\t\t\t\t\tnamedCurve: \"P-256\"\n\t\t\t\t\t}, false, [\"verify\"]);\n\t\t\t\t\tfullModuleFile = JSON.stringify(fullModuleFile);\n\t\t\t\t\tif (!await crypto.subtle.verify({\n\t\t\t\t\t\tname: \"ECDSA\",\n\t\t\t\t\t\thash: {\n\t\t\t\t\t\t\tname: \"SHA-256\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}, importSigningKey, hexToU8A(fullModuleSignature), new TextEncoder().encode(fullModuleFile))) throw new Error(\"MODULE_SIGNATURE_VERIFICATION_FAILED\");\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(\"Failed to verify module:\", e);\n\t\t\t\t\tif (critical && modules.core.bootMode != \"disable-harden\") await panic(\"CRITICAL_MODULE_VERIFICATION_FAILED\", {\n\t\t\t\t\t\tname: \"/modules/\" + moduleName,\n\t\t\t\t\t\tparams: [modules.defaultSystem],\n\t\t\t\t\t\tunderlyingJS: e\n\t\t\t\t\t});\n\t\t\t\t\tif (modules.core.bootMode != \"disable-harden\") {\n\t\t\t\t\t\tmoduleList.splice(moduleList.indexOf(moduleName), 1);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmodules.fs.mounts[\".\" + moduleName] = await modules.mounts.fileMount({\n\t\t\t\tsrcFile: modules.defaultSystem + \"/modules/\" + moduleName,\n\t\t\t\tread_only: true\n\t\t\t});\n\t\t\tif (moduleName == \"00-keys.fs\") await loadKHRL();\n\t\t\tif (modules.core.bootMode == \"logboot\") modules.core.tty_bios_api.println(\"\\t../modules/\" + moduleName);\n\t\t}\n\t\tlet newSystemMount = \"system\";\n\t\tif (modules.defaultSystem == \"system\") newSystemMount = \"system-\" + crypto.getRandomValues(new Uint8Array(4)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\tmodules.fs.mounts[newSystemMount] = await modules.mounts.overlayMount({\n\t\t\tmounts: [ modules.defaultSystem, ...moduleList.map(a => \".\" + a) ]\n\t\t});\n\t\tmodules.defaultSystem = newSystemMount;\n\t} catch (e) {\n\t\tconsole.error(\"Module system failed:\", e);\n\t}\n}\nawait loadModules();","b7a04becb1071e7ca86f16550a2672774ef8ea03b02c9dbbb64199ec343ca96bcc6008842cee550950e7fdcb2d2f680e28b2c17950de1083c6af4f8fe487c5d9":"function loadUi() {\n\t// @pcos-app-mode native\n\tlet uiStyle = document.createElement(\"style\");\n\tuiStyle.innerHTML = `body {\n\t\toverflow: hidden;\n\t\tbackground: black;\n\t\tcursor: none;\n\t\tfont-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n\t}\n\n\t.taskbar {\n\t\twidth: 100%;\n\t\tbackground: ${modules.core.bootMode == \"safe\" ? \"rgb(128, 128, 128)\" : \"rgba(128, 128, 128, 0.85)\"};\n\t\tleft: 0;\n\t\tbottom: 0;\n\t\tposition: absolute;\n\t\tpadding: 4px;\n\t\tbox-sizing: border-box;\n\t\tborder-radius: 4px;\n\t\tdisplay: flex;\n\t}\n\n\t.taskbar .clock {\n\t\tmargin-right: 4px;\n\t}\n\n\t.taskbar .icon {\n\t\twidth: 27px;\n\t\theight: 27px;\n\t\tbackground-size: contain;\n\t\tmargin: 0 4px;\n\t}\n\n\t.filler {\n\t\tflex: 1;\n\t}\n\n\t.window {\n\t\tposition: absolute;\n\t\ttop: 50%;\n\t\tleft: 50%;\n\t\ttransform: translate(-50%, -50%);\n\t\tbackground-color: ${modules.core.bootMode == \"safe\" ? \"rgb(240, 240, 240)\" : \"rgba(240, 240, 240, 0.5)\"};\n\t\tborder: 1px solid #ccc;\n\t\tbox-shadow: ${modules.core.bootMode == \"safe\" ? \"none\" : \"0 0 5px rgba(0, 0, 0, 0.3)\"};\n\t\tz-index: 1;\n\t\tresize: both;\n\t\twidth: 320px;\n\t\theight: 180px;\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t\toverflow: auto;\n\t\tbackdrop-filter: ${modules.core.bootMode == \"safe\" ? \"none\" : \"blur(8px)\"};\n\t\tanimation: ${modules.core.bootMode == \"safe\" ? \"none\" : \"fade-in 0.1s ease-in forwards\"};\n\t\tborder-radius: 4px;\n\t}\n\n\n\t.window.icon {\n\t\ttop: 72px;\n\t\tleft: 72px;\n\t\tresize: none;\n\t\twidth: 128px;\n\t\theight: 128px;\n\t}\n\n\t.window.dark {\n\t\tbackground-color: ${modules.core.bootMode == \"safe\" ? \"rgb(55, 55, 55)\" : \"rgba(55, 55, 55, 0.5)\"};\n\t\tcolor: white;\n\t\tborder: 1px solid #1b1b1b;\n\t}\n\n\t.window .title-bar {\n\t\tpadding: 6px;\n\t\tbackground-color: ${modules.core.bootMode == \"safe\" ? \"rgb(204, 204, 204)\" : \"rgba(204, 204, 204, 0.5)\"};\n\t\tcursor: move;\n\t\tdisplay: flex;\n\t\tflex: 1;\n\t\tuser-select: none;\n\t}\n\n\t.window.dark .title-bar {\n\t\tbackground-color: ${modules.core.bootMode == \"safe\" ? \"rgb(27, 27, 27)\" : \"rgba(27, 27, 27, 0.5)\"};\n\t}\n\n\t.window .button {\n\t\tcursor: pointer;\n\t\tpadding: 4px;\n\t\tborder: none;\n\t\tflex: 1;\n\t\tmargin: 0 0 0 2px;\n\t\tborder-radius: 4px;\n\t}\n\n\t.window .button:hover {\n\t\topacity: 75%;\n\t}\n\n\t.window .close-button {\n\t\tbackground: red;\n\t\tcolor: white;\n\t}\n\n\t.window .title-displayer {\n\t\tflex: 100;\n\t}\n\n\t.window .close-button:disabled {\n\t\topacity: 25%;\n\t}\n\n\t.window.fullscreen .resize-handle {\n\t\tdisplay: none;\n\t}\n\n\t.window.fullscreen {\n\t\twidth: 100% !important;\n\t\theight: 100% !important;\n\t\tposition: fixed;\n\t\ttop: 0 !important;\n\t\tleft: 0 !important;\n\t\ttransform: none;\n\t\tresize: none;\n\t\tborder: none;\n\t\tbox-shadow: none;\n\t}\n\n\t.window.fullscreen .title-bar {\n\t\tcursor: default;\n\t}\n\n\t.window .content {\n\t\tflex: 100;\n\t\toverflow: auto;\n\t\tposition: relative;\n\t\tbackground-color: #f0f0f0;\n\t}\n\n\t.window.dark .content {\n\t\tbackground-color: #373737;\n\t}\n\n\t.session {\n\t\tposition: fixed;\n\t\ttop: 0;\n\t\tleft: 0;\n\t\twidth: 100%;\n\t\theight: 100%;\n\t\tbackground: black;\n\t\tcursor: default;\n\t\tanimation: ${modules.core.bootMode == \"safe\" ? \"none\" : \"fade-in 0.1s ease-in forwards\"};\n\t}\n\n\t.session.secure {\n\t\tbackground: none${modules.core.bootMode == \"safe\" ? \" !important\" : \"\"};\n\t\tbackdrop-filter: ${modules.core.bootMode == \"safe\" ? \"none\" : \"blur(8px) brightness(50%)\"};\n\t\tanimation: ${modules.core.bootMode == \"safe\" ? \"none\" : \"fade 0.1s ease-out forwards\"};\n\t}\n\n\t.hidden {\n\t\tdisplay: none;\n\t}\n\t\n\t@keyframes fade-in {\n\t\t0% {\n\t\t\topacity: 0;\n\t\t}\n\n\t\t100% {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\n\t@keyframes fade {\n\t\t0% {\n\t\t\tbackdrop-filter: blur(0px) brightness(100%);\n\t\t}\n\n\t\t100% {\n\t\t\tbackdrop-filter: blur(8px) brightness(50%);\n\t\t}\n\t}`;\n\tdocument.head.appendChild(uiStyle);\n\n\tfunction createWindow(sessionId, makeFullscreenOnAllScreens, asIconWindow, reportMovement) {\n\t\tlet fullscreen = makeFullscreenOnAllScreens || matchMedia(\"(max-width: 600px)\").matches;\n\t\tif (asIconWindow) fullscreen = false;\n\t\tlet id = crypto.getRandomValues(new Uint8Array(64)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\tlet windowDiv = document.createElement('div');\n\t\twindowDiv.className = 'window ' + (fullscreen ? \"fullscreen \" : \"\") + \" \" + (asIconWindow ? \"icon\" : \"\");\n\t\tif (session.attrib(sessionId, \"dark\")) windowDiv.classList.add(\"dark\");\n\t\twindowDiv.id = 'window-' + id;\n\t\tlet titleBar = document.createElement('div');\n\t\ttitleBar.className = 'title-bar';\n\t\tlet title = document.createElement('span');\n\t\ttitle.className = 'title-displayer';\n\t\tlet closeButton = document.createElement('button');\n\t\tcloseButton.className = 'button close-button';\n\t\tcloseButton.innerHTML = '&#10005;';\n\t\ttitleBar.appendChild(title);\n\t\tif (!fullscreen && !asIconWindow) {\n\t\t\tlet fullscreenButton = document.createElement('button');\n\t\t\tfullscreenButton.className = 'button';\n\t\t\tfullscreenButton.innerHTML = '&#x25a1;';\n\t\t\tfullscreenButton.onclick = function() {\n\t\t\t\twindowDiv.classList.toggle(\"fullscreen\");\n\t\t\t}\n\t\t\ttitleBar.appendChild(fullscreenButton);\n\t\t}\n\t\tif (!asIconWindow) titleBar.appendChild(closeButton);\n\t\twindowDiv.appendChild(titleBar);\n\t\tlet content = document.createElement('div');\n\t\tcontent.className = 'content';\n\t\twindowDiv.appendChild(content);\n\t\tsession.tracker[sessionId].html.appendChild(windowDiv);\n\t\tif (!fullscreen) makeDraggable(windowDiv, titleBar, reportMovement);\n\t\treturn {\n\t\t\twindowDiv,\n\t\t\ttitle,\n\t\t\tcloseButton,\n\t\t\tcontent,\n\t\t\tsessionId\n\t\t};\n\t}\n\n\tfunction makeDraggable(windowDiv, titleBar, reportMovement) {\n\t\tlet pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;\n\n\t\ttitleBar.onmousedown = dragMouseDown;\n\t\ttitleBar.ontouchstart = dragMouseDown;\n\n\t\tfunction dragMouseDown(e) {\n\t\t\tif (e.type != \"touchstart\") e.preventDefault();\n\t\t\tif (e.type == \"touchstart\") e = e.touches[0];\n\t\t\tpos3 = e.clientX;\n\t\t\tpos4 = e.clientY;\n\n\t\t\tdocument.onmouseup = closeDragElement;\n\t\t\tdocument.ontouchend = closeDragElement;\n\t\t\tdocument.ontouchcancel = closeDragElement;\n\t\t\tdocument.onmousemove = elementDrag;\n\t\t\tdocument.ontouchmove = elementDrag;\n\t\t}\n\n\t\tfunction elementDrag(e) {\n\t\t\te.preventDefault();\n\t\t\tif (e.type == \"touchmove\") e = e.touches[0];\n\t\t\tpos1 = pos3 - e.clientX;\n\t\t\tpos2 = pos4 - e.clientY;\n\t\t\tpos3 = e.clientX;\n\t\t\tpos4 = e.clientY;\n\n\t\t\tif (!windowDiv.classList.contains(\"fullscreen\")) {\n\t\t\t\tif (reportMovement) reportMovement(windowDiv.offsetLeft - pos1, windowDiv.offsetTop - pos2);\n\t\t\t\twindowDiv.style.top = windowDiv.offsetTop - pos2 + 'px';\n\t\t\t\twindowDiv.style.left = windowDiv.offsetLeft - pos1 + 'px';\n\t\t\t}\n\t\t}\n\n\t\tfunction closeDragElement() {\n\t\t\tdocument.onmouseup = null;\n\t\t\tdocument.ontouchend = null;\n\t\t\tdocument.ontouchcancel = null;\n\t\t\tdocument.onmousemove = null;\n\t\t\tdocument.ontouchmove = null;\n\t\t}\n\t}\n\n\tlet session = {\n\t\tmksession: function() {\n\t\t\tif (modules.shuttingDown) throw new Error(\"SYSTEM_SHUTDOWN_REQUESTED\");\n\t\t\tlet identifier = crypto.getRandomValues(new Uint8Array(64)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\tlet session = document.createElement('div');\n\t\t\tsession.className = \"session hidden\";\n\t\t\tdocument.body.appendChild(session);\n\t\t\tthis.tracker[identifier] = {\n\t\t\t\thtml: session,\n\t\t\t\tattrib: {}\n\t\t\t};\n\t\t\treturn identifier;\n\t\t},\n\t\trmsession: function(session) {\n\t\t\tthis.tracker[session].html.remove();\n\t\t\tdelete this.tracker[session];\n\t\t},\n\t\tmuteAllSessions: function() {\n\t\t\tfor (let session in this.tracker) this.tracker[session].html.classList.add(\"hidden\");\n\t\t\tthis.active = null;\n\t\t},\n\t\tactivateSession: function(session) {\n\t\t\tthis.tracker[this.active]?.html?.classList?.add(\"hidden\");\n\t\t\tthis.tracker[session].html.classList.remove(\"hidden\");\n\t\t\tthis.active = session;\n\t\t},\n\t\tattrib: function(session, key, val) {\n\t\t\tif (val !== undefined) this.tracker[session].attrib[key] = val;\n\t\t\tif (key !== undefined) return this.tracker[session].attrib[key];\n\t\t\treturn this.tracker[session].attrib;\n\t\t},\n\t\tdestroy: function() {\n\t\t\tfor (let session in this.tracker) this.rmsession(session);\n\t\t\tthis.tracker = {};\n\t\t\tdelete this.systemSession;\n\t\t\tdelete modules.liu;\n\t\t\tdelete modules.serviceSession;\n\t\t\tuiStyle.remove();\n\t\t\tdelete modules.uiStyle;\n\t\t},\n\t\ttracker: {},\n\t\tactive: null\n\t}\n\n\tmodules.window = createWindow;\n\tmodules.session = session;\n\tmodules.uiStyle = uiStyle;\n\n\tmodules.session.systemSession = session.mksession();\n\tsession.muteAllSessions();\n\tsession.activateSession(modules.session.systemSession);\n\tmodules.startupWindow = modules.window(modules.session.systemSession);\n\tmodules.startupWindowProgress = document.createElement(\"progress\");\n\tmodules.startupWindow.title.innerText = \"PCOS 3\";\n\tmodules.startupWindow.content.style.padding = \"8px\";\n\tmodules.startupWindow.closeButton.classList.toggle(\"hidden\", true);\n\tmodules.startupWindow.content.innerText = \"PCOS is starting...\";\n\tmodules.startupWindow.content.appendChild(document.createElement(\"br\"));\n\tmodules.startupWindow.content.appendChild(modules.startupWindowProgress);\n}\n\nloadUi();","3128c725891c0635c14800ebc1fc795e1f70096aaa833006d7b0cace8a65bc11c5e9b861388bd6dfa8eca9af5943e5330fd1f3099e9a44950995648373c4e86d":"function loadIpc() {\n\t// @pcos-app-mode native\n\tmodules.ipc = {\n\t\tcreate: function() {\n\t\t\tlet id = crypto.getRandomValues(new Uint8Array(64)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\tthis._ipc[id] = { owner: \"root\", group: \"root\", world: false, _listeners: [] };\n\t\t\treturn id;\n\t\t},\n\t\tdeclareAccess: function(id, access) {\n\t\t\tthis._ipc[id] = { ...this._ipc[id], ...access };\n\t\t},\n\t\tlistenFor: function(id) {\n\t\t\tlet thatIPC = this._ipc;\n\t\t\treturn new Promise(function(resolve) {\n\t\t\t\tlet hasResolved = false;\n\t\t\t\treturn thatIPC[id]._listeners.push(function e(d) {\n\t\t\t\t\tif (hasResolved) return;\n\t\t\t\t\thasResolved = true;\n\t\t\t\t\treturn resolve(d);\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\t\tsend: function(id, data) {\n\t\t\ttry {\n\t\t\t\tthis._ipc[id]._listeners.forEach(listener => listener(data));\n\t\t\t} catch {}\n\t\t},\n\t\tgetIPC: function(id) {\n\t\t\tlet ipc = { ...this._ipc[id] };\n\t\t\tipc._listeners = ipc._listeners.length;\n\t\t\treturn ipc;\n\t\t},\n\t\t_ipc: {}\n\t}\n}\nloadIpc();","fe53a5e6ca891475c253b94084ed733da9db6f656a4851247cec6d2937e2df967845b1b9913332566a932ff8023810bb304350f49392c7fe7a7177699c3d9acc":"function loadWebsocketSupport() {\n\tlet websocketAPI = {\n\t\tgetHandle: function(url) {\n\t\t\tlet handle = Array.from(crypto.getRandomValues(new Uint8Array(64))).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\tlet websocket = new WebSocket(url);\n\t\t\twebsocket.binaryType = \"arraybuffer\";\n\t\t\twebsocketAPI._handles[handle] = {\n\t\t\t\tws: websocket,\n\t\t\t\tacl: {\n\t\t\t\t\towner: handle.slice(0, 16),\n\t\t\t\t\tgroup: handle.slice(0, 16),\n\t\t\t\t\tworld: true\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn handle;\n\t\t},\n\t\tsend: (arg) => websocketAPI._handles[arg.handle].ws.send(arg.data),\n\t\tclose: function(handle) {\n\t\t\tif (websocketAPI._handles.hasOwnProperty(handle)) websocketAPI._handles[handle].ws.close();\n\t\t\tdelete websocketAPI._handles[handle];\n\t\t},\n\t\tgetInfo: function(handle) {\n\t\t\treturn {\n\t\t\t\tbufferedAmount: websocketAPI._handles[handle].ws.bufferedAmount,\n\t\t\t\textensions: websocketAPI._handles[handle].ws.extensions,\n\t\t\t\tprotocol: websocketAPI._handles[handle].ws.protocol,\n\t\t\t\treadyState: websocketAPI._handles[handle].ws.readyState,\n\t\t\t\turl: websocketAPI._handles[handle].ws.url\n\t\t\t}\n\t\t},\n\t\twaitForEvent: function(arg) {\n\t\t\treturn new Promise(function(resolve) {\n\t\t\t\twebsocketAPI._handles[arg.handle].ws.addEventListener(arg.eventName, function meName(arg2) {\n\t\t\t\t\tif (arg.eventName == \"message\") resolve(arg2.data);\n\t\t\t\t\telse if (arg.eventName == \"error\") resolve({\n\t\t\t\t\t\tcode: arg2.code,\n\t\t\t\t\t\treason: arg2.reason,\n\t\t\t\t\t\twasClean: arg2.wasClean\n\t\t\t\t\t});\n\t\t\t\t\telse resolve(arg.eventName);\n\t\t\t\t\ttry {\n\t\t\t\t\t\twebsocketAPI._handles[arg.handle].ws.removeEventListener(arg.eventName, meName);\n\t\t\t\t\t} catch {}\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\t\tassertAccess: function(arg) {\n\t\t\tif (arg.newACL) websocketAPI._handles[arg.handle].acl = arg.newACL;\n\t\t\treturn websocketAPI._handles[arg.handle].acl;\n\t\t},\n\t\twebsocketState: (handle) => websocketAPI._handles[handle].ws.readyState,\n\t\t_handles: {}\n\t}\n\tmodules.websocket = websocketAPI;\n}\n\nloadWebsocketSupport();","461c13b94e49a0dd7911d5f600436158f83bb9f7be90c514365d73f8732afd4d4c4378133965d612733e01b76c3bb5610a2c670f6cf03a77d56ca2b3076ef946":"function loadLull() {\n\tlet lullSession;\n\tmodules.lull = function() {\n\t\tif (lullSession) return;\n\t\tlet style = document.createElement(\"style\");\n\t\tstyle.innerHTML = `* { cursor: none !important; };`;\n\t\tdocument.head.appendChild(style);\n\t\tlullSession = modules.session.mksession();\n\t\tmodules.session.muteAllSessions();\n\t\tmodules.session.activateSession(lullSession);\n\t\tfunction wake() {\n\t\t\tremoveEventListener(\"mousemove\", wake);\n\t\t\tremoveEventListener(\"click\", wake);\n\t\t\tremoveEventListener(\"keydown\", wake);\n\t\t\tstyle.remove();\n\t\t\tmodules.session.muteAllSessions();\n\t\t\tmodules.session.activateSession(modules.session.systemSession);\n\t\t\tmodules.session.rmsession(lullSession);\n\t\t\tlullSession = null;\n\t\t}\n\t\taddEventListener(\"mousemove\", wake);\n\t\taddEventListener(\"click\", wake);\n\t\taddEventListener(\"keydown\", wake);\n\t}\n}\nloadLull();","60a3f733cee1e10c07364c67b817ebb981779851a8a1521deb9baebeaa44b675338e516ad659b5cb4eaaf653e7f49986376044c64ccbd14968e700ed853e6979":"async function networkd() {\n\tlet hexToU8A = (hex) => Uint8Array.from(hex.match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\tlet u8aToHex = (u8a) => Array.from(u8a).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\tmodules.network = { connected: false, address: null, ws: null, runOnClose: Promise.resolve(), _runOnClose: _ => 1 };\n\ttry {\n\t\tlet config = await modules.fs.read(modules.defaultSystem + \"/etc/network.json\");\n\t\tconfig = JSON.parse(config);\n\t\tfunction isPacketFiltered(packet) {\n\t\t\tif (!config.filters) return false;\n\t\t\tfor (let filter of config.filters) {\n\t\t\t\tif (filter.type == 0) return filter.result;\n\t\t\t\tif (filter.type == 1 && isPacketFrom(packet, filter)) return filter.result;\n\t\t\t\tif (filter.type == 2 && filter.protocol == packet.data.type) return filter.result;\n\t\t\t\tif (filter.type == 3 && isPacketFrom(packet, filter) && filter.protocol == packet.data.type) return filter.result;\n\t\t\t\tif (filter.type == 4 && isPacketFrom(packet, filter) &&\n\t\t\t\t\t(packet.data.type == \"connectionful\" || packet.data.type == \"connectionless\")) {\n\t\t\t\t\t\tif (packet.data.gate == filter.gate) return filter.result;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tfunction isPacketFrom(packet, filter) {\n\t\t\tif (filter.from == packet.from) return true;\n\t\t\tif (filter.ipHash == packet.from.slice(0, 8)) return true;\n\t\t\tif (filter.systemID == packet.from.slice(8, 24)) return true;\n\t\t\treturn false;\n\t\t}\n\t\tmodules.network.reloadConfig = async function() {\n\t\t\tconfig = JSON.parse(await modules.fs.read(modules.defaultSystem + \"/etc/network.json\"));\n\t\t\tmodules.network.updates = config.updates;\n\t\t\ttry {\n\t\t\t\tws.send(JSON.stringify({\n\t\t\t\t\tfinalProxyPacket: true\n\t\t\t\t}));\n\t\t\t\tws.close();\n\t\t\t} catch {\n\t\t\t\tonclose();\n\t\t\t}\n\t\t}\n\t\tmodules.network.updates = config.updates;\n\t\tlet stage = 0;\n\t\tlet pukey = (modules.core.prefs.read(\"system_id\") || {}).public;\n\t\tlet importedKey = await crypto.subtle.importKey(\"jwk\", (modules.core.prefs.read(\"system_id\") || {}).private, {\n\t\t\tname: \"ECDSA\",\n\t\t\tnamedCurve: \"P-256\"\n\t\t}, true, [\"sign\"]);\n\t\tlet ws = new WebSocket(config.url);\n\t\tlet handle = Array.from(crypto.getRandomValues(new Uint8Array(64))).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\tmodules.network.runOnClose = new Promise(a => modules.network._runOnClose = a);\n\t\tws.binaryType = \"arraybuffer\";\n\t\tasync function onclose() {\n\t\t\tmodules.network.connected = false;\n\t\t\tmodules.network.address = null;\n\t\t\tmodules.network.hostname = null;\n\t\t\tmodules.network._runOnClose();\n\t\t\tws = new WebSocket(config.url);\n\t\t\tstage = 0;\n\t\t\tws.onmessage = onmessage;\n\t\t\tws.onclose = onclose;\n\t\t\tmodules.network.runOnClose = new Promise(a => modules.network._runOnClose = a);\n\t\t}\n\t\tasync function onmessage(e) {\n\t\t\tlet messageData;\n\t\t\ttry {\n\t\t\t\tmessageData = JSON.parse(e.data);\n\t\t\t} catch {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (stage == 0) {\n\t\t\t\tws.send(JSON.stringify({ ...pukey, forceConnect: true, userCustomizable: config.ucBits, hostname: config.hostname }));\n\t\t\t\tstage++;\n\t\t\t} else if (stage == 1) {\n\t\t\t\tif (messageData.event != \"SignatureRequest\") {\n\t\t\t\t\tws.onclose = null;\n\t\t\t\t\tdelete modules.websocket._handles[handle];\n\t\t\t\t\treturn ws.close();\n\t\t\t\t}\n\t\t\t\tws.send(u8aToHex(new Uint8Array(await crypto.subtle.sign({\n\t\t\t\t\tname: \"ECDSA\",\n\t\t\t\t\thash: {\n\t\t\t\t\t\tname: \"SHA-256\"\n\t\t\t\t\t}\n\t\t\t\t}, importedKey, hexToU8A(messageData.signBytes)))));\n\t\t\t\tstage++;\n\t\t\t} else if (stage == 2) {\n\t\t\t\tif (messageData.event != \"ConnectionEstablished\") {\n\t\t\t\t\tws.onclose = null;\n\t\t\t\t\tdelete modules.websocket._handles[handle];\n\t\t\t\t\treturn ws.close();\n\t\t\t\t}\n\t\t\t\tmodules.websocket._handles[handle] = {\n\t\t\t\t\tws: ws,\n\t\t\t\t\tacl: {\n\t\t\t\t\t\towner: handle.slice(0, 16),\n\t\t\t\t\t\tgroup: handle.slice(0, 16),\n\t\t\t\t\t\tworld: true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmodules.network.connected = true;\n\t\t\t\tmodules.network.address = messageData.address;\n\t\t\t\tmodules.network.hostname = messageData.hostname;\n\t\t\t\tmodules.network.ws = handle;\n\t\t\t\tstage++;\n\t\t\t} else if (stage == 3) {\n\t\t\t\tif (messageData.event == \"DisconnectionComplete\") {\n\t\t\t\t\tmodules.network.connected = false;\n\t\t\t\t\tmodules.network.address = null;\n\t\t\t\t\tmodules.network.hostname = null;\n\t\t\t\t\tmodules.network.ws = null;\n\t\t\t\t\tmodules.network._runOnClose();\n\t\t\t\t\tws.onclose = null;\n\t\t\t\t\tdelete modules.websocket._handles[handle];\n\t\t\t\t\treturn ws.close();\n\t\t\t\t}\n\t\t\t\tif (messageData.from) {\n\t\t\t\t\tif (isPacketFiltered(messageData)) {\n\t\t\t\t\t\te.stopImmediatePropagation();\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (messageData.data.type == \"ping\") {\n\t\t\t\t\t\tif (typeof messageData.data.resend !== \"string\") return;\n\t\t\t\t\t\tif (messageData.data.resend.length > 64) return;\n\t\t\t\t\t\tws.send(JSON.stringify({ receiver: messageData.from, data: { type: \"pong\", resend: messageData.data.resend } }));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tws.onmessage = onmessage;\n\t\tws.onclose = onclose;\n\t} catch {\n\t\tmodules.network.serviceStopped = true;\n\t\tmodules.core.tty_bios_api.println(\"network: not starting network\");\n\t}\n}\nnetworkd();","044d19c1aabc454fc5adef9a2da13d8b0e7aeff49e78992646407f8af85f26042b87559c014451cf88db3639b3c33c272b86cb712efd1a676d00bfda6bf17dee":"function reeAPIs() {\n\t// @pcos-app-mode native\n\n\tasync function denyUnmanifested(list, token) {\n\t\tlet privileges = (await modules.tokens.info(token)).privileges;\n\t\tlet isAllowlist = list.some(a => a.lineType == \"allow\");\n\t\tif (isAllowlist) list = list.filter(a => a.lineType == \"allow\");\n\t\tlet disallowedRegistry = [];\n\t\tfor (let privilege of privileges) {\n\t\t\tif ((!list.some(x => x.data == privilege && x.lineType == \"allow\") && isAllowlist) || list.some(x => x.data == privilege && x.lineType == \"deny\")) {\n\t\t\t\tprivileges = privileges.filter(x => x != privilege);\n\t\t\t\tdisallowedRegistry.push(privilege);\n\t\t\t}\n\t\t}\n\t\tmodules.tokens.removePrivileges(token, disallowedRegistry);\n\t\treturn privileges;\n\t}\n\n\tmodules.reeAPIInstance = async function(opts) {\n\t\tlet {ree, ses, token, taskId, limitations, privateData} = opts;\n\t\tlet processToken = token;\n\t\tlet tokenInfo = await modules.tokens.info(token);\n\t\tlet user = tokenInfo.user;\n\t\tlet groups = tokenInfo.groups || [];\n\t\tlet privileges = tokenInfo.privileges;\n\t\tlet processPipes = [];\n\t\tlet websockets = [];\n\t\tlet automatedLogonSessions = {};\n\t\tlet networkListens = {};\n\t\tlet connections = {};\n\t\tlet language = modules.session.attrib(ses, \"language\") || undefined;\n\t\tprivileges = await denyUnmanifested(limitations, token);\n\n\t\tasync function fs_action(action, privilegeCheck, path, ...xtra) {\n\t\t\tlet fsPermissions;\n\t\t\ttry {\n\t\t\t\tfsPermissions = await modules.fs.permissions(path);\n\t\t\t} catch (e) {\n\t\t\t\tthrow new Error(\"PERMISSION_CHECKING_FAILED\");\n\t\t\t}\n\t\t\tif (!privilegeCheck(fsPermissions)) throw new Error(\"PERMISSION_DENIED\");\n\t\t\ttry {\n\t\t\t\tlet response = await modules.fs[action](path, ...xtra);\n\t\t\t\treturn response;\n\t\t\t} catch (e) {\n\t\t\t\tif (e.name == \"Error\") throw e;\n\t\t\t\tthrow new Error(\"FS_ACTION_FAILED\");\n\t\t\t}\n\t\t}\n\t\tasync function recursiveKeyVerify(key, khrl) {\n\t\t\tif (!key) throw new Error(\"NO_KEY\");\n\t\t\tlet u8aToHex = (u8a) => Array.from(u8a).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\tlet hash = u8aToHex(new Uint8Array(await crypto.subtle.digest(\"SHA-256\", new TextEncoder().encode((key.keyInfo?.key || key.key).x + \"|\" + (key.keyInfo?.key || key.key).y))));\n\t\t\tlet hexToU8A = (hex) => Uint8Array.from(hex.match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\tif (khrl.includes(hash)) throw new Error(\"KEY_REVOKED\");\n\t\t\tlet signedByKey = modules.ksk_imported;\n\t\t\tif (key.keyInfo && key.keyInfo?.signedBy) {\n\t\t\t\tsignedByKey = JSON.parse(await modules.fs.read(modules.defaultSystem + \"/etc/keys/\" + key.keyInfo.signedBy, token));\n\t\t\t\tif (!signedByKey.keyInfo) throw new Error(\"NOT_KEYS_V2\");\n\t\t\t\tif (!signedByKey.keyInfo.usages.includes(\"keyTrust\")) throw new Error(\"NOT_KEY_AUTHORITY\");\n\t\t\t\tawait recursiveKeyVerify(signedByKey, khrl);\n\t\t\t\tsignedByKey = await crypto.subtle.importKey(\"jwk\", signedByKey.keyInfo.key, {\n\t\t\t\t\tname: \"ECDSA\",\n\t\t\t\t\tnamedCurve: \"P-256\"\n\t\t\t\t}, false, [\"verify\"]);\n\t\t\t}\n\t\t\tif (!await crypto.subtle.verify({\n\t\t\t\tname: \"ECDSA\",\n\t\t\t\thash: {\n\t\t\t\t\tname: \"SHA-256\"\n\t\t\t\t}\n\t\t\t}, signedByKey, hexToU8A(key.signature), new TextEncoder().encode(JSON.stringify(key.key || key.keyInfo)))) throw new Error(\"KEY_SIGNATURE_VERIFICATION_FAILED\");\n\t\t\treturn true;\n\t\t}\n\n\t\tree.beforeCloseDown(async function() {\n\t\t\tfor (let processPipe of processPipes) delete modules.ipc._ipc[processPipe];\n\t\t\tfor (let connection in connections) try { networkListens[connections[connection].networkListenID].ws.send(JSON.stringify({\n\t\t\t\treceiver: connections[connection].from,\n\t\t\t\tdata: {\n\t\t\t\t\ttype: \"connectionful\",\n\t\t\t\t\taction: \"drop\",\n\t\t\t\t\tconnectionID: connection.slice(0, -7),\n\t\t\t\t\tgate: connections[connection].gateIfNeeded\n\t\t\t\t}\n\t\t\t})); } catch {}\n\t\t\tfor (let networkListen in networkListens) networkListens[networkListen].ws.removeEventListener(\"message\", networkListens[networkListen].fn);\n\t\t\tfor (let websocket of websockets) modules.websocket.close(websocket);\n\t\t\tawait modules.tokens.revoke(token);\n\t\t\tfor (let i in modules.csps) if (modules.csps[i].hasOwnProperty(\"removeSameGroupKeys\")) modules.csps[i].removeSameGroupKeys(null, taskId);\n\t\t});\n\t\tlet apis = {\n\t\t\tprivate: {\n\t\t\t\tsetUser: async function(newUser) {\n\t\t\t\t\tuser = newUser;\n\t\t\t\t\tgroups = (await modules.users.getUserInfo(newUser, false, token || processToken)).groups || [];\n\t\t\t\t},\n\t\t\t\taddPrivilege: (newPrivilege) => !privileges.includes(newPrivilege) && privileges.push(newPrivilege),\n\t\t\t\trmPrivilege: (newPrivilege) => privileges.includes(newPrivilege) && privileges.splice(privileges.indexOf(newPrivilege), 1),\n\t\t\t\tsetPrivileges: (newPrivileges) => privileges = newPrivileges,\n\t\t\t\treauthorize: async function() {\n\t\t\t\t\tlet tokenInfo = await modules.tokens.info(token);\n\t\t\t\t\tuser = tokenInfo.user;\n\t\t\t\t\tgroups = tokenInfo.groups || [];\n\t\t\t\t\tprivileges = tokenInfo.privileges;\n\t\t\t\t\tprivileges = await denyUnmanifested(limitations, token);\n\t\t\t\t}\n\t\t\t},\n\t\t\tpublic: {\n\t\t\t\tgetUser: () => user,\n\t\t\t\tgetPrivileges: () => privileges,\n\t\t\t\tterminate: async function() {\n\t\t\t\t\tawait ree.closeDown();\n\t\t\t\t},\n\t\t\t\trmPrivilege: async function(privilege) {\n\t\t\t\t\tif (!privileges.includes(privilege)) throw new Error(\"NO_SUCH_PRIVILEGE\");\n\t\t\t\t\tprivileges.splice(privileges.indexOf(privilege), 1);\n\t\t\t\t\tawait modules.tokens.removePrivilege(token, privilege);\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\trmPrivileges: async function(privilegesRemoved) {\n\t\t\t\t\tprivileges = privileges.filter(x => !privilegesRemoved.includes(x));\n\t\t\t\t\tawait modules.tokens.removePrivileges(token, privilegesRemoved);\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tswitchUser: async function(desiredUser) {\n\t\t\t\t\tif (!privileges.includes(\"SWITCH_USERS_AUTOMATICALLY\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tawait modules.tokens.halfInitialize(token, desiredUser);\n\t\t\t\t\tlet tokenInfo = await modules.tokens.info(token);\n\t\t\t\t\tuser = tokenInfo.user;\n\t\t\t\t\tgroups = tokenInfo.groups || [];\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tshutdown: async function(arg) {\n\t\t\t\t\tlet {isKexec, isReboot, force, token} = arg;\n\t\t\t\t\tif (!privileges.includes(\"SYSTEM_SHUTDOWN\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (force) {\n\t\t\t\t\t\ttry { modules.websocket._handles[modules.network.ws].ws.close(); } catch {}\n\t\t\t\t\t\tmodules.session.destroy();\n\t\t\t\t\t\tif (isReboot) return location.reload();\n\t\t\t\t\t\treturn modules.killSystem();\n\t\t\t\t\t}\n\t\t\t\t\tawait modules.restart(!isReboot, token || processToken, isKexec);\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tfs_read: async function(arg) {\n\t\t\t\t\tlet {path, token} = arg;\n\t\t\t\t\tif (!privileges.includes(\"FS_READ\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn await fs_action(\"read\", (fsPermissions) => fsPermissions.owner == user || fsPermissions.world.includes(\"r\") || groups.includes(fsPermissions.group) || privileges.includes(\"FS_BYPASS_PERMISSIONS\"), path, token || processToken);\n\t\t\t\t},\n\t\t\t\tfs_ls: async function(arg) {\n\t\t\t\t\tlet {path, token} = arg;\n\t\t\t\t\tif (!privileges.includes(\"FS_READ\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn await fs_action(\"ls\",\n\t\t\t\t\t(fsPermissions) =>\n\t\t\t\t\t\tfsPermissions.owner == user ||\n\t\t\t\t\t\tgroups.includes(fsPermissions.group) ||\n\t\t\t\t\t\t(fsPermissions.world.includes(\"r\") &&\n\t\t\t\t\t\tfsPermissions.world.includes(\"x\")) || privileges.includes(\"FS_BYPASS_PERMISSIONS\"), path, token || processToken);\n\t\t\t\t},\n\t\t\t\tfs_write: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"FS_WRITE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet {path, data, token} = arg;\n\t\t\t\t\tlet pathParent = path.split(\"/\").slice(0, -1).join(\"/\");\n\t\t\t\t\tlet basename = path.split(\"/\").slice(-1)[0];\n\t\t\t\t\tlet isCreating = false;\n\t\t\t\t\tlet fsParentPermissions;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!(await modules.fs.ls(pathParent, token || processToken)).includes(basename)) isCreating = true;\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tthrow new Error(\"CREATION_CHECK_FAILED\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfsParentPermissions = await modules.fs.permissions(pathParent, token || processToken);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tthrow new Error(\"PERMISSION_CHECKING_FAILED\");\n\t\t\t\t\t}\n\t\t\t\t\tif (!fsParentPermissions.world.includes(\"w\") && fsParentPermissions.owner != user && !groups.includes(fsParentPermissions.group) && !privileges.includes(\"FS_BYPASS_PERMISSIONS\")) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\t\n\t\t\t\t\tif (isCreating) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait modules.fs.chown(path, user, token || processToken);\n\t\t\t\t\t\t\tawait modules.fs.chgrp(path, groups[0], token || processToken);\n\t\t\t\t\t\t\tawait modules.fs.chmod(path, \"r\", token || processToken);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tif (e.name == \"Error\") throw e;\n\t\t\t\t\t\t\tthrow new Error(\"PERMISSION_CHANGE_FAILED\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn await fs_action(\"write\", (fsPermissions) => fsPermissions.owner == user || groups.includes(fsPermissions.group) || fsPermissions.world.includes(\"w\") || privileges.includes(\"FS_BYPASS_PERMISSIONS\"), path, data, token || processToken);\n\t\t\t\t},\n\t\t\t\tfs_rm: async function(arg) {\n\t\t\t\t\tlet {path, token} = arg;\n\t\t\t\t\tif (!privileges.includes(\"FS_REMOVE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn await fs_action(\"rm\", (fsPermissions) => fsPermissions.owner == user || privileges.includes(\"FS_BYPASS_PERMISSIONS\"), path, token);\n\t\t\t\t},\n\t\t\t\tfs_mkdir: async function(arg) {\n\t\t\t\t\tlet {path, token} = arg;\n\t\t\t\t\tif (!privileges.includes(\"FS_WRITE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet pathParent = path.split(\"/\").slice(0, -1).join(\"/\");\n\t\t\t\t\tlet fsPermissions;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfsPermissions = await modules.fs.permissions(pathParent, token || processToken);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tthrow new Error(\"PERMISSION_CHECKING_FAILED\");\n\t\t\t\t\t}\n\t\t\t\t\tif (!fsPermissions.world.includes(\"w\") && fsPermissions.owner != user && !groups.includes(fsPermissions.group) && !privileges.includes(\"FS_BYPASS_PERMISSIONS\")) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait modules.fs.chown(path, user, token || processToken);\n\t\t\t\t\t\tawait modules.fs.chgrp(path, groups[0] || user, token || processToken);\n\t\t\t\t\t\tawait modules.fs.chmod(path, \"rx\", token || processToken);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (e.name == \"Error\") throw e;\n\t\t\t\t\t\tthrow new Error(\"PERMISSION_CHANGE_FAILED\");\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn await modules.fs.mkdir(path, token || processToken);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (e.name == \"Error\") throw e;\n\t\t\t\t\t\tthrow new Error(\"FS_ACTION_FAILED\");\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfs_chown: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"FS_CHANGE_PERMISSION\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet {path, newUser, token} = arg;\n\t\t\t\t\treturn await fs_action(\"chown\", (fsPermissions) => fsPermissions.owner == user || privileges.includes(\"FS_BYPASS_PERMISSIONS\"), path, newUser, token || processToken);\n\t\t\t\t},\n\t\t\t\tfs_chgrp: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"FS_CHANGE_PERMISSION\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet {path, newGrp, token} = arg;\n\t\t\t\t\treturn await fs_action(\"chgrp\", (fsPermissions) => fsPermissions.owner == user || privileges.includes(\"FS_BYPASS_PERMISSIONS\"), path, newGrp, token || processToken);\n\t\t\t\t},\n\t\t\t\tfs_chmod: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"FS_CHANGE_PERMISSION\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet {path, newPermissions, token} = arg;\n\t\t\t\t\treturn await fs_action(\"chmod\", (fsPermissions) => fsPermissions.owner == user || privileges.includes(\"FS_BYPASS_PERMISSIONS\"), path, newPermissions, token || processToken);\n\t\t\t\t},\n\t\t\t\tfs_permissions: async function(arg) {\n\t\t\t\t\tlet {path, token} = arg;\n\t\t\t\t\tif (!privileges.includes(\"FS_READ\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet pathParent = path.split(\"/\").slice(0, -1).join(\"/\");\n\t\t\t\t\tif (pathParent != \"\") {\n\t\t\t\t\t\tlet fsPermissions;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tfsPermissions = await modules.fs.permissions(pathParent, token || processToken);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tthrow new Error(\"PERMISSION_CHECKING_FAILED\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!fsPermissions.world.includes(\"r\") && fsPermissions.owner != user && !privileges.includes(\"FS_BYPASS_PERMISSIONS\")) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\t}\n\t\t\t\t\treturn await fs_action(\"permissions\", () => true, path, token || processToken);\n\t\t\t\t},\n\t\t\t\tfs_mounts: async function() {\n\t\t\t\t\tif (!privileges.includes(\"FS_LIST_PARTITIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn await modules.fs.lsmounts();\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (e.name == \"Error\") throw e;\n\t\t\t\t\t\tthrow new Error(\"FS_ACTION_FAILED\");\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfs_sync: async function(arg) {\n\t\t\t\t\tlet {mount, token} = arg;\n\t\t\t\t\tif (!privileges.includes(\"FS_UNMOUNT\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn await modules.fs.sync(mount, token || processToken);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (e.name == \"Error\") throw e;\n\t\t\t\t\t\tthrow new Error(\"FS_ACTION_FAILED\");\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfs_unmount: async function(arg) {\n\t\t\t\t\tlet {mount, token, force} = arg;\n\t\t\t\t\tif (!privileges.includes(\"FS_UNMOUNT\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn await modules.fs.unmount(mount, token || processToken, force);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (e.name == \"Error\") throw e;\n\t\t\t\t\t\tthrow new Error(\"FS_ACTION_FAILED\");\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfs_mountInfo: async function(mount) {\n\t\t\t\t\tif (!privileges.includes(\"FS_LIST_PARTITIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn await modules.fs.mountInfo(mount);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (e.name == \"Error\") throw e;\n\t\t\t\t\t\tthrow new Error(\"FS_ACTION_FAILED\");\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tgetSystemMount: async function() {\n\t\t\t\t\tif (!privileges.includes(\"FS_LIST_PARTITIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.defaultSystem;\n\t\t\t\t},\n\t\t\t\tcreatePipe: async function() {\n\t\t\t\t\tif (!privileges.includes(\"IPC_CREATE_PIPE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet pipe = await modules.ipc.create();\n\t\t\t\t\tmodules.ipc.declareAccess(pipe, {\n\t\t\t\t\t\towner: user,\n\t\t\t\t\t\tgroup: groups[0],\n\t\t\t\t\t\tworld: false\n\t\t\t\t\t});\n\t\t\t\t\tprocessPipes.push(pipe);\n\t\t\t\t\treturn pipe;\n\t\t\t\t},\n\t\t\t\tlistenToPipe: async function(pipe) {\n\t\t\t\t\tif (!privileges.includes(\"IPC_LISTEN_PIPE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet permissions = await modules.ipc.getIPC(pipe);\n\t\t\t\t\tif (permissions.owner != user && !groups.includes(permissions.group) && !permissions.world && !privileges.includes(\"IPC_BYPASS_PERMISSIONS\") && !processPipes.includes(pipe)) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\treturn await modules.ipc.listenFor(pipe);\n\t\t\t\t},\n\t\t\t\tsendToPipe: async function(dataSend) {\n\t\t\t\t\tif (!privileges.includes(\"IPC_SEND_PIPE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet {pipe, data} = dataSend;\n\t\t\t\t\tlet permissions = await modules.ipc.getIPC(pipe);\n\t\t\t\t\tif (permissions.owner != user && !groups.includes(permissions.group) && !permissions.world && !privileges.includes(\"IPC_BYPASS_PERMISSIONS\") && !processPipes.includes(pipe)) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\treturn await modules.ipc.send(pipe, data);\n\t\t\t\t},\n\t\t\t\tclosePipe: async function(pipe) {\n\t\t\t\t\tif (!processPipes.includes(pipe)) throw new Error(\"NOT_OWN_PIPE\");\n\t\t\t\t\tprocessPipes.splice(processPipes.indexOf(pipe), 1);\n\t\t\t\t\treturn delete modules.ipc._ipc[pipe];\n\t\t\t\t},\n\t\t\t\tsetPipePermissions: async function(opts) {\n\t\t\t\t\tif (!privileges.includes(\"IPC_CHANGE_PERMISSION\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet {pipe, newPermissions} = opts;\n\t\t\t\t\tlet permissions = await modules.ipc.getIPC(pipe);\n\t\t\t\t\tif (permissions.owner != user && !groups.includes(permissions.group) && !permissions.world && !privileges.includes(\"IPC_BYPASS_PERMISSIONS\") && !processPipes.includes(pipe)) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\treturn await modules.ipc.declareAccess(pipe, newPermissions);\n\t\t\t\t},\n\t\t\t\televate: async function(newPrivileges) {\n\t\t\t\t\tnewPrivileges = newPrivileges.filter(privilege => !privileges.includes(privilege));\n\t\t\t\t\tnewPrivileges = Array.from(new Set(newPrivileges));\n\t\t\t\t\tif (!privileges.includes(\"SWITCH_USERS_AUTOMATICALLY\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tprivileges.push(...newPrivileges);\n\t\t\t\t\tawait modules.tokens.addPrivileges(token, newPrivileges);\n\t\t\t\t\tprivileges = await denyUnmanifested(limitations, token);\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tgetVersion: function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_BUILD\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.pcos_version;\n\t\t\t\t},\n\t\t\t\tlocale: function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_LOCALE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn language || navigator.languages[0].split(\"-\")[0].toLowerCase();\n\t\t\t\t},\n\t\t\t\tosLocale: function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_LOCALE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.locales.get(\"OS_LOCALE\", language);\n\t\t\t\t},\n\t\t\t\tgetUserInfo: async function(arg) {\n\t\t\t\t\tlet {desiredUser, token, sensitive} = arg;\n\t\t\t\t\tif (!privileges.includes(\"GET_USER_INFO\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (desiredUser != user && !privileges.includes(\"USER_INFO_OTHERS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (sensitive && desiredUser != user && !privileges.includes(\"SENSITIVE_USER_INFO_OTHERS\")) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\treturn await modules.users.getUserInfo(desiredUser, sensitive, token || processToken);\n\t\t\t\t},\n\t\t\t\tsetUserInfo: async function(arg) {\n\t\t\t\t\tlet {desiredUser, token, info} = arg;\n\t\t\t\t\tif (!privileges.includes(\"SET_USER_INFO\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn await modules.users.moduser(desiredUser, info, token || processToken);\n\t\t\t\t},\n\t\t\t\tsetOwnSecurityChecks: async function(arg) {\n\t\t\t\t\tlet {token, checks} = arg;\n\t\t\t\t\tif (!privileges.includes(\"SET_SECURITY_CHECKS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet allowedTypes = [ \"pbkdf2\", \"informative\", \"informative_deny\", \"timeout\", \"timeout_deny\", \"serverReport\", \"pc-totp\", \"totp\", \"workingHours\", \"zkpp\" ];\n\t\t\t\t\tlet sanitizedChecks = [];\n\t\t\t\t\tchecks.filter(a => allowedTypes.includes(a.type));\n\t\t\t\t\tfor (let checkIndex in checks) {\n\t\t\t\t\t\tlet check = checks[checkIndex];\n\t\t\t\t\t\tif (check.type == \"pbkdf2\") {\n\t\t\t\t\t\t\tif (!check.salt || !check.hash) continue;\n\t\t\t\t\t\t\tcheck = { type: \"pbkdf2\", salt: check.salt, hash: check.hash };\n\t\t\t\t\t\t} else if (check.type == \"informative\" || check.type == \"informative_deny\") {\n\t\t\t\t\t\t\tif (!check.message) continue;\n\t\t\t\t\t\t\tcheck = { type: check.type, message: check.message };\n\t\t\t\t\t\t} else if (check.type == \"timeout\" || check.type == \"timeout_deny\") {\n\t\t\t\t\t\t\tif (!check.timeout) continue;\n\t\t\t\t\t\t\tcheck = { type: check.type, timeout: check.timeout };\n\t\t\t\t\t\t} else if (check.type == \"serverReport\") {\n\t\t\t\t\t\t\tif (!check.url) continue;\n\t\t\t\t\t\t\tcheck = { type: \"serverReport\", url: check.url };\n\t\t\t\t\t\t} else if (check.type == \"pc-totp\" || check.type == \"totp\") {\n\t\t\t\t\t\t\tif (!check.secret) continue;\n\t\t\t\t\t\t\tcheck = { type: check.type, secret: check.secret };\n\t\t\t\t\t\t} else if (check.type == \"workingHours\") {\n\t\t\t\t\t\t\tif (!check.start || !check.end) continue;\n\t\t\t\t\t\t\tif (typeof check.start.hours !== \"number\" || typeof check.start.minutes !== \"number\" || typeof check.start.seconds !== \"number\") continue;\n\t\t\t\t\t\t\tif (typeof check.end.hours !== \"number\" || typeof check.end.minutes !== \"number\" || typeof check.end.seconds !== \"number\") continue;\n\t\t\t\t\t\t\tcheck = {\n\t\t\t\t\t\t\t\ttype: \"workingHours\",\n\t\t\t\t\t\t\t\tstart: {\n\t\t\t\t\t\t\t\t\thours: check.start.hours,\n\t\t\t\t\t\t\t\t\tminutes: check.start.minutes,\n\t\t\t\t\t\t\t\t\tseconds: check.start.seconds\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tend: {\n\t\t\t\t\t\t\t\t\thours: check.end.hours,\n\t\t\t\t\t\t\t\t\tminutes: check.end.minutes,\n\t\t\t\t\t\t\t\t\tseconds: check.end.seconds\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else if (check.type == \"zkpp\") {\n\t\t\t\t\t\t\tif (!check.publicKey) continue;\n\t\t\t\t\t\t\tcheck = { type: \"zkpp\", publicKey: check.publicKey };\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsanitizedChecks.push(check);\n\t\t\t\t\t}\n\t\t\t\t\tlet previousUserInfo = await modules.users.getUserInfo(user, false, token || processToken);\n\t\t\t\t\tawait modules.users.moduser(user, { ...previousUserInfo, securityChecks: sanitizedChecks }, token || processToken);\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tgetNewToken: async function(desiredUser) {\n\t\t\t\t\tif (!privileges.includes(\"ELEVATE_PRIVILEGES\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (modules.session.attrib(ses, \"secureLock\")) await modules.session.attrib(ses, \"secureLock\");\n\t\t\t\t\tif (modules.session.active != ses) throw new Error(\"TRY_AGAIN_LATER\");\n\t\t\t\t\tlet releaseLock;\n\t\t\t\t\tlet lock = new Promise((resolve) => releaseLock = resolve);\n\t\t\t\t\tmodules.session.attrib(ses, \"secureLock\", lock);\n\t\t\t\t\tlet secureSession = await modules.session.mksession();\n\t\t\t\t\tmodules.session.attrib(ses, \"secureID\", secureSession);\n\t\t\t\t\tmodules.session.attrib(secureSession, \"language\", language);\n\n\t\t\t\t\tlet dom = modules.session.tracker[secureSession].html;\n\t\t\t\t\tlet ogDom = modules.session.tracker[ses].html;\n\t\t\t\t\tlet bgfx = document.createElement(\"div\");\n\t\t\t\t\tbgfx.classList.add(\"session\", \"secure\");\n\t\t\t\t\tdom.appendChild(bgfx);\n\t\t\t\t\tmodules.session.attrib(secureSession, \"dark\", modules.session.attrib(ses, \"dark\"));\n\t\t\t\t\tdom.style.background = ogDom.style.background;\n\t\t\t\t\tdom.style.backgroundSize = \"100% 100%\";\n\n\t\t\t\t\tmodules.session.muteAllSessions();\n\t\t\t\t\tmodules.session.activateSession(secureSession);\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet logonUI = await modules.authui(secureSession, desiredUser);\n\t\t\t\t\t\treturn new Promise(function(resolve) {\n\t\t\t\t\t\t\tlogonUI.hook(async function(result) {\n\t\t\t\t\t\t\t\treleaseLock();\n\t\t\t\t\t\t\t\tmodules.session.attrib(ses, \"secureLock\", null);\n\t\t\t\t\t\t\t\tmodules.session.attrib(ses, \"secureID\", null);\n\t\t\t\t\t\t\t\tmodules.session.muteAllSessions();\n\t\t\t\t\t\t\t\tmodules.session.rmsession(secureSession);\n\t\t\t\t\t\t\t\tmodules.session.activateSession(ses);\n\t\t\t\t\t\t\t\tif (result.success == false) return resolve(false);\n\t\t\t\t\t\t\t\treturn resolve(result.token);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tconsole.error(\"authui:\", e);\n\t\t\t\t\t\treleaseLock();\n\t\t\t\t\t\tmodules.session.attrib(ses, \"secureLock\", null);\n\t\t\t\t\t\tmodules.session.attrib(ses, \"secureID\", null);\n\t\t\t\t\t\tmodules.session.muteAllSessions();\n\t\t\t\t\t\tmodules.session.rmsession(secureSession);\n\t\t\t\t\t\tmodules.session.activateSession(ses);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tgetProcessToken: () => processToken,\n\t\t\t\tsetProcessToken: async function(desiredToken) {\n\t\t\t\t\tif (!privileges.includes(\"ELEVATE_PRIVILEGES\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet validation = await modules.tokens.validate(desiredToken, {});\n\t\t\t\t\tif (!validation) throw new Error(\"INVALID_TOKEN\");\n\t\t\t\t\ttoken = processToken = desiredToken;\n\t\t\t\t\tlet tokenInfo = await modules.tokens.info(token);\n\t\t\t\t\tuser = tokenInfo.user;\n\t\t\t\t\tgroups = tokenInfo.groups || [];\n\t\t\t\t\tprivileges = tokenInfo.privileges;\n\t\t\t\t\tprivileges = await denyUnmanifested(limitations, token);\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\trevokeToken: function(dt) {\n\t\t\t\t\tif (!privileges.includes(\"MANAGE_TOKENS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.tokens.revoke(dt || processToken);\n\t\t\t\t},\n\t\t\t\tforkToken: function(dt) {\n\t\t\t\t\tif (!privileges.includes(\"MANAGE_TOKENS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.tokens.fork(dt || processToken);\n\t\t\t\t},\n\t\t\t\tremoveTokenPrivilege: async function(arg) {\n\t\t\t\t\tlet {token, privilege} = arg;\n\t\t\t\t\tif (!privileges.includes(\"MANAGE_TOKENS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tawait modules.tokens.removePrivilege(token, privilege);\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\tremoveTokenPrivileges: async function(arg) {\n\t\t\t\t\tlet {token} = arg;\n\t\t\t\t\tif (!privileges.includes(\"MANAGE_TOKENS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tawait modules.tokens.removePrivileges(token, arg.privileges);\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\testimateStorage: async function() {\n\t\t\t\t\tif (!privileges.includes(\"FS_LIST_PARTITIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet estimate = await navigator.storage.estimate();\n\t\t\t\t\treturn {\n\t\t\t\t\t\tinternal: {\n\t\t\t\t\t\t\tused: estimate.usage,\n\t\t\t\t\t\t\tfree: estimate.quota - estimate.usage,\n\t\t\t\t\t\t\ttotal: estimate.quota\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\tstartTask: async function(arg) {\n\t\t\t\t\tlet {file, argPassed, token, runInBackground, silent, privateData} = arg;\n\t\t\t\t\tif (!privileges.includes(\"START_TASK\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (runInBackground && !privileges.includes(\"START_BACKGROUND_TASK\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!token) token = await modules.tokens.fork(processToken);\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn await modules.tasks.exec(file, argPassed, modules.window(runInBackground ? modules.serviceSession : ses), token, silent, privateData);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (e.name == \"Error\") throw e;\n\t\t\t\t\t\tthrow new Error(\"UNABLE_TO_START_TASK\");\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tlistTasks: async function() {\n\t\t\t\t\tif (!privileges.includes(\"LIST_TASKS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.tasks.listPublicTasks();\n\t\t\t\t},\n\t\t\t\ttaskInfo: async function(taskId) {\n\t\t\t\t\tif (!privileges.includes(\"LIST_TASKS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn await modules.tasks.taskInfo(taskId);\n\t\t\t\t},\n\t\t\t\tsignalTask: async function(arg) {\n\t\t\t\t\tlet {taskId, signal} = arg;\n\t\t\t\t\tif (!privileges.includes(\"SIGNAL_TASK\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!privileges.includes(\"TASK_BYPASS_PERMISSIONS\")) {\n\t\t\t\t\t\tlet taskInfo = await modules.tasks.taskInfo(taskId);\n\t\t\t\t\t\tif (taskInfo.runBy != user) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\t}\n\t\t\t\t\treturn await modules.tasks.sendSignal(taskId, signal);\n\t\t\t\t},\n\t\t\t\tlookupLocale: function(key) {   \n\t\t\t\t\tif (!privileges.includes(\"GET_LOCALE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.locales.get(key, language);\n\t\t\t\t},\n\t\t\t\tlookupOtherLocale: function(arg) {\n\t\t\t\t\tlet {key, locale} = arg;   \n\t\t\t\t\tif (!privileges.includes(\"GET_LOCALE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.locales.get(key, locale);\n\t\t\t\t},\n\t\t\t\tufTimeInc: function(args) {\n\t\t\t\t\tif (!privileges.includes(\"GET_LOCALE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.userfriendliness.inconsiderateTime(language, ...args);\n\t\t\t\t},\n\t\t\t\tufInfoUnits: function(args) {\n\t\t\t\t\tif (!privileges.includes(\"GET_LOCALE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.userfriendliness.informationUnits(language, ...args)\n\t\t\t\t},\n\t\t\t\tisDarkThemed: function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_THEME\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.session.attrib(ses, \"dark\")\n\t\t\t\t},\n\t\t\t\tfetchSend: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"FETCH_SEND\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet {url, init} = arg;\n\t\t\t\t\tlet fetc = await fetch(url, init);\n\t\t\t\t\tlet responseAB;\n\t\t\t\t\tif (init.mode != \"no-cors\" && !init.noArrayBuffer) responseAB = await fetc.arrayBuffer();\n\t\t\t\t\treturn {\n\t\t\t\t\t\tstatus: fetc.status,\n\t\t\t\t\t\tstatusText: fetc.statusText,\n\t\t\t\t\t\tok: fetc.ok,\n\t\t\t\t\t\tredirected: fetc.redirected,\n\t\t\t\t\t\ttype: fetc.type,\n\t\t\t\t\t\turl: fetc.url,\n\t\t\t\t\t\theaders: Object.fromEntries(Array.from(fetc.headers)),\n\t\t\t\t\t\tarrayBuffer: responseAB,\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\tswitchUserWithSetup: async function(desiredUser) {\n\t\t\t\t\tif (!privileges.includes(\"SWITCH_USERS_AUTOMATICALLY\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tawait modules.tokens.userInitialize(token, desiredUser);\n\t\t\t\t\tlet tokenInfo = await modules.tokens.info(token);\n\t\t\t\t\tuser = tokenInfo.user;\n\t\t\t\t\tgroups = tokenInfo.groups || [];\n\t\t\t\t\tprivileges = tokenInfo.privileges;\n\t\t\t\t\tprivileges = await denyUnmanifested(limitations, token);\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t\trunKlvlCode: async function(code) {\n\t\t\t\t\tif (!privileges.includes(\"RUN_KLVL_CODE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn eval(code);\n\t\t\t\t},\n\t\t\t\tcspOperation: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"CSP_OPERATIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.csps[arg.cspProvider][arg.operation](arg.cspArgument, taskId);\n\t\t\t\t},\n\t\t\t\tavailableCsps: async function() {\n\t\t\t\t\tif (!privileges.includes(\"CSP_OPERATIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn Object.keys(modules.csps);\n\t\t\t\t},\n\t\t\t\tufTimeCon: function(args) {\n\t\t\t\t\tif (!privileges.includes(\"GET_LOCALE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.userfriendliness.considerateTime(language, ...args);\n\t\t\t\t},\n\t\t\t\twebsocketOpen: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"WEBSOCKETS_OPEN\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet handle = await modules.websocket.getHandle(arg);\n\t\t\t\t\twebsockets.push(handle);\n\t\t\t\t\tmodules.websocket.assertAccess({ handle, newACL: {\n\t\t\t\t\t\towner: user,\n\t\t\t\t\t\tgroup: groups[0],\n\t\t\t\t\t\tworld: false\n\t\t\t\t\t}});\n\t\t\t\t\treturn handle;\n\t\t\t\t},\n\t\t\t\tlistenToWebsocket: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"WEBSOCKETS_LISTEN\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet permissions = modules.websocket.assertAccess({ handle: arg.handle });\n\t\t\t\t\tif (permissions.owner != user && !groups.includes(permissions.group) && !permissions.world && !privileges.includes(\"WEBSOCKET_BYPASS_PERMISSIONS\") && !websockets.includes(arg.handle)) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\treturn await modules.websocket.waitForEvent(arg);\n\t\t\t\t},\n\t\t\t\tsendToWebsocket: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"WEBSOCKETS_SEND\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet permissions = modules.websocket.assertAccess({ handle: arg.handle });\n\t\t\t\t\tif (permissions.owner != user && !groups.includes(permissions.group) && !permissions.world && !privileges.includes(\"WEBSOCKET_BYPASS_PERMISSIONS\") && !websockets.includes(arg.handle)) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\treturn await modules.websocket.send(arg);\n\t\t\t\t},\n\t\t\t\tcloseWebsocket: async function(websocket) {\n\t\t\t\t\tif (!websockets.includes(websocket)) throw new Error(\"NOT_OWN_WEBSOCKET\");\n\t\t\t\t\twebsockets.splice(websockets.indexOf(websocket), 1);\n\t\t\t\t\treturn modules.websocket.close(websocket);\n\t\t\t\t},\n\t\t\t\twebsocketInfo: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"WEBSOCKET_INFO\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet permissions = modules.websocket.assertAccess({ handle: arg.handle });\n\t\t\t\t\tif (permissions.owner != user && !groups.includes(permissions.group) && !permissions.world && !privileges.includes(\"WEBSOCKET_BYPASS_PERMISSIONS\") && !websockets.includes(arg.handle)) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\treturn await modules.websocket.getInfo(arg);\n\t\t\t\t},\n\t\t\t\tsetWebsocketPermissions: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"WEBSOCKET_SET_PERMISSIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet permissions = modules.websocket.assertAccess({ handle: arg.handle });\n\t\t\t\t\tif (permissions.owner != user && !groups.includes(permissions.group) && !permissions.world && !privileges.includes(\"WEBSOCKET_BYPASS_PERMISSIONS\") && !websockets.includes(arg.handle)) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\treturn await modules.websocket.assertAccess(arg);\n\t\t\t\t},\n\t\t\t\tgetPublicSystemID: async function() {\n\t\t\t\t\tif (!privileges.includes(\"IDENTIFY_SYSTEM\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn (modules.core.prefs.read(\"system_id\") || {}).public;\n\t\t\t\t},\n\t\t\t\tgetPrivateSystemID: async function() {\n\t\t\t\t\tif (!privileges.includes(\"IDENTIFY_SYSTEM_SENSITIVE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn (modules.core.prefs.read(\"system_id\") || {}).private;\n\t\t\t\t},\n\t\t\t\ttypeIntoOtherCLI: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"CLI_MODIFICATIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!modules.tasks.tracker.hasOwnProperty(arg.taskId)) throw new Error(\"TASK_NOT_FOUND\");\n\t\t\t\t\tlet bypassWorks = modules.tasks.tracker[arg.taskId].apis.public.getProcessToken() == arg.bypass;\n\t\t\t\t\tif (!bypassWorks) {\n\t\t\t\t\t\tlet taskInfo = await modules.tasks.taskInfo(arg.taskId);\n\t\t\t\t\t\tif (taskInfo.runBy != user && !privileges.includes(\"TASK_BYPASS_PERMISSIONS\")) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\t}\n\t\t\t\t\tif (!modules.tasks.tracker[arg.taskId].cliio) throw new Error(\"NO_CLI_ATTACHED\");\n\t\t\t\t\treturn await modules.tasks.tracker[arg.taskId].cliio.xtermInstance.input(arg.text, arg.human);\n\t\t\t\t},\n\t\t\t\tgetOtherCLIData: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"CLI_MODIFICATIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!modules.tasks.tracker.hasOwnProperty(arg.taskId)) throw new Error(\"TASK_NOT_FOUND\");\n\t\t\t\t\tlet bypassWorks = modules.tasks.tracker[arg.taskId].apis.public.getProcessToken() == arg.bypass;\n\t\t\t\t\tif (!bypassWorks) {\n\t\t\t\t\t\tlet taskInfo = await modules.tasks.taskInfo(arg.taskId);\n\t\t\t\t\t\tif (taskInfo.runBy != user && !privileges.includes(\"TASK_BYPASS_PERMISSIONS\")) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\t}\n\t\t\t\t\tif (!modules.tasks.tracker[arg.taskId].cliio) throw new Error(\"NO_CLI_ATTACHED\");\n\t\t\t\t\treturn await modules.tasks.tracker[arg.taskId].cliio.signup();\n\t\t\t\t},\n\t\t\t\twaitForOtherCLI: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"CLI_MODIFICATIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!modules.tasks.tracker.hasOwnProperty(arg.taskId)) throw new Error(\"TASK_NOT_FOUND\");\n\t\t\t\t\tlet bypassWorks = modules.tasks.tracker[arg.taskId].apis.public.getProcessToken() == arg.bypass;\n\t\t\t\t\tif (!bypassWorks) {\n\t\t\t\t\t\tlet taskInfo = await modules.tasks.taskInfo(arg.taskId);\n\t\t\t\t\t\tif (taskInfo.runBy != user && !privileges.includes(\"TASK_BYPASS_PERMISSIONS\")) throw new Error(\"PERMISSION_DENIED\");\n\t\t\t\t\t}\n\t\t\t\t\tif (modules.tasks.tracker[arg.taskId].cliio) return true;\n\t\t\t\t\treturn await modules.tasks.tracker[arg.taskId].cliio.attachedCLISignUp();\n\t\t\t\t},\n\t\t\t\tlldaRead: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"LLDISK_READ\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.core.disk.partition(arg.partition).getData();\n\t\t\t\t},\n\t\t\t\tlldaWrite: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"LLDISK_WRITE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.core.disk.partition(arg.partition).setData(arg.data);\n\t\t\t\t},\n\t\t\t\tlldaList: async function() {\n\t\t\t\t\tif (!privileges.includes(\"LLDISK_LIST_PARTITIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.core.disk.partitions();\n\t\t\t\t},\n\t\t\t\tlldaInitPartitions: async function() {\n\t\t\t\t\tif (!privileges.includes(\"LLDISK_INIT_PARTITIONS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.core.disk.insertPartitionTable();\n\t\t\t\t},\n\t\t\t\tlldaRemove: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"LLDISK_REMOVE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.core.disk.partition(arg.partition).remove();\n\t\t\t\t},\n\t\t\t\tlldaIDBRead: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"LLDISK_IDB_READ\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.core.idb.readPart(arg.key);\n\t\t\t\t},\n\t\t\t\tlldaIDBWrite: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"LLDISK_IDB_WRITE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tawait modules.core.idb.writePart(arg.key, arg.value);\n\t\t\t\t},\n\t\t\t\tlldaIDBRemove: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"LLDISK_IDB_REMOVE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tawait modules.core.idb.removePart(arg.key);\n\t\t\t\t},\n\t\t\t\tlldaIDBList: async function() {\n\t\t\t\t\tif (!privileges.includes(\"LLDISK_IDB_LIST\")) throw new Error(\"UNAUTHORIZED_ACTION\"); \n\t\t\t\t\treturn modules.core.idb.listParts(); \n\t\t\t\t},\n\t\t\t\tlldaIDBSync: async function() {\n\t\t\t\t\tif (!privileges.includes(\"LLDISK_IDB_SYNC\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tawait modules.core.idb.sync();\n\t\t\t\t},\n\t\t\t\tfs_mount: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"FS_MOUNT\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (modules.fs.mounts[arg.mountpoint]) throw new Error(\"MOUNT_EXISTS\");\n\t\t\t\t\tmodules.fs.mounts[arg.mountpoint] = await modules.mounts[arg.filesystem](arg.filesystemOptions);\n\t\t\t\t},\n\t\t\t\tsupportedFilesystems: async function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_FILESYSTEMS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn Object.keys(modules.mounts);\n\t\t\t\t},\n\t\t\t\tinstalledLocales: async function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_LOCALE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn Object.keys(modules.locales).filter(a => a != \"get\" && a != \"defaultLocale\");\n\t\t\t\t},\n\t\t\t\trunningServer: async function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_SERVER_URL\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn location.origin;\n\t\t\t\t},\n\t\t\t\tfs_isDirectory: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"FS_READ\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet {path, token} = arg;\n\t\t\t\t\treturn await fs_action(\"isDirectory\", (fsPermissions) => fsPermissions.owner == user || fsPermissions.world.includes(\"r\") || groups.includes(fsPermissions.group) || privileges.includes(\"FS_BYPASS_PERMISSIONS\"), path, token || processToken);\n\t\t\t\t},\n\t\t\t\tautomatedLogonCreate: async function(arg) {\n\t\t\t\t\tlet { desiredUser, token } = arg;\n\t\t\t\t\tif (!privileges.includes(\"ELEVATE_PRIVILEGES\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet automatedLogon = Array.from(crypto.getRandomValues(new Uint8Array(64))).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet access = await modules.users.access(desiredUser, token || processToken);\n\t\t\t\t\t\taccess = await access.getNextPrompt();\n\t\t\t\t\t\tautomatedLogonSessions[automatedLogon] = access;\n\t\t\t\t\t} catch {\n\t\t\t\t\t\tthrow new Error(\"AUTOMATED_LOGON_CREATE_FAILED\")\n\t\t\t\t\t}\n\t\t\t\t\treturn automatedLogon;\n\t\t\t\t},\n\t\t\t\tautomatedLogonGet: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"ELEVATE_PRIVILEGES\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet sharedObj = { ...automatedLogonSessions[arg] };\n\t\t\t\t\t\tdelete sharedObj.input;\n\t\t\t\t\t\treturn sharedObj;\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tthrow new Error(\"AUTOMATED_LOGON_GET_FAILED\");\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tautomatedLogonInput: async function(arg) {\n\t\t\t\t\tlet { session, input } = arg;\n\t\t\t\t\tif (!privileges.includes(\"ELEVATE_PRIVILEGES\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\tautomatedLogonSessions[session] = await automatedLogonSessions[session].input(input);\n\t\t\t\t\t} catch {\n\t\t\t\t\t\tthrow new Error(\"AUTOMATED_LOGON_INPUT_FAILED\");\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tautomatedLogonDelete: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"ELEVATE_PRIVILEGES\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tdelete automatedLogonSessions[arg];\n\t\t\t\t},\n\t\t\t\tsetSystemMount: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"SET_DEFAULT_SYSTEM\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tmodules.defaultSystem = arg;\n\t\t\t\t},\n\t\t\t\tusedRAM: async function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_SYSTEM_RESOURCES\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet mem = performance.memory;\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttotal: mem.jsHeapSizeLimit,\n\t\t\t\t\t\t\tused: mem.usedJSHeapSize,\n\t\t\t\t\t\t\tfree: mem.jsHeapSizeLimit - mem.usedJSHeapSize\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch {}\n\t\t\t\t\tlet mem = await performance.measureUserAgentSpecificMemory();\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttotal: Infinity,\n\t\t\t\t\t\tused: mem.bytes,\n\t\t\t\t\t\tfree: Infinity\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tcheckBootMode: async function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_BOOT_MODE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.core.bootMode || \"normal\";\n\t\t\t\t},\n\t\t\t\tgetScreenInfo: async function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_SCREEN_INFO\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn {\n\t\t\t\t\t\twidth: document.documentElement.clientWidth,\n\t\t\t\t\t\theight: document.documentElement.clientHeight,\n\t\t\t\t\t\tcolorDepth: screen.colorDepth,\n\t\t\t\t\t\torientation: {\n\t\t\t\t\t\t\ttype: screen.orientation.type,\n\t\t\t\t\t\t\tangle: screen.orientation.angle\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfullWidth: screen.width,\n\t\t\t\t\t\tfullHeight: screen.height,\n\t\t\t\t\t\tavailWidth: screen.availWidth,\n\t\t\t\t\t\tavailHeight: screen.availHeight,\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\twaitTermination: async function(arg) {\n\t\t\t\t\tif (!privileges.includes(\"LIST_TASKS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.tasks.waitTermination(arg);\n\t\t\t\t},\n\t\t\t\tconsentGetToken: async function(params) {\n\t\t\t\t\tif (!privileges.includes(\"ELEVATE_PRIVILEGES\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (modules.session.attrib(ses, \"secureLock\")) await modules.session.attrib(ses, \"secureLock\");\n\t\t\t\t\tif (modules.session.active != ses) throw new Error(\"TRY_AGAIN_LATER\");\n\t\t\t\t\tlet { desiredUser, intent } = params;\n\t\t\t\t\tif (!intent) throw new Error(\"INTENT_REQUIRED\");\n\t\t\t\t\tlet releaseLock;\n\t\t\t\t\tlet lock = new Promise((resolve) => releaseLock = resolve);\n\t\t\t\t\tmodules.session.attrib(ses, \"secureLock\", lock);\n\t\t\t\t\tlet secureSession = await modules.session.mksession();\n\t\t\t\t\tmodules.session.attrib(ses, \"secureID\", secureSession);\n\t\t\t\t\tmodules.session.attrib(secureSession, \"language\", language);\n\n\t\t\t\t\tlet dom = modules.session.tracker[secureSession].html;\n\t\t\t\t\tlet ogDom = modules.session.tracker[ses].html;\n\t\t\t\t\tlet bgfx = document.createElement(\"div\");\n\t\t\t\t\tbgfx.classList.add(\"session\", \"secure\");\n\t\t\t\t\tdom.appendChild(bgfx);\n\t\t\t\t\tmodules.session.attrib(secureSession, \"dark\", modules.session.attrib(ses, \"dark\"));\n\t\t\t\t\tdom.style.background = ogDom.style.background;\n\t\t\t\t\tdom.style.backgroundSize = \"100% 100%\";\n\n\t\t\t\t\tmodules.session.muteAllSessions();\n\t\t\t\t\tmodules.session.activateSession(secureSession);\n\t\t\t\t\tlet task = await modules.tasks.taskInfo(taskId);\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet logonUI = await modules.consentui(secureSession, {\n\t\t\t\t\t\t\tuser: desiredUser,\n\t\t\t\t\t\t\tpath: task.file,\n\t\t\t\t\t\t\targs: task.arg,\n\t\t\t\t\t\t\tintent,\n\t\t\t\t\t\t\tname: params.name\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn new Promise(function(resolve) {\n\t\t\t\t\t\t\tlogonUI.hook(async function(result) {\n\t\t\t\t\t\t\t\treleaseLock();\n\t\t\t\t\t\t\t\tmodules.session.attrib(ses, \"secureLock\", null);\n\t\t\t\t\t\t\t\tmodules.session.attrib(ses, \"secureID\", null);\n\t\t\t\t\t\t\t\tmodules.session.muteAllSessions();\n\t\t\t\t\t\t\t\tmodules.session.rmsession(secureSession);\n\t\t\t\t\t\t\t\tmodules.session.activateSession(ses);\n\t\t\t\t\t\t\t\tif (result.success == false) return resolve(false);\n\t\t\t\t\t\t\t\treturn resolve(result.token);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tconsole.error(\"consentui:\", e);\n\t\t\t\t\t\treleaseLock();\n\t\t\t\t\t\tmodules.session.attrib(ses, \"secureLock\", null);\n\t\t\t\t\t\tmodules.session.attrib(ses, \"secureID\", null);\n\t\t\t\t\t\tmodules.session.muteAllSessions();\n\t\t\t\t\t\tmodules.session.rmsession(secureSession);\n\t\t\t\t\t\tmodules.session.activateSession(ses);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tnetworkPing: async function(address) {\n\t\t\t\t\tif (!privileges.includes(\"PCOS_NETWORK_PING\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet websocketHandle = modules.network.ws;\n\t\t\t\t\tif (!websocketHandle) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\tlet websocket = modules.websocket._handles[websocketHandle].ws;\n\t\t\t\t\tif (websocket.readyState != 1) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\treturn Promise.race([ new Promise(async function(resolve, reject) {\n\t\t\t\t\t\tlet networkListenID = Array.from(crypto.getRandomValues(new Uint8Array(64))).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\t\tlet packetId = Array.from(crypto.getRandomValues(new Uint8Array(32))).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\t\tlet resend = Array.from(crypto.getRandomValues(new Uint8Array(32))).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\t\tfunction eventListener(e) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlet packet = JSON.parse(e.data);\n\t\t\t\t\t\t\t\tif (packet.packetID == packetId && packet.event == \"AddressUnreachable\") {\n\t\t\t\t\t\t\t\t\treject(new Error(\"ADDRESS_UNREACHABLE\"));\n\t\t\t\t\t\t\t\t\tdelete networkListens[networkListenID];\n\t\t\t\t\t\t\t\t\twebsocket.removeEventListener(\"message\", eventListener);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (packet.from == address && packet.data.type == \"pong\" && packet.data.resend == resend) {\n\t\t\t\t\t\t\t\t\tresolve(\"success\");\n\t\t\t\t\t\t\t\t\tdelete networkListens[networkListenID];\n\t\t\t\t\t\t\t\t\twebsocket.removeEventListener(\"message\", eventListener);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnetworkListens[networkListenID] = { ws: websocket, fn: eventListener };\n\t\t\t\t\t\twebsocket.addEventListener(\"message\", eventListener);\n\t\t\t\t\t\twebsocket.send(JSON.stringify({\n\t\t\t\t\t\t\treceiver: address,\n\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\ttype: \"ping\",\n\t\t\t\t\t\t\t\tresend: resend\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tid: packetId\n\t\t\t\t\t\t}))\n\t\t\t\t\t}), new Promise((_, reject) => modules.network.runOnClose.then(_ => reject(new Error(\"NETWORK_CLOSED\")))) ]);\n\t\t\t\t},\n\t\t\t\tlogOut: async function(desiredUser) {\n\t\t\t\t\tif (desiredUser != user && !privileges.includes(\"LOGOUT_OTHERS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (desiredUser == user && !privileges.includes(\"LOGOUT\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (modules.session.active != ses && !privileges.includes(\"LOGOUT_OTHERS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tawait modules.logOut(desiredUser);\n\t\t\t\t},\n\t\t\t\tlock: async function() {\n\t\t\t\t\tif (modules.session.active == ses && !privileges.includes(\"LOGOUT\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (modules.session.active != ses && !privileges.includes(\"LOGOUT_OTHERS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tmodules.session.muteAllSessions();\n\t\t\t\t\tmodules.session.activateSession(modules.session.systemSession);\n\t\t\t\t},\n\t\t\t\tgetPrivateData: () => privateData,\n\t\t\t\tlull: async function() {\n\t\t\t\t\tif (!privileges.includes(\"LULL_SYSTEM\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (modules.session.active != ses && !privileges.includes(\"LULL_SYSTEM_FORCE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tawait modules.lull();\n\t\t\t\t},\n\t\t\t\tconnlessListen: async function(gate) {\n\t\t\t\t\tif (!privileges.includes(\"CONNLESS_LISTEN\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!gate.startsWith(\"user_\") && !privileges.includes(\"CONNLESS_LISTEN_GLOBAL\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet websocketHandle = modules.network.ws;\n\t\t\t\t\tif (!websocketHandle) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\tlet websocket = modules.websocket._handles[websocketHandle].ws;\n\t\t\t\t\tif (websocket.readyState != 1) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\treturn Promise.race([ new Promise(async function(resolve) {\n\t\t\t\t\t\tlet networkListenID = Array.from(crypto.getRandomValues(new Uint8Array(64))).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\t\tfunction eventListener(e) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlet packet = JSON.parse(e.data);\n\t\t\t\t\t\t\t\tif (packet.data.type == \"connectionless\" && packet.data.gate == gate) {\n\t\t\t\t\t\t\t\t\twebsocket.removeEventListener(\"message\", eventListener);\n\t\t\t\t\t\t\t\t\tdelete networkListens[networkListenID];\n\t\t\t\t\t\t\t\t\tresolve(packet);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnetworkListens[networkListenID] = { ws: websocket, fn: eventListener };\n\t\t\t\t\t\twebsocket.addEventListener(\"message\", eventListener);\n\t\t\t\t\t}), new Promise((_, reject) => modules.network.runOnClose.then(_ => reject(new Error(\"NETWORK_CLOSED\")))) ]);\n\t\t\t\t},\n\t\t\t\tconnlessSend: async function(sendOpts) {\n\t\t\t\t\tif (!privileges.includes(\"CONNLESS_SEND\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet websocketHandle = modules.network.ws;\n\t\t\t\t\tif (!websocketHandle) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\tlet websocket = modules.websocket._handles[websocketHandle].ws;\n\t\t\t\t\tif (websocket.readyState != 1) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\tlet { gate, address, content } = sendOpts;\n\t\t\t\t\tlet packetId = Array.from(crypto.getRandomValues(new Uint8Array(32))).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\twebsocket.send(JSON.stringify({\n\t\t\t\t\t\treceiver: address,\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\ttype: \"connectionless\",\n\t\t\t\t\t\t\tgate: gate,\n\t\t\t\t\t\t\tcontent: content\n\t\t\t\t\t\t},\n\t\t\t\t\t\tid: packetId\n\t\t\t\t\t}));\n\t\t\t\t\treturn Promise.race([ new Promise(async function(resolve, reject) {\n\t\t\t\t\t\tlet networkListenID = Array.from(crypto.getRandomValues(new Uint8Array(64))).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\t\tfunction eventListener(e) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlet packet = JSON.parse(e.data);\n\t\t\t\t\t\t\t\tif (packet.from) return;\n\t\t\t\t\t\t\t\tif (packet.packetID == packetId) {\n\t\t\t\t\t\t\t\t\twebsocket.removeEventListener(\"message\", eventListener);\n\t\t\t\t\t\t\t\t\tdelete networkListens[networkListenID];\n\t\t\t\t\t\t\t\t\tif (packet.event == \"PacketPong\") return resolve(\"success\");\n\t\t\t\t\t\t\t\t\treject(new Error(\"ADDRESS_UNREACHABLE\"));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnetworkListens[networkListenID] = { ws: websocket, fn: eventListener };\n\t\t\t\t\t\twebsocket.addEventListener(\"message\", eventListener);\n\t\t\t\t\t}), new Promise((_, reject) => modules.network.runOnClose.then(_ => reject(new Error(\"NETWORK_CLOSED\")))) ]);\n\t\t\t\t},\n\t\t\t\tgetUsers: async function(token) {\n\t\t\t\t\tif (!privileges.includes(\"GET_USER_LIST\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn await modules.users.getUsers(token || processToken);\n\t\t\t\t},\n\t\t\t\tgetNetworkAddress: async function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_NETWORK_ADDRESS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.network.address;\n\t\t\t\t},\n\t\t\t\tconnfulListen: async function(listenOpts) {\n\t\t\t\t\tif (!privileges.includes(\"CONNFUL_LISTEN\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet {gate, key, private, verifyClientKeyChain} = listenOpts;\n\t\t\t\t\tif (!gate.startsWith(\"user_\") && !privileges.includes(\"CONNFUL_LISTEN_GLOBAL\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet websocketHandle = modules.network.ws;\n\t\t\t\t\tif (!websocketHandle) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\tlet websocket = modules.websocket._handles[websocketHandle].ws;\n\t\t\t\t\tif (websocket.readyState != 1) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\tlet networkListenID = Array.from(crypto.getRandomValues(new Uint8Array(64))).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\tlet usableKey = await crypto.subtle.importKey(\"jwk\", private, {name: \"ECDSA\", namedCurve: \"P-256\"}, true, [\"sign\"]);\n\t\t\t\t\tlet hexToU8A = (hex) => Uint8Array.from(hex.match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\t\t\tlet u8aToHex = (u8a) => Array.from(u8a).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\tlet _connectionBufferPromise = null;\n\t\t\t\t\tlet _connectionBufferReject = null;\n\t\t\t\t\tlet connectionBufferPromise = new Promise((r, j) => [_connectionBufferPromise, _connectionBufferReject] = [r, j]);\n\t\t\t\t\tasync function eventListener(e) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlet packet = JSON.parse(e.data);\n\t\t\t\t\t\t\tif (!packet.from) return;\n\t\t\t\t\t\t\tif (packet.data.type == \"connectionful\" && packet.data.gate == gate && packet.data.action == \"start\") {\n\t\t\t\t\t\t\t\tif (!packet.data.connectionID) return;\n\t\t\t\t\t\t\t\tif (connections[packet.data.connectionID + \":server\"]) return;\n\t\t\t\t\t\t\t\tlet ephemeralKey = await crypto.subtle.generateKey({name: \"ECDH\", namedCurve: \"P-256\"}, true, [\"deriveBits\"]);\n\t\t\t\t\t\t\t\tlet exported = await crypto.subtle.exportKey(\"jwk\", ephemeralKey.publicKey);\n\t\t\t\t\t\t\t\texported = {signedBy: \"serverKey\", usages: [\"connfulSecureEphemeral\"], key:exported};\n\t\t\t\t\t\t\t\tlet signature = u8aToHex(new Uint8Array(await crypto.subtle.sign({\n\t\t\t\t\t\t\t\t\tname: \"ECDSA\",\n\t\t\t\t\t\t\t\t\thash: \"SHA-256\"\n\t\t\t\t\t\t\t\t}, usableKey, new TextEncoder().encode(JSON.stringify(exported)))));\n\t\t\t\t\t\t\t\tlet theirUsableKey = await crypto.subtle.importKey(\"jwk\", packet.data.content.keyInfo.key, {\n\t\t\t\t\t\t\t\t\tname: \"ECDH\",\n\t\t\t\t\t\t\t\t\tnamedCurve: \"P-256\"\n\t\t\t\t\t\t\t\t}, true, []);\n\t\t\t\t\t\t\t\tlet joinedKeys = await crypto.subtle.deriveBits({ name: \"ECDH\", public: theirUsableKey }, ephemeralKey.privateKey, 256);\n\t\t\t\t\t\t\t\tlet aesUsableKey = await crypto.subtle.importKey(\"raw\", joinedKeys, {name: \"AES-GCM\"}, true, [\"encrypt\", \"decrypt\"]);\n\t\t\t\t\t\t\t\tlet _dataBufferPromise = null, _rejectDataPromise = null;\n\t\t\t\t\t\t\t\tlet dataBufferPromise = new Promise((r, j) => [_dataBufferPromise, _rejectDataPromise] = [r, j]);\n\t\t\t\t\t\t\t\tconnections[packet.data.connectionID + \":server\"] = {\n\t\t\t\t\t\t\t\t\tourKey: ephemeralKey,\n\t\t\t\t\t\t\t\t\tfrom: packet.from,\n\t\t\t\t\t\t\t\t\ttheirMainKeyReceived: false,\n\t\t\t\t\t\t\t\t\ttheirKeyRaw: packet.data.content,\n\t\t\t\t\t\t\t\t\taesUsableKey,\n\t\t\t\t\t\t\t\t\tdataBuffer: [],\n\t\t\t\t\t\t\t\t\tdataBufferPromise,\n\t\t\t\t\t\t\t\t\t_dataBufferPromise,\n\t\t\t\t\t\t\t\t\t_rejectDataPromise,\n\t\t\t\t\t\t\t\t\tnetworkListenID\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\twebsocket.send(JSON.stringify({\n\t\t\t\t\t\t\t\t\treceiver: packet.from,\n\t\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\t\ttype: \"connectionful\",\n\t\t\t\t\t\t\t\t\t\taction: \"start\",\n\t\t\t\t\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\t\t\t\tkeyInfo: exported,\n\t\t\t\t\t\t\t\t\t\t\tsignature\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tconnectionID: packet.data.connectionID\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\t} else if (packet.data.type == \"connectionful\" && packet.data.gate == gate && packet.data.action == \"xchange\") {\n\t\t\t\t\t\t\t\tif (!packet.data.connectionID) return;\n\t\t\t\t\t\t\t\tif (!connections.hasOwnProperty(packet.data.connectionID + \":server\")) return;\n\t\t\t\t\t\t\t\tif (connections[packet.data.connectionID + \":server\"].theirMainKeyReceived) return;\n\t\t\t\t\t\t\t\tif (connections[packet.data.connectionID + \":server\"].dying) return;\n\t\t\t\t\t\t\t\tlet theirMainKeyDecrypt = JSON.parse(new TextDecoder().decode(await crypto.subtle.decrypt({\n\t\t\t\t\t\t\t\t\tname: \"AES-GCM\",\n\t\t\t\t\t\t\t\t\tiv: hexToU8A(packet.data.content.iv),\n\t\t\t\t\t\t\t\t}, connections[packet.data.connectionID + \":server\"].aesUsableKey, hexToU8A(packet.data.content.ct))));\n\t\t\t\t\t\t\t\tlet usableMainKey = await crypto.subtle.importKey(\"jwk\", theirMainKeyDecrypt.keyInfo.key, {\n\t\t\t\t\t\t\t\t\tname: \"ECDSA\",\n\t\t\t\t\t\t\t\t\tnamedCurve: \"P-256\"\n\t\t\t\t\t\t\t\t}, true, [\"verify\"]);\n\t\t\t\t\t\t\t\tlet verifyKeySignature = await crypto.subtle.verify({\n\t\t\t\t\t\t\t\t\tname: \"ECDSA\",\n\t\t\t\t\t\t\t\t\thash: \"SHA-256\"\n\t\t\t\t\t\t\t\t}, usableMainKey, hexToU8A(connections[packet.data.connectionID + \":server\"].theirKeyRaw.signature), new TextEncoder().encode(JSON.stringify(connections[packet.data.connectionID + \":server\"].theirKeyRaw.keyInfo)));\n\t\t\t\t\t\t\t\tif (verifyClientKeyChain && verifyKeySignature) {\n\t\t\t\t\t\t\t\t\tverifyKeySignature = false;\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tlet khrlFiles = await modules.fs.ls(modules.defaultSystem + \"/etc/keys/khrl\", processToken);\n\t\t\t\t\t\t\t\t\t\tlet khrlSignatures = [];\n\t\t\t\t\t\t\t\t\t\tfor (let khrlFile of khrlFiles) {\n\t\t\t\t\t\t\t\t\t\t\tlet khrl = JSON.parse(await modules.fs.read(modules.defaultSystem + \"/etc/keys/khrl/\" + khrlFile, processToken));\n\t\t\t\t\t\t\t\t\t\t\tlet khrlSignature = khrl.signature;\n\t\t\t\t\t\t\t\t\t\t\tdelete khrl.signature;\n\t\t\t\t\t\t\t\t\t\t\tif (await crypto.subtle.verify({\n\t\t\t\t\t\t\t\t\t\t\t\tname: \"ECDSA\",\n\t\t\t\t\t\t\t\t\t\t\t\thash: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tname: \"SHA-256\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}, modules.ksk_imported, hexToU8A(khrlSignature), new TextEncoder().encode(JSON.stringify(khrl.list)))) {\n\t\t\t\t\t\t\t\t\t\t\t\tkhrlSignatures.push(...khrl.list);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tverifyKeySignature = await recursiveKeyVerify(theirMainKeyDecrypt, khrlSignatures);\n\t\t\t\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!verifyKeySignature || !theirMainKeyDecrypt.keyInfo.usages.includes(\"connfulSecureClient:\" + packet.from)) {\n\t\t\t\t\t\t\t\t\tdelete connections[packet.data.connectionID + \":server\"];\n\t\t\t\t\t\t\t\t\twebsocket.send(JSON.stringify({\n\t\t\t\t\t\t\t\t\t\treceiver: packet.from,\n\t\t\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"connectionful\",\n\t\t\t\t\t\t\t\t\t\t\taction: \"drop\",\n\t\t\t\t\t\t\t\t\t\t\tconnectionID: packet.data.connectionID\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconnections[packet.data.connectionID + \":server\"].theirMainKeyReceived = theirMainKeyDecrypt;\n\t\t\t\t\t\t\t\tlet iv = crypto.getRandomValues(new Uint8Array(16));\n\t\t\t\t\t\t\t\twebsocket.send(JSON.stringify({\n\t\t\t\t\t\t\t\t\treceiver: packet.from,\n\t\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\t\ttype: \"connectionful\",\n\t\t\t\t\t\t\t\t\t\taction: \"xchange\",\n\t\t\t\t\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\t\t\t\tiv: u8aToHex(iv),\n\t\t\t\t\t\t\t\t\t\t\tct: u8aToHex(new Uint8Array(await crypto.subtle.encrypt({\n\t\t\t\t\t\t\t\t\t\t\t\tname: \"AES-GCM\",\n\t\t\t\t\t\t\t\t\t\t\t\tiv\n\t\t\t\t\t\t\t\t\t\t\t}, connections[packet.data.connectionID + \":server\"].aesUsableKey, new TextEncoder().encode(JSON.stringify(key)))))\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tconnectionID: packet.data.connectionID\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\t} else if (packet.data.type == \"connectionful\" && packet.data.gate == gate && packet.data.action == \"drop\") {\n\t\t\t\t\t\t\t\tif (!packet.data.connectionID) return;\n\t\t\t\t\t\t\t\tif (!connections.hasOwnProperty(packet.data.connectionID + \":server\")) return;\n\t\t\t\t\t\t\t\tif (connections[packet.data.connectionID + \":server\"].dying) return;\n\t\t\t\t\t\t\t\twebsocket.send(JSON.stringify({\n\t\t\t\t\t\t\t\t\treceiver: packet.from,\n\t\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\t\ttype: \"connectionful\",\n\t\t\t\t\t\t\t\t\t\taction: \"drop\",\n\t\t\t\t\t\t\t\t\t\tconnectionID: packet.data.connectionID\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\t\tif (connections[packet.data.connectionID + \":server\"]._rejectDataPromise)\n\t\t\t\t\t\t\t\t\tconnections[packet.data.connectionID + \":server\"]._rejectDataPromise(new Error(\"CONNECTION_DROPPED\"));\n\t\t\t\t\t\t\t\tconnections[packet.data.connectionID + \":server\"].dying = true;\n\t\t\t\t\t\t\t\tif (!connections[packet.data.connectionID + \":server\"].dataBuffer.length)\n\t\t\t\t\t\t\t\t\tdelete connections[packet.data.connectionID + \":server\"];\n\t\t\t\t\t\t\t} else if (packet.data.type == \"connectionful\" && packet.data.gate == gate && packet.data.action == \"nice2meetu\") {\n\t\t\t\t\t\t\t\tif (!packet.data.connectionID) return;\n\t\t\t\t\t\t\t\tif (!connections.hasOwnProperty(packet.data.connectionID + \":server\")) return;\n\t\t\t\t\t\t\t\tif (!connections[packet.data.connectionID + \":server\"].theirMainKeyReceived) return;\n\t\t\t\t\t\t\t\tif (!connections[packet.data.connectionID + \":server\"].aesUsableKey) return;\n\t\t\t\t\t\t\t\tif (connections[packet.data.connectionID + \":server\"].dying) return;\n\t\t\t\t\t\t\t\tnetworkListens[networkListenID].connectionBuffer.push(packet.data.connectionID + \":server\");\n\t\t\t\t\t\t\t\tlet _curcbp = _connectionBufferPromise;\n\t\t\t\t\t\t\t\tconnectionBufferPromise = new Promise((r, j) => [_connectionBufferPromise, _connectionBufferReject] = [r, j]);\n\t\t\t\t\t\t\t\tnetworkListens[networkListenID].connectionBufferPromise = connectionBufferPromise;\n\t\t\t\t\t\t\t\t_curcbp();\n\t\t\t\t\t\t\t} else if (packet.data.type == \"connectionful\" && packet.data.gate == gate && packet.data.action == \"data\") {\n\t\t\t\t\t\t\t\tif (!packet.data.connectionID) return;\n\t\t\t\t\t\t\t\tif (!connections.hasOwnProperty(packet.data.connectionID + \":server\")) return;\n\t\t\t\t\t\t\t\tif (!connections[packet.data.connectionID + \":server\"].aesUsableKey) return;\n\t\t\t\t\t\t\t\tif (!connections[packet.data.connectionID + \":server\"].theirMainKeyReceived) return;\n\t\t\t\t\t\t\t\tif (connections[packet.data.connectionID + \":server\"].dying) return;\n\t\t\t\t\t\t\t\tif (connections[packet.data.connectionID + \":server\"].writingLock) await connections[packet.data.connectionID + \":server\"].writingLock;\n\t\t\t\t\t\t\t\tlet writingLockRelease;\n\t\t\t\t\t\t\t\tlet writingLock = new Promise(r => writingLockRelease = r);\n\t\t\t\t\t\t\t\tconnections[packet.data.connectionID + \":server\"].writingLock = writingLock;\n\t\t\t\t\t\t\t\tconnections[packet.data.connectionID + \":server\"].dataBuffer.push(new TextDecoder().decode(await crypto.subtle.decrypt({\n\t\t\t\t\t\t\t\t\tname: \"AES-GCM\",\n\t\t\t\t\t\t\t\t\tiv: hexToU8A(packet.data.content.iv)\n\t\t\t\t\t\t\t\t}, connections[packet.data.connectionID + \":server\"].aesUsableKey, hexToU8A(packet.data.content.ct))));\n\t\t\t\t\t\t\t\tif (!(connections[connID + \":server\"].dataBuffer.length - 1)) {\n\t\t\t\t\t\t\t\t\tlet _curdbp = connections[packet.data.connectionID + \":server\"].dataBufferPromise;\n\t\t\t\t\t\t\t\t\tlet _dataBufferPromise = null, _rejectDataPromise = null;\n\t\t\t\t\t\t\t\t\tlet dataBufferPromise = new Promise((r, e) => [_dataBufferPromise, _rejectDataPromise] = [r, e]);\n\t\t\t\t\t\t\t\t\tconnections[packet.data.connectionID + \":server\"].dataBufferPromise = dataBufferPromise;\n\t\t\t\t\t\t\t\t\tconnections[packet.data.connectionID + \":server\"]._dataBufferPromise = _dataBufferPromise;\n\t\t\t\t\t\t\t\t\tconnections[packet.data.connectionID + \":server\"]._rejectDataPromise = _rejectDataPromise;\n\t\t\t\t\t\t\t\t\t_curdbp();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twritingLockRelease();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch {}\n\t\t\t\t\t}\n\t\t\t\t\tnetworkListens[networkListenID] = { ws: websocket, gate: gate, fn: eventListener, connectionBuffer: [], connectionBufferPromise }\n\t\t\t\t\tmodules.network.runOnClose.then(function() {\n\t\t\t\t\t\tfor (let connectionID in connections) if (connections[connectionID].networkListenID == networkListenID) {\n\t\t\t\t\t\t\tconnections[connectionID].dying = true;\n\t\t\t\t\t\t\tconnections[connectionID]._rejectDataPromise(new Error(\"NETWORK_CLOSED\"));\n\t\t\t\t\t\t\tif (!connections[connectionID].dataBuffer.length) delete connections[connectionID];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdelete networkListens[networkListenID];\n\t\t\t\t\t\t_connectionBufferReject(new Error(\"NETWORK_CLOSED\"));\n\t\t\t\t\t});\n\t\t\t\t\twebsocket.addEventListener(\"message\", eventListener);\n\t\t\t\t\treturn networkListenID;\n\t\t\t\t},\n\t\t\t\tconnfulListenConnections: async function(networkListenID) {\n\t\t\t\t\tif (!privileges.includes(\"CONNFUL_LISTEN\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!networkListens.hasOwnProperty(networkListenID)) throw new Error(\"INVALID_LISTEN_ID\");\n\t\t\t\t\tif (!networkListens[networkListenID].connectionBuffer.length) await networkListens[networkListenID].connectionBufferPromise;\n\t\t\t\t\tlet connectionID = networkListens[networkListenID].connectionBuffer[0];\n\t\t\t\t\tnetworkListens[networkListenID].connectionBuffer = networkListens[networkListenID].connectionBuffer.slice(1);\n\t\t\t\t\treturn connectionID;\n\t\t\t\t},\n\t\t\t\tgetBuildTime: function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_BUILD\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.build_time;\n\t\t\t\t},\n\t\t\t\tconnfulConnect: async function(connOpts) {\n\t\t\t\t\tif (!privileges.includes(\"CONNFUL_CONNECT\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet {address, gate, key, private, doNotVerifyServer, verifyByDomain} = connOpts;\n\t\t\t\t\tlet websocketHandle = modules.network.ws;\n\t\t\t\t\tif (!websocketHandle) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\tlet websocket = modules.websocket._handles[websocketHandle].ws;\n\t\t\t\t\tif (websocket.readyState != 1) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\tlet networkListenID = Array.from(crypto.getRandomValues(new Uint8Array(64))).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\tlet connID = crypto.getRandomValues(new Uint8Array(64)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\t\tlet hexToU8A = (hex) => Uint8Array.from(hex.match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\t\t\tlet u8aToHex = (u8a) => Array.from(u8a).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\tlet newKeyKA, exportedKA;\n\t\t\t\t\tif (!key && !private) {\n\t\t\t\t\t\tnewKeyKA = await crypto.subtle.generateKey({name: \"ECDSA\", namedCurve: \"P-256\"}, true, [\"sign\", \"verify\"]);\n\t\t\t\t\t\texportedKA = await crypto.subtle.exportKey(\"jwk\", newKeyKA.publicKey);\n\t\t\t\t\t\texportedKA = { keyInfo: { usages: [\"connfulSecureClient:\" + modules.network.address], key: exportedKA }, signature: null };\n\t\t\t\t\t\tnewKeyKA = newKeyKA.privateKey;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewKeyKA = await crypto.subtle.importKey(\"jwk\", private, {name: \"ECDSA\", namedCurve: \"P-256\"}, true, [\"sign\"]);\n\t\t\t\t\t\texportedKA = key;\n\t\t\t\t\t}\n\t\t\t\t\tlet ephemeralKey = await crypto.subtle.generateKey({name: \"ECDH\", namedCurve: \"P-256\"}, true, [\"deriveBits\"]);\n\t\t\t\t\tlet exported = await crypto.subtle.exportKey(\"jwk\", ephemeralKey.publicKey);\n\t\t\t\t\texported = { signedBy: \"clientKey\", usages: [\"connfulSecureEphemeral\"], key: exported };\n\t\t\t\t\tlet signature = u8aToHex(new Uint8Array(await crypto.subtle.sign({\n\t\t\t\t\t\tname: \"ECDSA\",\n\t\t\t\t\t\thash: \"SHA-256\"\n\t\t\t\t\t}, newKeyKA, new TextEncoder().encode(JSON.stringify(exported)))));\n\t\t\t\t\tlet _dataBufferPromise = null;\n\t\t\t\t\tlet _rejectDataPromise = null;\n\t\t\t\t\tlet dataBufferPromise = new Promise((r, e) => [_dataBufferPromise, _rejectDataPromise] = [r, e]);\n\t\t\t\t\tlet _settlePromise = null;\n\t\t\t\t\tlet _rejectPromise = null;\n\t\t\t\t\tlet settlePromise = new Promise((r, e) => [_settlePromise, _rejectPromise] = [r, e]);\n\t\t\t\t\tlet packetID = crypto.getRandomValues(new Uint8Array(32)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\t\tconnections[connID + \":client\"] = {\n\t\t\t\t\t\tourKey: ephemeralKey,\n\t\t\t\t\t\tfrom: address,\n\t\t\t\t\t\ttheirMainKeyReceived: false,\n\t\t\t\t\t\ttheirKeyRaw: null,\n\t\t\t\t\t\taesUsableKey: null,\n\t\t\t\t\t\tnetworkListenID,\n\t\t\t\t\t\tdataBuffer: [],\n\t\t\t\t\t\tdataBufferPromise,\n\t\t\t\t\t\tsettlePromise,\n\t\t\t\t\t\tgateIfNeeded: gate\n\t\t\t\t\t}\n\t\t\t\t\tasync function eventListener(e) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlet packet = JSON.parse(e.data);\n\t\t\t\t\t\t\tif (!packet.from) {\n\t\t\t\t\t\t\t\tif (packet.event == \"AddressUnreachable\" && packet.packetID == packetID)\n\t\t\t\t\t\t\t\t\t_rejectPromise(new Error(\"ADDRESS_UNREACHABLE\"));\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (packet.data.gate) return;\n\t\t\t\t\t\t\tif (packet.data.type == \"connectionful\" && packet.data.connectionID == connID && packet.data.action == \"start\") {\n\t\t\t\t\t\t\t\tif (connections[connID + \":client\"].aesUsableKey) return;\n\t\t\t\t\t\t\t\tlet theirUsableKey = await crypto.subtle.importKey(\"jwk\", packet.data.content.keyInfo.key, {\n\t\t\t\t\t\t\t\t\tname: \"ECDH\",\n\t\t\t\t\t\t\t\t\tnamedCurve: \"P-256\"\n\t\t\t\t\t\t\t\t}, true, []);\n\t\t\t\t\t\t\t\tlet joinedKeys = await crypto.subtle.deriveBits({\n\t\t\t\t\t\t\t\t\tname: \"ECDH\",\n\t\t\t\t\t\t\t\t\tpublic: theirUsableKey\n\t\t\t\t\t\t\t\t}, ephemeralKey.privateKey, 256);\n\t\t\t\t\t\t\t\tlet aesUsableKey = await crypto.subtle.importKey(\"raw\", joinedKeys, {\n\t\t\t\t\t\t\t\t\tname: \"AES-GCM\"\n\t\t\t\t\t\t\t\t}, true, [\"encrypt\", \"decrypt\"]);\n\t\t\t\t\t\t\t\tconnections[connID + \":client\"].aesUsableKey = aesUsableKey;\n\t\t\t\t\t\t\t\tconnections[connID + \":client\"].theirKeyRaw = packet.data.content;\n\t\t\t\t\t\t\t\tlet iv = crypto.getRandomValues(new Uint8Array(16));\n\t\t\t\t\t\t\t\twebsocket.send(JSON.stringify({\n\t\t\t\t\t\t\t\t\treceiver: address,\n\t\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\t\ttype: \"connectionful\",\n\t\t\t\t\t\t\t\t\t\taction: \"xchange\",\n\t\t\t\t\t\t\t\t\t\tconnectionID: connID,\n\t\t\t\t\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\t\t\t\tiv: u8aToHex(iv),\n\t\t\t\t\t\t\t\t\t\t\tct: u8aToHex(new Uint8Array(await crypto.subtle.encrypt({\n\t\t\t\t\t\t\t\t\t\t\t\tname: \"AES-GCM\",\n\t\t\t\t\t\t\t\t\t\t\t\tiv\n\t\t\t\t\t\t\t\t\t\t\t}, aesUsableKey, new TextEncoder().encode(JSON.stringify(exportedKA)))))\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tgate\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\t} else if (packet.data.type == \"connectionful\" && packet.data.connectionID == connID && packet.data.action == \"xchange\") {\n\t\t\t\t\t\t\t\tif (connections[connID + \":client\"].theirMainKeyReceived) return;\n\t\t\t\t\t\t\t\tlet theirMainKeyDecrypt = JSON.parse(new TextDecoder().decode(await crypto.subtle.decrypt({\n\t\t\t\t\t\t\t\t\tname: \"AES-GCM\",\n\t\t\t\t\t\t\t\t\tiv: hexToU8A(packet.data.content.iv)\n\t\t\t\t\t\t\t\t}, connections[connID + \":client\"].aesUsableKey, hexToU8A(packet.data.content.ct))));\n\t\t\t\t\t\t\t\tlet usableMainKey = await crypto.subtle.importKey(\"jwk\", theirMainKeyDecrypt.keyInfo.key, {name: \"ECDSA\", namedCurve: \"P-256\"}, true, [\"verify\"]);\n\t\t\t\t\t\t\t\tlet verifyKeySignature = await crypto.subtle.verify({\n\t\t\t\t\t\t\t\t\tname: \"ECDSA\",\n\t\t\t\t\t\t\t\t\thash: \"SHA-256\"\n\t\t\t\t\t\t\t\t}, usableMainKey, hexToU8A(connections[connID + \":client\"].theirKeyRaw.signature), new TextEncoder().encode(JSON.stringify(connections[connID + \":client\"].theirKeyRaw.keyInfo)));\n\t\t\t\t\t\t\t\tif (!doNotVerifyServer && verifyKeySignature) {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tlet khrlFiles = await modules.fs.ls(modules.defaultSystem + \"/etc/keys/khrl\", processToken);\n\t\t\t\t\t\t\t\t\t\tlet khrlSignatures = [];\n\t\t\t\t\t\t\t\t\t\tfor (let khrlFile of khrlFiles) {\n\t\t\t\t\t\t\t\t\t\t\tlet khrl = JSON.parse(await modules.fs.read(modules.defaultSystem + \"/etc/keys/khrl/\" + khrlFile, processToken));\n\t\t\t\t\t\t\t\t\t\t\tlet khrlSignature = khrl.signature;\n\t\t\t\t\t\t\t\t\t\t\tdelete khrl.signature;\n\t\t\t\t\t\t\t\t\t\t\tif (await crypto.subtle.verify({\n\t\t\t\t\t\t\t\t\t\t\t\tname: \"ECDSA\",\n\t\t\t\t\t\t\t\t\t\t\t\thash: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tname: \"SHA-256\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}, modules.ksk_imported, hexToU8A(khrlSignature), new TextEncoder().encode(JSON.stringify(khrl.list)))) {\n\t\t\t\t\t\t\t\t\t\t\t\tkhrlSignatures.push(...khrl.list);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tverifyKeySignature = await recursiveKeyVerify(theirMainKeyDecrypt, khrlSignatures);\n\t\t\t\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t\t\t\tverifyKeySignature = false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!verifyKeySignature || (!theirMainKeyDecrypt.keyInfo.usages.includes(\"connfulSecureServer:\" + address) &&\n\t\t\t\t\t\t\t\t\t\t!theirMainKeyDecrypt.keyInfo.usages.includes(\"connfulSecureServer:\" + verifyByDomain))) {\n\t\t\t\t\t\t\t\t\t_rejectPromise(new Error(\"SERVER_SIGNATURE_VERIFICATION_FAILED\"));\n\t\t\t\t\t\t\t\t\twebsocket.removeEventListener(\"message\", eventListener);\n\t\t\t\t\t\t\t\t\tdelete connections[connID + \":client\"];\n\t\t\t\t\t\t\t\t\tdelete networkListens[networkListenID];\n\t\t\t\t\t\t\t\t\treturn websocket.send(JSON.stringify({\n\t\t\t\t\t\t\t\t\t\treceiver: address,\n\t\t\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\t\t\ttype: \"connectionful\",\n\t\t\t\t\t\t\t\t\t\t\taction: \"drop\",\n\t\t\t\t\t\t\t\t\t\t\tconnectionID: connID,\n\t\t\t\t\t\t\t\t\t\t\tgate\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconnections[connID + \":client\"].theirMainKeyReceived = theirMainKeyDecrypt;\n\t\t\t\t\t\t\t\twebsocket.send(JSON.stringify({\n\t\t\t\t\t\t\t\t\treceiver: address,\n\t\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\t\ttype: \"connectionful\",\n\t\t\t\t\t\t\t\t\t\taction: \"nice2meetu\",\n\t\t\t\t\t\t\t\t\t\tconnectionID: connID,\n\t\t\t\t\t\t\t\t\t\tgate\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\t\t_settlePromise();\n\t\t\t\t\t\t\t} else if (packet.data.type == \"connectionful\" && packet.data.connectionID == connID && packet.data.action == \"drop\") {\n\t\t\t\t\t\t\t\tif (connections[connID + \":client\"].dying) return;\n\t\t\t\t\t\t\t\t_rejectPromise(new Error(\"CONNECTION_DROPPED\"));\n\t\t\t\t\t\t\t\tif (_rejectDataPromise) _rejectDataPromise(new Error(\"CONNECTION_DROPPED\"));\n\t\t\t\t\t\t\t\twebsocket.send(JSON.stringify({\n\t\t\t\t\t\t\t\t\treceiver: address,\n\t\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\t\ttype: \"connectionful\",\n\t\t\t\t\t\t\t\t\t\taction: \"drop\",\n\t\t\t\t\t\t\t\t\t\tconnectionID: connID,\n\t\t\t\t\t\t\t\t\t\tgate\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\t\tconnections[connID + \":client\"].dying = true;\n\t\t\t\t\t\t\t\twebsocket.removeEventListener(\"message\", eventListener);\n\t\t\t\t\t\t\t\tdelete networkListens[networkListenID];\n\t\t\t\t\t\t\t\tif (!connections[connID + \":client\"].dataBuffer.length) delete connections[connID + \":client\"];\n\t\t\t\t\t\t\t} else if (packet.data.type == \"connectionful\" && packet.data.connectionID == connID && packet.data.action == \"data\") {\n\t\t\t\t\t\t\t\tif (!connections[connID + \":client\"].aesUsableKey) return;\n\t\t\t\t\t\t\t\tif (!connections[connID + \":client\"].theirMainKeyReceived) return;\n\t\t\t\t\t\t\t\tif (connections[connID + \":client\"].writingLock) await connections[connID + \":client\"].writingLock;\n\t\t\t\t\t\t\t\tlet writingLockRelease;\n\t\t\t\t\t\t\t\tlet writingLock = new Promise(r => writingLockRelease = r);\n\t\t\t\t\t\t\t\tconnections[connID + \":client\"].writingLock = writingLock;\n\t\t\t\t\t\t\t\tconnections[connID + \":client\"].dataBuffer.push(new TextDecoder().decode(await crypto.subtle.decrypt({\n\t\t\t\t\t\t\t\t\tname: \"AES-GCM\",\n\t\t\t\t\t\t\t\t\tiv: hexToU8A(packet.data.content.iv)\n\t\t\t\t\t\t\t\t}, connections[connID + \":client\"].aesUsableKey, hexToU8A(packet.data.content.ct))));\n\t\t\t\t\t\t\t\tif (!(connections[connID + \":client\"].dataBuffer.length - 1)) {\n\t\t\t\t\t\t\t\t\t_dataBufferPromise();\n\t\t\t\t\t\t\t\t\tdataBufferPromise = new Promise((r, e) => [_dataBufferPromise, _rejectDataPromise] = [r, e]);\n\t\t\t\t\t\t\t\t\tconnections[packet.data.connectionID + \":client\"].dataBufferPromise = dataBufferPromise;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twritingLockRelease();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch {}\n\t\t\t\t\t};\n\t\t\t\t\tnetworkListens[networkListenID] = { ws: websocket, gate: gate, fn: eventListener };\n\t\t\t\t\twebsocket.addEventListener(\"message\", eventListener);\n\t\t\t\t\twebsocket.send(JSON.stringify({\n\t\t\t\t\t\treceiver: address,\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\ttype: \"connectionful\",\n\t\t\t\t\t\t\taction: \"start\",\n\t\t\t\t\t\t\tgate,\n\t\t\t\t\t\t\tconnectionID: connID,\n\t\t\t\t\t\t\tcontent: { keyInfo: exported, signature }\n\t\t\t\t\t\t},\n\t\t\t\t\t\tid: packetID\n\t\t\t\t\t}));\n\t\t\t\t\tmodules.network.runOnClose.then(function() {\n\t\t\t\t\t\tif (connections.hasOwnProperty(connID + \":client\")) {\n\t\t\t\t\t\t\tconnections[connID + \":client\"].dying = true;\n\t\t\t\t\t\t\tif (!connections[connID + \":client\"].dataBuffer.length) delete connections[connID + \":client\"];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdelete networkListens[networkListenID];\n\t\t\t\t\t\t_rejectPromise(new Error(\"NETWORK_CLOSED\"));\n\t\t\t\t\t\t_rejectDataPromise(new Error(\"NETWORK_CLOSED\"));\n\t\t\t\t\t});\n\t\t\t\t\treturn connID + \":client\";\n\t\t\t\t},\n\t\t\t\tconnfulConnectionSettled: async function(connectionID) {\n\t\t\t\t\tif (!privileges.includes(\"CONNFUL_CONNECT\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!connections.hasOwnProperty(connectionID)) throw new Error(\"NO_SUCH_CONNECTION\");\n\t\t\t\t\tawait connections[connectionID].settlePromise;\n\t\t\t\t},\n\t\t\t\tconnfulDisconnect: async function(connectionID) {\n\t\t\t\t\tif (!privileges.includes(\"CONNFUL_DISCONNECT\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!connections.hasOwnProperty(connectionID)) throw new Error(\"NO_SUCH_CONNECTION\");\n\t\t\t\t\tif (connections[connectionID].dying) return;\n\t\t\t\t\tnetworkListens[connections[connectionID].networkListenID].ws.send(JSON.stringify({\n\t\t\t\t\t\treceiver: connections[connectionID].from,\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\ttype: \"connectionful\",\n\t\t\t\t\t\t\taction: \"drop\",\n\t\t\t\t\t\t\tconnectionID: connectionID.slice(0, -7),\n\t\t\t\t\t\t\tgate: connections[connectionID].gateIfNeeded\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t\t\t},\n\t\t\t\tconnfulForceDisconnect: async function(connectionID) {\n\t\t\t\t\tif (!privileges.includes(\"CONNFUL_DISCONNECT\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tdelete connections[connectionID];\n\t\t\t\t},\n\t\t\t\tconnfulWrite: async function(sendOpts) {\n\t\t\t\t\tif (!privileges.includes(\"CONNFUL_WRITE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!connections.hasOwnProperty(sendOpts.connectionID)) throw new Error(\"NO_SUCH_CONNECTION\");\n\t\t\t\t\tif (connections[sendOpts.connectionID].dying) throw new Error(\"CONNECTION_DROPPED\");\n\t\t\t\t\tlet iv = crypto.getRandomValues(new Uint8Array(16));\n\t\t\t\t\tlet u8aToHex = (u8a) => Array.from(u8a).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\tnetworkListens[connections[sendOpts.connectionID].networkListenID].ws.send(JSON.stringify({\n\t\t\t\t\t\treceiver: connections[sendOpts.connectionID].from,\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\ttype: \"connectionful\",\n\t\t\t\t\t\t\taction: \"data\",\n\t\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\tiv: u8aToHex(iv),\n\t\t\t\t\t\t\t\tct: u8aToHex(new Uint8Array(await crypto.subtle.encrypt({\n\t\t\t\t\t\t\t\t\tname: \"AES-GCM\",\n\t\t\t\t\t\t\t\t\tiv\n\t\t\t\t\t\t\t\t}, connections[sendOpts.connectionID].aesUsableKey, new TextEncoder().encode(sendOpts.data))))\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tconnectionID: sendOpts.connectionID.slice(0, -7),\n\t\t\t\t\t\t\tgate: connections[sendOpts.connectionID].gateIfNeeded\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t\t\t},\n\t\t\t\tconnfulRead: async function(connectionID) {\n\t\t\t\t\tif (!privileges.includes(\"CONNFUL_READ\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!connections.hasOwnProperty(connectionID)) throw new Error(\"NO_SUCH_CONNECTION\");\n\t\t\t\t\tif (!connections[connectionID].dataBuffer.length) await connections[connectionID].dataBufferPromise;\n\t\t\t\t\tlet data = connections[connectionID].dataBuffer.shift();\n\t\t\t\t\tif (connections[connectionID].dying && connections[connectionID].dataBuffer.length == 0) delete connections[connectionID]; \n\t\t\t\t\treturn data;\n\t\t\t\t},\n\t\t\t\tconnfulAddressGet: async function(connectionID) {\n\t\t\t\t\tif (!privileges.includes(\"CONNFUL_ADDRESS_GET\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!connections.hasOwnProperty(connectionID)) throw new Error(\"NO_SUCH_CONNECTION\");\n\t\t\t\t\treturn connections[connectionID].from;\n\t\t\t\t},\n\t\t\t\tconnfulIdentityGet: async function(connectionID) {\n\t\t\t\t\tif (!privileges.includes(\"CONNFUL_IDENTITY_GET\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!connections.hasOwnProperty(connectionID)) throw new Error(\"NO_SUCH_CONNECTION\");\n\t\t\t\t\treturn connections[connectionID].theirMainKeyReceived;\n\t\t\t\t},\n\t\t\t\tsystemUptime: async function() {\n\t\t\t\t\tif (!privileges.includes(\"SYSTEM_UPTIME\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn Math.floor(performance.now());\n\t\t\t\t},\n\t\t\t\tnetworkRawWrite: function(data) {\n\t\t\t\t\tif (!privileges.includes(\"NETWORK_RAW_WRITE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet websocketHandle = modules.network.ws;\n\t\t\t\t\tif (!websocketHandle) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\tlet websocket = modules.websocket._handles[websocketHandle].ws;\n\t\t\t\t\tif (websocket.readyState != 1) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\twebsocket.send(data);\n\t\t\t\t},\n\t\t\t\tnetworkRawRead: function() {\n\t\t\t\t\tif (!privileges.includes(\"NETWORK_RAW_READ\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet websocketHandle = modules.network.ws;\n\t\t\t\t\tif (!websocketHandle) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\tlet websocket = modules.websocket._handles[websocketHandle].ws;\n\t\t\t\t\tif (websocket.readyState != 1) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\treturn Promise.race([ new Promise(async function(resolve) {\n\t\t\t\t\t\tnetworkListens[networkListenID] = { ws: websocket, fn: _ => resolve(_.data) };\n\t\t\t\t\t\twebsocket.addEventListener(\"message\", eventListener);\n\t\t\t\t\t}), new Promise((_, reject) => modules.network.runOnClose.then(_ => reject(new Error(\"NETWORK_CLOSED\")))) ]);\n\t\t\t\t},\n\t\t\t\tgetHostname: async function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_HOSTNAME\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.network.hostname;\n\t\t\t\t},\n\t\t\t\tresolve: async function(name) {\n\t\t\t\t\tif (!privileges.includes(\"RESOLVE_NAME\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet websocketHandle = modules.network.ws;\n\t\t\t\t\tif (!websocketHandle) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\tlet websocket = modules.websocket._handles[websocketHandle].ws;\n\t\t\t\t\tif (websocket.readyState != 1) throw new Error(\"NETWORK_UNREACHABLE\");\n\t\t\t\t\tlet tlds = JSON.parse(await modules.fs.read(modules.defaultSystem + \"/etc/tlds.json\"));\n\t\t\t\t\tfunction resolveRecursive(name, address) {\n\t\t\t\t\t\tif (tlds.hasOwnProperty(name)) return tlds[name];\n\t\t\t\t\t\tif (address == null) return null;\n\t\t\t\t\t\treturn new Promise(function(resolve) {\n\t\t\t\t\t\t\tlet gate = \"user_\" + Array.from(crypto.getRandomValues(new Uint8Array(16))).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\t\t\tlet networkListenID = Array.from(crypto.getRandomValues(new Uint8Array(64))).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\t\t\tfunction eventListener(e) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tlet packet = JSON.parse(e.data);\n\t\t\t\t\t\t\t\t\tif (packet.data.type == \"connectionless\" && packet.data.gate == gate && packet.from == address) {\n\t\t\t\t\t\t\t\t\t\twebsocket.removeEventListener(\"message\", eventListener);\n\t\t\t\t\t\t\t\t\t\tdelete networkListens[networkListenID];\n\t\t\t\t\t\t\t\t\t\tresolve(packet.data.content);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnetworkListens[networkListenID] = { ws: websocket, fn: eventListener };\n\t\t\t\t\t\t\twebsocket.addEventListener(\"message\", eventListener);\n\t\t\t\t\t\t\twebsocket.send(JSON.stringify({\n\t\t\t\t\t\t\t\treceiver: address,\n\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\ttype: \"connectionless\",\n\t\t\t\t\t\t\t\t\tgate: \"resolve\",\n\t\t\t\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\t\t\treply: gate,\n\t\t\t\t\t\t\t\t\t\tquery: name\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tlet nameParts = name.split(\".\").reverse();\n\t\t\t\t\tlet currentResolve;\n\t\t\t\t\tfor (let part = 0; part < nameParts.length; part++) currentResolve = await resolveRecursive(nameParts.slice(0, part + 1).reverse().join(\".\"), currentResolve);\n\t\t\t\t\treturn currentResolve;\n\t\t\t\t},\n\t\t\t\tpatchDiff: function(libraryOptions) {\n\t\t\t\t\tif (!privileges.includes(\"PATCH_DIFF\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (!window.diff) throw new Error(\"MODULE_REQUIRED\");\n\t\t\t\t\tlet operations = { diff_core, diff, lcs, calcPatch, applyPatch, calcSlices };\n\t\t\t\t\treturn [ ...operations[libraryOptions.operation](...libraryOptions.args) ];\n\t\t\t\t},\n\t\t\t\tsetFirmware: async function(new_flash) {\n\t\t\t\t\tif (!privileges.includes(\"SET_FIRMWARE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tif (modules.core.setFW) {\n\t\t\t\t\t\tawait modules.core.setFW(new_flash);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tlocalStorage.setItem(\"runtime_flash\", new_flash);\n\t\t\t\t},\n\t\t\t\treloadNetworkConfig: async function() {\n\t\t\t\t\tif (!privileges.includes(\"RELOAD_NETWORK_CONFIG\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tawait modules.network.reloadConfig();\n\t\t\t\t},\n\t\t\t\tbatteryStatus: async function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_BATTERY_STATUS\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\tlet battery = await navigator.getBattery();\n\t\t\t\t\treturn {\n\t\t\t\t\t\tcharging: battery.charging,\n\t\t\t\t\t\tlevel: battery.level,\n\t\t\t\t\t\tchargingTime: battery.chargingTime,\n\t\t\t\t\t\tdischargingTime: battery.dischargingTime\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\tgetUpdateService: async function() {\n\t\t\t\t\tif (!privileges.includes(\"GET_UPDATE_SERVICE\")) throw new Error(\"UNAUTHORIZED_ACTION\");\n\t\t\t\t\treturn modules.network.updates;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlet customAPIs = modules.customAPIs;\n\t\tif (customAPIs) {\n\t\t\tfor (let api in (customAPIs.public || {})) apis.public[api] = async (...args) => customAPIs.public[api](processToken, ...args);\n\t\t\tfor (let api in (customAPIs.private || {})) apis.private[api] = async (...args) => customAPIs.private[api](processToken, ...args);\n\t\t}\n\t\treturn apis;\n\t}\n}\nreeAPIs();","793f0634e3428d92d45695e1661c7384219a05ea7835f1fab6bdd2cad7ebd17058cb647a7b26b0010de4ff5da553056e88432fd75ed3f1efadcbf16d831b85f7":"function loadBasicCSP() {\n\tmodules.csps = {};\n\tlet cryptoKeys = {};\n\tfunction cryptoKeyIntoKeyObject(ck, groupBy) {\n\t\tif (ck.privateKey && ck.publicKey) return {\n\t\t\tprivateKey: cryptoKeyIntoKeyObject(ck.privateKey, groupBy),\n\t\t\tpublicKey: cryptoKeyIntoKeyObject(ck.publicKey, groupBy),\n\t\t};\n\t\tlet keyID = crypto.getRandomValues(new Uint8Array(64)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\tif (!cryptoKeys.hasOwnProperty(groupBy)) cryptoKeys[groupBy] = {};\n\t\tcryptoKeys[groupBy][keyID] = ck;\n\t\treturn {\n\t\t\ttype: ck.type,\n\t\t\textractable: ck.extractable,\n\t\t\talgorithm: ck.algorithm,\n\t\t\tusages: ck.usages,\n\t\t\tkeyID: keyID\n\t\t}\n\t}\n\tmodules.csps.basic = {\n\t\tcspMetadata: function() {\n\t\t\treturn {\n\t\t\t\tname: \"Basic Cryptographic Provider\",\n\t\t\t\tversion: modules.pcos_version,\n\t\t\t\tdeveloper: \"PCsoft\",\n\t\t\t\tfeatures: Object.keys(modules.csps.basic)\n\t\t\t}\n\t\t},\n\t\trandom: async function(typedArray) {\n\t\t\treturn crypto.getRandomValues(typedArray);\n\t\t},\n\t\timportKey: async function(arg, groupBy) {\n\t\t\treturn cryptoKeyIntoKeyObject(await crypto.subtle.importKey(arg.format, arg.keyData, arg.algorithm, arg.extractable, arg.keyUsages), groupBy);\n\t\t},\n\t\tgenerateKey: async function(arg, groupBy) {\n\t\t\treturn cryptoKeyIntoKeyObject(await crypto.subtle.generateKey(arg.algorithm, arg.extractable, arg.keyUsages), groupBy);\n\t\t},\n\t\tderiveBits: async function(arg, groupBy) {\n\t\t\targ.baseKey = cryptoKeys[groupBy][arg.baseKey.keyID];\n\t\t\tif (arg.algorithm.public) arg.algorithm.public = cryptoKeys[groupBy][arg.algorithm.public.keyID];\n\t\t\treturn crypto.subtle.deriveBits(arg.algorithm, arg.baseKey, arg.length);\n\t\t},\n\t\tderiveKey: async function(arg, groupBy) {\n\t\t\targ.baseKey = cryptoKeys[groupBy][arg.baseKey.keyID];\n\t\t\tif (arg.algorithm.public) arg.algorithm.public = cryptoKeys[groupBy][arg.algorithm.public.keyID];\n\t\t\treturn cryptoKeyIntoKeyObject(await crypto.subtle.deriveKey(arg.algorithm, arg.baseKey, arg.derivedKeyType, arg.extractable, arg.keyUsages), groupBy);\n\t\t},\n\t\twrapKey: async function(arg, groupBy) {\n\t\t\targ.key = cryptoKeys[groupBy][arg.key.keyID];\n\t\t\targ.wrappingKey = cryptoKeys[groupBy][arg.wrappingKey.keyID];\n\t\t\treturn crypto.subtle.wrapKey(arg.format, arg.key, arg.wrappingKey, arg.wrapAlgo);\n\t\t},\n\t\tdigest: async function(arg) {\n\t\t\treturn crypto.subtle.digest(arg.algorithm, arg.data);\n\t\t},\n\t\tencrypt: async function(arg, groupBy) {\n\t\t\targ.key = cryptoKeys[groupBy][arg.key.keyID];\n\t\t\treturn crypto.subtle.encrypt(arg.algorithm, arg.key, arg.data);\n\t\t},\n\t\tsign: async function(arg, groupBy) {\n\t\t\targ.key = cryptoKeys[groupBy][arg.key.keyID];\n\t\t\treturn crypto.subtle.sign(arg.algorithm, arg.key, arg.data);\n\t\t},\n\t\texportKey: async function(arg, groupBy) {\n\t\t\targ.key = cryptoKeys[groupBy][arg.key.keyID];\n\t\t\treturn crypto.subtle.exportKey(arg.format, arg.key);\n\t\t},\n\t\tunwrapKey: async function(arg, groupBy) {\n\t\t\targ.unwrappingKey = cryptoKeys[groupBy][arg.unwrappingKey.keyID];\n\t\t\treturn cryptoKeyIntoKeyObject(await crypto.subtle.unwrapKey(arg.format, arg.keyData, arg.unwrappingKey, arg.unwrapAlgo, arg.unwrappedKeyAlgo, arg.extractable, arg.keyUsages), groupBy);\n\t\t},\n\t\tdecrypt: async function(arg, groupBy) {\n\t\t\targ.key = cryptoKeys[groupBy][arg.key.keyID];\n\t\t\treturn crypto.subtle.decrypt(arg.algorithm, arg.key, arg.data);\n\t\t},\n\t\tverify: async function(arg, groupBy) {\n\t\t\targ.key = cryptoKeys[groupBy][arg.key.keyID];\n\t\t\treturn crypto.subtle.verify(arg.algorithm, arg.key, arg.signature, arg.data);\n\t\t},\n\t\tunloadKey: (key, groupBy) => delete cryptoKeys[groupBy][key.keyID],\n\t\tremoveSameGroupKeys: (_, groupBy) => delete cryptoKeys[groupBy]\n\t}\n\tif (window.nacl) {\n\t\tmodules.csps.tweetnacl = {\n\t\t\tcspMetadata: function() {\n\t\t\t\treturn {\n\t\t\t\t\tname: \"TweetNaCl Cryptographic Provider\",\n\t\t\t\t\tversion: \"1.0.3\",\n\t\t\t\t\tdeveloper: \"TweetNaCl.js developers (https://github.com/dchest/tweetnacl-js)\",\n\t\t\t\t\tfeatures: Object.keys(modules.csps.tweetnacl)\n\t\t\t\t}\n\t\t\t},\n\t\t\trandom: typedArray => nacl.randomBytes(typedArray.length),\n\t\t\tgenerateKey: type => nacl[type].keyPair(),\n\t\t\tderiveKey: arg => nacl[arg.type].keyPair.fromSeed(arg.seed),\n\t\t\tdigest: message => nacl.hash(message),\n\t\t\tencrypt: arg => nacl[arg.type](arg.message, arg.nonce, arg.key1, arg.key2),\n\t\t\tsign: arg => nacl.sign.detached(arg.message, arg.secretKey),\n\t\t\tdecrypt: arg => nacl[arg.type].open(arg.box, arg.nonce, arg.key1, arg.key2),\n\t\t\tverify: arg => nacl.sign.detached.verify(arg.message, arg.signature, arg.publicKey)\n\t\t};\n\t}\n}\nloadBasicCSP();","f3775a6f2543705abbec6bd4a39e146c339870abaefbc6af74823ac47ce654647131263e28544eb39b22418ccd820c882d7b9acb9ae17f9cdabc016ae0a9d06b":"function localization() {\n\t// @pcos-app-mode native\n\tlet locales = {\n        get: function(key, lang) {\n\t\t\tlang = lang || locales.defaultLocale || navigator.languages[0].split(\"-\")[0].toLowerCase();\n\t\t\tlet locale = locales[lang];\n\t\t\tif (!locale) locale = locales[locales.defaultLocale || \"en\"];\n\t\t\tif (!locale) locale = {};\n\t\t\tif (!locale.hasOwnProperty(key)) locale = locales[locales.defaultLocale || \"en\"] || {};\n\t\t\treturn locale.hasOwnProperty(key) ? locale[key] : key;\n\t\t}\n\t}\n\tmodules.locales = locales;\n}\nlocalization();","62851c8b6b8c91d7c59c3f780457e4595190eb68ce9ea92454607d37d4defd33308b8f2f9ff6329ee1c7eb69e81de742856594b3ba7c48fc60cba07036903384":"function loadTasks() {\n\t// @pcos-app-mode native\n\tmodules.startupWindow.content.innerText = modules.locales.get(\"PCOS_STARTING\");\n\tlet tasks = {\n\t\texec: async function(file, arg, windowObject, token, silent, privateData) {\n\t\t\tlet errorAudio = new Audio();\n\t\t\ttry {\n\t\t\t\tlet errorSoundPerm = await modules.fs.permissions(modules.defaultSystem + \"/etc/sounds/error.aud\", token);\n\t\t\t\tif (!errorSoundPerm.world.includes(\"r\")) throw new Error(\"Not allowed to read error.aud\");\n\t\t\t\tlet errorSound = await modules.fs.read(modules.defaultSystem + \"/etc/sounds/error.aud\", token);\n\t\t\t\terrorAudio.src = errorSound;\n\t\t\t} catch {}\n\t\t\tif (modules.session.attrib(windowObject.sessionId, \"loggingOut\")) throw new Error(\"LOGGING_OUT\");\n\t\t\tlet language = modules.session.attrib(windowObject.sessionId, \"language\") || undefined;\n\t\t\tif (modules.shuttingDown) {\n\t\t\t\twindowObject.windowDiv.remove();\n\t\t\t\tthrow new Error(\"SYSTEM_SHUTDOWN_REQUESTED\");\n\t\t\t}\n\t\t\tlet appRedirecting = {};\n\t\t\ttry {\n\t\t\t\tappRedirecting = JSON.parse(await this.fs.read(modules.defaultSystem + \"/etc/appRedir\", token));\n\t\t\t} catch {}\n\t\t\tif (modules.core.bootMode == \"safe\") appRedirecting = {};\n\t\t\tif (appRedirecting.hasOwnProperty(file)) file = appRedirecting[file];\n\t\t\twindowObject.title.innerText = modules.locales.get(\"UNTITLED_APP\", language);\n\t\t\twindowObject.content.innerText = \"\";\n\t\t\twindowObject.content.style = \"\";\n\t\t\tlet taskId = crypto.getRandomValues(new Uint8Array(64)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\tlet executablePermissions, executable;\n\t\t\ttry {\n\t\t\t\texecutablePermissions = await this.fs.permissions(file, token);\n\t\t\t\texecutable = await this.fs.read(file, token);\n\t\t\t} catch (e) {\n\t\t\t\twindowObject.title.innerText = modules.locales.get(\"APP_STARTUP_CRASH_TITLE\", language);\n\t\t\t\twindowObject.content.innerText = modules.locales.get(\"APP_STARTUP_CRASH\", language);\n\t\t\t\twindowObject.content.style.padding = \"8px\";\n\t\t\t\twindowObject.closeButton.disabled = false;\n\t\t\t\twindowObject.closeButton.onclick = (e) => windowObject.windowDiv.remove() && e.stopPropagation();\n\t\t\t\tif (silent) windowObject.windowDiv.remove();\n\t\t\t\tif (!silent) errorAudio.play();\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\tif (!executablePermissions.world.includes(\"r\") || !executablePermissions.world.includes(\"x\")) {\n\t\t\t\twindowObject.title.innerText = modules.locales.get(\"PERMISSION_DENIED\", language);\n\t\t\t\twindowObject.content.innerText = modules.locales.get(\"MORE_PERMISSION_DENIED\", language);\n\t\t\t\twindowObject.content.style.padding = \"8px\";\n\t\t\t\twindowObject.closeButton.disabled = false;\n\t\t\t\twindowObject.closeButton.onclick = (e) => windowObject.windowDiv.remove() && e.stopPropagation();\n\t\t\t\tif (silent) windowObject.windowDiv.remove();\n\t\t\t\tif (!silent) errorAudio.play();\n\t\t\t\tthrow new Error(\"MORE_PERMISSION_DENIED\", language);\n\t\t\t}\n\t\t\tif (!executable.includes(\"// @pcos-app-mode isolat\" + \"able\")) {\n\t\t\t\twindowObject.title.innerText = modules.locales.get(\"COMPATIBILITY_ISSUE_TITLE\", language);\n\t\t\t\twindowObject.content.innerText = modules.locales.get(\"COMPATIBILITY_ISSUE\", language);\n\t\t\t\twindowObject.content.style.padding = \"8px\";\n\t\t\t\twindowObject.closeButton.disabled = false;\n\t\t\t\twindowObject.closeButton.onclick = (e) => windowObject.windowDiv.remove() && e.stopPropagation();\n\t\t\t\tif (silent) windowObject.windowDiv.remove();\n\t\t\t\tif (!silent) errorAudio.play();\n\t\t\t\tthrow new Error(\"COMPATIBILITY_ISSUE\");\n\t\t\t}\n\t\t\tlet appHardening = {overridable:true};\n\t\t\ttry {\n\t\t\t\tappHardening = JSON.parse(await this.fs.read(modules.defaultSystem + \"/etc/appHarden\", token));\n\t\t\t} catch {}\n\t\t\tlet disableHarden = appHardening.overridable && modules.core.bootMode == \"disable-harden\";\n\t\t\tif (disableHarden) appHardening = {overridable:true};\n\t\t\tlet limitations = [];\n\t\t\tlet execSignature = {};\n\t\t\tif (executable.includes(\"// =====BEGIN MANIFEST=====\")) {\n\t\t\t\tlet parsingLines = executable.split(\"\\n\");\n\t\t\t\tlet parsingBoundStart = parsingLines.indexOf(\"// =====BEGIN MANIFEST=====\");\n\t\t\t\tlet parsingBoundEnd = parsingLines.indexOf(\"// =====END MANIFEST=====\");\n\t\t\t\tlet upToParse = parsingLines.slice(parsingBoundStart, parsingBoundEnd + 1);\n\t\t\t\tlet knownLineTypes = [\"allow\", \"deny\"];\n\t\t\t\tfor (let line of upToParse) {\n\t\t\t\t\tlet lineType = line.split(\": \")[0].replace(\"// \", \"\");\n\t\t\t\t\tlet lineData = line.replace(\"// \" + lineType + \": \", \"\");\n\t\t\t\t\tif (lineType == \"signature\") {\n\t\t\t\t\t\texecSignature.signature = lineData;\n\t\t\t\t\t\texecutable = executable.replace(line + \"\\n\", \"\");\n\t\t\t\t\t}\n\t\t\t\t\tif (lineType == \"signer\") execSignature.signer = lineData;\n\t\t\t\t\tif (lineType == \"asck\") execSignature.selfContainedSigner = lineData;\n\t\t\t\t\tif (knownLineTypes.includes(lineType)) {\n\t\t\t\t\t\tlet dataParts = lineData.split(\", \");\n\t\t\t\t\t\tfor (let data of dataParts) limitations.push({ lineType, data });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (disableHarden) limitations = [];\n\t\t\tlet hexToU8A = (hex) => Uint8Array.from(hex.match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\tlet u8aToHex = (u8a) => Array.from(u8a).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\tif (!limitations.some(lim => lim.lineType == \"allow\") && appHardening.requireAllowlist && !disableHarden) {\n\t\t\t\twindowObject.title.innerText = modules.locales.get(\"PERMISSION_DENIED\", language);\n\t\t\t\twindowObject.content.innerText = modules.locales.get(\"NO_APP_ALLOWLIST\", language);\n\t\t\t\twindowObject.content.style.padding = \"8px\";\n\t\t\t\twindowObject.closeButton.disabled = false;\n\t\t\t\twindowObject.closeButton.onclick = (e) => windowObject.windowDiv.remove() && e.stopPropagation();\n\t\t\t\tif (silent) windowObject.windowDiv.remove();\n\t\t\t\tif (!silent) errorAudio.play();\n\t\t\t\tthrow new Error(\"NO_APP_ALLOWLIST\");\n\t\t\t}\n\n\t\t\tasync function recursiveKeyVerify(key, khrl) {\n\t\t\t\tif (!key) throw new Error(\"NO_KEY\");\n\t\t\t\tlet hash = u8aToHex(new Uint8Array(await crypto.subtle.digest(\"SHA-256\", new TextEncoder().encode((key.keyInfo?.key || key.key).x + \"|\" + (key.keyInfo?.key || key.key).y))));\n\t\t\t\tif (khrl.includes(hash)) throw new Error(\"KEY_REVOKED\");\n\t\t\t\tlet signedByKey = modules.ksk_imported;\n\t\t\t\tif (key.keyInfo && key.keyInfo?.signedBy) {\n\t\t\t\t\tsignedByKey = JSON.parse(await modules.fs.read(modules.defaultSystem + \"/etc/keys/\" + key.keyInfo.signedBy, token));\n\t\t\t\t\tif (!signedByKey.keyInfo) throw new Error(\"NOT_KEYS_V2\");\n\t\t\t\t\tif (!signedByKey.keyInfo.usages.includes(\"keyTrust\")) throw new Error(\"NOT_KEY_AUTHORITY\");\n\t\t\t\t\tawait recursiveKeyVerify(signedByKey, khrl);\n\t\t\t\t\tsignedByKey = await crypto.subtle.importKey(\"jwk\", signedByKey.keyInfo.key, {\n\t\t\t\t\t\tname: \"ECDSA\",\n\t\t\t\t\t\tnamedCurve: \"P-256\"\n\t\t\t\t\t}, false, [\"verify\"]);\n\t\t\t\t}\n\t\t\t\tif (!await crypto.subtle.verify({\n\t\t\t\t\tname: \"ECDSA\",\n\t\t\t\t\thash: {\n\t\t\t\t\t\tname: \"SHA-256\"\n\t\t\t\t\t}\n\t\t\t\t}, signedByKey, hexToU8A(key.signature), new TextEncoder().encode(JSON.stringify(key.key || key.keyInfo)))) throw new Error(\"KEY_SIGNATURE_VERIFICATION_FAILED\");\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif ((execSignature.signer || appHardening.requireSignature || execSignature.selfContainedSigner) && !disableHarden) {\n\t\t\t\ttry {\n\t\t\t\t\tlet khrlFiles = await this.fs.ls(modules.defaultSystem + \"/etc/keys/khrl\", token);\n\t\t\t\t\tlet khrlSignatures = [];\n\t\t\t\t\tfor (let khrlFile of khrlFiles) {\n\t\t\t\t\t\tlet khrl = JSON.parse(await this.fs.read(modules.defaultSystem + \"/etc/keys/khrl/\" + khrlFile, token));\n\t\t\t\t\t\tlet khrlSignature = khrl.signature;\n\t\t\t\t\t\tdelete khrl.signature;\n\t\t\t\t\t\tif (await crypto.subtle.verify({\n\t\t\t\t\t\t\tname: \"ECDSA\",\n\t\t\t\t\t\t\thash: {\n\t\t\t\t\t\t\t\tname: \"SHA-256\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, modules.ksk_imported, hexToU8A(khrlSignature), new TextEncoder().encode(JSON.stringify(khrl.list)))) {\n\t\t\t\t\t\t\tkhrlSignatures.push(...khrl.list);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlet signingKey = JSON.parse(execSignature.selfContainedSigner || \"null\");\n\t\t\t\t\tif (!signingKey || appHardening.disableASCK) signingKey = JSON.parse(await this.fs.read(modules.defaultSystem + \"/etc/keys/\" + execSignature.signer, token));\n\t\t\t\t\tawait recursiveKeyVerify(signingKey, khrlSignatures);\n\t\t\t\t\tif (signingKey.keyInfo) if (!signingKey.keyInfo.usages.includes(\"appTrust\")) throw new Error(\"NOT_APP_SIGNING_KEY\");\n\t\t\t\t\tlet importSigningKey = await crypto.subtle.importKey(\"jwk\", signingKey.keyInfo?.key || signingKey.key, {\n\t\t\t\t\t\tname: \"ECDSA\",\n\t\t\t\t\t\tnamedCurve: \"P-256\"\n\t\t\t\t\t}, false, [\"verify\"]);\n\t\t\t\t\tif (!await crypto.subtle.verify({\n\t\t\t\t\t\tname: \"ECDSA\",\n\t\t\t\t\t\thash: {\n\t\t\t\t\t\t\tname: \"SHA-256\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}, importSigningKey, hexToU8A(execSignature.signature), new TextEncoder().encode(executable))) throw new Error(\"APP_SIGNATURE_VERIFICATION_FAILED\");\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(\"Failed to verify app signature:\", e);\n\t\t\t\t\twindowObject.title.innerText = modules.locales.get(\"PERMISSION_DENIED\", language);\n\t\t\t\t\twindowObject.content.innerText = modules.locales.get(\"SIGNATURE_VERIFICATION_FAILED\", language).replace(\"%s\", execSignature.signer || modules.locales.get(\"UNKNOWN_PLACEHOLDER\", language));\n\t\t\t\t\twindowObject.content.style.padding = \"8px\";\n\t\t\t\t\twindowObject.closeButton.disabled = false;\n\t\t\t\t\twindowObject.closeButton.onclick = (e) => windowObject.windowDiv.remove() && e.stopPropagation();\n\t\t\t\t\tif (silent) windowObject.windowDiv.remove();\n\t\t\t\t\tif (!silent) errorAudio.play();\n\t\t\t\t\tthrow new Error(\"APP_OR_KEY_SIGNATURE_VERIFICATION_FAILED\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet ree = await this.ree(windowObject.content, token);\n\t\t\ttry {\n\t\t\t\tmodules.session.attrib(windowObject.sessionId, \"openReeWindows\", [ ...(modules.session.attrib(windowObject.sessionId, \"openReeWindows\") || []), taskId ]);\n\t\t\t\targ = arg || [];\n\t\t\t\tif (!(arg instanceof Array)) arg = [];\n\t\t\t\targ = arg.map(a => String(a));\n\t\t\t\tlet that = this;\n\t\t\t\tree.iframe.style = \"width: 100%; height: 100%; border: none; top: 0; left: 0; position: absolute;\";\n\t\t\t\tlet reeAPIInstance = await modules.reeAPIInstance({ ree, ses: windowObject.sessionId, token, taskId, limitations, privateData });\n\t\t\t\tfor (let action in reeAPIInstance.public) ree.exportAPI(action, (e) => reeAPIInstance.public[action](e.arg));\n\t\t\t\tthis.tracker[taskId] = {\n\t\t\t\t\tree,\n\t\t\t\t\tfile: file,\n\t\t\t\t\targ: arg,\n\t\t\t\t\tapis: reeAPIInstance,\n\t\t\t\t\tcritical: false,\n\t\t\t\t\tcliio: {\n\t\t\t\t\t\tattached: false,\n\t\t\t\t\t\tattachedCLISignUp: function() {\n\t\t\t\t\t\t\treturn new Promise(a => attachedCLIRegistrations.push(a));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tlet registrations = [];\n\t\t\t\tlet attachedCLIRegistrations = [];\n\t\t\t\tlet cliCache = [];\n\t\t\t\twindowObject.closeButton.addEventListener(\"click\", () => that.sendSignal(taskId, 15));\n\t\t\t\tree.exportAPI(\"attachCLI\", async function() {\n\t\t\t\t\tif (that.tracker[taskId].cliio.attached) return true;\n\t\t\t\t\tif (!window.Terminal) return false;\n\t\t\t\t\tfor (let registration of attachedCLIRegistrations) registration();\n\t\t\t\t\tattachedCLIRegistrations = [];\n\t\t\t\t\tlet signup = () => new Promise((resolve) => registrations.push(resolve));\n\t\t\t\t\tree.iframe.hidden = true;\n\t\t\t\t\tlet termDiv = document.createElement(\"div\");\n\t\t\t\t\ttermDiv.style = \"position: absolute; top: 0; left: 0; width: 100%; height: 100%;\";\n\t\t\t\t\tlet fitAddon = new FitAddon.FitAddon();\n\t\t\t\t\tlet termInstance = new Terminal();\n\t\t\t\t\ttermInstance.loadAddon(fitAddon);\n\t\t\t\t\ttermInstance.open(termDiv);\n\t\t\t\t\twindowObject.content.appendChild(termDiv);\n\t\t\t\t\tthat.tracker[taskId].cliio.attached = true;\n\t\t\t\t\tthat.tracker[taskId].cliio.xtermInstance = termInstance;\n\t\t\t\t\tlet onresizeFn = () => fitAddon.fit();\n\t\t\t\t\tonresizeFn();\n\t\t\t\t\tlet robs = new ResizeObserver(onresizeFn);\n\t\t\t\t\tthat.tracker[taskId].cliio.robsInstance = robs;\n\t\t\t\t\trobs.observe(windowObject.windowDiv);\n\t\t\t\t\tthat.tracker[taskId].cliio.signup = signup;\n\t\t\t\t\tthat.tracker[taskId].cliio.xtermInstance.onData(e => cliCache.push(e));\n\t\t\t\t\ttermInstance.clear();\n\t\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, 8));\n\t\t\t\t\treturn true;  \n\t\t\t\t});\n\t\t\t\tree.exportAPI(\"toMyCLI\", async function(apiArg) {\n\t\t\t\t\tif (that.tracker[taskId].cliio.attached) {\n\t\t\t\t\t\tthat.tracker[taskId].cliio.xtermInstance.write(apiArg.arg);\n\t\t\t\t\t\tfor (let registered in registrations) {\n\t\t\t\t\t\t\tawait registrations[registered]({ type: \"write\", data: apiArg.arg });\n\t\t\t\t\t\t\tregistrations.splice(0, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tree.exportAPI(\"fromMyCLI\", async function() {\n\t\t\t\t\tif (!that.tracker[taskId].cliio.attached) return false;\n\t\t\t\t\tlet ti = that.tracker[taskId].cliio.xtermInstance;\n\t\t\t\t\treturn new Promise(async function(resolve) {\n\t\t\t\t\t\tif (cliCache.length) {\n\t\t\t\t\t\t\tlet element = cliCache[0];\n\t\t\t\t\t\t\tcliCache = cliCache.slice(1);\n\t\t\t\t\t\t\tresolve(element);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet d = ti.onData(async function(e) {\n\t\t\t\t\t\t\tcliCache = cliCache.slice(1);\n\t\t\t\t\t\t\tresolve(e);\n\t\t\t\t\t\t\td.dispose();\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\tree.exportAPI(\"clearMyCLI\", async function() {\n\t\t\t\t\tif (that.tracker[taskId].cliio.attached) that.tracker[taskId].cliio.xtermInstance.clear();\n\t\t\t\t\tfor (let registered in registrations) {\n\t\t\t\t\t\tawait registrations[registered]({ type: \"consoleClear\" });\n\t\t\t\t\t\tregistrations.splice(registered, 1);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tree.exportAPI(\"cliSize\", function() {\n\t\t\t\t\tif (!that.tracker[taskId].cliio.attached) return [ 0, 0 ];\n\t\t\t\t\treturn [ that.tracker[taskId].cliio.xtermInstance.cols, that.tracker[taskId].cliio.xtermInstance.rows ];\n\t\t\t\t});\n\t\t\t\tree.exportAPI(\"detachCLI\", function() {\n\t\t\t\t\tif (!that.tracker[taskId].cliio.attached) return true;\n\t\t\t\t\tthat.tracker[taskId].cliio.attached = false;\n\t\t\t\t\tthat.tracker[taskId].cliio.xtermInstance.clear();\n\t\t\t\t\tthat.tracker[taskId].cliio.robsInstance.disconnect();\n\t\t\t\t\tdelete that.tracker[taskId].cliio.robsInstance;\n\t\t\t\t\tthat.tracker[taskId].cliio.xtermInstance.dispose();\n\t\t\t\t\tdelete that.tracker[taskId].cliio.xtermInstance;\n\t\t\t\t\tdelete that.tracker[taskId].cliio.signup;\n\t\t\t\t\tregistrations = [];\n\t\t\t\t\tree.iframe.hidden = false;\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t\tree.exportAPI(\"windowVisibility\", (apiArg) => windowObject.windowDiv.classList.toggle(\"hidden\", !apiArg.arg));\n\t\t\t\tree.exportAPI(\"windowTitleSet\", (apiArg) => windowObject.title.innerText = apiArg.arg);\n\t\t\t\tree.exportAPI(\"windowResize\", function(apiArg) {\n\t\t\t\t\tif (reeAPIInstance.public.getPrivileges().includes(\"GRAB_ATTENTION\")) {\n\t\t\t\t\t\twindowObject.windowDiv.style.width = apiArg.arg[0] + \"px\";\n\t\t\t\t\t\twindowObject.windowDiv.style.height = apiArg.arg[1] + \"px\";\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tree.exportAPI(\"windowSize\", function() {\n\t\t\t\t\treturn {\n\t\t\t\t\t\twidth: windowObject.windowDiv.clientWidth,\n\t\t\t\t\t\theight: windowObject.windowDiv.clientHeight\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tree.exportAPI(\"windowRelocate\", function(apiArg) {\n\t\t\t\t\tif (reeAPIInstance.public.getPrivileges().includes(\"GRAB_ATTENTION\")) {\n\t\t\t\t\t\twindowObject.windowDiv.style.top = apiArg.arg[0] + \"px\";\n\t\t\t\t\t\twindowObject.windowDiv.style.left = apiArg.arg[1] + \"px\";\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tree.exportAPI(\"windowFullscreen\", function(apiArg) {\n\t\t\t\t\tif (reeAPIInstance.public.getPrivileges().includes(\"GRAB_ATTENTION\")) {\n\t\t\t\t\t\twindowObject.windowDiv.classList.toggle(\"fullscreen\", apiArg.arg);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tree.exportAPI(\"closeability\", (apiArg) => windowObject.closeButton.classList.toggle(\"hidden\", !apiArg.arg));\n\t\t\t\tree.exportAPI(\"critical\", function(apiArg) {\n\t\t\t\t\tif (reeAPIInstance.public.getPrivileges().includes(\"SYSTEM_STABILITY\")) {\n\t\t\t\t\t\tthat.tracker[taskId].critical = !!apiArg.arg;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tawait ree.eval(\"taskId = \" + JSON.stringify(taskId) + \";\");\n\t\t\t\tawait ree.eval(\"exec_args = \" + JSON.stringify(arg) + \";\");\n\t\t\t\tree.beforeCloseDown(function() {\n\t\t\t\t\tlet orw = modules.session.attrib(windowObject.sessionId, \"openReeWindows\");\n\t\t\t\t\torw.splice(orw.indexOf(taskId), 1);\n\t\t\t\t\tmodules.session.attrib(windowObject.sessionId, \"openReeWindows\", orw);\n\t\t\t\t\tif (that.tracker[taskId].cliio.attached) {    \n\t\t\t\t\t\tthat.tracker[taskId].cliio.attached = false;\n\t\t\t\t\t\tthat.tracker[taskId].cliio.xtermInstance.clear();\n\t\t\t\t\t\tthat.tracker[taskId].cliio.robsInstance.disconnect();\n\t\t\t\t\t\tthat.tracker[taskId].cliio.robsInstance = null;\n\t\t\t\t\t\tthat.tracker[taskId].cliio.xtermInstance.dispose();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tree.beforeCloseDown(() => windowObject.windowDiv.remove());\n\t\t\t\tree.beforeCloseDown(() => delete that.tracker[taskId]);\n\t\t\t\tawait ree.eval(executable);\n\t\t\t} catch (e) {\n\t\t\t\tree.closeDown();\n\t\t\t\twindowObject.title.innerText = modules.locales.get(\"APP_STARTUP_CRASH_TITLE\", language);\n\t\t\t\twindowObject.content.innerText = modules.locales.get(\"APP_STARTUP_CRASH\", language);\n\t\t\t\twindowObject.content.style.padding = \"8px\";\n\t\t\t\twindowObject.closeButton.disabled = false;\n\t\t\t\twindowObject.windowDiv.classList.toggle(\"hidden\", false);\n\t\t\t\twindowObject.closeButton.onclick = (e) => windowObject.windowDiv.remove() && e.stopPropagation();\n\t\t\t\tif (silent) windowObject.windowDiv.remove();\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\treturn taskId;\n\t\t},\n\t\tsendSignal: async function(taskId, signal, bypassCritical) {\n\t\t\tif (signal == 9) {\n\t\t\t\tif (this.tracker[taskId].critical && !bypassCritical) {\n\t\t\t\t\tlet memory = this.tracker[taskId];\n\t\t\t\t\tawait memory.ree.closeDown();\n\t\t\t\t\tawait panic(\"CRITICAL_TASK_FAILED\", {\n\t\t\t\t\t\tname: memory.file,\n\t\t\t\t\t\tparams: memory.arg\n\t\t\t\t\t});\n\t\t\t\t\tthrow new Error(\"CRITICAL_TASK_FAILED\");\n\t\t\t\t}\n\t\t\t\treturn await this.tracker[taskId].ree.closeDown();\n\t\t\t}\n\t\t\treturn await this.tracker[taskId].ree.eval(\"dispatchEvent(new CustomEvent(\\\"signal\\\", { detail: \" + JSON.stringify(signal) + \", bubbles: true }));\");\n\t\t},\n\t\trunsProperly: async function(taskId) {\n\t\t\ttry {\n\t\t\t\treturn await this.tracker[taskId].ree.eval(\"true\");\n\t\t\t} catch (e) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tlistPublicTasks: () => Object.keys(tasks.tracker),\n\t\twaitTermination: async function(taskId) {\n\t\t\tif (!this.tracker.hasOwnProperty(taskId)) return;\n\t\t\treturn new Promise((resolve) => this.tracker[taskId].ree.beforeCloseDown(() => resolve()));\n\t\t},\n\t\ttaskInfo: async function(taskId) {\n\t\t\tif (!this.tracker.hasOwnProperty(taskId)) return null;\n\t\t\tlet info = await modules.tokens.info(this.tracker[taskId].apis.public.getProcessToken());\n\t\t\tif (!info) info = { user: taskId.slice(0, 16) };\n\t\t\treturn {\n\t\t\t\tfile: this.tracker[taskId].file,\n\t\t\t\targ: this.tracker[taskId].arg,\n\t\t\t\trunBy: info.user,\n\t\t\t\tcliio: this.tracker[taskId].cliio.attached\n\t\t\t}\n\t\t},\n\t\ttracker: {},\n\t\tfs: modules.fs,\n\t\tree: modules.core.createREE\n\t};\n\t\n\tmodules.tasks = tasks;\n}\nloadTasks();","ea49eeb03da7f291bcca718c66707941ee97ad35d9e449c4965dc65d6191f302221b3a26a7382bcba68385111e60fb0d0dc6e26e3f0d71833707cc8ad8fc537e":"async function logOut(target) {\n\tlet liu = modules.liu;\n\tif (!liu.hasOwnProperty(target)) throw new Error(\"USER_NOT_LOGGED_IN\");\n\tlet session = liu[target].session;\n\tlet token = liu[target].logon.token;\n\tlet secureSession = modules.session.attrib(session, \"secureID\");\n\tawait modules.session.attrib(session, \"loggingOut\", true);\n\tclearInterval(liu[target].clockInterval);\n\tif (modules.session.active == session || (secureSession && modules.session.active == secureSession)) await modules.session.muteAllSessions();\n\tawait modules.session.activateSession(modules.session.systemSession);\n\tlet loggingOutWindow = modules.window(modules.session.systemSession, true);\n\tloggingOutWindow.title.innerText = modules.locales.get(\"LOGGING_OUT\");\n\tloggingOutWindow.content.style.padding = \"8px\";\n\tloggingOutWindow.closeButton.disabled = true;\n\tloggingOutWindow.content.innerText = modules.locales.get(\"LOGGING_OUT\");\n\tlet taskList = modules.session.attrib(session, \"openReeWindows\") || [];\n\tlet timeout = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n\tfunction allProcessesClosed() {\n\t\treturn new Promise(function(resolve) {\n\t\t\tlet int = setInterval(function() {\n\t\t\t\ttry {\n\t\t\t\t\ttaskList = modules.session.attrib(session, \"openReeWindows\") || [];\n\t\t\t\t\tif (Object.keys(taskList).length == 0) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t\tclearInterval(int);\n\t\t\t\t\t}\n\t\t\t\t} catch {\n\t\t\t\t\tresolve();\n\t\t\t\t\tclearInterval(int);\n\t\t\t\t}\n\t\t\t})\n\t\t});\n\t}\n\tloggingOutWindow.content.innerText = modules.locales.get(\"POLITE_CLOSE_SIGNAL\");\n\tfor (let taskId of taskList) modules.tasks.sendSignal(taskId, 15);\n\tawait Promise.race([\n\t\ttimeout(5000),\n\t\tallProcessesClosed()\n\t]);\n\tloggingOutWindow.content.innerText = modules.locales.get(\"ABRUPT_CLOSE_SIGNAL\");\n\tif (secureSession) {\n\t\ttaskList = modules.session.attrib(secureSession, \"openReeWindows\") || [];\n\t\tfor (let taskId of taskList) modules.tasks.sendSignal(taskId, 9);\n\t}\n\ttaskList = modules.session.attrib(session, \"openReeWindows\") || [];\n\tfor (let taskId of taskList) modules.tasks.sendSignal(taskId, 9);\n\tawait allProcessesClosed();\n\tloggingOutWindow.windowDiv.remove();\n\tdelete modules.liu[target];\n\tawait modules.tokens.revoke(token);\n\tif (secureSession) await modules.session.rmsession(secureSession);\n\tawait modules.session.rmsession(session);\n}\n\nmodules.logOut = logOut;","78707e166657c8a3b6d0997299044330539e8a92ec9ffaa5d22629606df7adf2d27b4d15dc2a0e8eca946f28dbe2025ad2c972eb3b4c1dc99b40362f99090fa0":"function restartLoad() {\n\t// @pcos-app-mode native\n\tfunction timeout(ms) {\n\t\treturn new Promise(resolve => setTimeout(resolve, ms));\n\t}\n\tfunction allProcessesClosed() {\n\t\treturn new Promise(function(resolve) {\n\t\t\tlet int = setInterval(function() {\n\t\t\t\tif (Object.keys(modules.tasks.tracker).length == 0) {\n\t\t\t\t\tresolve();\n\t\t\t\t\tclearInterval(int);\n\t\t\t\t}\n\t\t\t})\n\t\t});\n\t}\n\t\n\tasync function restart(noAutomaticReload = false, token, kexec) {\n\t\ttry {\n\t\t\tlet shutdownSoundPerm = await modules.fs.permissions(modules.defaultSystem + \"/etc/sounds/shutdown.aud\");\n\t\t\tif (!shutdownSoundPerm.world.includes(\"r\")) throw new Error(\"Not allowed to read shutdown.aud\");\n\t\t\tlet shutdownSound = await modules.fs.read(modules.defaultSystem + \"/etc/sounds/shutdown.aud\");\n\t\t\tlet shutdownAudio = new Audio();\n\t\t\tshutdownAudio.src = shutdownSound;\n\t\t\tshutdownAudio.play();\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to play shutdown.aud:\", e);\n\t\t}\n\t\tmodules.shuttingDown = true;\n\t\tlet window = modules.window;\n\t\tlet fs = modules.fs;\n\t\tlet tasks = modules.tasks;\n\t\tmodules.session.muteAllSessions();\n\t\tmodules.session.activateSession(modules.session.systemSession);\n\t\tlet windowDiv = window(modules.session.systemSession, true);\n\t\twindowDiv.closeButton.classList.toggle(\"hidden\", true);\n\t\twindowDiv.title.innerText = modules.locales.get(\"PCOS_RESTARTING\").replace(\"%s\", \"\");\n\t\twindowDiv.content.style.padding = \"8px\";\n\t\tlet description = document.createElement(\"p\");\n\t\tdescription.innerText = modules.locales.get(\"PCOS_RESTARTING\").replace(\"%s\", modules.locales.get(\"PLEASE_WAIT\"));\n\t\twindowDiv.content.appendChild(description);\n\t\tdescription.innerText = modules.locales.get(\"PCOS_RESTARTING\").replace(\"%s\", modules.locales.get(\"POLITE_CLOSE_SIGNAL\"));\n\t\tfor (let taskId in tasks.tracker) tasks.sendSignal(taskId, 15);\n\t\tawait Promise.race([\n\t\t\ttimeout(5000),\n\t\t\tallProcessesClosed()\n\t\t]);\n\t\ttry {\n\t\t\tmodules.websocket._handles[modules.network.ws].send(JSON.stringify({\n\t\t\t\tfinalProxyPacket: true\n\t\t\t}));\n\t\t} catch {}\n\t\tdescription.innerText = modules.locales.get(\"PCOS_RESTARTING\").replace(\"%s\", modules.locales.get(\"ABRUPT_CLOSE_SIGNAL\"));\n\t\tfor (let taskId in tasks.tracker) tasks.sendSignal(taskId, 9, true);\n\t\tawait allProcessesClosed();\n\t\ttry {\n\t\t\tmodules.websocket._handles[modules.network.ws].ws.onclose = null;\n\t\t\tmodules.websocket._handles[modules.network.ws].ws.close();\n\t\t\tdelete modules.websocket._handles[modules.network.ws];\n\t\t} catch {}\n\t\tdescription.innerText = modules.locales.get(\"PCOS_RESTARTING\").replace(\"%s\", modules.locales.get(\"UNMOUNTING_MOUNTS\"));\n\t\tfor (let mount in fs.mounts) try { await fs.sync(mount, token); } catch {}\n\t\tfor (let mount in fs.mounts) try { await fs.umount(mount, token); } catch {}\n\t\tfor (let mount in fs.mounts) try { await fs.umount(mount, token, true); } catch {}\n\t\tdescription.innerText = modules.locales.get(\"PCOS_RESTARTING\").replace(\"%s\", modules.locales.get(\"RESTARTING\"));\n\t\tif (!noAutomaticReload) {\n\t\t\tif (kexec) {\n\t\t\t\ttry {\n\t\t\t\t\tmodules.session.destroy();\n\t\t\t\t\tawait new ((async _=>0).constructor)(\n\t\t\t\t\t\tmodules.core.disk.partition(\"boot\").getData()\n\t\t\t\t\t)();\n\t\t\t\t\treturn modules.killSystem();\n\t\t\t\t} catch (e) {\n\t\t\t\t\tawait panic(\"KEXEC_FAILED\", {\n\t\t\t\t\t\tname: \"kexec\",\n\t\t\t\t\t\tunderlyingJS: e\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn location.reload();\n\t\t}\n\t\tmodules.killSystem();\n\t\tdescription.innerText = modules.locales.get(\"SAFE_TO_CLOSE\");\n\t\tlet button = document.createElement(\"button\");\n\t\tbutton.innerText = modules.locales.get(\"RESTART_BUTTON\");\n\t\tbutton.onclick = function() {\n\t\t\tdescription.innerText = modules.locales.get(\"PCOS_RESTARTING\").replace(\"%s\", modules.locales.get(\"RESTARTING\"));\n\t\t\tbutton.remove();\n\t\t\tlocation.reload();\n\t\t}\n\t\twindowDiv.content.appendChild(button);\n\t}\n\t\n\tmodules.restart = restart;\n}\n\nrestartLoad();","cb627a1b3712e5104d109c2d586be5802b00c1b0c53282399787eb0c56286ef5825c89dfa73e58934349e6f2b1b7d8c13321d457ce55b135952f2c3ed284c695":"function loadUserFriendly() {\n\t// @pcos-app-mode native\n\tmodules.userfriendliness = {\n\t\tinconsiderateTime: function(language, ms, majorUnitsOnly, displayMs) {\n\t\t\tlet string = \"\";\n\t\t\tlet days = Math.floor(ms / 86400000);\n\t\t\tlet hours = Math.floor(ms / 3600000) % 24;\n\t\t\tlet minutes = Math.floor(ms / 60000) % 60;\n\t\t\tlet seconds = Math.floor(ms / 1000) % 60;\n\t\t\tif (days) string = string + modules.locales.get(\"SHORT_DAYS\", language).replace(\"%s\", days) + \" \";\n\t\t\tif (days && majorUnitsOnly) return string;\n\t\t\tif (hours) string = string + modules.locales.get(\"SHORT_HOURS\", language).replace(\"%s\", hours) + \" \";\n\t\t\tif (hours && majorUnitsOnly) return string;\n\t\t\tif (minutes) string = string + modules.locales.get(\"SHORT_MINUTES\", language).replace(\"%s\", minutes) + \" \";\n\t\t\tif (minutes && majorUnitsOnly) return string;\n\t\t\tif (seconds) string = string + modules.locales.get(\"SHORT_SECONDS\", language).replace(\"%s\", seconds) + \" \";\n\t\t\tif (displayMs && (ms % 1000)) {\n\t\t\t\tif (seconds && majorUnitsOnly) return string;\n\t\t\t\tstring = string + modules.locales.get(\"SHORT_MILLISECONDS\", language).replace(\"%s\", (ms % 1000)) + \" \";\n\t\t\t}\n\t\t\treturn string;\n\t\t},\n\t\tinformationUnits: function(language, bytes, majorUnitsOnly) {\n\t\t\tlet string = \"\";\n\t\t\tlet tb = Math.floor(bytes / (1024 * 1024 * 1024 * 1024));\n\t\t\tlet gb = Math.floor(bytes / (1024 * 1024 * 1024)) % 1024;\n\t\t\tlet mb = Math.floor(bytes / (1024 * 1024)) % 1024;\n\t\t\tlet kb = Math.floor(bytes / 1024) % 1024;\n\t\t\tlet b = bytes % 1024;\n\t\t\tif (tb) string = string + modules.locales.get(\"SHORT_TERABYTES\", language).replace(\"%s\", tb) + \" \";\n\t\t\tif (tb && majorUnitsOnly) return string;\n\t\t\tif (gb) string = string + modules.locales.get(\"SHORT_GIGABYTES\", language).replace(\"%s\", gb) + \" \";\n\t\t\tif (gb && majorUnitsOnly) return string;\n\t\t\tif (mb) string = string + modules.locales.get(\"SHORT_MEGABYTES\", language).replace(\"%s\", mb) + \" \";\n\t\t\tif (mb && majorUnitsOnly) return string;\n\t\t\tif (kb) string = string + modules.locales.get(\"SHORT_KILOBYTES\", language).replace(\"%s\", kb) + \" \";\n\t\t\tif (kb && majorUnitsOnly) return string;\n\t\t\tif (b) string = string + modules.locales.get(\"SHORT_BYTES\", language).replace(\"%s\", b);\n\t\t\tif (b && majorUnitsOnly) return string;\n\t\t\treturn string;\n\t\t},\n\t\tconsiderateTime: function(language, ms, majorUnitsOnly, displayMs) {\n\t\t\tlet dateObject = new Date(ms + (new Date(ms).getTimezoneOffset() * 60000));\n\t\t\tlet string = \"\";\n\t\t\tlet years = dateObject.getFullYear() - 1970;\n\t\t\tlet months = dateObject.getMonth();\n\t\t\tlet days = dateObject.getDate() - 1;\n\t\t\tlet hours = dateObject.getHours();\n\t\t\tlet minutes = dateObject.getMinutes();\n\t\t\tlet seconds = dateObject.getSeconds();\n\t\t\tlet millisec = dateObject.getMilliseconds();\n\t\t\tif (years) string = string + modules.locales.get(\"SHORT_YEARS\", language).replace(\"%s\", years) + \" \";\n\t\t\tif (years && majorUnitsOnly) return string;\n\t\t\tif (months) string = string + modules.locales.get(\"SHORT_MONTHS\", language).replace(\"%s\", months) + \" \";\n\t\t\tif (months && majorUnitsOnly) return string;\n\t\t\tif (days) string = string + modules.locales.get(\"SHORT_DAYS\", language).replace(\"%s\", days) + \" \";\n\t\t\tif (days && majorUnitsOnly) return string;\n\t\t\tif (hours) string = string + modules.locales.get(\"SHORT_HOURS\", language).replace(\"%s\", hours) + \" \";\n\t\t\tif (hours && majorUnitsOnly) return string;\n\t\t\tif (minutes) string = string + modules.locales.get(\"SHORT_MINUTES\", language).replace(\"%s\", minutes) + \" \";\n\t\t\tif (minutes && majorUnitsOnly) return string;\n\t\t\tif (seconds) string = string + modules.locales.get(\"SHORT_SECONDS\", language).replace(\"%s\", seconds) + \" \";\n\t\t\tif (displayMs && millisec) {\n\t\t\t\tif (seconds && majorUnitsOnly) return string;\n\t\t\t\tstring = string + modules.locales.get(\"SHORT_MILLISECONDS\", language).replace(\"%s\", (millisec % 1000)) + \" \";\n\t\t\t}\n\t\t\treturn string;\n\t\t}\n\t}\n}\nloadUserFriendly();","a87b3e3dc1c97b19fc2bfb4eaf98e8c2cbfa93edc73aead2946b6d2e8a300eb4aeaafa16258a9c2a17764a6bd489d7bdb393fc026925c359a5075e5c06bc8b08":"function setupTokens() {\n\t// @pcos-app-mode native\n\tmodules.tokens = {\n\t\tgenerate: async function() {\n\t\t\tlet rng = crypto.getRandomValues(new Uint8Array(64));\n\t\t\tlet token = Array.from(rng).map(x => x.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\tthis._tokens[token] = { privileges: [], user: \"nobody\", groups: [] };\n\t\t\treturn token;\n\t\t},\n\t\trevoke: async function(token) {\n\t\t\tdelete this._tokens[token];\n\t\t},\n\t\tsetPrivileges: async function(token, privileges) {\n\t\t\tthis._tokens[token].privileges = privileges;\n\t\t},\n\t\taddPrivilege: async function(token, privilege) {\n\t\t\tthis._tokens[token].privileges.push(privilege);\n\t\t},\n\t\taddPrivileges: async function(token, privileges) {\n\t\t\tthis._tokens[token].privileges.push(...privileges);\n\t\t},\n\t\tremovePrivilege: async function(token, privilege) {\n\t\t\tthis._tokens[token].privileges = this._tokens[token].privileges.filter(x => x != privilege);\n\t\t},\n\t\tremovePrivileges: async function(token, privileges) {\n\t\t\tthis._tokens[token].privileges = this._tokens[token].privileges.filter(x => !privileges.includes(x));\n\t\t},\n\t\tuserInitialize: async function(token, user) {\n\t\t\tthis._tokens[token].user = user;\n\t\t\tthis._tokens[token].groups = (await modules.users.getUserInfo(user, token)).groups || [];\n\t\t\tthis._tokens[token].privileges = [\"FS_READ\", \"FS_WRITE\", \"FS_REMOVE\", \"FS_CHANGE_PERMISSION\", \"FS_LIST_PARTITIONS\", \"IPC_CREATE_PIPE\", \"IPC_LISTEN_PIPE\", \"IPC_SEND_PIPE\", \"IPC_CHANGE_PERMISSION\", \"ELEVATE_PRIVILEGES\", \"GET_USER_INFO\", \"SET_SECURITY_CHECKS\", \"START_TASK\", \"LIST_TASKS\", \"SIGNAL_TASK\", \"FETCH_SEND\", \"CSP_OPERATIONS\", \"IDENTIFY_SYSTEM\", \"WEBSOCKETS_OPEN\", \"WEBSOCKETS_LISTEN\", \"WEBSOCKETS_SEND\", \"WEBSOCKET_SET_PERMISSIONS\", \"MANAGE_TOKENS\", \"WEBSOCKET_INFO\", \"GRAB_ATTENTION\", \"CLI_MODIFICATIONS\", \"GET_THEME\", \"GET_LOCALE\", \"GET_FILESYSTEMS\", \"GET_BUILD\", \"GET_SERVER_URL\", \"START_BACKGROUND_TASK\", \"GET_BOOT_MODE\", \"GET_SCREEN_INFO\", \"PCOS_NETWORK_PING\", \"LOGOUT\", \"LULL_SYSTEM\", \"CONNLESS_LISTEN\", \"CONNLESS_SEND\", \"GET_NETWORK_ADDRESS\", \"CONNFUL_LISTEN\", \"CONNFUL_CONNECT\", \"CONNFUL_DISCONNECT\", \"CONNFUL_WRITE\", \"CONNFUL_READ\", \"CONNFUL_ADDRESS_GET\", \"SYSTEM_UPTIME\", \"GET_HOSTNAME\", \"RESOLVE_NAME\", \"PATCH_DIFF\", \"GET_BATTERY_STATUS\", \"CONNFUL_IDENTITY_GET\", \"GET_UPDATE_SERVICE\"];\n\t\t\tif (user == \"root\") this._tokens[token].privileges.push(\"FS_UNMOUNT\", \"SYSTEM_SHUTDOWN\", \"SWITCH_USERS_AUTOMATICALLY\", \"USER_INFO_OTHERS\", \"SET_USER_INFO\", \"FS_BYPASS_PERMISSIONS\", \"IPC_BYPASS_PERMISSIONS\", \"TASK_BYPASS_PERMISSIONS\", \"SENSITIVE_USER_INFO_OTHERS\", \"SYSTEM_STABILITY\", \"RUN_KLVL_CODE\", \"IDENTIFY_SYSTEM_SENSITIVE\", \"WEBSOCKET_BYPASS_PERMISSIONS\", \"LLDISK_READ\", \"LLDISK_WRITE\", \"LLDISK_LIST_PARTITIONS\", \"LLDISK_REMOVE\", \"LLDISK_IDB_READ\", \"LLDISK_IDB_WRITE\", \"LLDISK_IDB_REMOVE\", \"LLDISK_IDB_LIST\", \"LLDISK_IDB_SYNC\", \"FS_MOUNT\", \"SET_DEFAULT_SYSTEM\", \"GET_SYSTEM_RESOURCES\", \"LLDISK_INIT_PARTITIONS\", \"LOGOUT_OTHERS\", \"LULL_SYSTEM_FORCE\", \"CONNLESS_LISTEN_GLOBAL\", \"GET_USER_LIST\", \"CONNFUL_LISTEN_GLOBAL\", \"NETWORK_RAW_WRITE\", \"NETWORK_RAW_READ\", \"SET_FIRMWARE\", \"RELOAD_NETWORK_CONFIG\");\n\t\t\tif ((await modules.users.getUserInfo(user, token)).blankPrivileges) this._tokens[token].privileges = [];\n\t\t\tthis._tokens[token].privileges.push(...((await modules.users.getUserInfo(user, token)).additionalPrivilegeSet || []));\n\t\t\tthis._tokens[token].privileges = Array.from(new Set(this._tokens[token].privileges));\n\t\t},\n\t\thalfInitialize: async function(token, user) {\n\t\t\tthis._tokens[token].user = user;\n\t\t\tthis._tokens[token].groups = (await modules.users.getUserInfo(user, token)).groups || [];\n\t\t},\n\t\tinfo: async function(token) {\n\t\t\treturn this._tokens[token];\n\t\t},\n\t\tvalidate: async function(token, criteria) {\n\t\t\tif (!this._tokens.hasOwnProperty(token)) return false;\n\t\t\tif (criteria.user && this._tokens[token].user != criteria.user) return false;\n\t\t\tif (criteria.group && !this._tokens[token].groups.includes(criteria.group)) return false;\n\t\t\tif (criteria.privilege && !this._tokens[token].privileges.includes(criteria.privilege)) return false;\n\t\t\treturn true;\n\t\t},\n\t\tfork: async function(token) {\n\t\t\tlet rng = crypto.getRandomValues(new Uint8Array(64));\n\t\t\tlet newToken = Array.from(rng).map(x => x.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\tthis._tokens[newToken] = JSON.parse(JSON.stringify(this._tokens[token]));\n\t\t\treturn newToken;  \n\t\t},\n\t\t_tokens: {}\n\t}\n}\nsetupTokens();","1a01c6ed5fe0e35a492069fe7b1b4064ce84d194ebbcf577eec8ae33b2eda9eab28d2115a3e4509f07bb2ceffc48d6de2875c5ee8cac0e6e60e00715b1b932ed":"async function setupUsers() {\n\t// @pcos-app-mode native\n\tasync function handleAuthentication(user, prompts, finishFunction) {\n\t\tlet currentPromptIndex = 0;\n\t\tlet destroyed = false;\n\n\t\treturn {\n\t\t\tgetNextPrompt: async function() {\n\t\t\t\tif (destroyed) return {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tmessage: modules.locales.get(\"AUTH_FAILED_NEW\")\n\t\t\t\t};\n\t\t\t\tif (currentPromptIndex >= prompts.length) {\n\t\t\t\t\tif (finishFunction) await finishFunction(true);\n\t\t\t\t\tlet token = await modules.tokens.generate();\n\t\t\t\t\tawait modules.tokens.userInitialize(token, user);\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsuccess: true,\n\t\t\t\t\t\tmessage: modules.locales.get(\"AUTH_SUCCESS\"),\n\t\t\t\t\t\ttoken: token\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tlet that = this;\n\t\t\t\tlet currentPrompt = prompts[currentPromptIndex];\n\t\t\t\tlet used = false;\n\t\t\t\t\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: \"intermediate\",\n\t\t\t\t\ttype: currentPrompt.type,\n\t\t\t\t\tmessage: currentPrompt.message,\n\t\t\t\t\twantsUserInput: currentPrompt.userInput,\n\t\t\t\t\tchallenge: currentPrompt.challenge,\n\t\t\t\t\tinput: async function(input) {\n\t\t\t\t\t\tif (used || destroyed) return that.getNextPrompt();\n\t\t\t\t\t\tif (!used) used = true;\n\t\t\t\t\t\tlet verified;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tverified = await currentPrompt.verify(input);\n\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\tverified = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!verified) {\n\t\t\t\t\t\t\tdestroyed = true;\n\t\t\t\t\t\t\tif (finishFunction) await finishFunction(false);\n\t\t\t\t\t\t\treturn { success: false, message: modules.locales.get(\"AUTH_FAILED\") };\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcurrentPromptIndex++;\n\t\t\t\t\t\treturn that.getNextPrompt();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\t}\n\n\tlet test = \"{}\";\n\ttry {\n\t\ttest = await modules.fs.read(modules.defaultSystem + \"/etc/security/users\");\n\t} catch {\n\t\tif (!modules.settingUp) test = \"systemStatusInvalid\";\n\t}\n\ttry {\n\t\tJSON.parse(test);\n\t} catch (e) {\n\t\tif (!modules.settingUp) await panic(\"USER_SYSTEM_CORRUPTED\", {\n\t\t\tname: \"/etc/security/users\",\n\t\t\tparams: [modules.defaultSystem],\n\t\t\tunderlyingJS: e\n\t\t})\n\t}\n\n\tmodules.users = {\n\t\tinit: async function(token) {\n\t\t\tawait this.mkrecursive(modules.defaultSystem + \"/etc/security\", token);\n\t\t\tawait modules.fs.chmod(modules.defaultSystem + \"/etc\", \"rx\", token);\n\t\t\tawait this.mkrecursive(modules.defaultSystem + \"/root\", token);\n\t\t\tawait modules.fs.write(modules.defaultSystem + \"/etc/security/users\", JSON.stringify({root: {\n\t\t\t\tsecurityChecks: [],\n\t\t\t\tgroups: [\"root\"],\n\t\t\t\thomeDirectory: modules.defaultSystem + \"/root\"\n\t\t\t},\n\t\t\tauthui: {\n\t\t\t\tsecurityChecks: [],\n\t\t\t\tgroups: [\"authui\"],\n\t\t\t\thomeDirectory: modules.defaultSystem,\n\t\t\t\tblankPrivileges: true,\n\t\t\t\tadditionalPrivilegeSet:  [ \"IPC_SEND_PIPE\", \"GET_LOCALE\", \"GET_THEME\", \"ELEVATE_PRIVILEGES\", \"FS_READ\", \"FS_LIST_PARTITIONS\", \"CSP_OPERATIONS\" ]\n\t\t\t}}), token);\n\t\t},\n\t\tmkrecursive: async function(dir, token) {\n\t\t\tlet slices = dir.split(\"/\");\n\t\t\tfor (let slice in slices) {\n\t\t\t\tlet previousParts = slices.slice(0, slice).join(\"/\");\n\t\t\t\tif (!previousParts) continue;\n\t\t\t\tlet currentPart = slices[slice];\n\t\t\t\tlet check = await modules.fs.ls(previousParts, token);\n\t\t\t\tpreviousParts += \"/\";\n\t\t\t\tif (!check.includes(currentPart)) await modules.fs.mkdir(previousParts + currentPart, token);\n\t\t\t}\n\t\t},\n\t\tmoduser: async function(user, data, token) {\n\t\t\tlet userDB = JSON.parse(await modules.fs.read(modules.defaultSystem + \"/etc/security/users\"), token);\n\t\t\tuserDB[user] = data;\n\t\t\tawait modules.fs.write(modules.defaultSystem + \"/etc/security/users\", JSON.stringify(userDB), token);\n\t\t},\n\t\tgetUserInfo: async function(user, sensitive = false, token) {\n\t\t\tlet userDB = JSON.parse(await modules.fs.read(modules.defaultSystem + \"/etc/security/users\"), token);\n\t\t\tif (!userDB.hasOwnProperty(user)) return null;\n\t\t\tuserDB = userDB[user];\n\t\t\tif (!sensitive) delete userDB.securityChecks;\n\t\t\treturn userDB;\n\t\t},\n\t\tconfigured: async function(token) {\n\t\t\ttry {\n\t\t\t\tJSON.parse(await modules.fs.read(modules.defaultSystem + \"/etc/security/users\"), token);\n\t\t\t\treturn true;\n\t\t\t} catch {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\taccess: async function(user, token) {\n\t\t\tlet userDB = JSON.parse(await modules.fs.read(modules.defaultSystem + \"/etc/security/users\"), token);\n\t\t\tlet credentials = userDB[user].securityChecks;\n\t\t\tfor (let check in credentials) {\n\t\t\t\tif (credentials[check].type == \"pbkdf2\") {\n\t\t\t\t\tcredentials[check].userInput = true;\n\t\t\t\t\tcredentials[check].type = \"password\";\n\t\t\t\t\tcredentials[check].message = modules.locales.get(\"PASSWORD_PROMPT\");\n\t\t\t\t\tcredentials[check].verify = async function(input) {\n\t\t\t\t\t\treturn (await modules.core.pbkdf2(input, credentials[check].salt)) == credentials[check].hash;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (credentials[check].type == \"informative\" || credentials[check].type == \"informative_deny\") {\n\t\t\t\t\tcredentials[check].verify = () => credentials[check].type == \"informative\";\n\t\t\t\t\tcredentials[check].type = \"informative\";\n\t\t\t\t\tcredentials[check].userInput = false;\n\t\t\t\t}\n\t\t\t\tif (credentials[check].type == \"timeout\" || credentials[check].type == \"timeout_deny\") {\n\t\t\t\t\tlet isTimeout = credentials[check].type == \"timeout\";\n\t\t\t\t\tcredentials[check].message = modules.locales.get(\"PLEASE_WAIT_TIME\").replace(\"%s\", modules.userfriendliness.inconsiderateTime(credentials[check].timeout));\n\t\t\t\t\tcredentials[check].verify = () => new Promise(resolve => setTimeout(resolve, credentials[check].timeout, isTimeout));\n\t\t\t\t\tcredentials[check].type = \"promise\";\n\t\t\t\t\tcredentials[check].userInput = false;\n\t\t\t\t}\n\t\t\t\tif (credentials[check].type == \"serverReport\") {\n\t\t\t\t\tcredentials[check].message = modules.locales.get(\"REPORTING_LOGON\");\n\t\t\t\t\tcredentials[check].type = \"promise\";\n\t\t\t\t\tcredentials[check].verify = async function() {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlet response = await fetch(credentials[check].url);\n\t\t\t\t\t\t\tif (!response.ok) return false;\n\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcredentials[check].userInput = false;\n\t\t\t\t}\n\t\t\t\tif (credentials[check].type == \"pc-totp\") {\n\t\t\t\t\tcredentials[check].message = modules.locales.get(\"TOTP_PC_PROMPT\");\n\t\t\t\t\tcredentials[check].type = \"text\";\n\t\t\t\t\tcredentials[check].userInput = true;\n\t\t\t\t\tcredentials[check].verify = async function(input) {\n\t\t\t\t\t\tlet sha256 = async b => Array.from(new Uint8Array(await crypto.subtle.digest(\"SHA-256\", new TextEncoder().encode(b)))).map(a => a.toString(16).padStart(2, \"0\")).join(\"\");\n\t\t\t\t\t\tlet c = Math.floor((Math.floor(Date.now() / 1000)) / 30);\n\t\t\t\t\t\tlet hash = await sha256(credentials[check].secret + c);\n\t\t\t\t\t\thash = parseInt(hash, 16);\n\t\t\t\t\t\thash = hash % 60466176;\n\t\t\t\t\t\thash = hash.toString();\n\t\t\t\t\t\thash = hash.split(\"\", 6);\n\t\t\t\t\t\thash = hash.join(\"\");\n\t\t\t\t\t\treturn hash == input;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (credentials[check].type == \"totp\") {\n\t\t\t\t\tcredentials[check].message = modules.locales.get(\"TOTP_PROMPT\");\n\t\t\t\t\tcredentials[check].type = \"text\";\n\t\t\t\t\tcredentials[check].userInput = true;\n\t\t\t\t\tlet hexToU8A = (hex) => Uint8Array.from(hex.match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\t\t\tlet keyImport = await crypto.subtle.importKey(\"raw\", hexToU8A(credentials[check].secret?.padStart(20, \"0\")), {\n\t\t\t\t\t\tname: \"HMAC\",\n\t\t\t\t\t\thash: \"SHA-1\"\n\t\t\t\t\t}, true, [ \"sign\" ]);\n\t\t\t\t\t\n\t\t\t\t\tcredentials[check].verify = async function(input) {\n\t\t\t\t\t\tlet counter = hexToU8A(Math.floor(Date.now() / 30000).toString(16).padStart(16, \"0\"));\n\t\t\t\t\t\tlet hmacSign = await crypto.subtle.sign(\"HMAC\", keyImport, counter);\n\t\t\t\t\t\thmacSign = Array.from(new Uint8Array(hmacSign));\n\t\t\t\t\t\tlet offset = hmacSign[19] & 0xf; // https://datatracker.ietf.org/doc/html/rfc4226#section-5.4\n\t\t\t\t\t\tlet code = (hmacSign[offset] & 0x7f) << 24\n\t\t\t\t\t\t\t| (hmacSign[offset + 1] & 0xff) << 16\n\t\t\t\t\t\t\t| (hmacSign[offset + 2] & 0xff) << 8\n\t\t\t\t\t\t\t| (hmacSign[offset + 3] & 0xff);\n\t\t\t\t\t\tcode = code % 1000000;\n\t\t\t\t\t\treturn (code.toString() == input) || (code.toString().padStart(6, \"0\") == input);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (credentials[check].type == \"workingHours\") {\n\t\t\t\t\tlet workingHourStarts = new Date();\n\t\t\t\t\tworkingHourStarts.setHours(credentials[check].start.hours || 0, credentials[check].start.minutes || 0, credentials[check].start.seconds || 0);\n\t\t\t\t\tlet workingHourEnds = new Date();\n\t\t\t\t\tworkingHourEnds.setHours(credentials[check].end.hours || 0, credentials[check].end.minutes || 0, credentials[check].end.seconds || 0);\n\t\t\t\t\t\n\t\t\t\t\tif (new Date() > workingHourEnds || new Date() < workingHourStarts) {\n\t\t\t\t\t\tcredentials[check].message = modules.locales.get(\"WORKING_HOURS_UNMET\");\n\t\t\t\t\t\tcredentials[check].type = \"informative\";\n\t\t\t\t\t\tcredentials[check].userInput = false;\n\t\t\t\t\t\tcredentials[check].verify = () => false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcredentials[check].message = modules.locales.get(\"AUTH_SUCCESS\");\n\t\t\t\t\t\tcredentials[check].type = \"promise\";\n\t\t\t\t\t\tcredentials[check].userInput = false;\n\t\t\t\t\t\tcredentials[check].verify = () => true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (credentials[check].type == \"zkpp\") {\n\t\t\t\t\tcredentials[check].message = modules.locales.get(\"MODULE_REQUIRED\").replace(\"%s\", \"tweetnacl\");\n\t\t\t\t\tcredentials[check].type = \"informative\";\n\t\t\t\t\tcredentials[check].userInput = false;\n\t\t\t\t\tcredentials[check].verify = () => false;\n\t\t\t\t\tif (window.nacl) {\n\t\t\t\t\t\tlet hexToU8A = (hex) => Uint8Array.from(hex.match(/.{1,2}/g).map(a => parseInt(a, 16)));\n\t\t\t\t\t\tlet randomChallenge = crypto.getRandomValues(new Uint8Array(64)).reduce((a, b) => a + b.toString(16).padStart(2, \"0\"), \"\");\n\t\t\t\t\t\tcredentials[check].message = modules.locales.get(\"PASSWORD_PROMPT\");\n\t\t\t\t\t\tcredentials[check].type = \"zkpp_password\";\n\t\t\t\t\t\tcredentials[check].userInput = true;\n\t\t\t\t\t\tcredentials[check].challenge = randomChallenge;\n\t\t\t\t\t\tcredentials[check].verify = input => nacl.sign.detached.verify(hexToU8A(credentials[check].challenge), hexToU8A(input), hexToU8A(credentials[check].publicKey));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (credentials.length == 0) {\n\t\t\t\tcredentials.push({\n\t\t\t\t\ttype: \"informative\",\n\t\t\t\t\tmessage: modules.locales.get(\"ACCESS_NOT_SETUP\"),\n\t\t\t\t\tuserInput: false,\n\t\t\t\t\tverify: () => false\n\t\t\t\t})\n\t\t\t}\n\t\t\treturn handleAuthentication(user, credentials);\n\t\t},\n\t\tgetUsers: async function(token) {\n\t\t\tlet userDB = JSON.parse(await modules.fs.read(modules.defaultSystem + \"/etc/security/users\"), token);\n\t\t\treturn Object.keys(userDB);\n\t\t}\n\t}\n}\nawait setupUsers();","a2cef86f80e0a583cd5a8c68d4c2dd015144c641ed6f29a77200723c9c13518e4ba755f948bbd9c733cac64996992ae24c25f181f5e96a429c20cfa774b3a785":"async function authui(ses = modules.session.active, user, token, isLogonScreen) {\n\t// @pcos-app-mode native\n\tif (modules.shuttingDown) return { hook: _ => _ };\n\tlet appToken;\n\tif (token) appToken = modules.tokens.fork(token);\n\telse {\n\t\tappToken = await modules.tokens.generate();\n\t\tawait modules.tokens.userInitialize(appToken, \"authui\");\n\t}\n\tlet hook = new Function();\n\tlet ipc = await modules.ipc.create();\n\tmodules.ipc.declareAccess(ipc, { owner: \"authui\", group: \"authui\", world: false });\n\tlet windowObject = modules.window(ses);\n\tif (isLogonScreen) windowObject.closeButton.classList.toggle(\"hidden\", true);\n\tlet authTask = await modules.tasks.exec(modules.defaultSystem + \"/apps/authui.js\", [], windowObject, appToken, false, [ ipc, user || \"\" ]);\n\tasync function waitForIt() {\n\t\tlet msg = await Promise.race([\n\t\t\tmodules.ipc.listenFor(ipc),\n\t\t\tmodules.tasks.waitTermination(authTask)\n\t\t]);\n\t\tdelete modules.ipc._ipc[ipc];\n\t\ttry {\n\t\t\tawait modules.tasks.sendSignal(authTask, 9);\n\t\t\thook(msg);\n\t\t} catch {\n\t\t\thook({\n\t\t\t\tsuccess: false,\n\t\t\t\tcancelled: true\n\t\t\t});\n\t\t}\n\t}\n\twaitForIt();\n\treturn { hook: (e) => hook = e };\n}\nmodules.authui = authui;","486052a755358f960bdd4717fa4990e7e1dfb74a117b224dbc7558b0cedab080008231a2a7e3a1dde5e7c55ad1306cf29f584bd7c64790db35f7b5b3be22c080":"async function consentui(ses = modules.session.active, config, token) {\n\t// @pcos-app-mode native\n\tif (modules.shuttingDown) return { hook: _ => _ };\n\tlet appToken;\n\tif (token) appToken = modules.tokens.fork(token);\n\telse {\n\t\tappToken = await modules.tokens.generate();\n\t\tawait modules.tokens.userInitialize(appToken, \"authui\");\n\t}\n\tlet hook = new Function();\n\tlet ipc = await modules.ipc.create();\n\tmodules.ipc.declareAccess(ipc, { owner: \"authui\", group: \"authui\", world: false });\n\tlet windowObject = modules.window(ses);\n\tlet authTask = await modules.tasks.exec(modules.defaultSystem + \"/apps/consentui.js\", [], windowObject, appToken, false, [\n\t\tipc,\n\t\tconfig.user || \"\",\n\t\tJSON.stringify({\n\t\t\tpath: config.path,\n\t\t\targs: config.args,\n\t\t\tsubmittedIntent: config.intent,\n\t\t\tsubmittedName: config.name\n\t\t})\n\t]);\n\tasync function waitForIt() {\n\t\tlet msg = await Promise.race([\n\t\t\tmodules.ipc.listenFor(ipc),\n\t\t\tmodules.tasks.waitTermination(authTask)\n\t\t]);\n\t\tdelete modules.ipc._ipc[ipc];\n\t\ttry {\n\t\t\tawait modules.tasks.sendSignal(authTask, 9);\n\t\t\thook(msg);\n\t\t} catch {\n\t\t\thook({\n\t\t\t\tsuccess: false,\n\t\t\t\tcancelled: true\n\t\t\t});\n\t\t}\n\t}\n\twaitForIt();\n\treturn { hook: (e) => hook = e };\n}\nmodules.consentui = consentui;","b807e8ec228387673b3e104db8358b0033f679a01bb5f4ab176668b14b0b17c8e14dfeb0db34f6d325b10437e50dcca6c1cbcee4ac0939ce9448aa7c05bd4606":"async function requireLogon() {\n\t// @pcos-app-mode native\n\ttry {\n\t\tlet startupSoundPerm = await modules.fs.permissions(modules.defaultSystem + \"/etc/sounds/startup.aud\");\n\t\tif (!startupSoundPerm.world.includes(\"r\")) throw new Error(\"Not allowed to read startup.aud\");\n\t\tlet startupSound = await modules.fs.read(modules.defaultSystem + \"/etc/sounds/startup.aud\");\n\t\tlet startupAudio = new Audio();\n\t\tstartupAudio.src = startupSound;\n\t\tstartupAudio.play();\n\t} catch (e) {\n\t\tconsole.error(\"Failed to play startup sound:\", e);\n\t}\n\tlet liu = {};\n\tmodules.liu = liu;\n\tserviceLogon();\n\tlet insertedLockMessage = false;\n\tasync function handleLogin(resolvedLogon, liu) {\n\t\tmodules.session.muteAllSessions();\n\t\tlet userInfo = await modules.tokens.info(resolvedLogon.token);\n\t\tlet session;\n\t\tlet liuUser = userInfo.user;\n\t\tlet wasLiuLoaded = false;\n\t\tif (liu.hasOwnProperty(userInfo.user)) {\n\t\t\tsession = liu[userInfo.user].session;\n\t\t\tawait modules.tokens.revoke(resolvedLogon.token);\n\t\t\tresolvedLogon = liu[userInfo.user].logon;\n\t\t\tuserInfo = await modules.tokens.info(resolvedLogon.token);\n\t\t\twasLiuLoaded = true;\n\t\t} else {\n\t\t\tsession = modules.session.mksession();\n\t\t\tliu[userInfo.user] = {\n\t\t\t\tsession,\n\t\t\t\tlogon: resolvedLogon,\n\t\t\t}\n\t\t}\n\t\tif (modules.session.attrib(session, \"secureID\")) return modules.session.activateSession(modules.session.attrib(session, \"secureID\"));\n\t\tmodules.session.activateSession(session);\n\t\tlet dom = modules.session.tracker[session].html;\n\t\tlet bgPic = \"\";\n\t\tlet isDark = false;\n\t\tlet locale;\n\t\tlet basicPrivilegeChecklist = [ \"FS_READ\", \"FS_LIST_PARTITIONS\", \"IPC_SEND_PIPE\", \"IPC_LISTEN_PIPE\", \"START_TASK\", \"GET_LOCALE\", \"GET_THEME\", \"LOGOUT\" ];\n\t\tif (!basicPrivilegeChecklist.every(privilege => userInfo.privileges.includes(privilege))) {\n\t\t\tlet failureMessage = modules.window(session);\n\t\t\tfailureMessage.title.innerText = \"Permission denied\";\n\t\t\tfailureMessage.content.style.padding = \"8px\";\n\t\t\tfailureMessage.content.innerText = \"There were not enough privileges to log you in. Please contact your system administrator.\";\n\t\t\tfailureMessage.closeButton.onclick = async function() {\n\t\t\t\tfailureMessage.windowDiv.remove();\n\t\t\t\tawait modules.logOut(userInfo.user);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tlet permissions = await modules.fs.permissions((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.wallpaper\", resolvedLogon.token);\n\t\t\tif (permissions.owner != userInfo.user && !userInfo.groups.includes(permissions.group) && !(permissions.world.includes(\"r\") && permissions.world.includes(\"x\")) && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\tthrow new Error(\"Permission denied reading wallpaper\");\n\t\t\t}\n\t\t\tbgPic = await modules.fs.read((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.wallpaper\", resolvedLogon.token);\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to read wallpaper:\", e);\n\t\t}\n\t\ttry {\n\t\t\tlet permissionsdm = await modules.fs.permissions((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.darkmode\", resolvedLogon.token);\n\t\t\tif (permissionsdm.owner != userInfo.user && !userInfo.groups.includes(permissionsdm.group) && !(permissionsdm.world.includes(\"r\") && permissionsdm.world.includes(\"x\")) && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\tthrow new Error(\"Permission denied reading dark mode preference\");\n\t\t\t}\n\t\t\tisDark = (await modules.fs.read((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.darkmode\", resolvedLogon.token)) == \"true\";\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to read dark mode preference:\", e);\n\t\t}\n\t\ttry {\n\t\t\tlet permissionsloc = await modules.fs.permissions((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.locale\", resolvedLogon.token);\n\t\t\tif (permissionsloc.owner != userInfo.user && !userInfo.groups.includes(permissionsloc.group) && !(permissionsloc.world.includes(\"r\") && permissionsloc.world.includes(\"x\")) && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\tthrow new Error(\"Permission denied reading locale preference\");\n\t\t\t}\n\t\t\tlocale = await modules.fs.read((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.locale\", resolvedLogon.token);\n\t\t\tmodules.session.attrib(session, \"language\", locale);\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to read dark mode preference:\", e);\n\t\t}\n\t\tif (modules.core.bootMode == \"safe\") {\n\t\t\tisDark = true;\n\t\t\tif (!wasLiuLoaded) {\n\t\t\t\tlet message = document.createElement(\"span\");\n\t\t\t\tmessage.innerText = modules.locales.get(\"SAFE_MODE_MSG\", locale);\n\t\t\t\tmessage.style = \"position: absolute; right: 8px; bottom: 8px; color: white;\";\n\t\t\t\tdom.appendChild(message);\n\t\t\t\tlet message2 = document.createElement(\"span\");\n\t\t\t\tmessage2.innerText = modules.locales.get(\"SAFE_MODE_MSG\", locale);\n\t\t\t\tmessage2.style = \"position: absolute; top: 8px; left: 8px; color: white;\";\n\t\t\t\tdom.appendChild(message2);\n\t\t\t}\n\t\t\tbgPic = \"\";\n\t\t}\n\t\tif (modules.core.bootMode == \"disable-harden\" && !wasLiuLoaded) {\n\t\t\tlet message = document.createElement(\"span\");\n\t\t\tmessage.innerText = modules.locales.get(\"INSECURE_MODE_MSG\", locale);\n\t\t\tmessage.style = \"position: absolute; right: 8px; bottom: 8px; color: white;\";\n\t\t\tdom.appendChild(message);\n\t\t\tlet message2 = document.createElement(\"span\");\n\t\t\tmessage2.innerText = modules.locales.get(\"INSECURE_MODE_MSG\", locale);\n\t\t\tmessage2.style = \"position: absolute; top: 8px; left: 8px; color: white;\";\n\t\t\tdom.appendChild(message2);\n\t\t}\n\t\tmodules.session.attrib(session, \"dark\", isDark);\n\t\tdom.style.background = \"url(\" + JSON.stringify(bgPic) + \")\";\n\t\tif (modules.core.bootMode == \"safe\") dom.style.background = \"black\";\n\t\tdom.style.backgroundSize = \"100% 100%\";\n\t\tif (!wasLiuLoaded) {\n\t\t\tlet autoRunNecessities = [];\n\t\t\ttry {\n\t\t\t\tlet autoRunPermissions = await modules.fs.permissions((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.autorunNecessity\", resolvedLogon.token);\n\t\t\t\tif (autoRunPermissions.owner != userInfo.user && !userInfo.groups.includes(autoRunPermissions.group) && !(autoRunPermissions.world.includes(\"r\") && autoRunPermissions.world.includes(\"x\")) && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\t\tthrow new Error(\"Permission denied reading autorun necessities\");\n\t\t\t\t}\n\t\t\t\tif (modules.core.bootMode != \"safe\") autoRunNecessities = await modules.fs.ls((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.autorunNecessity\", resolvedLogon.token);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(\"Failed to read autorun necessities:\", e);\n\t\t\t}\n\t\t\tfunction breakNecessityFailure() {\n\t\t\t\tlet failureMessage = modules.window(session);\n\t\t\t\tfailureMessage.title.innerText = modules.locales.get(\"PERMISSION_DENIED\", locale);\n\t\t\t\tfailureMessage.content.style.padding = \"8px\";\n\t\t\t\tfailureMessage.content.innerText = modules.locales.get(\"AUTORUN_NECESSITIES_FAILED\", locale);\n\t\t\t\tfailureMessage.closeButton.onclick = async function() {\n\t\t\t\t\tfailureMessage.windowDiv.remove();\n\t\t\t\t\tawait modules.logOut(userInfo.user);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let autoRunNecessity of autoRunNecessities) {\n\t\t\t\tlet necessityPermissions = await modules.fs.permissions((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.autorunNecessity/\" + autoRunNecessity, resolvedLogon.token);\n\t\t\t\tif (necessityPermissions.owner != userInfo.user && !userInfo.groups.includes(necessityPermissions.group) && !(necessityPermissions.world.includes(\"r\") && necessityPermissions.world.includes(\"x\")) && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\t\treturn breakNecessityFailure();\n\t\t\t\t}\n\t\t\t\tlet link = await modules.fs.read((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.autorunNecessity/\" + autoRunNecessity, resolvedLogon.token);\n\t\t\t\ttry {\n\t\t\t\t\tlink = JSON.parse(link);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(\"Failed to parse autorun necessity:\", e);\n\t\t\t\t\treturn breakNecessityFailure();\n\t\t\t\t}\n\t\t\t\tif (link.disabled) continue;\n\t\t\t\ttry {\n\t\t\t\t\tlet ipcPipe = modules.ipc.create();\n\t\t\t\t\tmodules.ipc.declareAccess(ipcPipe, {\n\t\t\t\t\t\towner: userInfo.user,\n\t\t\t\t\t\tgroup: userInfo.groups[0],\n\t\t\t\t\t\tworld: false\n\t\t\t\t\t});\n\t\t\t\t\tlet forkedToken;\n\t\t\t\t\tif (link.automaticLogon) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlet logon = await modules.users.access(link.automaticLogon.username, resolvedLogon.token);\n\t\t\t\t\t\t\tlogon = await logon.getNextPrompt();\n\t\t\t\t\t\t\tfor (let response of link.automaticLogon.responses)\n\t\t\t\t\t\t\t\tif (logon.success == \"intermediate\") logon = await logon.input(response);\n\t\t\t\t\t\t\tif (!logon.success) throw new Error(logon.message);\n\t\t\t\t\t\t\tforkedToken = logon.token;\n\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\tif (necessityPermissions.world.includes(\"r\") && forkedToken) {\n\t\t\t\t\t\t\tlet ownUser = await modules.tokens.info(forkedToken);\n\t\t\t\t\t\t\tlet ownUserInfo = await modules.users.getUserInfo(ownUser.user, true, forkedToken);\n\t\t\t\t\t\t\townUserInfo.securityChecks = [];\n\t\t\t\t\t\t\tawait modules.users.moduser(ownUser.user, ownUserInfo, forkedToken);\n\t\t\t\t\t\t\tawait modules.tokens.revoke(forkedToken);\n\t\t\t\t\t\t\tforkedToken = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!forkedToken) forkedToken = await modules.tokens.fork(resolvedLogon.token);\n\t\t\t\t\tlet appWindow = modules.window(session);\n\t\t\t\t\tlet ipcResult = modules.ipc.listenFor(ipcPipe);\n\t\t\t\t\tlet taskId = await modules.tasks.exec(link.path, [ ...(link.args || []), ipcPipe ], appWindow, forkedToken, true);\n\t\t\t\t\tlet finishTaskPromise = new Promise(function(resolve) {\n\t\t\t\t\t\tmodules.tasks.tracker[taskId].ree.beforeCloseDown(() => resolve());\n\t\t\t\t\t})\n\t\t\t\t\tipcResult = await Promise.race([ipcResult, finishTaskPromise]);\n\t\t\t\t\tif (!ipcResult) throw new Error(\"Software rejected autorun necessity.\");\n\t\t\t\t\tif (modules.tasks.tracker.hasOwnProperty(taskId)) await modules.tasks.sendSignal(taskId, 9);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(\"Failed to execute autorun necessity:\", e);\n\t\t\t\t\treturn breakNecessityFailure();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlet autoRun = [];\n\t\t\ttry {\n\t\t\t\tlet autoRunPermissions = await modules.fs.permissions((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.autorun\", resolvedLogon.token);\n\t\t\t\tif (autoRunPermissions.owner != userInfo.user && !userInfo.groups.includes(autoRunPermissions.group) && !(autoRunPermissions.world.includes(\"r\") && autoRunPermissions.world.includes(\"x\")) && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\t\tthrow new Error(\"Permission denied reading autorun\");\n\t\t\t\t}\n\t\t\t\tif (modules.core.bootMode != \"safe\") autoRun = await modules.fs.ls((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.autorun\", resolvedLogon.token);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(\"Failed to read autorun:\", e);\n\t\t\t}\n\t\t\tfor (let autoRunFile of autoRun) {\n\t\t\t\tlet autoRunItemPermissions = await modules.fs.permissions((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.autorun/\" + autoRunFile, resolvedLogon.token);\n\t\t\t\tif (autoRunItemPermissions.owner != userInfo.user && !userInfo.groups.includes(autoRunItemPermissions.group) && !(autoRunItemPermissions.world.includes(\"r\") && autoRunItemPermissions.world.includes(\"x\")) && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) continue;\n\t\t\t\tlet link = await modules.fs.read((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/.autorun/\" + autoRunFile, resolvedLogon.token);\n\t\t\t\ttry {\n\t\t\t\t\tlink = JSON.parse(link);\n\t\t\t\t} catch {}\n\t\t\t\tif (link.disabled) continue;\n\t\t\t\ttry {\n\t\t\t\t\tlet forkedToken;\n\t\t\t\t\tif (link.automaticLogon) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlet logon = await modules.users.access(link.automaticLogon.username, resolvedLogon.token);\n\t\t\t\t\t\t\tlogon = await logon.getNextPrompt();\n\t\t\t\t\t\t\tfor (let response of link.automaticLogon.responses)\n\t\t\t\t\t\t\t\tif (logon.success == \"intermediate\") logon = await logon.input(response);\n\t\t\t\t\t\t\tif (!logon.success) throw new Error(logon.message);\n\t\t\t\t\t\t\tforkedToken = logon.token;\n\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\tif (autoRunItemPermissions.world.includes(\"r\") && forkedToken) {\n\t\t\t\t\t\t\tlet ownUser = await modules.tokens.info(forkedToken);\n\t\t\t\t\t\t\tlet ownUserInfo = await modules.users.getUserInfo(ownUser.user, true, forkedToken);\n\t\t\t\t\t\t\townUserInfo.securityChecks = [];\n\t\t\t\t\t\t\tawait modules.users.moduser(ownUser.user, ownUserInfo, forkedToken);\n\t\t\t\t\t\t\tawait modules.tokens.revoke(forkedToken);\n\t\t\t\t\t\t\tforkedToken = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!forkedToken) forkedToken = await modules.tokens.fork(resolvedLogon.token);\n\t\t\t\t\tlet appWindow = modules.window(session);\n\t\t\t\t\tawait modules.tasks.exec(link.path, [ ...(link.args || []) ], appWindow, forkedToken);\n\t\t\t\t} catch {}\n\t\t\t}\n\n\t\t\tlet icons = [];\n\t\t\tlet lastIconPlacement = [ 72, 72 ];\n\t\t\ttry {\n\t\t\t\tlet permissions = await modules.fs.permissions((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/desktop\", resolvedLogon.token);\n\t\t\t\tif (permissions.owner != userInfo.user && !userInfo.groups.includes(permissions.group) && !(permissions.world.includes(\"r\") && permissions.world.includes(\"x\")) && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\t\tthrow new Error(\"Permission denied reading desktop icons\");\n\t\t\t\t}\n\t\t\t\ticons = await modules.fs.ls((await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/desktop\", resolvedLogon.token);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(\"Failed to read desktop icons:\", e);\n\t\t\t}\n\t\t\tfor (let icon of icons) {\n\t\t\t\tif (icon.split(\"/\").slice(-1)[0].startsWith(\".\")) continue;\n\t\t\t\ttry {\n\t\t\t\t\tlet iconPath = (await modules.users.getUserInfo(userInfo.user, false, resolvedLogon.token)).homeDirectory + \"/desktop/\" + icon;\n\t\t\t\t\tlet permissions = await modules.fs.permissions(iconPath, resolvedLogon.token);\n\t\t\t\t\tif (permissions.owner != userInfo.user && !userInfo.groups.includes(permissions.group) && !permissions.world.includes(\"r\") && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\t\t\tthrow new Error(\"Permission denied reading desktop icon\");\n\t\t\t\t\t}\n\t\t\t\t\tlet isDir = await modules.fs.isDirectory(iconPath, resolvedLogon.token);\n\t\t\t\t\tlet linkName = iconPath.split(\"/\").slice(-1)[0];\n\t\t\t\t\tlet appLink = { path: modules.defaultSystem + \"/apps/explorer.js\", args: [ iconPath ], name: linkName, placed: lastIconPlacement, icon: modules.defaultSystem + \"/etc/icons/fileicon.pic\" };\n\t\t\t\t\tif (!isDir) {\n\t\t\t\t\t\tif (linkName.endsWith(\".lnk\")) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tappLink = { placed: lastIconPlacement, icon: modules.defaultSystem + \"/etc/icons/lnk.pic\", ...(JSON.parse(await modules.fs.read(iconPath, resolvedLogon.token))) };\n\t\t\t\t\t\t\t\tappLink._isRealLink = true;\n\t\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet ext = linkName.split(\".\").slice(-1)[0];\n\t\t\t\t\t\t\tappLink.icon = modules.defaultSystem + \"/etc/icons/\" + ext + \".pic\";\n\t\t\t\t\t\t\tlet assocsPermissions = await modules.fs.permissions(modules.defaultSystem + \"/apps/associations\", resolvedLogon.token);\n\t\t\t\t\t\t\tif (assocsPermissions.owner != userInfo.user && !userInfo.groups.includes(assocsPermissions.group) && !(assocsPermissions.world.includes(\"r\") && assocsPermissions.world.includes(\"x\")) && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\t\t\t\t\tthrow new Error(\"Permission denied reading associations\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet associations = await modules.fs.ls(modules.defaultSystem + \"/apps/associations\", resolvedLogon.token);\n\t\t\t\t\t\t\tif (!associations.includes(ext)) appLink.disabled = true;\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tlet associationPermissions = await modules.fs.permissions(modules.defaultSystem + \"/apps/associations/\" + ext, resolvedLogon.token);\n\t\t\t\t\t\t\t\tif (!associationPermissions.world.includes(\"r\") && !userInfo.groups.includes(associationPermissions.group) && associationPermissions.owner != userInfo.user && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\t\t\t\t\t\tthrow new Error(\"Permission denied reading association\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tappLink = { placed: lastIconPlacement, icon: appLink.icon, ...(JSON.parse(await modules.fs.read(modules.defaultSystem + \"/apps/associations/\" + ext, resolvedLogon.token))) };\n\t\t\t\t\t\t\t\tappLink.args = [ ...(appLink.args || []), iconPath ];\n\t\t\t\t\t\t\t\tappLink.name = linkName;\n\t\t\t\t\t\t\t\tdelete appLink.localeDatabaseName;\n\t\t\t\t\t\t\t\tdelete appLink.localeReferenceName;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (appLink.disabled) continue;\n\t\t\t\t\tif (isDir) appLink.icon = modules.defaultSystem + \"/etc/icons/foldericon.pic\";\n\t\t\t\t\tlet iconWindow = modules.window(session, false, true, async function(newx, newy) {\n\t\t\t\t\t\tif (appLink._isRealLink) {\n\t\t\t\t\t\t\tappLink.placed = [ newx, newy ];\n\t\t\t\t\t\t\tdelete appLink._isRealLink;\n\t\t\t\t\t\t\tif (permissions.owner != userInfo.user && !userInfo.groups.includes(permissions.group) && !permissions.world.includes(\"w\") && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\t\t\t\t\tthrow new Error(\"Permission denied writing desktop icon\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tawait modules.fs.write(iconPath, JSON.stringify(appLink), resolvedLogon.token);\n\t\t\t\t\t\t\tappLink._isRealLink = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\ticonWindow.title.innerText = (appLink.localeReferenceName ? modules.locales.get(appLink.localeReferenceName, locale) : null) || (appLink.localeDatabaseName ? (appLink.localeDatabaseName[locale] || appLink.localeDatabaseName[modules.locales.defaultLocale] || appLink.localeDatabaseName[navigator.language.slice(0, 2).toLowerCase()]) : null) || appLink.name;\n\t\t\t\t\tlet iconEl = document.createElement(\"img\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet permissions = await modules.fs.permissions(appLink.icon, resolvedLogon.token);\n\t\t\t\t\t\tif (permissions.owner != userInfo.user && !userInfo.groups.includes(permissions.group) && !permissions.world.includes(\"r\") && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\t\t\t\tthrow new Error(\"Permission denied reading desktop icon picture\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\ticonEl.src = await modules.fs.read(appLink.icon, resolvedLogon.token);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tconsole.error(\"Failed to read desktop icon picture:\", e);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\ticonEl.style = \"width: 100%; height: 100%; position: absolute;\";\n\t\t\t\t\ticonWindow.content.appendChild(iconEl);\n\t\t\t\t\ticonWindow.windowDiv.style.top = appLink.placed[1] + \"px\";\n\t\t\t\t\ticonWindow.windowDiv.style.left = appLink.placed[0] + \"px\";\n\t\t\t\t\ticonEl.addEventListener(\"click\", async function() {\n\t\t\t\t\t\tlet forkedToken;\n\t\t\t\t\t\tif (appLink.automaticLogon) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlet logon = await modules.users.access(appLink.automaticLogon.username, resolvedLogon.token);\n\t\t\t\t\t\t\t\tlogon = await logon.getNextPrompt();\n\t\t\t\t\t\t\t\tfor (let response of appLink.automaticLogon.responses)\n\t\t\t\t\t\t\t\t\tif (logon.success == \"intermediate\") logon = await logon.input(response);\n\t\t\t\t\t\t\t\tif (!logon.success) throw new Error(logon.message);\n\t\t\t\t\t\t\t\tforkedToken = logon.token;\n\t\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!forkedToken) forkedToken = await modules.tokens.fork(resolvedLogon.token);\n\t\t\t\t\t\tlet appWindow = modules.window(session);\n\t\t\t\t\t\tawait modules.tasks.exec(appLink.path, [ ...(appLink.args || []) ], appWindow, forkedToken);\n\t\t\t\t\t});\n\t\t\t\t\tlastIconPlacement = appLink.placed;\n\t\t\t\t\tlastIconPlacement[1] += 136;\n\t\t\t\t\tif (lastIconPlacement[1] > (dom.clientHeight - 136)) {\n\t\t\t\t\t\tlastIconPlacement[0] += 136;\n\t\t\t\t\t\tlastIconPlacement[1] = 72;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(\"Failed to read desktop icon:\", e);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet startMenuChannel = modules.ipc.create();\n\t\t\tmodules.ipc.declareAccess(startMenuChannel, {\n\t\t\t\towner: userInfo.user,\n\t\t\t\tgroup: userInfo.groups[0],\n\t\t\t\tworld: false\n\t\t\t});\n\t\t\tlet taskbar = document.createElement(\"div\");\n\t\t\tlet clock = document.createElement(\"span\");\n\t\t\tlet startButton = document.createElement(\"button\");\n\t\t\tlet startMenu = modules.window(session);\n\t\t\tlet forkedStartMenuToken = await modules.tokens.fork(resolvedLogon.token);\n\n\t\t\tfunction startMenuStub() {\n\t\t\t\tif (startMenu.windowDiv.parentElement == null) startMenu = modules.window(session);\n\t\t\t\tstartMenu.windowDiv.classList.toggle(\"hidden\", true);\n\t\t\t\tstartMenu.title.innerText = modules.locales.get(\"START_MENU\", locale);\n\t\t\t\tstartMenu.content.style.padding = \"8px\";\n\t\t\t\tstartMenu.content.innerText = \"\";\n\t\t\t\tlet description = document.createElement(\"span\");\n\t\t\t\tlet logout = document.createElement(\"button\");\n\t\t\t\tdescription.innerText = modules.locales.get(\"START_MENU_FAILED\", locale);\n\t\t\t\tlogout.innerText = modules.locales.get(\"LOG_OUT_BUTTON\", locale).replace(\"%s\", userInfo.user);\n\t\t\t\tlogout.onclick = _ => modules.logOut(userInfo.user);\n\t\t\t\tstartMenu.content.appendChild(description);\n\t\t\t\tstartMenu.content.appendChild(document.createElement(\"br\"));\n\t\t\t\tstartMenu.content.appendChild(logout);\n\t\t\t\tstartMenu.closeButton.onclick = () => startMenu.windowDiv.classList.toggle(\"hidden\", true);\n\t\t\t\tstartButton.onclick = _ => startMenu.windowDiv.classList.toggle(\"hidden\");\n\t\t\t}\n\n\t\t\tstartMenuStub();\n\t\t\tstartButton.innerText = modules.locales.get(\"START_MENU_BTN\", locale);\n\t\t\tstartButton.style = \"padding: 4px;\";\n\t\t\ttry {\n\t\t\t\tawait modules.tasks.exec(modules.defaultSystem + \"/apps/startMenu.js\", [], startMenu, forkedStartMenuToken, true, startMenuChannel);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(\"Failed to start start menu:\", e);\n\t\t\t\tstartMenuStub();\n\t\t\t}\n\n\t\t\t(async function() {\n\t\t\t\twhile (true) {\n\t\t\t\t\tlet listen = await modules.ipc.listenFor(startMenuChannel);\n\t\t\t\t\tif (listen.run) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlet forkedToken;\n\t\t\t\t\t\t\tif (listen.run.automaticLogon) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tlet logon = await modules.users.access(listen.run.automaticLogon.username, resolvedLogon.token);\n\t\t\t\t\t\t\t\t\tlogon = await logon.getNextPrompt();\n\t\t\t\t\t\t\t\t\tfor (let response of listen.run.automaticLogon.responses)\n\t\t\t\t\t\t\t\t\t\tif (logon.success == \"intermediate\") logon = await logon.input(response);\n\t\t\t\t\t\t\t\t\tif (!logon.success) throw new Error(logon.message);\n\t\t\t\t\t\t\t\t\tforkedToken = logon.token;\n\t\t\t\t\t\t\t\t} catch {}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!forkedToken) forkedToken = await modules.tokens.fork(resolvedLogon.token);\n\t\t\t\t\t\t\tlet appWindow = modules.window(session);\n\t\t\t\t\t\t\tawait modules.tasks.exec(listen.run.path, [ ...(listen.run.args || []) ], appWindow, forkedToken);\n\t\t\t\t\t\t} catch {}\n\t\t\t\t\t} else if (listen.success) {\n\t\t\t\t\t\tstartButton.onclick = () => modules.ipc.send(startMenuChannel, { open: true });\n\t\t\t\t\t} else if (listen.dying) {\n\t\t\t\t\t\tstartMenu = modules.window(session);\n\t\t\t\t\t\tstartMenuStub();\n\t\t\t\t\t\tforkedStartMenuToken = await modules.tokens.fork(resolvedLogon.token);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait modules.tasks.exec(modules.defaultSystem + \"/apps/startMenu.js\", [], startMenu, forkedStartMenuToken, true, startMenuChannel);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tconsole.error(\"Failed to start start menu:\", e);\n\t\t\t\t\t\t\tstartMenuStub();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})();\n\n\t\t\ttaskbar.className = \"taskbar\";\n\t\t\tclock.className = \"clock\";\n\t\t\tlet filler = document.createElement(\"div\");\n\t\t\tfiller.className = \"filler\";\n\t\t\tlet battery = document.createElement(\"div\");\n\t\t\tlet networkIcon = document.createElement(\"div\");\n\t\t\tlet pcosNetworkIcon = document.createElement(\"div\");\n\t\t\tlet iconCache = {};\n\t\t\tfor (let iconFile of [\"network_\", \"network_offline_\", \"pcos_network_\", \"pcos_network_offline_\", \"readyToPlay_\", \"batteryChargeFinished_\", \"dying_\", \"charging_\"]) {\n\t\t\t\ttry {\n\t\t\t\t\tlet permissions = await modules.fs.permissions(modules.defaultSystem + \"/etc/icons/\" + iconFile + \"icon.pic\", resolvedLogon.token);\n\t\t\t\t\tif (permissions.owner != userInfo.user && !userInfo.groups.includes(permissions.group) && !permissions.world.includes(\"r\") && !userInfo.privileges.includes(\"FS_BYPASS_PERMISSIONS\")) {\n\t\t\t\t\t\tthrow new Error(\"Permission denied reading taskbar icon picture\");\n\t\t\t\t\t}\n\t\t\t\t\ticonCache[iconFile] = await modules.fs.read(modules.defaultSystem + \"/etc/icons/\" + iconFile + \"icon.pic\", resolvedLogon.token);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(\"Failed to read taskbar icon picture:\", e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet toggle = false;\n\t\t\tclock.addEventListener(\"click\", _ => toggle = !toggle);\n\t\t\tliu[liuUser].clockInterval = setInterval(async function() {\n\t\t\t\tclock.innerText = Intl.DateTimeFormat(locale, { timeStyle: toggle ? undefined : \"medium\" }).format()\n\t\t\t\tnetworkIcon.style.backgroundImage = \"url(\" + JSON.stringify(navigator.onLine ? iconCache.network_ : iconCache.network_offline_) + \")\";\n\t\t\t\tnetworkIcon.title = modules.locales.get(\"NETWORK_STATUS_\" + (navigator.onLine ? \"ONLINE\" : \"OFFLINE\"), locale)\n\t\t\t\tpcosNetworkIcon.style.backgroundImage = \"url(\" + JSON.stringify(modules.network.connected ? iconCache.pcos_network_ : iconCache.pcos_network_offline_) + \")\";\n\t\t\t\tpcosNetworkIcon.title = modules.locales.get(\"PCOS_NETWORK_STATUS_\" + (modules.network.connected ? \"ONLINE\" : \"OFFLINE\"), locale).replace(\"%s\", userInfo.privileges.includes(\"GET_HOSTNAME\") ? (modules.network.hostname || modules.locales.get(\"UNKNOWN_PLACEHOLDER\", locale)) : modules.locales.get(\"UNKNOWN_PLACEHOLDER\", locale)).replace(\"%s\", userInfo.privileges.includes(\"GET_NETWORK_ADDRESS\") ? (modules.network.address || \"0\").match(/.{1,4}/g).join(\":\") : modules.locales.get(\"UNKNOWN_PLACEHOLDER\", locale));\n\t\t\t\tif (modules.network.serviceStopped) pcosNetworkIcon.title = modules.locales.get(\"PCOS_NETWORK_STATUS_STOPPED\", locale);\n\t\t\t\tlet batteryStatus = {charging: true, chargingTime: 0, dischargingTime: 0, level: 1};\n\t\t\t\tlet batteryStatusIcon = iconCache.readyToPlay_;\n\t\t\t\tlet batteryStatusDescription = modules.locales.get(\"BATTERY_STATUS_UNAVAILABLE\", locale);\n\t\t\t\tif (navigator.getBattery && userInfo.privileges.includes(\"GET_BATTERY_STATUS\")) {\n\t\t\t\t\tbatteryStatus = await navigator.getBattery();\n\t\t\t\t\tbatteryStatusDescription = modules.locales.get(\"BATTERY_STATUS_\" + (batteryStatus.charging ? \"CHARGING\" : \"DISCHARGING\"), locale)\n\t\t\t\t\t\t.replace(\"%s\", (batteryStatus.level * 100).toFixed(2))\n\t\t\t\t\t\t.replace(\"%s\", modules.userfriendliness.inconsiderateTime(\n\t\t\t\t\t\t\t(batteryStatus.charging ? batteryStatus.chargingTime : batteryStatus.dischargingTime) * 1000\n\t\t\t\t\t\t));\n\t\t\t\t\tif (batteryStatus.level < 0.2) batteryStatusIcon = iconCache.dying_;\n\t\t\t\t\tif (batteryStatus.charging) batteryStatusIcon = batteryStatus.level == 1 ? iconCache.batteryChargeFinished_ : iconCache.charging_;\n\t\t\t\t}\n\t\t\t\tbattery.style.backgroundImage = \"url(\" + JSON.stringify(batteryStatusIcon) + \")\";\n\t\t\t\tbattery.title = batteryStatusDescription;\n\t\t\t}, 500);\n\t\t\t\n\t\t\tbattery.className = \"icon\";\n\t\t\tnetworkIcon.className = \"icon\";\n\t\t\tpcosNetworkIcon.className = \"icon\";\n\t\t\ttaskbar.appendChild(startButton);\n\t\t\ttaskbar.appendChild(filler);\n\t\t\ttaskbar.appendChild(battery);\n\t\t\ttaskbar.appendChild(networkIcon);\n\t\t\ttaskbar.appendChild(pcosNetworkIcon);\n\t\t\ttaskbar.appendChild(clock);\n\t\t\tdom.appendChild(taskbar);\n\t\t}\n\t}\n\twhile (!modules.shuttingDown) {\n\t\tlet useDefaultUser = await modules.fs.permissions(modules.defaultSystem + \"/etc/security/automaticLogon\");\n\t\tuseDefaultUser = !useDefaultUser.world.includes(\"w\");\n\t\tlet defaultUser;\n\t\ttry {\n\t\t\tif (useDefaultUser) defaultUser = await modules.fs.read(modules.defaultSystem + \"/etc/security/automaticLogon\");\n\t\t} catch {}\n\t\tlet sysDom = modules.session.tracker[modules.session.systemSession].html;\n\t\tlet lockWallpaper = \"\";\n\t\tlet lockIsDark = false;\n\t\ttry {\n\t\t\tlockWallpaper = await modules.fs.read(modules.defaultSystem + \"/etc/wallpapers/lockscreen.pic\");\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to read lockscreen.pic:\", e);\n\t\t}\n\t\ttry {\n\t\t\tlockIsDark = (await modules.fs.read(modules.defaultSystem + \"/etc/darkLockScreen\")) == \"true\";\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to read darkLockScreen:\", e);\n\t\t}\n\t\tif (modules.core.bootMode == \"safe\") {\n\t\t\tlockIsDark = true;\n\t\t\tlockWallpaper = \"\";\n\t\t\tif (!insertedLockMessage) {\n\t\t\t\tinsertedLockMessage = true;\n\t\t\t\tlet message = document.createElement(\"span\");\n\t\t\t\tmessage.innerText = modules.locales.get(\"SAFE_MODE_MSG\");\n\t\t\t\tmessage.style = \"position: absolute; right: 8px; bottom: 8px; color: white;\";\n\t\t\t\tsysDom.appendChild(message);\n\t\t\t\tlet message2 = document.createElement(\"span\");\n\t\t\t\tmessage2.innerText = modules.locales.get(\"SAFE_MODE_MSG\");\n\t\t\t\tmessage2.style = \"position: absolute; top: 8px; left: 8px; color: white;\";\n\t\t\t\tsysDom.appendChild(message2);\n\t\t\t}\n\t\t}\n\t\tif (modules.core.bootMode == \"disable-harden\" && !insertedLockMessage) {\n\t\t\tinsertedLockMessage = true;\n\t\t\tlet message = document.createElement(\"span\");\n\t\t\tmessage.innerText = modules.locales.get(\"INSECURE_MODE_MSG\");\n\t\t\tmessage.style = \"position: absolute; right: 8px; bottom: 8px; color: white;\";\n\t\t\tsysDom.appendChild(message);\n\t\t\tlet message2 = document.createElement(\"span\");\n\t\t\tmessage2.innerText = modules.locales.get(\"INSECURE_MODE_MSG\");\n\t\t\tmessage2.style = \"position: absolute; top: 8px; left: 8px; color: white;\";\n\t\t\tsysDom.appendChild(message2);\n\t\t}\n\t\tsysDom.style.background = \"url(\" + JSON.stringify(lockWallpaper) + \")\";\n\t\tif (modules.core.bootMode == \"safe\") sysDom.style.background = \"black\";\n\t\tsysDom.style.backgroundSize = \"100% 100%\";\n\t\tmodules.session.attrib(modules.session.systemSession, \"dark\", lockIsDark);\n\t\tlet logon, resolvedLogon;\n\t\twhile (!modules.shuttingDown) {\n\t\t\tlogon = await modules.authui(modules.session.systemSession, defaultUser, undefined, true);\n\t\t\tresolvedLogon = await waitForLogon(logon);\n\t\t\tif (resolvedLogon.success) break;\n\t\t}\n\t\tif (!resolvedLogon.success) break;\n\t\thandleLogin(resolvedLogon, liu);\n\t\tif (useDefaultUser && defaultUser) {\n\t\t\tlet newWindow = modules.window(modules.session.systemSession);\n\t\t\tnewWindow.title.innerText = modules.locales.get(\"LOG_IN_INVITATION\");\n\t\t\tlet button = document.createElement(\"button\");\n\t\t\tbutton.innerText = modules.locales.get(\"LOG_IN_INVITATION\");\n\t\t\tnewWindow.content.appendChild(button);\n\t\t\tnewWindow.closeButton.classList.toggle(\"hidden\", true);\n\t\t\tawait hookButtonClick(button);\n\t\t\tnewWindow.windowDiv.remove();\n\t\t}\n\t}\n}\n\nasync function serviceLogon() {\n\tlet session = modules.session.mksession();\n\tmodules.session.attrib(session, \"dark\", true);\n\tlet dom = modules.session.tracker[session].html;\n\tdom.style.backgroundColor = \"black\";\n\tlet message = document.createElement(\"span\");\n\tmessage.innerText = \"Service Desktop\";\n\tmessage.style = \"position: absolute; right: 8px; bottom: 8px; color: white;\";\n\tdom.appendChild(message);\n\tlet startButton = document.createElement(\"button\");\n\tstartButton.innerText = modules.locales.get(\"START_MENU_BTN\");\n\tstartButton.style = \"padding: 4px;\";\n\tstartButton.onclick = async function() {\n\t\tlet startMenu = modules.window(session);\n\t\tstartMenu.title.innerText = modules.locales.get(\"START_MENU\");\n\t\tstartMenu.content.style.padding = \"8px\";\n\t\tstartMenu.closeButton.onclick = () => startMenu.windowDiv.remove();\n\t\tlet lockButton = document.createElement(\"button\");\n\t\tlockButton.innerText = modules.locales.get(\"LOCK_BUTTON\");\n\t\tstartMenu.content.appendChild(lockButton);\n\t\tlockButton.onclick = async function() {\n\t\t\tstartMenu.windowDiv.remove();\n\t\t\tawait modules.session.muteAllSessions();\n\t\t\tawait modules.session.activateSession(modules.session.systemSession);\n\t\t}\n\t}\n\tlet taskbar = document.createElement(\"div\");\n\ttaskbar.className = \"taskbar\";\n\n\ttaskbar.appendChild(startButton);\n\tdom.appendChild(taskbar);\n\tmodules.serviceSession = session;\n\tif (modules.core.bootMode != \"safe\") {\n\t\tlet serviceList = [];\n\t\ttry {\n\t\t\tserviceList = await modules.fs.ls(modules.defaultSystem + \"/apps/services\");\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to list services:\", e);\n\t\t}\n\t\tfor (let service of serviceList) {\n\t\t\tlet serviceConfig;\n\t\t\tlet triggerPasswordReset = false;\n\t\t\ttry {\n\t\t\t\tlet permissions = await modules.fs.permissions(modules.defaultSystem + \"/apps/services/\" + service);\n\t\t\t\tif (permissions.world.includes(\"r\")) triggerPasswordReset = true;\n\t\t\t} catch {}\n\t\t\ttry {\n\t\t\t\tserviceConfig = await modules.fs.read(modules.defaultSystem + \"/apps/services/\" + service);\n\t\t\t\tserviceConfig = JSON.parse(serviceConfig);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(\"Failed to read service config of\", service, \":\", e);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (serviceConfig.disabled) continue;p\n\t\t\tlet serviceName = (serviceConfig.localeReferenceName ? modules.locales.get(serviceConfig.localeReferenceName) : null) || (serviceConfig.localeDatabaseName ? (serviceConfig.localeDatabaseName[navigator.language.slice(0, 2).toLowerCase()] || serviceConfig.localeDatabaseName[modules.locales.defaultLocale]) : null) || serviceConfig.name;\n\t\t\tif (!serviceConfig.automaticLogon) {\n\t\t\t\tconsole.error(\"Service\", serviceName, \"(\", service, \") does not have logon credentials set\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet forkedToken;\n\t\t\ttry {\n\t\t\t\tlet logon = await modules.users.access(serviceConfig.automaticLogon.username);\n\t\t\t\tlogon = await logon.getNextPrompt();\n\t\t\t\tfor (let response of serviceConfig.automaticLogon.responses)\n\t\t\t\t\tif (logon.success == \"intermediate\") logon = await logon.input(response);\n\t\t\t\tif (!logon.success) throw new Error(logon.message);\n\t\t\t\tforkedToken = logon.token;\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(\"Failed to create a logon session for\", serviceName, \"(\", service, \"):\", e);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (triggerPasswordReset) {\n\t\t\t\tlet ownUser = await modules.tokens.info(forkedToken);\n\t\t\t\tlet ownUserInfo = await modules.users.getUserInfo(ownUser.user, true, forkedToken);\n\t\t\t\townUserInfo.securityChecks = [];\n\t\t\t\tawait modules.users.moduser(ownUser.user, ownUserInfo, forkedToken);\n\t\t\t\tawait modules.tokens.revoke(forkedToken);\n\t\t\t\tconsole.error(\"Exposed credentials for\", serviceName, \"(\", service, \") have been made invalid\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tawait modules.tasks.exec(serviceConfig.path, [ ...(serviceConfig.args || []) ], modules.window(session), forkedToken, true);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(\"Failed to start service\", serviceName, \"(\", service, \"):\", e);\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction waitForLogon(toHook) {\n\treturn new Promise(function(resolve) {\n\t\ttoHook.hook(resolve);\n\t});\n}\n\nasync function hookButtonClick(button) {\n\treturn new Promise(function(resolve) {\n\t\tbutton.onclick = (e) => resolve(e);\n\t});\n}","9185ec44ce0547e97c4e4345a52d2a94cd82ca57d9e12fb6bdc9d8aef31b7d83c203f2ec5ef847c70d028c5b9375ff489cc5337dcf1a765bcae5bd0a773dabe1":"requireLogon();","5b7bce196960695304c640c861c0a7de3e90b3cb79d4ae3a2559b7d7427b5808d2c09d1c004d4b7c6a042a9f4a4c6182230a9653a44361eccf0dd4e2bd3a62f1":"function systemKillWaiter() {\n\t// @pcos-app-mode native\n\tmodules.startupWindow.windowDiv.remove();\n\treturn new Promise(function(resolve) {\n\t\tmodules.killSystem = resolve;\n\t});\n}\nreturn await systemKillWaiter();"},"buildInfo":{"for":"1322","when":1750599853182,"signer":"moduleSigner","critical":true,"signature":"a6b58b979d445c7f296bf773dbef71b37ec1bc6429c037093d44ef81d6759ba9ed116b5a356fddbf4795bb8cbb75e787502078d703b2deb32d3c9c30bc24c0dd"}}